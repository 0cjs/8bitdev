from    testmc  import tmc_tid
from    testmc.mos65  import  Machine
from    b8tool  import path
import  pytest

test_rig = '''
            cpu 6502
            org $1000
            include src/mos65/reader.a65
'''

def qset(m, input):
    ''' Set `input` as the parser input, returning the `q_point` value. This
        does not explicitly terminate the input with 0, though that will
        happen "automatically" when the simulator started with zeroed memory.
    '''
    buf = 0x300 - 2 - len(input)
    m.deposit(buf, input)
    m.depword(m.symtab.q_point, buf)
    return buf

#   Values to be returned by parsers
Alloc   = 'Alloc'           # Special: we expect an allocation from startcons
Nil     = 'Nil'

#   Parse success indicators
qA      = 'A'               # Always sucessful; ignore Z flag
qS      = 'S'               # Success: Z=1
qF      = 'F'               # Failure, Z=0

@pytest.mark.parametrize('qf, value, success, consumed, input', [
    #   qf: parser function
    #   value: expected value from the parser, `None` if failure (Z=0) expected
    #   success: qA, qS, qF (see above)
    #   consumed: the number input characters consumed (moving foward `q_point`)
    #   input: the input (bytestring) on which to run the parser function
    ('qspaces',     None,       qA,  0,  b'_'),
    ('qspaces',     None,       qA,  1,  b' _'),
    ('qspaces',     None,       qA,  3,  b'   _'),
    ('qLR',         None,       qF,  0,  b'_()'),
   #('qLR',         None,       qF,  0,  b'(('),
   #('qLR',         Nil,        qS,  2,  b'()'),
   #('qLR',         Nil,        qS,  4,  b'(  )'),
], ids=tmc_tid)
def testq(m, R, S, qf, value, success, consumed, input):
    start = qset(m, input)
    flags = { qA: R(), qS: R(Z=1), qF: R(Z=0) }[success]

    print('qf={} value={} start={} consumed={} input={}' \
        .format( qf, value, start, consumed, input))
    m.call(S[qf], R(Z=0))

    if value is None:
        assert (flags,  start + consumed) \
            == (m.regs, m.word(S.q_point))
    else:
        assert (flags,  start + consumed,  value) \
            == (m.regs, m.word(S.q_point), m.word(S.q_value))
