from    testmc  import tmc_tid
from    testmc.mc6800  import  Machine, Instructions as I
import  pytest

object_file = 'src/mc68/cjsmon.p'

def loadbios(m, input=None, output=None):
    bioscode = '.build/obj/src/tmc68/bioscode.p'
    S = m.symtab
    m.load(bioscode, mergestyle='prefcur', setPC=False)
    assert S['charinport'] == S['charoutport']
    return m.setiostreams(S.charinport, input, output)

####################################################################
#   pr* - printing output

@pytest.mark.parametrize('val, char', (
    (0x00, b'0'), (0x01, b'1'), (0x0E, b'E'), (0x0F, b'F'),
    (0x10, b'0'), (0xFE, b'E'),
), ids=tmc_tid)
def test_prnyb(m, S, R, val, char):
    _, output = loadbios(m)
    m.call(S.prnyb, R(a=val))
    assert char == output.getvalue()

@pytest.mark.parametrize('val, chars', (
    (0x00, b'00'), (0x0F, b'0F'), (0xA0, b'A0'), (0xFF, b'FF'),
), ids=tmc_tid)
def test_prhex(m, S, R, val, chars):
    _, outchars = loadbios(m)
    m.call(S.prhex, R(a=val))
    assert chars == outchars.getvalue()

####################################################################
#   q* - parsing

@pytest.mark.parametrize('testno, N, result, consumed, input', (
    ( 0,  1, 0xDEAD,  0, b''),
    ( 1,  1, 0xDEAD,  0, b'G'),
    ( 2,  1, 0xDEAD,  0, b'g'),
    ( 3,  0, 0x000F,  1, b'F'),
    ( 4,  0, 0x00A0,  2, b'A0'),
    ( 5,  0, 0x0B19,  3, b'B19'),
    ( 6,  0, 0x1234,  4, b'1234'),
    ( 7,  0, 0x0123,  4, b'01234'),
    ( 8,  0, 0xabcd,  4, b'aBcdE'),
), ids=tmc_tid)
def test_qhexword(m, S, R, testno, N, result, consumed, input):
    #   We re-use another routine's space.
    #   Change the address from test to test.
    buf = S.rdlinebuf + testno
    m.deposit(buf, input + b'\x00')
    print('buf=${:04X} {}'.format(buf, m.bytes(buf, len(input))), end='')
    m.depword(S.hexword, 0x9999)    # definitely not our output value

    m.call(S.qhexword, R(x=buf))
    hexword = m.word(S.hexword)
    print('\t\tX={:04X} N={} hexword=${:04X}'.format(m.x, m.N, hexword))

    assert R(x=buf+consumed) == m.regs
    assert R(N=N) == m.regs
    if N == 0: assert result == hexword

def test_qhexbyte(m, S, R):
    #   Most testing of internal details is done by test_qhexword.
    input    =  b'0 1 23 45 6789a bcd'
    expected = (0x00, None, 0x01, None, 0x23, None, 0x45, None,
                0x67, 0x89, 0x0A, None, 0xBC, 0x0D)
    m.deposit(S.rdlinebuf, input)
    print(input)
    x = S.rdlinebuf
    for ex in expected:
        m.call(S.qhexbyte, R(x=x))
        print('at={:04X} next={:04X} '.format(x, m.regs.x), end='')
        if ex is None:
            print('ex=None')
            assert R(N=1) == m.regs
            x += 1
        else:
            print('ex={:X}'.format(ex))
            assert (R(N=0), ex) == (m.regs, m.word(S.hexword))
            x = m.regs.x

####################################################################
#   rd* - read input

def test_rdchar(m, R, S):
    ' Mostly confirms that our test framework works. '
    chars = b'!\x00\x7F'
    inchars, _ = loadbios(m, chars)
    for char in chars:
        m.call(S.rdchar, R(a=0xEA))
        assert R(a=char) == m.regs

    #   Document how an attempt to read past available input fails.
    with pytest.raises(EOFError) as ex:
        m.call(S.rdchar)
    assert ex.match('No more input available')

@pytest.mark.parametrize('buf, input', (
    (b'',                   b'\r'),
    (b'a',                  b'a\r'),
    (b'jklm',               b'j_\bk_\x7Fl__\b\bm\r'),
    (b'',                   b'\b\x7F\b\r'),
    (b'ij',                 b'\b\x7Fgh\b\b\b\bij\r'),
    (b'\x01\n\x1F\x7E',     b'\x01\x00\n\x00\x1F\x00\x7E\r'),
))
def test_rdline(m, R, S, input, buf):
    TERM = b'END'
    istream, ostream = loadbios(m, input + TERM)
    m.deposit(S.rdlinebuf, b'\xA5'*40)
    m.call(S.rdline)

    assert R(x=S.rdlinebuf, C=0) == m.regs
    assert buf + b'\x00' == m.bytes(m.regs.x, len(buf)+1)

    assert TERM == istream.read(len(TERM))  # no unconsumed input

    def echo_of(readchars):
        out = []
        for i in readchars:
            if   i == 0:    pass                # NUL not echoed
            elif i == 0x7F: out.append(0x08)    # DEL echoes backspace
            elif i == 0x0D: out.append(0x0A)    # CR echos newline
            else:           out.append(i)
        return bytes(out)

    assert echo_of(input) == ostream.getvalue()

def test_rdline_ctrlC(m, R, S):
    istream, ostream = loadbios(m, b'pqr\bqp\x03END')
    m.call(S.rdline)
    assert [ R(x=S.rdlinebuf, C=1), b'pqqp\x00'             ] \
        == [ m.regs,                m.bytes(m.regs.x, 5)    ]
    assert b'END' == istream.read(3)
    assert b'pqr\bqp\a\n' == ostream.getvalue()   # BEL char sent

def test_rdline_rubout_at_beginning(m, R, S):
    istream, ostream = loadbios(m, b'\b\b\babc\b\r')

    #   Whatever happens to be just before the buffer may not be
    #   the best sentinel bytes, but we can't overwrite it because
    #   we don't know if something important might be there.
    prebuf = m.bytes(S.rdlinebuf - 4, 4)
    m.deposit(S.rdlinebuf, b'\xA5'*40)

    m.call(S.rdline)
    assert R(x=S.rdlinebuf, C=0) == m.regs
    assert prebuf + b'ab\x00' == m.bytes(m.regs.x - 4, 7)

def test_rdline_overflow(m, R, S):
    buflen = S.rdlinebuf_end - S.rdlinebuf
    bufinput = b'_' * (buflen - 3) + b'yz'
    istream, ostream = loadbios(m, bufinput + b'AB\r')

    postbuf = m.bytes(S.rdlinebuf_end, 4)
    m.call(S.rdline)

    expected_buf = bufinput + b'\x00' + postbuf
    actual_buf   = m.bytes(m.regs.x, len(expected_buf))
    assert [ R(x=S.rdlinebuf, C=0), expected_buf,   ] \
        == [ m.regs,                actual_buf,     ]

    #   A BEL for each char rejected when the buffer was full.
    assert bufinput + b'\a\a\n' == ostream.getvalue()

####################################################################
#   Commands (tested outside of command loop)

@pytest.mark.parametrize('loc, parselen, arg, data', [
    (0x7000,  0,  b'',                     b''),
    (0x7001,  2,  b'ff',                   b'\xFF'),
    (0x7002,  1,  b'1',                    b'\x01'),
    (0x7003,  4,  b'abcd',                 b'\xAB\xCD'),
    (0x6FFC, 20,  b'a bc def 0123  4   5', b'\x0A\xBC\xDE\x0F\x01\x23\x04\x05'),
    (0x7005,  1,  b'6x',                   b'\x06'),
    (0x7006,  5,  b'6 12 x',               b'\x06\x12'),
    (     1,  2,  b'34',                   b'\x34'),
], ids=tmc_tid)
def test_deposit(m, S, R, loc, parselen, arg, data):
    inbuf = S.rdlinebuf
    expected = b'\xEE' + data + b'\xEE'

    m.depword(S.Mcur, loc)
    m.deposit(inbuf, arg + b'\x00')
    m.depword(S.cmdqptr, inbuf)
    m.deposit(loc-1, b'\xEE'*len(expected))

    m.call(S.deposit, R(a=ord(':'), x=S.deposit))

    assert (inbuf,  inbuf + parselen,   expected) \
        == (inbuf,  m.word(S.cmdqptr),  m.bytes(loc-1, len(expected)))

####################################################################
#   Command loop

@pytest.mark.parametrize('cmdchar, foundaddr', [
    ('z', 0x0F0F),
    ('y', 0x0E0E),
    ('a', 0x0101),
    ('w', None),
    ('@', None),
])
def test_cmdloop_search(m, S, R, cmdchar, foundaddr):
    ' Test the command table search routine embedded in cmdloop. '
    CMDTBL = 0x3FFE
    tabledata = [ ('z', 0x0F0F), ('y', 0x0E0E),
                  ('a', 0x0101), ('\x00', 0x0000),
                ]
    for entry, char_addr in enumerate(tabledata):
        offset = entry * 3; char, addr = char_addr
        m.deposit(CMDTBL+offset,   [ord(char)])
        m.depword(CMDTBL+offset+1, [addr])
    m.depword(S.cmdtbl, CMDTBL)

    callcmd = S['cmdloop.callcmd'] + 2  # instruction after loading address
    unkcmd  = S['cmdloop.unkcmd']

    m.setregs(R(pc=S['cmdloop.search'], a=ord(cmdchar)))
    m.stepto(stopat=[callcmd, unkcmd], maxsteps=10000)

    if foundaddr is not None:
        #   We've loaded the right command address and are about to call it
        assert R(pc=callcmd, x=foundaddr) == m.regs
    else:
        #   We've gone through the entire table and not found the command.
        lastentry = CMDTBL + 3 * (len(tabledata)-1)
        assert R(pc=unkcmd, x=lastentry) == m.regs

def test_cmdloop_quitcmd(m, S, R):
    ' Minimal path that gets us through to exit. '
    #   Quit doesn't return to the parser loop; it manually removes the
    #   return address that .parse added. This means our JSRs/RTSs will
    #   match, so in this one case we can use m.call().
    istream, ostream = loadbios(m, b'Q\r')
    m.call(S.cmdloop)
    assert b'\n> Q\n' ==  ostream.getvalue()
    #   Make sure we exited at the point where we expected.
    assert R(pc=S.rtscmd) == m.regs

def test_cmdloop_cancel(m, S, R):
    ' Confirm that ctrl-C terminates input, ignores line. '
    istream, ostream = loadbios(m, b'^~123~^\x03' b'Q\r')
    m.call(S.cmdloop)
    assert b'\n> ^~123~^\x07\n' b'> Q\n' ==  ostream.getvalue()
    #   Make sure we exited at the point where we expected.
    assert R(pc=S.rtscmd) == m.regs

#   Because the parser loop sets up return addresses with PSH (continuation
#   passing style), m.call() will not see a JSR to match to each command's
#   RTS and thus exit after the first command. We get around this by
#   instead adding a quit command at the end of every test input and running
#   until we reach quitcmd, a unique location before monitor exit. (rtscmd
#   cannot be used for this because it's also used as a convenient branch
#   target for conditional RTS by other code.)

def cmdloop(m, S, R):
    m.setregs(R(pc=S.cmdloop))
    m.stepto(stopat=[S['quitcmd']], stopon=[0x00], maxsteps=10000)

def test_cmdloop_multicmd(m, S, R):
    ' Multiple command processing of the simplest possible commands. '
    istream, ostream = loadbios(m, b'^^ ^Q\r')
    cmdloop(m, S, R)
    assert b'\n> ^^ ^Q\n' b'\n\n\n' ==  ostream.getvalue()

def test_cmdloop_multiline(m, S, R):
    ''' Simple commands split across lines.

        This demonstrates some ill-formed behaviour; entering a line causes
        the input routine to produce a newline, but then the prompt prints
        another newline even though there was no output on the existing
        line. When we print newlines needs to be reworked.
    '''
    istream, ostream = loadbios(m, b' \r^\rQ\r')
    cmdloop(m, S, R)
    expected = bytes(
        b'\n> '     # initial prompt
        b' \n\n> '  # space (no command), unwanted NL, following prompt
        b'^\n\n\n> '  # ^ (print CR), unwanted NL, following prompt
        b'Q\n'      # quit command
        )
    assert expected ==  ostream.getvalue()

def test_cmdloop_setcur(m, S, R):
    istream, ostream = loadbios(m, b'a800 Q\r')
    cmdloop(m, S, R)
    assert 0xA800 == m.word(S.Mcur)

def test_cmdloop_deposit_examine(m, S, R):
    ' Simple integration test. '
    istream, ostream = loadbios(m, b'7655:cd\r7654:ab x Q\r')
    cmdloop(m, S, R)

    print(m.regs); print(m.bytes(m.regs.sp-8, 8))
    output = ostream.getvalue(); print(output)
    assert b'\n7654: AB CD' in output

@pytest.mark.skip
def test_cmdloop_eachrts(m, S, R):
    ''' A (currently non-working) hack to do "selective trace," printing
        the current instruction, stack contents and buffer contents at a
        few points during execution.
    '''
    input = b'a800\r3Q\r'
    input = b'^ ^^Q\r'
    istream, ostream = loadbios(m, input)
    m.deposit(0xA800, b'ABCDEFGH')

    stackbase = m.regs.sp + 1
    def showstack():
        return '{:02X}{:02X} {:02X}{:02X} {:02X}{:02X} {:02X}{:02X}' \
            .format(*m.bytes(stackbase-8, 8))

    m.setregs(R(pc=S.cmdloop))
    level = 0
    print('{}                {}'.format(m.regs, showstack()))
    while True:
        m.stepto(stopon=[I.JSR, I.BSR, I.RTS, I.PSHA],
            stopat=[ S['rtscmd'], S['cmdloop.parse'] - 1 ])
        r = m.regs
        opcode = m.byte(r.pc)
        if   opcode == I.PSHA:
            level += 1
            inst = 'PSH'
            dest = S['cmdloop.parse']
        elif opcode == I.JSR:
            level += 1
            inst = 'JSR'
            dest = m.word(r.pc+1)
        elif opcode == I.BSR:
            level += 1
            inst = 'BSR'
            dest = r.pc + 2 + m.byte(r.pc+1)
        else:
            level -= 1
            inst = 'RTS'
            dest = 0
        print('{} {:3d} {} {:04X}   {}   {}'
            .format(r, level, inst, dest, showstack(), m.bytes(r.x, 6)))

    assert 0
