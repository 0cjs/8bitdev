''' CRC-16-CCITT checksum test
    XXX The core of these tests should be pulled up to the generic level.
'''

from    testmc  import tmc_tid
from    testmc.i8080  import  Machine
from    binascii  import crc_hqx
import  pytest

test_rig = '''
            cpu 8080
            include  src/i8080/std.i80
            org $80
            include src/i8080/checksum/crc_16_ccitt.i80
'''

@pytest.mark.parametrize('expected_crc, input', [
    #   These from answers to: https://stackoverflow.com/q/1918090/107294
    (0xB1E4, [0x12, 0x34, 0x56, 0x70]),
    (0x1AAD, [0x5A, 0x26, 0x19, 0x77]),
    (0x29B1, b'123456789'),
    (  None, [0]),
    (  None, [0, 0]),
    (  None, [0, 0, 0, 0]),
    (  None, [0xED] * 0xFF),
    (  None, [0xED] * 0x100),
    (  None, [0xED] * 0x101),
    (  None, [0xED] * 0x201),
   #(  None, [0xED] * 0x1001),      # ~0.5s
    #   The following require maxsteps=1e7
   #(  None, [0xED] * 0xDE00),
   #(  None, [0xED] * 0xDF00),      # XXX bad CRC; why?
], ids=tmc_tid)
def test_cksum_crc_16_ccitt(m, S, R, expected_crc, input):
    if expected_crc is None:
        expected_crc = crc_hqx(bytes(input), 0xFFFF)
    DATA = 0x180
    m.deposit(DATA, input)

    m.setregs(R(de=DATA, bc=len(input)))

    print(f'data {m.hexdump(DATA, 12)} â€¦')
    print(f' expected: crc=${expected_crc:04X} nextstart:${DATA+len(input)}')
    m.call(S.cksum_crc_16_ccitt, maxsteps=1e7)

    crc = m.hl
    nextstart = m.de

    print(f'   actual: crc=${crc:04X} nextstart:${nextstart}')
    assert (expected_crc, DATA+len(input)) \
        == (crc,          nextstart      )
