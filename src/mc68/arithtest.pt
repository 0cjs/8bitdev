from    testmc  import *
from    testmc.mc6800  import *
import  pytest

R = Machine.Registers

object_file = 'src/mc68/arithtest.p'

@pytest.mark.parametrize('A, B, X, Y', [        # X = A / B; Y = remainder
    (  123,   124,     0,   123),   #  A < Q always, so X never used
    (  179,    10,    17,     9),
    (43201,   103,   419,    44),
])
def test_difUW_ss(m, S, A, B, X, Y):
    m.deposit(0, 0xA5)          # guard for loads _from_ 0 instead of _of_ 0

    addrvals = [ (S._A, A), (S._B, B),
                 (S._X, 22222), (S._Y, 11111), ]    # guards
    for a, v in addrvals: m.depword(a, v)
    print(m.hexdump(S._A, 10))

    m.call(S.divUW_ss, trace=0)
    print(m.hexdump(S._A, 10))
    assert (A, B, X, Y) == (A, B, m.word(S._X), m.word(S._Y))

@pytest.mark.parametrize('n', [
    0, 3, 15, 16, 17, 255, 256, 257, 999, 1000, 2001, 3002, 9999,
    10000, 10001, 16383, 16384, 16385, 32768, 33879, 0xFFFE, 0xFFFF,
])
def test_prdec_u16(m, S, R, loadbios, n):
    expected = '{}'.format(n).encode('ASCII')
    #   XXX use a version with leading zeros until we add removal of those
    expected = '{:05}'.format(n).encode('ASCII')
    print('expected', expected)

    loc = 0x7000 + (n & 0xFF ^ 0x55)    # pesudo-random location for input
    m.depword(loc, n)
    _, output = loadbios('tmc68')
    m.call(S.prdec_u16, R(x=loc), trace=0)
    print('input', m.hexdump(loc, 2), '  copy', m.hexdump(S._A, 2),
        '  regs', m.regs, '  output', output.getvalue())
    assert expected == output.getvalue()
