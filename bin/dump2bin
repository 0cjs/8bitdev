#!/usr/bin/env python3
#
#   dump2bin - convert hex dumps to binary, with error recovery
#
#   This is designed to work with the Apple 1 monitor dump output as
#   captured in a terminal program. It can take multiple capture files as
#   input (for a dump done several times) in order to detect and correct
#   dropped characters.
#
#   XXX Silently breaks on non-contiguous dumps.
#

from    functools  import partial, reduce
from    operator  import is_not
import  re, sys

lastaddress = None      # Used to generate better error messages

def main(argv=sys.argv):
    global lastaddress

    inputs = tuple(map(open, argv[1:])) # for some reason we must force eval
    while True:
        addrs, datas = zip(*map(parsenext, inputs))
        if not any(addrs):
            return
        #   We could try to handle missing data lines here, but it's not
        #   worth it; that would be a pretty broken dump. Instead, we just
        #   assume that any addresses that disagree had a character dropped.

        lastaddress = addr = majority(addrs)
        data = majority(datas)

        #   XXX The address is currently ignored; we just write the data out
        #   in sequence. This will silently break on non-contiguous dumps.
        print('{}:{}'.format(hexformat(addr), hexformat(data)))

LINEPAT = re.compile(r'^([0-9A-Fa-f]{4}):([ 0-9A-Fa-f]*)$')

int16 = partial(int, base=16)

def parsenext(input):
    ' Read and return the next data line. '
    while True:
        line = input.readline()
        if line == '': return None, tuple()
        match = LINEPAT.match(line.strip())
        if match:
            addr = int(match.group(1), 16)
            values = tuple(map(int16, match.group(2).split()))
            return addr, values

def majority(xs):
    xcount = dict()
    for x in xs:
        if x in xcount:
            xcount[x] += 1
        else:
            xcount[x] = 1
    for k, v in tuple(xcount.items()):
        if xcount[k] < 2:
            del xcount[k]
    if len(xcount) != 1:
        eprint('{:04X}: disagreement'.format(lastaddress))
        for x in xs:
            eprint('     ' + hexformat(x))
        #raise RuntimeError('{:04X}: no majority in {}'.format(lastaddress, xs))
    for k in xcount:
        return k

def hexformat(data):
    s = ''
    try:
        for i in data:  s += ' {:02X}'.format(i)
    except TypeError:       # not iterable
        try:
            s = '{:04X}'.format(data)
        except TypeError:   # not numeric
            s = repr(data)
    return s

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

if __name__ == '__main__':
    main()
