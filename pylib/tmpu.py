''' Test framework for code on py65 MPU.
'''

from    struct  import unpack_from
from    itertools  import repeat
from    py65.devices.mpu6502  import MPU

class TMPU():

    def __init__(self):
        self.mpu = MPU()

    def setregs(self, pc=None, a=None, x=None, y=None, sp=None):
        m = self.mpu
        if pc is not None:  m.pc = pc
        if  a is not None:   m.a =  a
        if  x is not None:   m.x =  x
        if  y is not None:   m.y =  y
        if sp is not None:  m.sp = sp
        #   We don't do processor status register here as flags should
        #   be set/reset individually, particularly because we should
        #   avoid ever changing unused bits 5 and 6.

    def assertregs(self, pc=None, a=None, x=None, y=None, sp=None, p=None):
        ''' Assert any registers specified have given values.

            This needs to be tweaked to produce better output on failure.
            - Hex comparisions would be nice.
            - Can we end the stack trace one level above this?
        '''
        #   XXX The assertions must not happen here because this is not
        #   compiled with pytest's instrumentation, so we don't see the
        #   values that failed. Change the API to take a set of registers
        #   (and flags?) to return and return a (named?) tuple that the
        #   caller can compare. Or just return everything and let the
        #   object's comparison routine ignore any unset values?
        m = self.mpu
        if pc is not None:  assert pc == m.pc
        if  a is not None:  assert  a == m.a
        if  x is not None:  assert  x == m.x
        if  y is not None:  assert  y == m.y
        if sp is not None:  assert sp == m.sp
        if  p is not None:
            #   Ignore unused bits 5 and 4 in the processor status register.
            assert  p & 0b11001111 == m.p & 0b11001111

    #   XXX This "examine" interface isn't so nice. Perhaps we can condense
    #   in down to a single examine() function that takes a length and type?

    def byteAt(self, addr):
        ' Examine a byte from memory. '
        return self.mpu.ByteAt(addr)

    def wordAt(self, addr):
        ' Examine a word from memory. '
        return self.mpu.WordAt(addr)

    def strAt(self, addr, len):
        ' Examine a string from memory. '
        #   This currently throws an exception if any of the bytes
        #   in the memory range are >0x7f. It's not clear how we
        #   should be decoding those. Possibly we want an option to
        #   clear the high bit on all chars before decoding.
        return bytes(self.mpu.memory[addr:addr+len]).decode('ASCII')

    def deposit(self, addr, values):
        self.mpu.memory[addr:addr+len(values)] = values

    def load_bin(self, buf):
        recs = ParseBin(buf)
        for addr, data in recs:
            self.deposit(addr, data)
        self.mpu.pc = recs.entrypoint

    def step(self, count=1):
        for _ in repeat(None, count):
            self.mpu.step()

class ParseBin(list):
    ''' Parse records in "Tandy CoCo Disk BASIC binary" (.bin) format
        as generated by the ASxxxx assembler's `aslink` program.

        This has poor error-handling; it is intended to be used only
        on files generated by assemblers and linkers that always
        produce valid output.
    '''
    def __init__(self, buf):
        #   There's not really any reason to keep the buf here, actually,
        #   so it would be more efficient to change this to use a binary
        #   input stream.
        self.buf = buf
        pos = 0
        while True:
            type, len, addr = unpack_from('>BHH', buf, pos)
            if type == 0:
                pos += 5
                data = unpack_from('B'*len, buf, pos)
                pos += len
                self.append((addr, list(data)))
            elif type == 0xFF:
                self.entrypoint = addr
                break
            else:
                raise ValueError('Bad .bin record type {} at {}: {}' \
                    .format(type, pos, buf[pos:pos+5]))
