from    testmc  import *
from    testmc.mc6800  import *
import  pytest

R = Machine.Registers

test_rig = '''
            cpu 6800
            org $1000

pmon_ramlo  equ $0080
pmon_org    equ $1000
            include src/mc68/std.a68
            include src/tmc68/bios.a68
            include src/pmon/pmon.a68

; ----------------------------------------------------------------------
;   Mock command table(s) for testing

            org $4FFF
cmdtbl_1
cmdentry_a  db  'a'             ; command character
            dw  $0000           ; command entrypoint (testing zeros here)
            db  'x',CTP_WORD    ; parameters
            db  'y',CTP_BYTE
            db  CTP_END

            db  CT_CONTINUE
            dw  cmdtbl_2

            org $5EEE
cmdtbl_2
cmdentry_n  db  'n'             ; command with no parameters
            dw  $1234
            db CTP_END

cmdentry_b  db  'b'
            dw  $100B
            db  'x',CTP_BYTE
            db  'y',CTP_WORD
            db  'n',CTP_NYBBLE
            db  'u',CTP_UVAR
            db  CTP_END

cmdentry_c  db  'c'
            dw  $100C
            db  CTP_END

cmdentry_d  db  'd'
            dw  $100D
            db  CTP_END

            db  CT_END

;   $7FFF onward is pmon RAM areas, set up by tests

; ----------------------------------------------------------------------
'''

param = pytest.mark.parametrize

@param('result, x, b', (
    ( 0x1000, 0x1000, 0x00 ),
    ( 0x2001, 0x2000, 0x01 ),
    ( 0x30FF, 0x3000, 0xFF ),
    ( 0x4100, 0x40FF, 0x01 ),
    ( 0x0001, 0xFFFF, 0x02 ),
))
def test_addXB(m, S, R, result, x, b):
    a = b ^ 0xA5
    inputs = R(x=x, b=b, a=a)
    print(inputs)
    m.call(S.addXB, inputs)
    assert R(x=result, a=a) == m.regs

@param('ctp_type_sym, ctp_len', [
    ('CTP_WORD', 2),
    ('CTP_BYTE', 1), ('CTP_NYBBLE', 1), ('CTP_UVAR', 1),
    #   XXX how to deal with boolean? need to look at _prev_ entry
    #       but how do we know if we have a previous entry?
])
def test_addBpvsize(m, R, S, ctp_type_sym, ctp_len):
    ctp_type = S[ctp_type_sym]
    addr = 0xA000 + ctp_type
    print('{}=${:02X} len={} addr=${:04X}'.format(
        ctp_type_sym, ctp_type, ctp_len, addr))
    m.deposit(addr, [ord('a'), ctp_type])   # param entry is paramchar, valtype
    m.call(S.addBpvsize, R(a=0xEA, b=0x10, x=addr))
    assert R(a=0xEA, b=0x10 + ctp_len, x=addr) == m.regs

@param('routine, pricount_in, pricount_out, output', [
    ('bs1', 0, 0, b''  ),   ('bsN', 0, 0, b''),
    ('bs1', 1, 0, b'\b'),   ('bsN', 1, 0, b'\b'),
    ('bs1', 2, 1, b'\b'),   ('bsN', 2, 0, b'\b\b'),
    ('bs1', 3, 2, b'\b'),   ('bsN', 3, 0, b'\b\b\b'),
])
def test_pri_bs(m, R, S, loadbios, routine, pricount_in, output, pricount_out):
    m.deposit(S.pricount, pricount_in)
    _, ostream = loadbios('tmc68')
    m.call(S['pri_' + routine])
    assert (pricount_out, output) == (m.byte(S.pricount), ostream.getvalue())

@param('parser, input, valword, output', [
    ('byte', b'\b', 0xDEAD, b'\b')
   #('byte', b'fe', 0xFE00, b'fe')
])
def test_qpval(m, R, S, loadbios, parser, input, valword, output):
    valaddr = 0x7000 + sum(input)
    m.depword(S.pvalp, valaddr)
    m.depword(valaddr, 0xDEAD)      # sentinel
    istream, ostream = loadbios('tmc68', input[1:])
    m.call(S['qpval_' + parser], R(a=input[0]))
    assert (valword, output) == (m.word(valaddr), ostream.getvalue())

@param('cmdentry_sym, paramchar, valtype_sym, valoff', [
    ('cmdentry_b', 'n', 'CTP_NYBBLE', 3),
])
def test_paramlookup_success(m, R, S,
        cmdentry_sym, paramchar, valtype_sym, valoff):
    pchar = ord(paramchar)
    valstart = 0x9000 + pchar
    m.depword(S.cmdentry, S[cmdentry_sym])
    m.depword(S.cmdpvals, valstart)
    m.call(S.paramlookup, R(a=pchar, b=0x7F, C=True))
    assert (R(a=pchar, C=False, b=S[valtype_sym]), valstart + valoff) \
        == (m.regs,                                m.word(S.pvalp))

def test_paramlookup_failure(m, R, S):
    m.depword(S.cmdentry, S.cmdentry_b)
    m.call(S.paramlookup, R(a=0xFF))
    assert R(C=True) == m.regs

@param('cmdchar, cpvals_offset', [
    #   The vals offsets are calculated by hand from the test command tbl above.
    ('a', 0), ('b', 3), ('c', 8), ('d', 8),
])
def test_cmdlookup_success(m, S, R, cmdchar, cpvals_offset):
    m.depword(S.cmdtbl, S.cmdtbl_1)
    m.depword(S.cmdpvbase, 0x7FFD)

    m.call(S.cmdlookup, R(a=ord(cmdchar), x=0xFFFF, C=1))

    cmdentry = m.word(S.cmdentry); print('entry:', m.hexdump(cmdentry, 9))
    cmdpvals = m.word(S.cmdpvals); print('pvals:', m.hexdump(cmdpvals, 9))
    assert (ord(cmdchar), False, S['cmdentry_'+cmdchar], 0x7FFD+cpvals_offset) \
        == (m.a,          m.C,   cmdentry,               cmdpvals)

@param('cmdchar', [0xFF, 0x00, 0x01, ord('Z')])
def test_cmdlookup_failure(m, S, R, cmdchar):
    m.depword(S.cmdtbl, S.cmdtbl_1)
    cmdpvbase = 0x7FFF + cmdchar    # test at different locations
    m.depword(S.cmdpvbase, cmdpvbase)
    #   Length of variables area below manually calculated
    #   from CTP_* values in test command table above.
    cmdpvals_end = cmdpvbase + 8

    m.call(S.cmdlookup, R(a=cmdchar, x=0xFFFF, C=0))
    assert (R(C=1, a=cmdchar), cmdpvals_end) == (m.regs,  m.word(S.cmdpvals))
