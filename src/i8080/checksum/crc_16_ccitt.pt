''' CRC-16-CCITT checksum test
    XXX The core of these tests should be pulled up to the generic level.
'''

from    testmc  import tmc_tid
from    testmc.i8080  import  Machine
from    binascii  import crc_hqx
import  pytest

test_rig = '''
            cpu 8080
            include  src/i8080/std.i80
            org $80
            include src/i8080/checksum/crc_16_ccitt.i80
'''

@pytest.mark.parametrize('crc, input', [
    #   These from answers to: https://stackoverflow.com/q/1918090/107294
    (0xB1E4, [0x12, 0x34, 0x56, 0x70]),
    (0x1AAD, [0x5A, 0x26, 0x19, 0x77]),
    (0x29B1, b'123456789'),
    (  None, [0]),
    (  None, [0, 0]),
    (  None, [0, 0, 0, 0]),
    (  None, [0xED] * 0xFF),
    (  None, [0xED] * 0x100),
    (  None, [0xED] * 0x101),
    (  None, [0xED] * 0x201),
   #(  None, [0xED] * 0x1001),      # ~0.5s
    #   The following require maxsteps=1e7
   #(  None, [0xED] * 0xDE00),
   #(  None, [0xED] * 0xDF00),      # XXX bad CRC; why?
], ids=tmc_tid)
def test_cksum_crc_16_ccitt(m, S, R, crc, input):
    if crc is None:
        crc = crc_hqx(bytes(input), 0xFFFF)
    DATA = 0x100
    m.deposit(DATA, input)
    m.call(S.cksum_crc_16_ccitt, R(de=DATA, bc=len(input)), maxsteps=1e7)
    print(f'len=${len(input):04X}' \
        f' ${m.hl:04X}: {m.hexdump(DATA, len(input))[6:200]}')
    assert crc == m.hl, f'expected ${m.hl:04X}'
