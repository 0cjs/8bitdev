;   Simple 6502 routines to test

            ;   All numbers are in hex unless specified otherwise. However, we
            ;   still need to prefix numbers starting with A-F with `0` or `$$`
            ;   so they're not confused with symbols.
            .radix h

;--------------------------------------------------------------------------
           ;   This is one way of specifying the location of the code, but
            ;   experimentation has shown that it's probably better to leave
            ;   all code and data in the default _CODE area and specify
            ;   `-b _CODE=0xNNNN` to the linker to do this.
            .area   CODE (abs)
            .org    400
            .end    400             ; entry point

            ;   Zero page area, allowing us to interleave zero-page and
            ;   code segment allocations.
            .area   ZP  (abs,pag)
            .org    80               ; allocated area starts 80 bytes in

;--------------------------------------------------------------------------
            .area   CODE

ident:      .str    "simple.a65"    ; we use this to check that we've loaded
                                    ; the correct binary data and symbol table

;--------------------------------------------------------------------------
;   Add X and Y, storing the result in xybuf and returning it in A
            .globl addxy,xybuf
addxy:      txa
            sty xybuf
            clc
            adc xybuf
            sta xybuf
            rts
xybuf:      .ds     1

;--------------------------------------------------------------------------
;   JMP [addr] vs PHA/RTS
;   See Woz's Sweet 16 article for details.
;   Enter with the index (0-3) of the jmplist routine in A.

jmpptr      =       0010        ; zero page

jmpabs:     asl                 ; convert index to word offset
            tax
            lda     jmplist,X   ; destination addr LSB
            sta     jmpptr
            inx
            lda     jmplist,X   ; destination addr MSB
            sta     jmpptr+1
            jmp     [jmpptr]

;   This is a table of entry points for routines.
;   WARNING: It must not cross a page boundary!
jmplist:    .dw     1234
            .dw     5678
            .dw     9abc
            .dw     $$def0      ; Starts with letter = read as symbol

;   Stores the address _before_ the routine, to avoid an add in jmpabsrts
jmprtslist: .dw     1234-1
            .dw     5678-1
            .dw     9abc-1
            .dw     $$def0-1    ; Starts with letter = read as symbol

jmpabsrts:  asl                 ; convert index to word offset
            tax
            lda     jmprtslist+1,X ; dest addr MSB
            pha
            lda     jmprtslist,X   ; dest addr LSB
            pha
            rts

;--------------------------------------------------------------------------
;   bsread: A source stream of bytes
;   Preserves X and Y. Each call returns in A the next byte from [bytesource],
;   incrementing bytesource after.  This is a bit awkward; if we were worried
;   about efficiency we'd read from [bytesource+1], among other things.

bsread:     sty     bs_ysave
            ldy     #0
            lda     [bytesource],y
            pha
            ldy     bs_ysave
            inc     bytesource
            bne     1$
            inc     bytesource+1
1$:         pla
            rts

            .area   ZP
bytesource: .ds     2       ; pointer to bytes to read
bs_ysave:   .ds     1       ; temp storage for Y register
            .area   CODE

;--------------------------------------------------------------------------
;   Read (using bsread) a pair of ASCII chars representing a printable
;   byte value, and convert it to that byte value, returning it in A.

asc_0       .equ    30
asc_9       .equ    39
asc_A       .equ    41
asc_F       .equ    46

            .area   ZP
rab_temp:   .ds     1
            .area   CODE

rd_ascii_byte:                  ; XXX test framework has 14 char limit
            jsr     bsread
            jsr     rab_decode
            asl                 ; store top nybble
            asl
            asl
            asl
            sta     rab_temp
            jsr     bsread
            jsr     rab_decode
            ora     rab_temp
            rts

;   Decode an ASCII char to a binary digit
rab_decode: cmp     #asc_0
            bmi     rab_error
            cmp     #asc_9+1
            bpl     rab_hex
            sec
            sbc     #asc_0      ; to numeric value
            rts
rab_hex:    cmp     #asc_A
            bmi     rab_error
            cmp     #asc_F+1
            bpl     rab_error
            sec
            sbc     #asc_A-0A   ; to numeric value
            rts

rab_error:  brk                 ; let the test framework catch this
