;   tmon - "tiny" (relatively) 8080 monitor
;
;   See the README for the user documentation.

; ----------------------------------------------------------------------
;   Status:
;   • Implemented:  J K I Q E W R V D . > ' /
;   • Untested:     O P           # tests require addtional support from t8dev
;   • To-do:        F C : S L T

; ----------------------------------------------------------------------
;   This requires the system-dependent files define the following before
;   including this file:
;   • tmon_ram: the workspace area, which must be RAM. No code or data
;     is generated here; it's all initialised at runtime.
;   • tmon_stksz: size of tmon's monitor stack (separate from user stack)
;   • tmon_rom: start of code and static data, and monitor entry point.

;   Abort assembly with a clear message if an essential definition is missing.
;   (Otherwise it says "error: expression must be evaluatable in first pass".)
;
;   XXX This doesn't work inside a section … endsection block. We should
;   just change this to generate error messages in some nice way. Maybe we
;   can set up a std.i80 macro that tests a symbol and generates an error
;   if it's not defined.
;
;   set ______,
;   pushv , tmon_rom, tmon_ram, tmon_stksz
;   popv  , ______,     ______,     ______

; ----------------------------------------------------------------------
;   Symbol naming:
;   • pr*       print routines
;   • q*        parsing routines
;   • cmd_ccc   command routines: ccc=command name
;   • ptab_ccc  parameter tables for commands; ccc=command name
;   • vX_ccc    memorised parameter values; X=parameter name, ccc=command name


; ======================================================================
;   Definitions

;   ASCII characters
ACK         equ  $06            ; Ctrl-F, keep current val and move forward
BS          equ  $08            ; Ctrl-H, backspace
LF          equ  $0A            ; Ctrl-J, linefeed
CR          equ  $0D            ; Ctrl-M, carriage return
NAK         equ  $15            ; Ctrl-U
CAN         equ  $18            ; Ctrl-X
DEL         equ  $7F

SPACE       equ  ' '
BACKSLASH   equ  '\\'

UPCASE      equ  %11011111      ; (lower case ASCII) ∧ UPCASE → upper case

; ----------------------------------------------------------------------

iCALL       equ  $CD            ; 8080 CALL aaaa instruction
iJP         equ  $C3            ; 8080 JMP aaaa instruction
iRET        equ  $C9            ; 8080 RET instruction

;   Command character and address of command code definition.
cmd         macro   char,addr
            cp   a,char
            jp   Z,addr
            endm

;   Byte-valued parameter: char followed by addr at which to store byte value.
pb          macro char,addr
            db    char
            dw    addr
            endm

;   Word-valued parameter: char followed by addr at which to store word value.
pw          macro char,addr
            db    char|$80
            dw    addr
            endm

; ======================================================================
;   RAM Work Area

            org  tmon_ram

            ds   tmon_stksz     ; reserve space for monitor stack
monstack                        ; first push will deposit below this

;   Registers
ureg_AF
ureg_F      ds   1
ureg_A      ds   1
ureg_BC
ureg_C      ds   1
ureg_B      ds   1
ureg_DE
ureg_E      ds   1
ureg_D      ds   1
ureg_HL
ureg_L      ds   1
ureg_H      ds   1
ureg_SP     ds   2
ureg_PC     ds   2

;   Command parameter values: v<PARAM>_<CMD>
v_start
vS_exec         ds   2      ; execute: start addr
vS_examine      ds   2      ; examine: start addr
vM_examine      ds   1      ; examine: display mode flags:
                            ;   b0=hex, b1=ASCII, b2=screen codes
vL_examine      ds   1      ; examine: # of lines to print
vW_examine      ds   1      ; examine: # of bytes per line ("width")
vS_deposit      ds   2      ; deposit: start addr
vN_deposit      ds   1      ; deposit: advance to next mode $00=off, $01=on
vP_port_in      ds   1      ; input port
vP_port_out     ds   1      ; output port
vV_port_out     ds   1      ; output port value
vS_source       ds   2      ; source range (copy/cksum/etc.): start addr
vE_source       ds   2      ; source range: end addr (non-inclusive)
vL_calc         ds   2      ; calc: ? param (left value)
vR_calc         ds   2      ; calc: / param (right value)
;
v_end
v_cksum         ds   2      ; checksum to determine if we re-init

;   Temporary storage, word and byte
t0          ds   1
t1          ds   1
t2          ds   1
t3          ds   1

tmon_ram_end

; ======================================================================
;   Entry point and main loop

            org  tmon_rom

;   Locations `tmon_rom` and `tmon_rom`+3  are the standard entry points
;   for the monitor.
;   • `entry` must be used for initial startup, and can be used when a
;     program wants to "exit" back to the monitor. This saves all registers
;     but the PC.
;   • `intentry` is the entry point for interrupts, whether via hardware
;     or software (the latter typically an RST instruction). This saves
;     all registers including the PC, and the `I`

entry       jp entry1

;   Interrupt entry point for the monitor.
;   Interrupts on the 8080 push only the return address on the stack.
;
;   We want to use as much of `entry` as possible, but because at the start
;   we can use no registers or flags until we save them we duplicate some
;   code. The only difference is that we set, rather than clear, the "entry
;   via interrupt" bit (b7) in A to indicate that we want to set the user
;   PC to set the user PC to the return address on the user stack.
;
intentry    di
            ld   (ureg_A),a
            ld   a,$80          ; Carry (t0) and entry via interrupt (b7) bits.
            jp   NC,entry1.savecarry
            ld   a,$81
            jp   entry1.savecarry

;   We don't have a PC to save here: either `intentry` above saved it or
;   we entered via `entry` with no known user PC, so we just retain the
;   last known value.
entry1      di                  ; ensure as best we can nothing will touch stack
            ld   (ureg_A),a
            ;   We must save the carry bit separately here because the DAD
            ;   we use later will affect it. We set bits in A to indicate
            ;   the value of the user carry (t0) and whether we entered via
            ;   an interrupt (b7). (`intentry` sets t0 to 1.)
            ld   a,0
            jp   NC,.savecarry
            ld   a,1            ; set "carry was set" bit, flags unaffected
.savecarry  ld   (t0),a         ; save carry and interrupt entry bits
            ld   (ureg_HL),hl
            ex   de,hl
            ld   (ureg_DE),hl
            ld   h,b
            ld   l,c
            ld   (ureg_BC),hl
            ld   hl,$0000
            add  hl,sp          ; SP → HL
            ld   (ureg_SP),hl
            ;   Now that we've saved the user stack pointer, we can switch
            ;   to our own stack. (We must never use the user stack because
            ;   it may be invalid, e.g. pointing into ROM.)
            ld   sp,monstack
            push af
            ex   (sp),hl
            pop  de             ; clean up stack
            ld   a,l            ; get flags
            and  a,$FE          ; clear carry
            ld   l,a
            ld   a,(t0)         ; load original carry, int flag, etc.
            and  $01            ;   and mask it
            or   a,l            ; bring in all other flags
            ld   (ureg_F),a
            ;   If we entered via intentry, we copy the return address to the
            ;   user PC so we can see where we came from.
            ld   a,(t0)
            and  $80            ; entry via int flag set?
            jp   Z,.end         ;   no: skip additional intentry processing
            ;
            ld   hl,(ureg_SP)   ;   yes: copy return address from stack
            ld   e,(hl)
            inc  hl
            ld   d,(hl)
            ex   de,hl
            ld   (ureg_PC),hl
            ld   a,'!'          ; indicate we came in via int
            call prchar
            call prspace
            ;
.end        ei                  ; interrupts can now use our stack
            call showregs       ; always print registers on entry

;   Check to see if our current command parameter values are "valid," i.e.,
;   matching a previously calculated and deposited checksum. (The checksum
;   is calculated and written just before the monitor calls usercode.)
;   If they're not valid, we init, because this is either the first time
;   the user has entered the monitor or something stomped on our values.
;
init        call cksum_v
            ex   de,hl              ; DE = current checksum
            ld   hl,(v_cksum)       ; HL = previous checksum
            call subHLDE            ; same?
            jp   Z,.end             ;   yes; do not re-init
.copy       ld   hl,v_initdata
            ld   de,v_start
            ld   b,v_end - v_start
.loop       ld   a,(hl)
            ld   (de),a
            inc  hl
            inc  de
            dec  b
            jp   NZ,.loop
.end

;   Print the prompt and read a command (but not the command's parameters).
;
;   Commands are expected to generate a newline (moving to the next line
;   after the command) if necessary, though they may also overwrite the
;   current line (by generating CR) if that won't overwrite any useful
;   input made before command execution.
;
prompt      ld   sp,monstack
            ld   a,'.'
            call prchar         ; prompt
.read       call rdchar
            call prvischar      ; echo input visibly
            call upcase         ; force to upper case if letter
            ;   Dispatch command if we match one.
            ;   • Commands are not called but are jumped to; they must
            ;     themselves come back here via a jump to `prompt`.
            ;   • Commands must generate their own initial newline; see above.
            ;   • Commands that execute immediately rather than waiting for
            ;     parameters and/or confirmation should be marked somehow.
            cmd  CR, cmd_newline
            cmd  "'",cmd_deposit_ascii
            cmd  ',',cmd_deposit_params
            cmd  '.',cmd_deposit_bytes
            cmd  '/',cmd_calc
          ; cmd  ':',cmd_deposit_intelhex
            cmd  ';',cmd_regs_deposit
            cmd  '>',cmd_deposit_words
          ; cmd  'A',cmd_examine_asm
            cmd  'B',cmd_examine_prev
            cmd  'D',cmd_examine_cur
            cmd  'E',cmd_examine_params
            cmd  'F',cmd_examine_next
            cmd  'I',cmd_iret
            cmd  'J',cmd_jump
            cmd  'K',cmd_call
          ; cmd  'M',cmd_copymem
            cmd  'O',cmd_port_out
            cmd  'P',cmd_port_in
            cmd  'Q',cmd_quit
            cmd  'R',cmd_regs_examine
          ; cmd  'S',cmd_deposit_motosrec
          ; cmd  'T',cmd_device_write
            cmd  'V',cmd_cksum
          ; cmd  'W',cmd_find
          ; cmd  'Y',cmd_device_read
            ;   No command; generate error.
.err        call errbeep
            ld   a,CR           ; back up over bad command and prompt
            call prchar
.end        jp   prompt

;   Cancel current command. This may be used (via `jp`) by a routine at any
;   call depth. It will print a backslash at the current cursor position to
;   indicate that the command has been cancelled, print a newline, and then
;   restart the prompt, which will reload the the stack pointer to be at
;   the base of the monitor stack.
;
cancel      call  pr4clear      ; clear any displayed value
            ld   a,BACKSLASH    ; indicate cancelled
            call prchar
            call prnl
.prompt     jp   prompt

;   Checksum the command parameters, returning the checksum in HL.
;   When stored in (v_cksum), this lets us tell if param vals have changed.
;
cksum_v     ld   de,v_start
            ld   c,v_end - v_start
            call cksum_crc_16_ccitt
            ret

; ======================================================================
;   Initial command parameter values.

v_default   macro   name,value
        ifndef  name
name        equ  value
        endif
            endm

;   These default parameters are fairly well suited for a system with ROM
;   in the lower 32K, RAM in the upper 32K and an 80-column terminal.
;
    v_default  vini_start,  $8000   ; start addr of examine, deposit, execute,
    v_default  vini_end,    $8100   ;   etc.; end addr of copy, cksum etc.
    v_default  vini_lines,  4       ; examine: number of lines to print
    v_default  vini_width,  16      ; examine: bytes/line to print
    v_default  vini_format, $03     ; examine: hex+ascii format

v_initdata  dw   vini_start     ; execute start
            dw   vini_start     ; examine start
            db   vini_format    ; examine format
            db   vini_lines     ; examine #lines
            db   vini_width     ; examine width #bytes
            dw   vini_start     ; deposit start
            db   $00            ; deposit advance to next mode off
            db   $00,$00,$00    ; input, output port, output data
            dw   vini_start     ; copy/cksum start
            dw   vini_end       ; copy/cksum end
            dw   $0000          ; calc left arg
            dw   $0000          ; calc right arg

; ======================================================================
;   Command parameter management.

;   ♠HL ♣ABCHL,(t2⋅3)   We've found a command; it's asking us to read and
;   update parameters (specified in a table passed in HL) and execute or
;   cancel it.
;
;   The parameters table is a sequence of 3-byte entries,
;   terminated by a $00 byte:
;   • byte0 [7:7]: param value size: 0=8-bit, 1=16-bit
;   • byte0 [6:0]: param name, as upper-case ASCII letter
;   • byte1,byte2 [15:0]: location in which to store param value
;
read_params ld   (t2),hl         ; save params table
.next       call rdchar
            call qexec          ; execute command?
            ret  Z              ;   yes: continue running command
            call cqcancel       ; cancel command if requested
            call prvischar
            cp   SPACE          ; ignore spaces.
            jp   Z,read_params
            ;
.parse_name ld   hl,(t2)
            call upcase         ; force to upper case if lettter
            ld   b,a            ; table entry to match
.tabnext    ld   a,(hl)         ; param name char from table
            or   a,a            ; end of table?
            jp   Z,.bad         ;   yes: char does not match a param name
            and  a,$7F          ; clear table char high bit (param value size)
            cp   a,b            ; this param matches?
            jp   Z,.found       ;   yes: process param
            inc  hl             ; no: next table entry
            inc  hl
            inc  hl
            jp   .tabnext
            ;
.found      ld   a,(hl)         ; param name from table
            and  $80            ; mask 16-bit (vs. 8-bit) flag
            ld   c,a            ;   and set this parameter for qhex
            inc  hl             ; go to param value location (no flags changed)
            ld   b,(hl)         ; save location LSB
            inc  hl
            ld   h,(hl)         ; load location MSB
            ld   l,b            ; load location LSB
            call qhex           ; C=value size, HL=store location
            ret  Z              ; input terminated w/execute; exec command
            jp   .next
            ;
.bad        call prback         ; backspace over bad param name
            call errbeep
            jp   .next

;   ♠CHL ♣ABDE ♡C   Read ASCII hex digits and update byte or word (HL).
;
;   This reads and stores an 8-bit (C=0) or 16-bit (C=*) value.
;   The existing value (HL) is displayed and the cursor is backspaced
;   to the start of the value.
;
;   At this point the user may type an initial character:
;   • a space to preserve the curent value:
;     returns Z=0 ("continue input") and HL moved past the value
;   • a `qexec` character to preserve the current value:
;     returns Z=1 ("execute") and HL is moved past the value
;   • a `cqcancel` character to preserve the current value:
;     jumps to `cancel` instead of returning; HL left at the value
;   • a digit to start entering a new value
;
;   Once a digit has been typed, the user may terminate digit input with:
;   • a space to store the new value in (HL):
;     returns Z=0 ("continue input") and HL moved past the value
;   • a `qexec` character to store the new value in (HL):
;     returns Z=1 ("execute") and HL is moved past the value
;   • a `cqcancel` character to preserve the current value:
;     jumps to `cancel` instead of returning; HL left at the value
;
;   If more digits than needed are entered the least-significant
;   (last-entered) digits are used.
;
qhex        call prhexval       ; load (DE=val B=#digits) and print curval
            ld   a,BS           ; backspace to
            call prBchars       ;   start of printed value
            call rdchar         ; first char requires special processing:
                                ;   space is preserve, but after it's store
            cp   ' '            ; keep current value and continue params?
            jp   Z,.keepval     ;   yes
            cp   ACK            ; alternate keep (Ctrl-F)
            jp   Z,.keepval
            call qexec          ; execute (not changing current val)?
            ret  Z              ;   yes
            ld   de,0           ; set leading digits 0 for entering new value
            jp   .startval

.next       call rdchar
.startval   call cqcancel       ; cancel command if requested
            jp   Z,cancel       ;   yes
            ;   At this point we've had input before the exec char, or
            ;   we would have exec'd above. So we must store it.
+           call qexec          ; terminate input and execute command?
            jp   Z,.storeDE     ;   yes (TCO)
            ;   We're not aborting input, but we can't yet store at this
            ;   point because we don't know if we might abort after future
            ;   digit input. Ideally we'd be able to handle backspace here,
            ;   but that requires not just undoing the last digit added to
            ;   DE but also knowing how far back we can backspace, which
            ;   is more code than we'd like to add here right now.
            call prvischar
            ld   b,0            ; set ASCII input to high bit clear
            cp   "'"            ; ASCII char input?
            jp   Z,.parsechar   ;   yes
            cp   '"'            ; ASCII char input with high bit set?
            jp   Z,.parsecharhi ;   yes
            cp   ' '            ; terminate input and continue?
            jp   NZ,.parsedigit ;    no
            jp   .storeDE       ; ret (TCO)

.keepval    push af
            call prhexval       ; print value again
            call prspace
            pop  af
            jp   .storeDE       ; increment HL, set Z, ret (TCO)
                                ;   (extra store is no-op)

.storeDE    push af             ; preserve input termination char
            ld   (hl),e         ; store LSB
            ld   a,0
            or   a,c            ; 16-bit flag set?
            jp   Z,.sdone       ;  no
            inc  hl             ;   yes: store MSB
            ld   (hl),d
.sdone      inc  hl;            ; return next location
            ;   It would acually be a bit nicer here to back up over all the
            ;   entered chars and reprint the value, so that you see any
            ;   leading 0 digits, but that seems more work than worthwhile.
            call pr4clear       ; clear extra digits if entered # was shorter
            pop  af             ; restore input termination char
            call qexec          ; set Z flag if it was an execute char
            ret

            ;   Parse digit and add it to DE.
.parsedigit call qdigit
            jp   C,.baddigit
            cp   $10            ; digit > 'F'?
            jp   NC,.baddigit
            ld   b,a            ; save new digit
            ld   a,d
            rlca                ; lower nybble of D to upper nybble,
            rlca
            rlca
            rlca
            and  $F0            ; clear lower nybble
            ld   d,a            ; save upper byte's upper nybble
            ld   a,e
            rlca                ; swap upper/lower nybbles
            rlca
            rlca
            rlca
            push af             ; save a copy
            and  a,$F0          ; clear lower nybble
            ld   e,a            ; save lower byte
            pop  af             ; restore copy
            and  a,$0F          ; mask out lower (ex-upper) nybble
            or   a,d            ; combine with upper byte's upper nybble
            ld   d,a            ; and save it
            ld   a,e
            or   a,b            ; mask new digit into E lower nybble
            ld   e,a
            jp   .next

.baddigit   call errbeep
            call prback         ; always ok because we displayed with prvis
            jp   .next

.parsecharhi ld  b,$80          ; set ASCII input to high bit set
.parsechar  call rdchar
            or   a,b
            call prvischar      ; to make sure we can backspace over it
            ld   d,e
            ld   e,a
            call prback         ; overwrite...
            call prback
            ld   a,e            ;   with hex value of char
            call prhexA
            jp   .next

; ======================================================================
;   Commands

; ----------------------------------------------------------------------
;   Execution commands

ptab_exec   pw   'S',vS_exec        ; start address of execution
            db   0

cmd_iret    ld   a,iRET
            ld   (t0),a
            ld   hl,ptab_none
            jp   exec

cmd_call    ld   a,iJP          ; we simulate the call with a JP
            ld   (t0),a
            ld   hl,(ureg_SP)   ;   after pushing the monitor entry point
            dec  hl             ;   on the user stack
            ld   a,MB(entry)
            ld   (hl),a
            dec  hl
            ld   a,LB(entry)
            ld   (hl),a
            ld   (ureg_SP),hl
            ;
            ld   hl,ptab_exec
            jp   exec

cmd_jump    ld   a,iJP
            ld   (t0),a
            ld   hl,ptab_exec
            jp   exec

            ;   XXX optimise the above with a ↓ fallthrough etc.
            ;   and maybe remove dup code in cmd_{call,jump}

;   ♣(t0⋅1⋅2)   Execute location
;   This sets up a trampoline at (t0⋅1⋅2) that does the appropriate JMP or
;   RET to start execution. Using this means that we need not use or change
;   any registers to execute at an arbitrary address.
;
exec        call read_params
            call prnl           ; to easily identify output from the routine
            ;
            call cksum_v        ; checksum current params so we don't re-init
            ld   (v_cksum),hl   ;   on re-entry if they've not been stomped
            ;
            ld   hl,(vS_exec)
            ld   (t1),hl        ; set addr or JMP or CALL instruction
            ;   Restore user values to most registers
            ld   hl,(ureg_DE)
            push hl
            pop  de
            ld   hl,(ureg_BC)
            push hl
            pop  bc
            ld   hl,(ureg_AF)
            push hl
            pop  af
            ;   Switch to and set up set up user stack
            ld   hl,(ureg_SP)   ; (load user stack)
            ld   sp,hl
            ld   hl,(ureg_HL)
            jp   t0             ; trampoline into user code

cmd_quit    ld   hl,ptab_none   ; no parameters,
            call read_params    ;   but must confirm/cancel
            call prnl
            jp   exit           ; system-supplied routine

; ----------------------------------------------------------------------
;   Examine commands

ptab_examine
            pw   'S',vS_examine     ; start: 16-bit value
            pb   'M',vM_examine     ; display mode bitfield (see above)
            pb   'L',vL_examine     ; number of lines to print: 8-bit value
            pb   'W',vW_examine     ; width (# of bytes to print): 8-bit value
ptab_none   db   0                  ; end of table

cmd_examine_params
            ld   hl,ptab_examine
            call read_params
            call prnl
.end        jp   prompt

;   Load examine parameters into registers and temps:
;   t0⋅1=HL=start address, BC=bytes/line, DE=lines to dump
examine_setup
            ld  hl,(vS_examine) ; start address parameter
            ld   (t0),hl        ; t0⋅1: current line start
            ld   b,0
            ld   a,(vW_examine)
            ld   c,a            ; BC: bytes/line
            ld   d,0
            ld   a,(vL_examine)
            ld   e,a            ; DE: number of lines to dump
            ret

cmd_examine_prev
            call examine_setup  ; BC=bytes/line, DE=lines
            ld   a,b            ; complement BC so add subtracts
            cpl
            ld   b,a
            ld   a,c
            cpl
            ld   c,a
            inc  bc
            jp   cmd_examine_next.addpage

cmd_examine_next
            call examine_setup  ; BC=bytes/line, DE=lines
.addpage    add  hl,bc          ; add to start addr no. of bytes per line
            dec  e              ;   as many times as lines to dump
            jp   NZ,.addpage
            ld   (vS_examine),hl ; update start address
            jp   cmd_examine_cur.noparams  ; and do the dump

cmd_examine_cur
.noparams   call prcr           ; we will overwrite the command line
            call examine_setup  ; BC=bytes/line DE=lines, HL=(t0⋅1)=curline addr
            ;
.startline  push bc             ; save BC=bytes/line
            push de             ; save DE=lines remaining
            call praddrHL       ; entered with HL=curline start addr
            ;
            ld   a,$01          ; hex format bit
            ld   hl,prmhexA
            call prexamine
            ld   a,$02          ; ASCII format bit
            ld   hl,prvischar
            call prexamine
            ld   a,$04          ; screen code format bit
            ld   hl,prscreenchar
            call prexamine
            ;
.nextline   call prnl
            pop  de             ; restore DE=lines remaining
            pop  bc             ; restore BC=bytes/line
            ld   hl,(t0)        ; curline start addr
            add  hl,bc          ; next line start addr
            ld   (t0),hl
            dec  e
            jp   NZ,.startline
            ;
.end        jp   prompt


;   ♠AHL(t0⋅1) ♣*(t2⋅3)   prexamine: If the bit in A is set in (vM_examine),
;   i.e. if the format is enabled, print a sequence of (vW_examine)
;   locations starting at (t0⋅1) using the routine in HL. If the bit is not
;   set, just return.
;
prexamine   ld   (t2),hl        ; save address of pr* routine
            ld   hl,vM_examine  ; formats bitfield address
            and  a,(hl)         ;   is our bit set?
            ret  Z              ;      no: just return
            ;
            call prspace
            ld   hl,(t0)        ; current line start address
            ld   a,(vW_examine)
            ld   c,a            ; number of bytes to print (width)
.nextbyte   ex   de,hl          ; save current byte address
            ld   hl,.continue
            push hl             ; continuation address whence pr* will return
            ld   hl,(t2)        ; pr* routine address
            push hl
            ex   de,hl          ; restore current byte address
            ld   a,(hl)         ; load byte to print
            ret                 ; call pr* with continuation
.continue   inc  hl             ; next byte
            dec  c              ; printed all bytes?
            jp   NZ,.nextbyte   ;    no: carry on
            ret

ptab_regs   pb   'F',ureg_F     ; flags
            pb   'A',ureg_A
            pb   'B',ureg_B
            pb   'C',ureg_C
            pb   'D',ureg_D
            pb   'E',ureg_E
            pb   'H',ureg_H
            pb   'L',ureg_L
            pw   'P',ureg_PC
            pw   'S',ureg_SP
            pw   'M',ureg_HL    ; mnemonic "Memory"
            pw   'T',ureg_DE    ; mnemonic "Target"
            pw   'I',ureg_BC    ; mnemonic "Index" (like a count)
            db 0

cmd_regs_deposit
            ld   hl,ptab_regs
            call read_params
            ; fallthrough

cmd_regs_examine
            call prcr           ; overwrite line, since we display everything
            call showregs
.end        jp   prompt

showregs    ld   hl,(ureg_PC)
            call prhexHL
            ld   hl,(ureg_SP)
            call .spprhexHL
            ;   flags
            call prspace
            ld   a,(ureg_F)
            call prflags
            ;   A BC CD EF HL
            call prspace
            ld   a,(ureg_A)
            call prhexA
            ld   hl,(ureg_BC)
            call .spprhexHL
            ld   hl,(ureg_DE)
            call .spprhexHL
            ld   hl,(ureg_HL)
            call .spprhexHL
            call prnl
            ret
            ;
.spprhexHL  call prspace
            call prhexHL
            ret

prflags     ld   b,8            ; 8 bits in flags
            ld   hl,flagchars   ; letters for flags, or 0 for no print
.nextbit    rla                 ; next flag value into carry
            push af             ; save remaining flags
            ld   a,(hl)         ; flag print char - 1
            inc  a              ; set flag char and ZSPA flags (C unaffected)
            jp   Z,.noprint
            jp   C,.print       ; if flag set, print flag char
            ld   a,'-'          ; otherwise flag-no-set char
.print      call prchar
.noprint    pop  af             ; restore remaining flags
            inc  hl             ; next flag char
            dec  b              ; next bit?
            jp   NZ,.nextbit    ;   yes: continue printing
            ret

;   We store the flag characters and $00 "ignore bit" bytes as one
;   less than their actual values because this makes it easier to test
;   the value, which we do by using INC. (We use INC instead of a logic
;   operation because that preserves the carry flag, which contains the
;   value of the flag we're printing.)
flagchars   db   'S'-1, 'Z'-1, 0-1, 'H'-1, 0-1, 'P'-1, 0-1, 'C'-1

; ----------------------------------------------------------------------
;   Deposit Commands

ptab_deposit_params
            pw   'S',vS_deposit     ; start: 16-bit value
            pb   'N',vN_deposit     ; advance to next mode
            pb   'E',t0             ; copy examine start address: temp store
            db   0                  ; end of table

cmd_deposit_params
            xor  a,a
            ld   (t0),a
            ld   hl,ptab_deposit_params
            call read_params
            call prnl
            ld   a,(t0)          ; copy examine start address?
            or   a,a
            jp   Z,.end         ;   no
            ld   hl,(vS_examine)
            ld   (vS_deposit),hl
.end        jp   prompt

cmd_deposit_words
            ld   c,1            ; qhex size flag: 16-bit stores (preserved)
            jp   cmd_deposit_hex

cmd_deposit_bytes
            ld   c,0            ; qhex size flag: 8-bit stores (preserved)
            ; fallthrough

cmd_deposit_hex
            call prcr           ; use existing line for entry
            ld  hl,(vS_deposit) ; start address
            call praddrHL
            call prspace
.next       call qhex
            jp   NZ,.next
            jp   deposit_end

depaddr     call prcr           ; use existing line for entry
            ld  hl,(vS_deposit) ; start address
            call praddrHL
            call prspace
            ret

cmd_deposit_ascii
            call depaddr
            ld   c,0            ; qhex size flag: 8-bit values in Ctrl-D mode
            dec  hl
.next       inc  hl
            ld   a,(hl)         ; load/print current value
            call prvischar
            call prback
            ;
            call rdchar
            call cqcancel       ; terminate command if cancel character
            call qexec          ; "execute" char? (newline)
            jp   Z,deposit_end  ;   yes: input complete
            ;
            cp   a,ACK          ; Ctrl-F to skip over this location?
            jp   NZ,+           ;    no: process input
            ld   a,(hl)         ;   yes: reprint and move to next char
            call prvischar
            jp   .next
            ;
+           cp   a,$04          ; Ctrl-D to switch to hex digit input?
            jp   NZ,.char       ;    no: normal char input
            call qhex
            jp   Z,deposit_end  ; we're done if qhex was exited w/"execute"
            dec  hl
            jp   .next
            ;
.char
            ld   (hl),a         ; store char
            call  prvischar     ; print input
            jp   .next          ; and next loc

deposit_end call prnl
            ld   a,(vN_deposit)
            or   a,a
            jp   Z,.noadvance
            ld   (vS_deposit),hl
.noadvance  jp   prompt

; ----------------------------------------------------------------------
;   Checksum and Copy Commands

ptab_source     pw   'S',vS_source  ; start: 16-bit value
                pw   'E',vE_source  ; end: 16-bit value
                db   0

;   Currently we support only the required CRC-16-CCITT algorithm,
;   and thus do not bother with an `f##` parameter.
cmd_cksum   ld   hl,ptab_source
            call read_params
.exec       call prcr           ; overprint with "start.end =cksum"
            ld   hl,(vS_source)
            ld   d,h            ; start address
            ld   e,l
            call praddrHL       ; print with colon to indicate end addr follows
            ld   hl,(vE_source) ; end address
            call prhexHL
            call subHLDE
            call pr3sp
            ld   a,'='
            call prchar
            ;
            ld   b,h            ; length
            ld   c,l
            call lcksum_crc_16_ccitt
            call prhexHL
            call prnl
.end        jp   prompt

            ;   Included here because required for all monitors.
            include src/i8080/checksum/crc_16_ccitt.i80

; ----------------------------------------------------------------------
;   Other Commands

cmd_newline call prback         ; erase visible ^M
            call prspace
            call prnl
            jp   prompt

ptab_port_in
            pb   'P',vP_port_in
            db   0

cmd_port_in
            ld   hl,ptab_port_in
            call read_params
            ld   a,(vP_port_in)
            ld   c,a                ; port number
            ld   a,$DB              ; OUT instruction
            jp   cmd_port_cont

ptab_port_out
            pb  'P',vP_port_out
            pb  'V',vV_port_out
            db   0

cmd_port_out
            ld   hl,ptab_port_out
            call read_params
            ld   a,(vP_port_out)
            ld   c,a                ; port number
            ld   a,(vV_port_out)
            ld   d,a                ; data to write
            ld   a,$D3              ; OUT instruction
            ;    fallthrough

cmd_port_cont ;  Set up trampoline
            ld   (t0),a         ; IN/OUT instruction
            ld   a,c
            ld   (t1),a         ; port to read/write
            ld   a,$C9
            ld   (t2),a         ; RET instruction
            call pr3sp          ; space out before printing read/write data
            ld   a,d            ; data to write (ignored if read)
            call t0             ; call trampoline
            call prhexA
            call prnl
            jp   prompt

ptab_calc
            pw   '?',vL_calc    ; left value: 16 bits
            pw   '/',vR_calc    ; right value: 16 bits
            db   0

cmd_calc
            ld   hl,ptab_calc
            call read_params
.exec       call prcr           ; output on same line, since we print inputs
            ;   Left/right input values
            ld   hl,(vL_calc)
            call praddrHL
            ex   hl,de
            ld   hl,(vR_calc)
            call prhexHL
            ex   hl,de
            ;   Addition result
            add  hl,de
            call .print
            ;   Subtraction result
            ld   hl,(vL_calc)
            call subHLDE
            call .print
            ;   Clear two spaces of any junk just to the right of the output.
            ;   This takes us to col 31, so we don't scroll on 32-col displays.
            call prspace
            call prspace
            call prnl
            ;
            jp   prompt
            ;
.print      call pr3sp
            call prhexHL
            call prspace
            ld   a,l
            call prvischar
            call prscreenchar
            ret

; ----------------------------------------------------------------------
;   Parsing Routines `q*`

;   ♠A Set Z flag if the char in A is an execute command character (CR or LF).
qexec       cp   CR
            ret  Z
            cp   LF
            ret

;   ♠A ♡A   If the char in A is a cancel command character (^U or ^X)
;           cancel the current command and go back to the prompt,
;           otherwise just return.
cqcancel    cp   CAN
            jp   Z,cancel
            cp   NAK
            jp   Z,cancel
            ret

            include "src/i8080/qhex.i80"     ; hex parsing

;   ♠A   If the char in A is not in the ctrl/numbers/punct area, upper-case it.
;        BUGS: modifies punctuation above $40, DEL, and anything with bit 7 set.
upcase      cp   '@'            ; in the letters area?
            ret  C              ;    no: don't change the char
            and  UPCASE
            ret

; ----------------------------------------------------------------------
;   Printing Routines `pr*`

;   ♣A ♡*   Backspace over the last printed character
prback      ld   a,BS
            jp   prchar         ; ret (TCO)

;   ♣A ♡*   Print a carriage return to move to the start of the current line.
prcr        ld   a,CR
            jp   prchar         ; ret (TCO)

;   ♣AB   Print three spaces or N spaces.
pr3sp       ld   b,3
prNsp       ld   a,' '
            ;   FALLTHROUGH

;   ♠AB ♣A ♡B*   Print char in A, B times. (Preserves B.)
prBchars    push bc
            ld   c,a
.next       ld   a,c
            call prchar
            dec  b
            jp   NZ,.next
            pop  bc
            ret

;   ♣AB ♡CDE   Print 4 spaces, 4 backspaces to clear ahead of cursor.
pr4clear    ld   b,4
            call prNsp
            ld   a,BS
            jp   prBchars       ; ret (TCO)

;   ♠HL ♣AHL   Print the zero-terminated string at HL.
prstr       ld   a,(hl)
            or   a,a
            ret  Z
            call prchar
            inc  hl
            jp   prstr

;   ♠AC ♣A ♡*   Print a byte in hex as part of multiple bytes on a line.
;               Spacing afterwards depends on C:
;               • C=0:   1 space: we're done printing the line
;               • C/8≠0: 1 space: we're in a group of 8 bytes
;               • C/8=0: 2 spaces: we're separating next 8-byte group
;               The space at the end gives better separation w/anything else
;               coming after.
prmhexA     call prhexA
            ld   a,c
            dec  a              ; last byte of line for 1-based count?
            jp   Z,prspace      ;   yes: one trailing space and ret (TCO)
            call prspace        ;    no: trailing space and may have a second
            ld   a,c
            and  a,$07          ; mask bottom three bits
            dec  a              ; adjust for 1-based count
            ret  NZ             ;   no: just the one space is fine
            jp   prspace        ;  yes: add a second space and ret (TCO)

;   ♠CHL,BDE ♣A ♡CHL   Print 2-byte (C=0) or 4-byte (C=*) value (HL).
;                      Return value in DE and # of digits in B.
;   C=0: print 2-digit byte; C=*: print 4-digit word.
;   On return, B is set to the length printed, 2 or 4.
prhexval    ld   b,2            ; default to 2-digit word
            ld   d,$00          ;   with returned MSB zero just in case
            ld   a,0
            or   a,c            ; print 4-digit word?
            jp   Z,.print2      ;    no
            ld   b,4            ; update digit count
            inc  hl             ; move up to MSB
            ld   d,(hl)
            ld   a,d
            call prhexA
            dec  hl             ; move down to LSB
.print2     ld   e,(hl)
            ld   a,e
            jp   prhexA         ; ret (TCO)

            include "src/i8080/pr.i80"       ; printing

;   ♠HL ♣A ♡HL,*   Print HL as a hex addres, followed by a colon.
praddrHL    call prhexHL
            ld   a,':'
            jp   prchar         ; ret (TCO)

; ======================================================================
;   Misc. routines

;   ♣A   HL ← HL - DE. Affected flags: Z.
;   XXX This should be in a generic file somewhere?
subHLDE     ld   a,l
            sub  a,e
            ld   l,a
            ld   a,h
            sbc  a,d
            ld   h,a
            or   a,l        ; Z flag set only if H and L are 0
            ret
