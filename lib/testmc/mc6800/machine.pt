from    testmc.mc6800  import Machine, Instructions as I
import  pytest

@pytest.fixture
def m():
    return Machine()

@pytest.fixture
def R(m):
    return m.Registers

####################################################################
#   Registers

def test_mem(m, R):
    assert 65536 == len(m.mem)
    assert 0 == m.mem[0]
    assert 0 == m.mem[65535]

def test_regs(m, R):
    r0 = R(pc=0, a=0, b=0, x=0, sp=0xBFFF, H=0, I=0, N=0, Z=0, V=0, C=0)
    assert r0 == m.regs

    m.setregs(R(b=0xF0, x=0xF000, sp=0x8000))
    assert (0, 0xF0, 0xF000, 0x8000) == (m.pc, m.b, m.x, m.sp)

    with pytest.raises(ValueError):  m.setregs(R(pc=0x10000))
    with pytest.raises(ValueError):  m.setregs(R(a=0x100))

def test_flags(m, R):
    assert R(H=0, I=0, N=0, Z=0, V=0, C=0) == m.regs

    m.setregs(R(I=1, V=1))
    assert R(H=0, I=1, N=0, Z=0, V=1, C=0) == m.regs

####################################################################
#   Instruction Execution

def test_step_notimplemented(m, R):
    ''' This should be replaced with a "bad opcode" test once we've no
        longer got unimplemented opcodes.
    '''
    m.deposit(0x100, [I.NOP, 0x3E])  # $3E = SWI
    m.setregs(R(pc=0x100))
    with pytest.raises(Machine.NotImplementedError) as ex:
        m.step(2)
    assert ex.match(r'^opcode=\$3E pc=\$0101$')

def test_step(m, R):
    ''' Smoke test; the detailed work of instruction execution is covered
        by the mc6800.opcodes tests, which also use step().
    '''
    start = 0x200
    m.deposit(start, [I.NOP] * 4)
    m.setregs(R(pc=start))

    m.step();   assert R(pc=start+1) == m.regs
    m.step(2);  assert R(pc=start+3) == m.regs
    m.step();   assert R(pc=start+4) == m.regs

def test_call(m, R):
    ' Integration test: multiple instruction execution. '
    start = 0x200
    m.deposit(start, [
        I.BSR,     4,           # 0200: to LDAA below
        I.NOP,                  # 0202:
        I.JMP,  0x02, 0x08,     # 0203: to RTS below
        I.LDAA, 0xCC,           # 0206:
        I.RTS,                  # 0208:
        ])
    m.setregs(R(pc=start))
    m.call(start, trace=True); print(m.regs)
    assert R(pc=0x0208, a=0xCC) == m.regs

####################################################################
#   Tracing and similar information

@pytest.mark.parametrize('ops, disasm', (
    ([0x00],                    'FCB $00'),     # invalid instruction
    ([0xFD],                    'FCB $FD'),     # invalid instruction
    ([I.LDAA,   0xFD],          'LDAA #$FD'),
    ([I.LDAAm,  0x00, 0x0A],    'LDAA $000A'),
    ([I.LDAAz,  0x03],          'LDAA $03'),
    ([I.LDABx,  0xCD],          'LDAB $CD,X'),
    ([I.BRA,    0xF8],          'BRA $009A'),   # depends on start addr below
    ([I.JMP,    0x00, 0x0A],    'JMP $000A'),
    ([I.PSHB,   ],              'PSHB'),
    ([I.NOP,    ],              'NOP'),
))
def test_disasm(m, R, ops, disasm):
    start = ops[0] + 0x80   # pseudo-random start address
    m.deposit(start, ops)
    m.setregs(R(pc=start))
    assert disasm == m.disasm()

@pytest.mark.xfail(strict=True, reason='Unimplemented feature')
def test_disasm_symtab():
    ''' We should be able to have the disassembly function look up addresses
       in `self.symtab` and, if present there, print the symbolic name
       rather than the raw address.
    '''
    assert 0
