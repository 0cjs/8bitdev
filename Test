#!/usr/bin/env bash
set -eu -o pipefail

die() {
    local exitcode="$1"; shift
    [[ -z $1 ]] || echo 1>&2 "$@"
    exit $exitcode
}

#   If $py is unset, set it to a reasonable default. Either way, confirm
#   that it appears to be a Python 3 interpreter.
#
checkpy() {
    : ${py:=python3}
    #   stderr not redirected here so user sees any error from run attempt.
    "$py" --version >/dev/null || die 2 "Bad Python interpreter: $py"
    local v=$("$py" --version 2>&1 | head -1)
    [[ $v = 'Python 3.'* ]] || die 2 "Bad Python version: $v"
}

tool_setup() {
    [[ ${#@} -eq 1 ]] \
        || { echo 1>&2 'tool_setup(): tool path arg required'; return 2; }
    local tool_path="$1"; shift
    [[ -x $tool_path ]] || return 69    # EX_UNAVAILABLE: support file nonexist

    #   The tool_path command is expected to produce build output messages
    #   on stdout (1) and stderr (2), and commands to configure this shell
    #   process (e.g., to set environment variables) on file descriptor 3.
    #
    #   The following rather magical statement handles this by redirecting
    #   fd 3 of the subprocess to the standard output, to be read and
    #   executed by the source (`.`) command, and redirecting stdout of the
    #   subprocess to our current process' stdout so we can still see that
    #   output or have it properly sent to wherever our stdout is directed.
    . <($tool_path 3>&1 1>/proc/$$/fd/1)
}

####################################################################
#   Main

basedir=$(cd "$(dirname "$0")" && pwd -P)
export BUILDDIR="$basedir/.build"
all_tools="$basedir/.all-tools"

export B8_BASEDIR="$basedir"
b8tool="$B8_BASEDIR/b8tool/b8tool"

#   Leading command line args (these must be at the start):
#   • -C: clean rebuild of everything, including toolchains
#   • -c: clean rebuild of only this repo's source (test/toolchain output)
#   • -A: build and use all tools
#   All args after these are passed on to pytest.
while [[ ${#@} -gt 0 ]]; do case "$1" in
    -C)     shift; rm -rf "$BUILDDIR";;
    -c)     shift; rm -rf "$BUILDDIR"/{obj,pytest};;
    -A)     shift; touch "$all_tools";;
    -p)     shift; py="$1"; shift;;
    *)      break;;
esac; done

cd "$basedir"

checkpy; . ./activate -q -p "$py"

[[ -f $all_tools ]] && tool_setup tool/asxxxx/Setup
tool_setup tool/asl/Setup
tool_setup tool/diskimg/Setup
tool_setup tool/dos33fs/Setup
tool_setup tool/linapple/Setup
[[ $PATH =~ ^$basedir/bin:|:$basedir/bin:|:$basedir/bin$ ]] \
    || export PATH="$basedir/bin:$PATH"
mkdir -p "$BUILDDIR/obj"

#   In the following builds we have no dependency graph, so everything is
#   rebuilt each time. Fortunately this is quite fast.

####################################################################
#   ASxxxx builds
#   Due to issues with 32-bit binaries, run only when $all_tools set.

[[ -f $all_tools ]] && {
    #   Though we don't need to explicitly specify `simple` as an input
    #   file for the link (aslink would get it from the output file) we
    #   do so anyway to test that b8tool handles it correctly.
    $b8tool asx     src/asxxxx/simple.a65
    $b8tool asxlink src/asxxxx/simple simple
    $b8tool asx     src/asxxxx/reloctest.a65
    $b8tool asxlink src/asxxxx/reloctest -b '_code=0x400'
    $b8tool asx     src/asxxxx/zptest.a65
    $b8tool asxlink src/asxxxx/zptest -b '_code=0x0300'
}

####################################################################
#   AS builds

objdir() {
    #   The object directory for built files is the source path
    #   relative to the base, but under .build/obj/.
    local d=$(dirname "$1")         # Source file directory
          d=${d#$basedir/}          # Remove $basedir prefix if present
    echo "$basedir/.build/obj/$d"
}

#   Build a unit-test version of a "library" file that's normally used by
#   other files via `include`. This adds the setup and structure that is
#   normally provided by the file including the library file.
#
#   This supplies an `org $1000` directive, but this can be overridden by
#   supplying your own `org` in an additional parameter, if necessary.
#
#   XXX It also defines a `UNIT_TESTING` symbol to allow conditional
#   assembly of definitions needed for the unit tests. (These are the same
#   definitions that would normally be supplied by the file including the
#   library file.) Such code is actually in the wrong place; it should
#   really be in the unit test's `.pt` file and extracted programatically.
#   (E.g., by evaluating the `.pt` file in a Python interpreter, printing
#   out the contents of the `unit_test_code` variable and then including
#   that output into the the top-level source file generated by asbuild().)
#   However, the Bash code to set all this up is already getting overly
#   complex, so this will probably have to wait until we rewrite this part
#   of the build/test system in Python.
#
astest() {
    local filename="$1"; shift
    local cpu std
    case "$filename" in
        *.a65)  cpu=6502; std=m65/std.a65;;
        *.a68)  cpu=6800; std=mc68/std.a68;;
        *)      die 5 "astest(): Unknown file extension: $filename";;
    esac
    # XXX
    $b8tool asl "$filename" \
        ';   Unit Test Assembly'                                    \
        ''                                                          \
        'UNIT_TESTING equ 1'                                        \
        ''                                                          \
        "           cpu $cpu"                                       \
        '           include "src/'"$std"'"'                         \
        '           org $1000'                                      \
        ''                                                          \
        "$@"
}

a2exebuild() {
    local exe=$(basename "$1")
          exe=${exe%.*}             # Remove extension
    local objdir=$(objdir "$1")
    $b8tool asl "$@"
    p2a2bin "$objdir/$exe.p" > "$objdir/$exe"

    #   Build a disk image that will run the program when booted.
    local baseimg="$BUILDDIR/tool/src/dskimg/a2/EMPTY-DOS33-48K-V254.dsk"
    local img="$objdir/$exe.dsk"
    cp "$baseimg" "$img"
    dos33 -y "$img" SAVE B "$objdir/$exe" "${exe^^}"
    echo '10 PRINT CHR$(4);"BRUN' "${exe^^}" '"' \
        | tokenize_asoft > "$objdir/$exe.HELLO"
    dos33 -y "$img" DELETE HELLO    # Avoids annoying SAVE overwrite warning
    dos33 -y "$img" SAVE A "$objdir/$exe.HELLO" HELLO
    dos33 -y "$img" HELLO HELLO     # Ensure HELLO is run on boot

    #   The above can be run with:
    #       linapple --conf tool/linapple/linapple.conf \
    #           --d1 .build/obj/exe/a2/charset.dsk
    #   We should work out an option to do this automatically.
}

#   Non-CPU-specific builds/tests (assembler/toolchain tests).
$b8tool asl src/asl/nomacro.a65
$b8tool asl src/asl/sym.a65

#   CPU-specific basic tests that do not rely on the assembly framework.
$b8tool asl src/asl/simple.a65 ' org $240'
$b8tool asl src/mc68/simple.a68

#   Standalone blobs of code.
$b8tool asl src/tmc68/bioscode.a68

#   "Library" routines
astest  src/m65/stdtest.a65
astest src/mc68/stdtest.a68
astest  src/m65/qhex.a65
astest src/mc68/qhex.a68

astest src/m65/objects.a65
astest src/m65/bigint.a65

#   Portable programs (i.e., not platform-specific)
#   and their platform-specific versions.
astest   src/mc68/hello.a68     '  include "src/tmc68/bios.a68"'
$b8tool asl exe/tmc68/hello.a68
$b8tool asl exe/jr200/hello.a68
astest   src/mc68/pmon.a68      '  include "src/tmc68/bios.a68"'
$b8tool asl exe/tmc68/pmon.a68
$b8tool asl exe/jr200/pmon.a68

#   Platform-specific code blobs
$b8tool asl src/a1/pia2.a65
$b8tool asl src/a2/misc.a65
$b8tool asl src/a2/mondump.a65
$b8tool asl src/c64.a65
$b8tool asl src/jr200/jr200.a68
$b8tool asl src/fm7.a69

#   Platform-specific programs
$b8tool asl     exe/a1/charset.a65
a2exebuild  exe/a2/charset.a65

#   Other stuff (probably needs sorting into categories above)
astest  src/mc68/cpxtest.a68
astest  src/mc68/continuation.a68


####################################################################
#   Tests

export PYTHONPATH="$basedir/lib"
#   XXX This probably relies on the cwd to find the pytest.ini.
pytest -q "$@"
