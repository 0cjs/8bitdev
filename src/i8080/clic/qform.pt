from    testmc.i8080  import  Machine
from    src.clic.objref  import asbytes, \
    NIL, T, sym1 as s1, sym2 as s2, smallint as i
from    collections  import namedtuple
import  pytest

param   = pytest.mark.parametrize
R       = Machine.Registers

test_rig = '''
            cpu  8080
            include  src/i8080/std.i80
            include  testmc/i8080/tmc/biosdef.i80

            org  $80
hcons_ptop  dw   $C000
hcons_pbot  dw   $B000
hcons_pcur  ds   2
fatal_nomem halt

            org  $200
            include  src/i8080/clic/qform.i80

            include  src/i8080/clic/qtok.i80
            include  src/i8080/clic/heap.i80
            include  src/i8080/arith.i80
            include  src/i8080/qhex.i80
'''

####################################################################

#   XXX should getc ignore NUL?

class G:
    ' getc command '
    def __init__(self, expected):
        self.expected = asbytes(expected)
        self.sym = 'getc'
        self.initregs = R(a=0xFF)
    def test(self, m):
        assert R(a=ord(self.expected)) == m.regs

class U:
    ' ungetc command '
    def __init__(self, char):
        self.char = asbytes(char)
        self.sym = 'ungetc'
        self.initregs = R(a=ord(self.char))
    def test(self, m):
        assert True         # result tested by subsequent `getc`


@param('testname, commands', [
   ( 'get-only',        [ G('a'), G('b'), G('\r'), G('c') ]),
   ( 'one-unget',       [ G('a'), U('a'), G('a'), G('b') ]),
   ( 'unget-overwrite', [ G('a'), U('a'), U('X'), G('X'), G('b') ]),
])
def test_getc_regular(m, R, S, loadbios, testname, commands):
    loadbios(input=b'ab\rcd')
    m.call(S.qform_init)
    for cmd in commands:
        m.call(S[cmd.sym], cmd.initregs)
        cmd.test(m)

####################################################################

def remainder(m, inp):
    pushback = m.byte(m.symtab.getc_buf)
    if pushback == 0x00:
        return inp.read()
    else:
        return bytes([pushback]) + inp.read()

@param('tokentext, next', [    # input is tokentext+next
    ('(',               ')'),
    ('ab',              '    '),
    ('ab',              '\r  '),
    ('ab',              ')'),
    ('ab',              '(def'),
    ('+12345',          ' '),
    ('-3.75e10',        ' '),
    ('\r\n\t\v\f XX',   ' '),           # leading whitespace stripped by test
    ('  (',             ')'),
    # XXX test escape chars
])
def test_rtok(m, R, S, loadbios, tokentext, next):
    tokentext = asbytes(tokentext)
    next      = asbytes(next)
    input     = tokentext + next
    inp, _    = loadbios(input=tokentext+next)
    m.deposit(S.tokbuf, b'\xEE'*S.tokbuflen)

    m.call(S.rtok)
    print(m.hexdump(S.tokbuf, S.tokbuflen+1))

    expected = tokentext.lstrip() + b'\xEE'
    assert [                        expected,              next] \
        == [m.bytes(S.tokbuf, len(expected)), remainder(m, inp)]

# XXX test token too long error

####################################################################

@param('form, err, ast', [
    #   Atoms
    ['x ',          0, s1('x')],
    ['foobar\r',    0, s2('fo')],
    ['()',          0, NIL],
    #   Structures
    ['(x)',         0, s1('(')],       # XXX wrong!
    #   Errors
    [')',           1, NIL],
])
def test_form(m, R, S, loadbios, form, err, ast):
    inp, _    = loadbios(input=asbytes(form))
    print(f'form={form!r} err={err} ast={ast}')
    m.call(S.rform, R(C=not err, de=0xFFFF))
    if err == 0:
        assert R(C=0, de=ast) == m.regs
    else:
        assert R(C=1) == m.regs
