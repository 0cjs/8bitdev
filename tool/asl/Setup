#!/usr/bin/env python3
'''
    Configure for use of the Macroassembler AS.

    This will prefer, in order:
      1. An already-built version local to this project under .build/.
      2. A version provided by the environment.
      3. Fetch, build and install a local version for #1 above.

    This has three output streams: stdout and stderr from this program
    and any programs it calls to do the setup (fetch, build and
    install), and the "configuration output," which prints Bash
    commands to configure the caller to use what it's set up.

    If file descriptor 3 is open when this is started, the
    configuration commands will be printed to that. The caller is
    expected to execute these, while passing through stdout and
    stderr, with the following Bash magic incantation:

        . <($tool_path 3>&1 1>/proc/$$/fd/1)

    If file descriptor 3 is not open, the configuration commands will
    be printed to stdout, prefixed by ``CONFIG: ``. (The caller can
    copy these and execute them by hand if he likes.)

    TODO:
    - Add ability to force fetch/build/use of local tool version even
      when one is available from the environment.

'''

####################################################################
#   Configuration

TOOLSET_NAME = 'asl'
SOURCE_REPO = 'https://github.com/KubaO/asl.git'
SOURCE_REF  = 'dev/cjs/current'

####################################################################
#   Globals

from    pathlib import Path
import  os, shutil, subprocess, sys, traceback

class ASL:

    def __init__(self):
        #   Project build directory under which we put our tool/ directory.
        self.builddir = None

    def pdir(self, dir, *subdirs, create=True):
        ''' Return an absolute path to a subdirectory under the prefix
            ($builddir/tools) we use for toolsets. The first level `dir`
            must be a member of `PREFIX_SUBDIRS`.

            If `create` is `True`, this will create the directory, if
            necessary.
        '''
        if not dir in PREFIX_SUBDIRS:
            raise ValueError('Internal error: {} not in PREFIX_SUBDIRS'.format(dir))

        d = self.builddir.joinpath('tool', dir, *subdirs)
        if create:
            d.mkdir(parents=True, exist_ok=True)
        d = d.resolve()   # strict=False not available in Python ≤3.5, so we
                          # must have created the directories before we resolve.
        return d

    def srcdir(self, resolve=False):
        if not resolve:
            return self.builddir.joinpath('tool', 'src', TOOLSET_NAME)
        else:
            #   Work around not having ``strict=True`` option to
            #   `Path.resolve()` in Python ≤3.5 by resolving `BUILDDIR`
            #   instead, which will always exist if we've reached the point
            #   of needing the target dir.
            return self.builddir.joinpath('tool', 'src').resolve().joinpath(TOOLSET_NAME)

    def setbuilddir(self):
        ''' Locate build and target directories.

            If the ``BUILDDIR`` environment variable is set, we use that,
            creating that directory if necessary. Otherwise if ``.build/``
            exists in the current working directory, we use that.
        '''
        if os.environ.get('BUILDDIR', None):
            self.builddir = Path(os.environ['BUILDDIR'])
            for d in PREFIX_SUBDIRS:
                self.builddir.joinpath('tool', d) \
                    .mkdir(parents=True, exist_ok=True)
            return

        if Path('.build').is_dir():
            self.builddir = Path('.build')
            return

    def setpath(self):
        ''' Update ``PATH`` to include the tools we're building.

            XXX This does not work on Windows.
        '''
        if not self.builddir:
            #   Cannot build; must rely on the environment providing the tool.
            return

        path = os.environ.get('PATH', None)
        if path is None:
            errexit(EX_CONFIG, 'ERROR: No PATH variable in environment')
        separator = ':'                     # XXX not right for Windows
        td = str(self.pdir('bin'))
        if td in path:                      # XXX mismatches if substring
            return
        path = td + separator + path
        os.environ['PATH'] = path
        printconfig("PATH='{}'".format(path))

    ####################################################################
    #   Fetch/build/install routines

    def check_installed(self):
        ''' *Silently* determine if the toolset is currently available or
            not and exit with success if it is.
        '''
        #   XXX Start with shutil.which, first?
        try:
            c = subprocess.run(['asl', '-this-is-not-an-option'],
                stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
        except FileNotFoundError:
            return
        if c.returncode == 4 and b'Invalid option' in c.stdout:
            successexit()

    def fetch(self):
        ''' Fetch the tool if not already present in TARGET. '''
        if self.srcdir().is_dir():
            print('----- Using existing source in {}'.format(self.srcdir()))
            return

        print('----- Cloning {} from {}'.format(TOOLSET_NAME, SOURCE_REPO))
        runcmd([ 'git', 'clone', str(SOURCE_REPO), str(self.srcdir()) ])

        print('----- Switching to ref or branch {}'.format(SOURCE_REF))
        runcmd([ 'git', '-C', str(self.srcdir()), 'checkout', str(SOURCE_REF) ])

    def configure(self):
        ''' Configure build, if not already done. '''
        if self.srcdir().joinpath('Makefile.def').exists():
            print('----- Using existing build configuration')
            return

        print('----- Configuring {}'.format(self.srcdir()))

        shutil.copyfile(
            str(Path(__file__).parent.joinpath('gitignore')),
            str(self.srcdir().joinpath('.gitignore')))
        shutil.copyfile(
            str(self.srcdir().joinpath(
                'Makefile.def-samples', 'Makefile.def-x86_64-unknown-linux')),
            str(self.srcdir().joinpath('Makefile.def')))

    def build(self):
        ''' Build  the tool.

            This is generally expected to rebuild the tool if any files have
            changed in the local source copy.
        '''
        #   Note we avoid building the documentation here.
        runcmd(['make', '-j8'], cwd=self.srcdir())

    def install(self):
        ''' For ASL we don't use `make install` because that wants to build the
            documentation, which requires LaTeX and even then tends to drop to
            interactive prompts about missing `german.sty` etc.

            As well, it's nicer four our purposes to use symlinks back to the
            build directory because then a developer tweaking AS can just
            `make` in the source directory to make the new version available to
            the build system.

            So instead we emulate the parts of install.{bat,cmd,sh} we want,
            which is bin/, lib/ (the message files are required) and include/.
        '''

        binfiles = ('asl', 'plist', 'alink', 'pbind', 'p2hex', 'p2bin',)
        for f in binfiles:
            dest = self.pdir('bin').joinpath(f)
            if not dest.exists(): dest.symlink_to(self.srcdir().joinpath(f))

        #   The localization message files normally go in lib/asl/, but the
        #   programs don't find them there by default (unless perhaps the
        #   prefix is /usr/local/). We could emit a setting for the AS_MSGPATH
        #   environment variable to indicate where they are, but to allow use
        #   of these tools from the command line without running the Setup
        #   script, it seems better to just drop the files into bin/, where the
        #   programs can automatically find them.
        #
        for path in self.srcdir().glob('*.msg'):
            dest = self.pdir('bin').joinpath(path.name)
            if not dest.exists(): dest.symlink_to(path)

        srcs = self.srcdir().joinpath('include')
        for src in srcs.glob('**/*'):
            if src.is_dir(): continue
            dest = self.pdir('include', 'asl').joinpath(src.relative_to(srcs))
            dest.parent.mkdir(parents=True, exist_ok=True)
            if not dest.exists(): dest.symlink_to(src)

    def main(self):
        self.setbuilddir()
        self.setpath()
        self.check_installed()
        if not self.builddir:
            errexit(EX_USAGE,
                'BUILDDIR not set and {} is not a directory.'.format(BUILDDIR))
        else:
            self.fetch()
            self.configure()
            self.build()
            self.install()

####################################################################
#   Main program

if (__name__) == '__main__':
    try:
        sys.path.insert(0, str(Path(__file__).parent.parent.resolve()))
        from setup import *
        ASL().main()
    except Exception as ex:
        printconfig('return', EX_SOFTWARE)
        errprint('INTERNAL ERROR in', sys.argv[0])
        traceback.print_exc()
        sys.exit(EX_SOFTWARE)
