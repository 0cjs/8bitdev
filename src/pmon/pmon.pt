from    testmc  import *
from    testmc.mc6800  import *
import  pytest

R = Machine.Registers

test_rig = '''
            cpu 6800
            org $1000

pmon_ramlo  equ $0080
pmon_org    equ $1000
            include src/mc68/std.a68
            include src/tmc68/bios.a68
            include src/pmon/pmon.a68

; ----------------------------------------------------------------------
;   Mock command table(s) for testing

            org $4FFF
cmdtbl_1
cmdentry_a  db  'a'             ; command character
            dw  $0000           ; command entrypoint (testing zeros here)
            db  'x',CTP_WORD    ; parameters
            db  'y',CTP_BYTE
            db  CTP_END

            db  CT_CONTINUE
            dw  cmdtbl_2

            org $5EEE
cmdtbl_2
cmdentry_n  db  'n'             ; command with no parameters
            dw  $1234
            db CTP_END

cmdentry_b  db  'b'
            dw  $100B
            db  'x',CTP_BYTE
            db  'y',CTP_WORD
            db  'n',CTP_NYBBLE
            db  'u',CTP_UVAR
            db  CTP_END

cmdentry_c  db  'c'
            dw  $100C
            db  CTP_END

cmdentry_d  db  'd'
            dw  $100D
            db  CTP_END

            db  CT_END

;   $7FFF onward is pmon RAM areas, set up by tests

; ----------------------------------------------------------------------
'''

param = pytest.mark.parametrize

@param('result, x, b', (
    ( 0x1000, 0x1000, 0x00 ),
    ( 0x2001, 0x2000, 0x01 ),
    ( 0x30FF, 0x3000, 0xFF ),
    ( 0x4100, 0x40FF, 0x01 ),
    ( 0x0001, 0xFFFF, 0x02 ),
))
def test_addXB(m, S, R, result, x, b):
    a = b ^ 0xA5
    inputs = R(x=x, b=b, a=a)
    print(inputs)
    m.call(S.addXB, inputs)
    assert R(x=result, a=a) == m.regs

@param('ctp_type_sym, ctp_len', [
    ('CTP_WORD', 2),
    ('CTP_BYTE', 1), ('CTP_NYBBLE', 1), ('CTP_UVAR', 1),
    #   XXX how to deal with boolean? need to look at _prev_ entry
    #       but how do we know if we have a previous entry?
])
def test_addBpvsize(m, R, S, ctp_type_sym, ctp_len):
    ctp_type = S[ctp_type_sym]
    addr = 0xA000 + ctp_type
    print('{}=${:02X} len={} addr=${:04X}'.format(
        ctp_type_sym, ctp_type, ctp_len, addr))
    m.deposit(addr, [ord('a'), ctp_type])   # param entry is paramchar, valtype
    m.call(S.addBpvsize, R(a=0xEA, b=0x10, x=addr))
    assert R(a=0xEA, b=0x10 + ctp_len, x=addr) == m.regs

def test_paramlookup(m, R, S):
    assert S.paramlookup
    assert 0

@param('cmdchar, cpvals_offset', [
    #   The vals offsets are calculated by hand from the test command tbl above.
    ('a', 0), ('b', 3), ('c', 8), ('d', 8),
])
def test_cmdlookup_success(m, S, R, cmdchar, cpvals_offset):
    m.depword(S.cmdtbl, S.cmdtbl_1)
    m.depword(S.cmdpvbase, 0x7FFD)

    m.call(S.cmdlookup, R(a=ord(cmdchar), x=0xFFFF, C=1))

    cmdentry = m.word(S.cmdentry); print('entry:', m.hexdump(cmdentry, 9))
    cmdpvals = m.word(S.cmdpvals); print('pvals:', m.hexdump(cmdpvals, 9))
    assert (ord(cmdchar), False, S['cmdentry_'+cmdchar], 0x7FFD+cpvals_offset) \
        == (m.a,          m.C,   cmdentry,               cmdpvals)

@param('cmdchar', [0xFF, 0x00, 0x01, ord('Z')])
def test_cmdlookup_failure(m, S, R, cmdchar):
    m.depword(S.cmdtbl, S.cmdtbl_1)
    cmdpvbase = 0x7FFF + cmdchar    # test at different locations
    m.depword(S.cmdpvbase, cmdpvbase)
    #   Length of variables area below manually calculated
    #   from CTP_* values in test command table above.
    cmdpvals_end = cmdpvbase + 8

    m.call(S.cmdlookup, R(a=cmdchar, x=0xFFFF, C=0))
    assert (R(C=1, a=cmdchar), cmdpvals_end) == (m.regs,  m.word(S.cmdpvals))
