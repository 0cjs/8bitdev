; ----------------------------------------------------------------------
;   qhex - hexadecimal number parsing and related routines
; ----------------------------------------------------------------------

  ifdef UNIT_TESTING
    ifndef qhex_len
qhex_len                    equ $20     ; BYTE max digits to parse
    endif
    ifndef qhex_out
qhex_out                    equ $21     ; WORD output of qhex*
    endif
  endif

; ----------------------------------------------------------------------
;   Parse up to A (1-4) ASCII hex digits at X, N=0 on success.
;   ♠X,qhex_out  ♣AB,qhex_len
;
;   Input:
;   - X: the start of the text to be parsed.
;   - A: 1-4, the maximum number of digits to parse
;   Temps:
;   - qhex_len
;   Output:
;   - X: the first char that failed to parse
;   - N flag: clear if at least one digit successfully parsed, set otherwise
;   - qhex_out: the parsed hex number, or $0000 on failure to parse any digits
;
;   No locations benefit significantly from being in the zero page.

qhexword    lda A,#4            ; parse up to 4 digits
            bra qhex

qhexbyte    lda A,#2
            ;   fallthrough

qhex        sta A,qhex_len
            clr qhex_out        ; current result: $0000
            clr qhex_out+1
            lda B,#$FF          ; non-zero indicates no digits read

.nextchar   lda A,,X
            bsr qdigit
            bmi .exit           ; bad digit, return
            cmp A,#$0F+1
            bcc .exit           ; digit in base >16
            inx                 ; consume this character
            asl A               ; shift value to upper nybble
            asl A
            asl A
            asl A
            lda B,#4
.shiftin    asl A               ; upper bit to carry
            rol qhex_out+1      ; low bit into LSB
            rol qhex_out        ; high bit into MSB
            dec B
            bne .shiftin
            ;   B is now 0, showing that we've read a digit.
            dec qhex_len
            bne .nextchar

.exit       tst B               ; did we consume at least one char?
            rts

; ----------------------------------------------------------------------
;   ♠A ♡BX Convert ASCII character to binary number in bases up to 41.
;   Returns N flag clear and binary digit in A, or N set on error.
;
;   This translates A-Z[\]^_ and a-z{|}~DEL as 10, 11...40. The caller
;   must check the returned value if the intended base was less than 41.

qdigit      cmp A,#'9'+1
            bcc .letter         ; >9, convert letter
            sub A,#'0'          ; convert digit, N set if <0
            rts
.letter
            and A,#%11011111    ; clear bit 5 to convert to upper-case
            bmi .exit           ; high bit set, error
            sub A,#'A'-$0A
            cmp A,#$0A          ; set N if < $0A
.exit       rts
