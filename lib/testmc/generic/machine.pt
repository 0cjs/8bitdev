from    testmc.generic   import *
from    testmc.memimage  import MemImage
import  pytest

@pytest.fixture
def M():
    class Machine(GenericMachine):

        class Registers(GenericRegisters):
            registers = (Reg('pc', 16), )
            srbits = (Bit(1), Bit(0), Flag('B'), Bit(1))

        def __init__(self, pc=0):
            self.mem = [0] * 16
            self.pc = pc
            #   This must still have either attribute B or a status
            #   resgister defined.

            #   Test attributes
            self._steps_taken = 0

        is_little_endian            = False
        def get_memory_seq(self):   return self.mem

        _JSR_opcodes    = set([0x28, 0x29])
        _RTS_opcodes    = set([0x20, 0x21])
        _ABORT_opcodes  = set([0x80, 0x81])

        def _getpc(self):
            return self.pc

        def _step(self):
            ''' In this test Machine, all opcodes are NOPs with the low two
                bits indicating how many additional bytes should be
                consumed as arguments to this opcode.
            '''
            argcount = self.byte(self.pc) & 0b11
            self.pc += argcount + 1
            self.pc &= 0xFFFF
            self._steps_taken += 1

    return Machine

@pytest.fixture
def R(M):
    ''' Registers class of the Machine created by the `M()` fixture.

        This assumes that the default for the Machine class has not
        been overridden in an instance. If you do override it, you must
        use the `Registers` attribute from that instance.
    '''
    return M.Registers

####################################################################
#   Instantiation

def test_abc():
    class M(GenericMachine):
        is_little_endian = None
        def get_memory_seq(): pass
    with pytest.raises(TypeError) as ex:
        M()
    assert ex.match(r"Can't instantiate abstract class M")
    assert ex.match(r'Registers')

def test_instantiation(M):
    assert type is type(M.Registers)
    r = M.Registers(pc=3);  assert    3 == r.pc
    r = M().Registers();    assert None is r.pc

####################################################################
#   Usage

def test_memory(M):
    ' Smoke test: make sure the functions are there. '
    m = M()
    assert  0 == m.byte(3)
    m.deposit(3, 42)
    assert 42 == m.byte(3)

def test_regs_flag_attributes(M, R):
    m = M(); m.B = False
    assert R() == m.regs
    assert R(pc=0, B=0) == m.regs

    m.pc = 3; m.B = True
    assert R(pc=3, B=1) == m.regs

def test_regs_status_register(M, R):
    R.srname = 'psr'

    m = M(); m.psr = 0b1001
    assert R() == m.regs
    assert R(pc=0, psr=0b1001) == m.regs
    assert R(B=False) == m.regs

    m.pc = 4; m.psr = 0b1011
    assert R(pc=4, psr=0b1011) == m.regs
    assert R(B=True) == m.regs

def test_setregs_flag_attributes(M, R):
    m = M(); m.B = False;       assert (     0, False) == (m.pc, m.B)
    m.setregs(R(pc=0xF000));    assert (0xF000, False) == (m.pc, m.B)
    m.setregs(R(B=1));          assert (0xF000,  True) == (m.pc, m.B)
    m.setregs(R(pc=4, B=0));    assert (     4, False) == (m.pc, m.B)

def test_setregs_status_register(M, R):
    R.srname = 'psr'

    m = M(); m.psr = 0b1001;    assert (0, 0b1001) == (m.pc, m.psr)
    m.setregs(R(pc=6));         assert (6, 0b1001) == (m.pc, m.psr)
    m.setregs(R(B=1));          assert (6, 0b1011) == (m.pc, m.psr)
    m.setregs(R(pc=7, B=0));    assert (7, 0b1001) == (m.pc, m.psr)

    #   setregs() (really, R.set_attrs_on()) ignores any PSR bits defined
    #   as constant bits rather than flags.
    m.setregs(R(psr=0b0110));   assert (7, 0b1011) == (m.pc, m.psr)

def test_regs_setregs_regsattr(M, R):
    ' Test using a separate object to hold the register values. '
    class SubMachine(): pass
    sm = SubMachine()
    sm.pc = 99;  sm.B = True

    m = M();  del m.pc;  m.regsobj = sm
    assert not hasattr(m, 'pc')
    assert not hasattr(m, 'B')
    assert not hasattr(m, 'srname')

    assert R(pc=99, B=1) == m.regs

    m.setregs(R(pc=201, B=0))
    assert R(pc=201, B=0) == m.regs
    assert (201, False) == (sm.pc, sm.B)
    assert not hasattr(m, 'pc')
    assert not hasattr(m, 'B')

####################################################################
#   Object code loading

def test__load_memimage(M, R):
    memlen = 0x800

    m = M()
    m.B = False
    m.mem = [0] * memlen

    mi = MemImage()
    rec1data = (0x8a, 0x8c, 0x09, 0x04, 0x18, 0x6d, 0x09, 0x04, 0x60)
    mi.append(mi.MemRecord(0x400, rec1data))
    mi.append(mi.MemRecord(0x123, (0xee,)))
    mi.entrypoint = 0x0403

    expected_mem \
        = [0] * 0x123 \
        + [0xEE] \
        + [0] * (0x400 - 0x124) \
        + list(rec1data) \
        + [0] * (memlen - 0x400 - 9)

    m.load_memimage(mi)
    assert R(pc=0x0403)    == m.regs
    assert expected_mem    == m.mem

@pytest.mark.xfail(strict=True, reason='''
    Much of load() is calling code that's already unit-tested, but there's
    still some complex logic in load() itself that's currently tested only
    by clients of this library.
''')
def test_load():
    assert 0 # XXX write me

####################################################################
#   Execution

def test_underscore_step(M):
    ' Test that our test _step() function is doing what it should. '
    m = M()
    m.deposit(m.pc, b''.join((
        b'\x00', b'\x01' * 2, b'\x02' * 3, b'\x03' * 4, b'\x04', )))

    ...;            assert  0 == m.pc
    m._step();      assert  1 == m.pc
    m._step();      assert  3 == m.pc
    m._step();      assert  6 == m.pc
    m._step();      assert 10 == m.pc
    m._step();      assert 11 == m.pc

def test_step(M):
    m = M();    assert 0 == m._steps_taken
    m.step();   assert 1 == m._steps_taken
    m.step(3);  assert 4 == m._steps_taken

@pytest.mark.parametrize('stopat, steps, pc', (
    (                       0xFD,   2, 3),  # stopat scalar
    (    [0x02, 0xFE, 0xFD, 0xFC],  2, 3),  # stopat collections
    (set([0x02, 0xFE, 0xFD, 0xFC]), 2, 3),
    (                       0x00,   3, 5),  # always execute first op
))
def test_stepto(M, stopat, steps, pc):
    m = M(); m.B = False
    m.deposit(m.pc, b'\x00\x01\xFD\xFD\x00\x00')
    print('stop at', type(stopat), stopat)   # test name not obvious
    m.stepto(stopat)
    assert (steps, pc) == (m._steps_taken, m.pc)

def test_stepto_empty_stopat_and_otherargs(M):
    m = M(); m.B = False
    m.deposit(m.pc, b'\x00\x01\xFD\xFD\x00\x00')
    with pytest.raises(m.Timeout) as ex:
        m.stepto(set(), maxsteps=3, trace=True)
    assert (3, 5) == (m._steps_taken, m.pc)
    assert ex.match('after 3 opcodes: CPU pc=0005')

def test_call_rts_regs(M, R):
    m = M(); m.B = False
    m.deposit(0x09, b'\x20')            # RTS

    m.call(0x09, R(B=True))
    assert R(pc=0x09, B=True) == m.regs # set regs but did not execute RTS

    m.call(0x06, R(B=False))            # a few NOPS then RTS
    assert R(pc=0x09, B=False) == m.regs

def test_call_shallow(M, R):
    m = M(); m.B = False
    m.deposit(0x08, b'\x28\x20\x20')    # JSR, RTS, RTS
    m.call(0x08)
    assert R(pc=0x0A) == m.regs         # returned before 2nd RTS

def test_call_deep(M, R):
    m = M(); m.B = False
    m.deposit(0x02, b''.join([
        b'\x29\x00',                    # JSR w/1-byte operand
        b'\x28\x28',                    # JSR, JSR
        b'\x21\x00',                    # RTS w/1-byte operand
        b'\x21\x00',                    # RTS w/1-byte operand
        b'\x20\x20',                    # RTS, RTS
        ]))
    m.call(0x02, trace=True)
    assert R(pc=0x0B) == m.regs

def test_call_abort(M, R):
    m = M(); m.B = False
    #                    6   7   8   9   A   B
    m.deposit(0x06, b'\x28\x20\x80\x81\x00\xC0')

    with pytest.raises(m.Abort) as ex:
        m.call(0x06, trace=True)                    # default abort opcode
    assert R(pc=0x08) == m.regs
    assert ex.match(r'^Abort on opcode=\$80: ')

    with pytest.raises(m.Abort) as ex:
        m.call(0x09, trace=True)                    # abort on first instruction
    assert R(pc=0x09) == m.regs
    assert ex.match(r'^Abort on opcode=\$81: ')

    with pytest.raises(m.Abort) as ex:
        m.call(0x06, aborts=0xC0, trace=True)       # non-default scalar abort
    assert R(pc=0x0B) == m.regs
    assert ex.match(r'^Abort on opcode=\$C0: ')

    with pytest.raises(m.Abort) as ex:
        m.call(0x06, aborts=(0xD0, 0xC0))           # non-default set abort
    assert R(pc=0x0B) == m.regs

def test_call_arg_overrides_R_pc(M, R):
    m = M(); m.B = False
    m.deposit(8, b'\x20')

    with pytest.raises(m.Abort):
        m.call(7, aborts=0)             # confirm abort works

    m.call(8, R(pc=2), aborts=0)        # exception if R(pc) overrides arg
    assert R(pc=8) == m.regs
