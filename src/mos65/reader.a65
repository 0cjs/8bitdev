;   a simple reader for (very limited) S-expressions

q_point     equ $60         ; pointer to current parse point in input buffer
q_value     equ $62         ; parsed value (if any)

;   ♡AXY consume a character
qchar       inc q_point
            bne .done
            inc q_point+1
.done       rts

;   ♠Y=0 ♣A ♡X consume spaces
qspaces     ldy #0
            lda (q_point),y
            cmp #' '
            beq .consume
            clc
            rts
.consume    jsr qchar
            clc
            bcc qspaces

;   attempt to parse a '()' (left-paren, right paren), interpreted as nil
qLR         ldy #0
            lda (q_point),y
            cmp #'('
            beq .close
            rts
.close      jsr qspaces
            lda (q_point),y
            cmp #'('




            end
----------------------------------------------------------------------

    parse: start by consuming spaces, then:
        - '(', ' '*, ')'    -> nil
        - 
        - consume spaces
        - '
        - '(' → start of list or nil (consume spaces to check
        - try smallint
        - anything else: symbol (just 2 chars for the moment)

    TOP:
        parse
        case
            object:         val := obj, goto DONE
            end of list:    ERROR "unclosed expr"
            start of list:  push(val), val → alloc(), cur = val, goto STARTING

    STARTING:   # reading value for already-alloc'd head cell of a list
                # - cur.car is waiting to be filled
                # - cur.cdr will be filled by APPENDING
        parse
        case
            object:         cur.car := obj
                            goto APPENDING
            end of list:    NOTREACHED because parser reads () as nil
            start of list:  cur.car → alloc()   # same as 2nd half SOL below
                            push(cur)
                            cur := cur.car
                            goto STARTING

    APPENDING:  # reading value for not-yet-alloc'd cell to append to cur list
                # - cur.car is filled
                # - cur.cdr is waiting to fill w/next cell ptr or end of list
        parse
        case
            end of input:   ERROR "unclosed expr"
            end of list:    cur.cdr := ∅
                            cur → pop(),
                            if cur = val: goto DONE
                                    else: goto APPENDING
            object:         cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car := obj      # ...is object
                            goto APPENDING      # continue with current list
            start of list:  cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car → alloc()   # ...points to head of new list
                            push(cur)           # we'll come back to this later
                            cur := cur.car      # start with new list
                            goto STARTING
