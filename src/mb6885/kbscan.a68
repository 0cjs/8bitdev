;   kbscan - "New" MB-6885 keyboard read with 2-key rollover

; ----------------------------------------------------------------------

;   For the moment we use the monitor's setting for break key processing.
brkkey_ena  equ  $13        ; BREAK key processing: $00=ignored
                            ;   $F0=call BREAKV (default after reset)

;    Keyboard: read/write
;      RD bits 7-4: kana-symbols, kana,    romaji-symbols, romaji
;        (equiv to: AltGR,        R-Shift, Ctrl,   L-Shift
;      WR bits 7-4: ??? break key enable/disable?
;      WR bits 3-0: row (col?) output (strobe?)
IO_kbd      equ  $EEC0

; ----------------------------------------------------------------------

;   ♡B Non-blocking read of keyboard, returning scan codes.
;   C=1: nothing pressed. C=0: char/graphic code returned in A.
;   Note that this is a different API from the ROM `KBIN`!
;
;   kbscan_actv points to kbscan_len bytes that store the currently pressed
;   key codes. On entry, any keys in this set that are currently pressed
;   will be ignored; any keys currently pressed will be removed. If the
;   storage is full, all keypresses will be ignored until one of the keys
;   in the set is released.
;
kbscan      psh B
            ;   Clear any keys that were marked as pressed in `kbscan_actv`
            ;   but have since been released.
.cr.start   lda B,#kbscan_len
            ldx #kbscan_actv
.cr.check   psh B
            ;   Check [X] and leave it set or clear it to $00.
            lda A,,X        ; load row bits (7-4), column (3-0)
            beq .cr.next    ; $00 = no active key in this slot
            tab             ; copy row bits, column
            and A,#$0F      ; mask column to scan
            sta A,IO_kbd    ;   (disables BREAK NMI too; dealt with later)
            lda A,IO_kbd    ; get modifier and rows currently down
   ;sta A,4,X               ; XXX DEBUG
            asl A           ; shift rows to high nybble
            asl A
            asl A
            asl A
            and A,,X        ; is row from kbscan_actv set in what we read?
            bne .cr.next    ;   yes: move on to next kbscan_actv
            lda #0          ; clear this active key
            sta A,,X
            ;   Next byte in array.
.cr.next    pul B
            dec B           ; remaining byte count == 0?
            beq .cr.end     ;   yes: done
            inx
            bra .cr.check
.cr.end

            ;   XXX SKETCH
            ;   Find the "next" keypress, i.e., the first in a scan of the
            ;   entire keyboard that is not in `kbscan_actv`.
.nk.start   lda B,#$0C      ; highest column number

.nk.loop    psh B           ; save current column
            sta B,IO_kbd    ; set column (disables BREAK NMI; dealt with later)
            lda A,IO_kbd    ; read modifier keys (b7-4) and rows (b3-0)
            ; XXX save modifier key bits here? Or once at start?
            asl A           ; move rows (b3-0) to high nybble (b7-4)
            asl A
            asl A
            asl A
            aba             ; copy column to low nybble (b3-0)
            tab             ; save all rows
            and A,#$F0      ; are any rows active?
            beq .nk.nxtcol  ;   no: continue scan

            ;   Check each row to see if it's active and not already pressed
            tba             ; restore all rows
            and A,#$1F      ; remove all rows but 0, keeping column
            bsr .chknewkey  ; is it a keypress that was not not already pressed?
            bne .savekey    ;   no: we have our new keypress
            ;
            tba             ; repeat above for
            and A,#$2F      ;   row 1
            bsr .chknewkey
            bne .savekey
            ;
            tba             ; repeat above for
            and A,#$4F      ;   row 2
            bsr .chknewkey
            bne .savekey
            ;
            tba             ; repeat above for
            and A,#$8F      ;   row 3
            bsr .chknewkey
            bne .savekey

.nk.nxtcol  ;   No new keypress in this column; move on to the next
            pul B           ; restore current column
            dec B           ; next column
            bpl .nk.loop    ; ≥0 → continue
            sec             ; indicate no new keys pressed
.nk.end     bra .exit

.savekey    ;   XXX write me
            clc             ; indicate key code returned in A
            ;   fallthrough

            sec             ; XXX nothing read (only while debugging)

.exit       ;   Carry flag and A have been set with return values;
            ;   ensure nothing here changes it!
            lda B,brkkey_ena; restore BREAK key on/off state
            sta B,IO_kbd    ; (we don't care about the column number)
            pul B
            rts

;   ♣ABX Return in X the first free (empty) slot in kbscan_actv.
;   Returns in flag N: 0=success, 1=no slots free
.freeslot   lda B,#kbscan_len-1
            ldx #kbscan_actv
-           lda A,,X
            beq .rts        ; 0 = free slot = not negative
            inx
            dec B
            bmi .rts        ; negative so returns no slots free
            bra -

.rts        rts

;   ♡AB♣X   Determine if we have a new keypress in A. Bits 3-0 are the column
;           that was scanned and one of bits 7-4 may be set to indicate which
;           key in that column is pressed.
;   Return flag Z:
;     0: A row bit is set and the row/col is not found in kbscan_actv.
;     1: Row bits = %0000 (no keypress) or keypress found in kbscan_actv
;        (i.e., no new key pressed).
;
;   The 2×PSH here to preserve B saves 4 bytes in the callers.
;
.chknewkey  psh B           ; save to avoid destruction
            psh A
            and A,#$F0      ; do we have a keypress?
            pul A
            beq .cnk.done   ;   no: return with Z=1

            lda B,#kbscan_len
            ldx #kbscan_actv-1
-           dec B           ; checked all slots?
            bmi .cnk.done   ;   yes: return with Z=0
            inx
            cmp A,,X        ; in this slot?
            beq .cnk.done   ;   yes: return with Z=1
            bra -

.cnk.done   pul B           ; assumes Z flag already set correctly
            rts


;   Array of bytes indicating which keys (excluding modifier keys) that
;   were still pressed when we last exited `kbscan`. The low nybble is the
;   column number as written to `IO_kbd` bits 3-0; the high nybble is
;   one bit from the row bits returned on a read of `IO_kbd` bits 3-0.
;   $00 indicates "no key pressed" in that slot.
    .ifndef kbscan_actv
kbscan_len  equ 3           ; length of kbscan_actv array; must be <$80!
kbscan_actv db 0
            db 0
            db 0
    .endif ; kbscan_actv
