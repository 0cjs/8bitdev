from    testmc.mc6800.opcodes   import Instructions as I
from    testmc.mc6800.opcodes   import *
from    testmc.mc6800.opimpl    import *
from    testmc.mc6800           import Machine
from    testmc                  import tmc_tid, LSB, MSB
from    numbers                 import Number
import  pytest

#   Many functions from the opimpl module are not directly tested, but
#   instead are tested through the tests of instruction implementations.
#   This is because we want to test directly as many instruction
#   implementations as possible. The instruction implementations themselves
#   are usually very simple, and so their tests are mainly testing the
#   support functions anyway.

####################################################################
#   Address handling, reading data at the PC

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         (   0xFE,      1,     0xFF),
                         (   0xFE,      2,     0x00),
                         (   0xFE,      3,     0x01),
                         (      1,     -1,        0),
                         (      1,     -2,     0xFF),
                         (      1,     -3,     0xFE),
), ids=tmc_tid)
def test_incbyte(initial, addend, expected):
    assert expected == incbyte(initial, addend)

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         ( 0xFFFE,      1,   0xFFFF),
                         ( 0xFFFE,      2,   0x0000),
                         ( 0xFFFE,      3,   0x0001),
                         (      1,     -1,        0),
                         (      1,     -2,   0xFFFF),
                         (      1,     -3,   0xFFFE),
                         ( 0x8000, 0xFFFF,   0x7FFF),
                         ( 0x8000,-0xFFFF,   0x8001),
), ids=tmc_tid)
def test_incword(initial, addend, expected):
    assert expected == incword(initial, addend)

@pytest.mark.parametrize(' inb,   out', (
                         (0x00,     0),
                         (0x01,     1),
                         (0x7F,  0x7F),
                         (0x80, -0x80),
                         (0xFF,    -1),
), ids=tmc_tid)
def test_readsignedbyte(inb, out):
    m = Machine()
    m.pc = 0xFFFF
    m.deposit(m.pc, inb)
    assert out == readsignedbyte(m)
    assert 0x0000 == m.pc

@pytest.mark.parametrize('     x, offset, target', (
                         (0x0000,   0x00, 0x0000),
                         (0x0004,   0x03, 0x0007),
                         (0x0080,   0xFF, 0x017F),
                         (0xFFFF,   0x01, 0x0000),
                         (0xFFFF,   0xFF, 0x00FE),
))
def test_readindex(x, offset, target):
    m = Machine()
    m.setregs(R(x=x, pc=0x10))
    m.deposit(0x10, offset)
    assert target == readindex(m)

####################################################################
#   Opcode test framework

R = Machine.Registers

def runop(opdata, *, machine=None, memsize=0x20,
        startaddr=0x0E, initregs=R(), initmem={},
        changedregs=R(), changedmem={}):
    m = machine
    if m is None:
        m = Machine(memsize=memsize)

    #   Set registers A, B and X to have non-zero values if they're not
    #   otherwise used to help detect if they're accidentally zeroed.
    m.a = 0xA5; m.b = 0xB5; m.x = 0xC5D5;

    #   For any register not explicitly set that has a value in changedregs,
    #   set it to some other value so we can confirm it was changed.
    unsetregs = set()
    for name, val in initregs.all().items():
        if val is None: unsetregs.add(name)
    #   But always exclude the program counter and stack pointer
    #   as they should never be randomized!
    unsetregs.discard('pc'); unsetregs.discard('sp')
    for name, val in changedregs.valued().items():
        if name in unsetregs:
            setattr(m, name, not val)
    #   Also set unexpected values for any memory locations expected to change.
    for addr, value in changedmem.items():
        m.mem[addr] = not value

    #   Now that unexpected values have been placed, set any specified
    #   initial data. This is done after the unexpected value
    #   initialization so that those can be explicitly overridden.
    m.deposit(startaddr, opdata)
    for addr, value in initmem.items():
        m.deposit(addr, value)
    m.setregs(initregs)

    m.pc = startaddr
    prevregs = m.regs
    prevmem = bytes(m.mem)

    m.step(1)

    regs = m.regs
    #   If any regs in the machine are unvalued (i.e., set to `None`)
    #   the opcode implementation has done something very wrong.
    unvalued = set(regs.all().keys()) - set(regs.valued().keys())
    assert not unvalued, 'op produced unvalued register(s)'

    if changedregs.pc is None:
        changedregs = changedregs.clone(pc=startaddr + len(opdata))
    allregs = prevregs.clone(**changedregs.valued())

    #   Lining these up in columns makes it easier to see what was wrong.
   #print('    expected all:', allregs)
   #print('expected changed:', changedregs)
   #print('          actual:', regs)

    #   First assert that the registers and flags expected to change have
    #   their correct values. This makes more clear test failures where a
    #   tested value is wrong.
    assert changedregs == regs, "expected register/flag changes"
    #   Now assert that the other registers and flags, which we did not expect
    #   to change (and are not explicitly tested), are actually unchanged.
    assert allregs == regs, "unexpected register/flag changes"

    newmem = bytearray(prevmem)
    for addr, value in changedmem.items():
        newmem[addr] = value
    assert newmem == m.mem

def extend_arg(b):
    ' If `b` is an 8-bit value, extend it to 16 bits by copying LSB to MSB. '
    if b > 0xFF:
        return b
    else:
        return (b << 8) | b

####################################################################
#   Misc instructions

def test_invalid_opcodes():
    badops = (
        0x00, 0x02, 0x03, 0x04, 0x05,
        0x12, 0x13, 0x14, 0x15, 0x18, 0x1A, 0x1C, 0x1D, 0x1E, 0x1F,
        0x21,                           0x38, 0x3A, 0x3C, 0x3D,
        0x41, 0x42, 0x45, 0x4B, 0x4E,   0x51, 0x52, 0x55, 0x5B, 0x5E,
        0x61, 0x62, 0x65, 0x6B,         0x71, 0x72, 0x75, 0x7B,
        0x83, 0x87, 0x8F,               0x93, 0x9D,
        0xA3,                           0xB3,
        0xC3, 0xC7, 0xCC, 0xCD, 0xCF,   0xD3, 0xDC, 0xDD,
        0xE3, 0xEC, 0xED,               0xF3, 0xFC, 0xFD,
    )
    for i, op in enumerate(badops):
        addr = 0x00E0 + i
        with pytest.raises(InvalidOpcode) as ex:
            runop([op], memsize=0x0140, startaddr=addr)
        assert (op, addr) == (ex.value.opcode, ex.value.pc)
        assert ex.match(r'^opcode=\${:02X} pc=\${:04X}$'.format(op, addr))

def test_NOP():
    #   The test framework will ensure that nothing but the PC has changed.
    runop([I.NOP])

####################################################################
#   Branches

def test_JMP():
    runop([I.JMP, 0xAB, 0xCD], changedregs=R(pc=0xABCD))

@pytest.mark.parametrize('offset,      x,     pc', (
                         (     0, 0xFFFF, 0xFFFF),
                         (     3, 0x1234, 0x1237),
                         (  0xFF, 0xFF80, 0x007F),
), ids=tmc_tid)
def test_JMPx(offset, x, pc):
    runop([I.JMPx, offset], initregs=R(x=x), changedregs=R(pc=pc))

def test_BRA():
    runop([I.BRA,    0], startaddr=0x13, changedregs=R(pc=0x0015))
    runop([I.BRA,    3], startaddr=0x14, changedregs=R(pc=0x0019))
    runop([I.BRA, 0x7F], startaddr=0x00, changedregs=R(pc=0x0081))
    runop([I.BRA, 0x80], startaddr=0x0E, changedregs=R(pc=0xFF90))
    runop([I.BRA, 0xFC], startaddr=0x08, changedregs=R(pc=0x0006))
    #   Additional coverage in test_readsignedbyte().

@pytest.mark.parametrize('op, taken, initregs', (
    #                       Carry flag
    (I.BCC, False, R(C=1)),             (I.BCC, True,  R(C=0)),
    (I.BCS, False, R(C=0)),             (I.BCS, True,  R(C=1)),
    #                       Zero flag
    (I.BEQ, False, R(Z=0)),             (I.BEQ, True,  R(Z=1)),
    (I.BNE, False, R(Z=1)),             (I.BNE, True,  R(Z=0)),
    #                       Negative flag
    (I.BMI, False, R(N=0)),             (I.BMI, True,  R(N=1)),
    (I.BPL, False, R(N=1)),             (I.BPL, True,  R(N=0)),
    #                       Overflow flag
    (I.BVC, False, R(V=1)),             (I.BVC, True,  R(V=0)),
    (I.BVS, False, R(V=0)),             (I.BVS, True,  R(V=1)),

), ids=tmc_tid)
def test_condbranch(op, initregs, taken):
    print('op {} ${:02X}, flag: {}, taken {} expected\n'
        .format(OPCODES[op][0], op, str(initregs).split()[-1], taken))
    runop([op, 0x40], initregs=initregs,
        changedregs= R(pc=0x0050) if taken else R(pc=0x0010))

####################################################################
#   Instructions affecting the stack

@pytest.mark.parametrize('initsp,    word,  newsp', (
                         (     0,  0x4142,      2),
                         (     1,  0x4243,      3),
                         (0xFFFD,  0xCECF, 0xFFFF),
                         (0xFFFE,  0xCF40,      0),
                         (0xFFFF,  0x4041,      1),
), ids=tmc_tid)
def test_popword(initsp, word, newsp):
    m = Machine()
    m.deposit(0x0000, b'\x40\x41\x42\x43')
    m.deposit(0xFFFC, b'\xCC\xCD\xCE\xCF')

    m.sp = initsp
    assert word == popword(m)
    assert newsp == m.sp

### Subroutine calls

def test_JSR():
    runop([I.JSR, 0x56, 0x78],
        memsize=65536, startaddr=0x1234,
        initregs    = R(sp=0),                      # test stack wraparound
        changedregs = R(pc=0x5678, sp=0xFFFE),
        changedmem  = { 0x0000: 0x37, 0xFFFF: 0x12, })

def test_JSRx():
    runop([I.JSRx,                    0x16],
        initregs    = R(sp=0x1F,  x=0xFFF0, ),
        changedregs = R(sp=0x1D, pc=0x0006, ),
        startaddr   =                   0x0123,     memsize=0x140,
        changedmem  = { 0x1E: 0x01, 0x1F: 0x25, },
    )

def test_BSR():
    runop([I.BSR, 0xFE], startaddr=0x12,            # calling self
        initregs    = R(sp=0x18),
        changedregs = R(sp=0x16, pc=0x12),
        changedmem  = { 0x17: 0x00, 0x18: 0x14, },
    )

def test_RTS():
    m = Machine(memsize=0x40)
    m.sp = 0x002D; m.depword(0x002E, 0x1234)
    runop([I.RTS], machine=m, changedregs=R(pc=0x1234, sp=0x002F))

### Data Movement
#   All the other data movement operations affect flags.
#   PSH and PUL do not, which is why they belong here rather than there.

def test_PULA():
    runop([I.PULA],
        initregs    = R(sp=0x000C),
        initmem     = { 0x000D: 0xA1 },
        changedregs = R(sp=0x000D, a=0xA1),
        )

def test_PSHA():
    runop([I.PSHA],
        initregs    = R(a=0xEF, sp=0x000F),
        changedregs = R(sp=0x000E),
        changedmem  = { 0x000F: 0xEF },
        )

####################################################################
#   Flag (Condition Code) Changes

@pytest.mark.parametrize('op, flag', (
    (I.CLC, R(C=0)), (I.SEC, R(C=1)),
    (I.CLV, R(V=0)), (I.SEV, R(V=1)),
    (I.CLI, R(I=0)), (I.SEI, R(I=1)),
), ids=tmc_tid)
def test_flag_change(op, flag):
    runop([op], changedregs=flag)

#   pccr = processor condition codes register (PRM A-70, A-72)
PCCRparams = {
    'argnames': 'pccr, flags',
    'argvalues': (
        (0b11000000, R(H=0, I=0, N=0, Z=0, V=0, C=0)),
        (0b11000001, R(H=0, I=0, N=0, Z=0, V=0, C=1)),
        (0b11000010, R(H=0, I=0, N=0, Z=0, V=1, C=0)),
        (0b11000100, R(H=0, I=0, N=0, Z=1, V=0, C=0)),
        (0b11001000, R(H=0, I=0, N=1, Z=0, V=0, C=0)),
        (0b11010000, R(H=0, I=1, N=0, Z=0, V=0, C=0)),
        (0b11100000, R(H=1, I=0, N=0, Z=0, V=0, C=0)),
        (0b11010101, R(H=0, I=1, N=0, Z=1, V=0, C=1)),
        (0b11101010, R(H=1, I=0, N=1, Z=0, V=1, C=0)),
        (0b11111111, R(H=1, I=1, N=1, Z=1, V=1, C=1)),
        ),
    'ids': tmc_tid,
    }

@pytest.mark.parametrize(**PCCRparams)
def test_tap(pccr, flags):
    runop([I.TAP], initregs=R(a=pccr), changedregs=flags)

@pytest.mark.parametrize(**PCCRparams)
def test_tpa(pccr, flags):
    runop([I.TPA], initregs=flags, changedregs=R(a=pccr))

####################################################################
#   Data Movement

def LDSTparams(baseaddr):
    ''' LDx/STx instructions loading/storing 8-bit values.
        All loads and stores affect N and Z and clear V.
    '''
    return { 'argnames':     '     addr,   arg, N, Z ',
             'argvalues': (( baseaddr+0,  0x00, 0, 1 ),
                           ( baseaddr+3,  0x01, 0, 0 ),
                           ( baseaddr+6,  0x7F, 0, 0 ),
                           ( baseaddr+9,  0x80, 1, 0 ),
                           ( baseaddr+2,  0xEA, 1, 0 ),
                           ( baseaddr+5,  0xFF, 1, 0 ),
                     ),
        'ids': tmc_tid,
    }

def LDST16params(baseaddr):
    ''' LDx/STx instructions loading/storing 16-bit values.
        All loads and stores affect N and Z and clear V.
    '''
    return { 'argnames':    '      addr,    arg, N, Z ',
             'argvalues': (( baseaddr+0, 0x0000, 0, 1 ),
                           ( baseaddr+3, 0x0001, 0, 0 ),
                           ( baseaddr+6, 0x00FF, 0, 0 ),
                           ( baseaddr+9, 0x0100, 0, 0 ),
                           ( baseaddr+2, 0x7FFF, 0, 0 ),
                           ( baseaddr+5, 0x8000, 1, 0 ),
                           ( baseaddr+4, 0xEA00, 1, 0 ),
                           ( baseaddr+7, 0xFFFF, 1, 0 ),
                          ),
        'ids': tmc_tid, }

def LDSTaccum(optemplate):
    ''' Parametrize by A and B accumulators.

        `optemplate` is the name of the opcode from `opcodes.OPCODES` with
        `~` in place of the accumulator name, e.g., ``LDA~m`` or ``BIT~m``.

        The opcode names for the A and B versions (``LDAAm``, ``LDABm``)
        will be generated; these can be looked up with ``I[opname]``.

        An `accval(value, regs_flags)` function will also be given; this
        constructs a `Registers` object where the selected accumulator is
        initialized with *value* and the remaining parameters are passed
        on to the `Registers` constructor, e.g. ``accval(0xFF, Z=1, V=0)``.
    '''
    opnameA = optemplate.replace('~', 'A')
    opnameB = optemplate.replace('~', 'B')
    def make_accval(accname):
        def accval(accvalue, **kwargs):
            return R(**{ accname: accvalue, **kwargs })
        return accval
    return dict(argnames='opname, accval',
        argvalues=((opnameA, make_accval('a')), (opnameB, make_accval('b'))))

def LDSToffsets(*additional):
    ' Offset parameters for indexed (,X) load/store tests. '
    return {    'argnames': 'offset',
                'argvalues': (3, 0, 0x80) + tuple(additional), }

#### Loads

@pytest.mark.parametrize(**LDSTaccum('LDA~'))
@pytest.mark.parametrize(**LDSTparams(0))
def test_LDA(opname, accval, addr, arg, N, Z):
    runop([I[opname], arg], changedregs=accval(arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDSTaccum('LDA~z'))
@pytest.mark.parametrize(**LDSTparams(0x44))
def test_LDAz(opname, accval, addr, arg, N, Z):
    runop([I[opname], LSB(addr)], changedregs=accval(arg, N=N, Z=Z, V=0),
        memsize=0x50, initmem={ addr: arg })

@pytest.mark.parametrize(**LDSTaccum('LDA~m'))
@pytest.mark.parametrize(**LDSTparams(0x101))
def test_LDAAm(opname, accval, addr, arg, N, Z):
    runop([I[opname], MSB(addr), LSB(addr)],
        changedregs=accval(arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: arg })

@pytest.mark.parametrize(**LDSTaccum('LDA~x'))
@pytest.mark.parametrize(**LDSTparams(0x85))
@pytest.mark.parametrize(**LDSToffsets())
def test_LDAx(opname, accval, addr, offset, arg, N, Z):
    runop([I[opname], offset],
        memsize=0x110, initmem={ addr+offset: LSB(arg) },
        initregs=R(x=addr), changedregs=accval(arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDST16params(0x40))
def test_LDX(addr, arg, N, Z):
    runop([I.LDX, MSB(arg), LSB(arg)], changedregs=R(x=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDST16params(0x22))
def test_LDXz(addr, arg, N, Z):
    runop([I.LDXz, LSB(addr)],
        changedregs=R(x=arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: MSB(arg), addr+1: LSB(arg) })

@pytest.mark.parametrize(**LDST16params(0xFF))
def test_LDXm(addr, arg, N, Z):
    runop([I.LDXm, MSB(addr), LSB(addr)],
        changedregs=R(x=arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: MSB(arg), addr+1: LSB(arg) })

@pytest.mark.parametrize(**LDST16params(0x59))
@pytest.mark.parametrize(**LDSToffsets(0xFC, 0xC1))
def test_LDXx(addr, offset, arg, N, Z):
    runop([I.LDXx, offset], memsize=0x200,
        initregs    = R(x=addr),
        initmem     = { addr+offset: MSB(arg), addr+offset+1: LSB(arg) },
        changedregs = R(x=arg, N=N, Z=Z, V=0),
    )

#### Stores

@pytest.mark.parametrize(**LDSTaccum('CLR~'))
@pytest.mark.parametrize('initval', (0x00, 0x02, 0xFF))
def test_CLRA(opname, accval, initval):
    runop([I[opname]], initregs=accval(initval),
        changedregs=(accval(0, N=0, Z=1, V=0, C=0)))

@pytest.mark.parametrize(' addr, initval', (
                         (0x0012,   0x00),
                         (0x0013,   0x03),
                         (0x0111,   0xFF),
), ids=tmc_tid)
def test_CLRm(addr, initval):
    runop([I.CLRm, MSB(addr), LSB(addr)], memsize=0x112,
        initmem={ addr: initval }, changedmem={ addr: 0 },
        changedregs=R(N=0, Z=1, V=0, C=0))

@pytest.mark.parametrize('x, offset, addr', (
    (      0x0003,    0, 0x0003),
    (      0x0004,    2, 0x0006),
    (0x10000-0xF8, 0xFF, 0x0007),
), ids=tmc_tid)
def test_CLRx(x, offset, addr):
    runop([I.CLRx, offset], initregs=R(x=x),
        changedregs=R(N=0, Z=1, V=0, C=0), changedmem={ addr: 0 })

@pytest.mark.parametrize(**LDSTaccum('STA~m'))
@pytest.mark.parametrize(**LDSTparams(0x0003))
def test_STAm(opname, accval, addr, arg, N, Z):
    runop([I[opname], MSB(addr), LSB(addr)], initregs=accval(arg),
        changedmem={ addr: arg }, changedregs=R(N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDSTaccum('STA~x'))
@pytest.mark.parametrize(**LDSTparams(0x0004))
@pytest.mark.parametrize(**LDSToffsets())
def test_STAx(opname, accval, addr, offset, arg, N, Z):
    runop([I[opname], offset], memsize=0x90, initregs=accval(arg, x=addr),
        changedmem={ addr+offset: arg }, changedregs=R(N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDST16params(0x40))
def test_STXm(addr, arg, N, Z):
    runop([I.STXm, MSB(addr), LSB(addr)], memsize=0x90, initregs=R(x=arg),
        changedmem={ addr: MSB(arg), addr+1: LSB(arg) },
        changedregs=R(N=N, Z=Z, V=0))

def test_STXm_rollover():
    runop([I.STXm, 0xFF, 0xFF], memsize=64*1024, initregs=R(x=0x89AB),
        changedmem={ 0xFFFF: 0x89, 0x0000: 0xAB }, changedregs=R(N=1, Z=0, V=0))

@pytest.mark.parametrize(**LDST16params(0xF0))
def test_STXz(addr, arg, N, Z):
    runop([I.STXz, addr], memsize=0x100, initregs=R(x=arg),
        changedmem={ addr: MSB(arg), addr+1: LSB(arg) },
        changedregs = R(N=N, Z=Z, V=0))

####################################################################
#   Flag handling for data movement and logic

def test_isneg():
    assert not isneg(0)
    assert not isneg(0x7F)
    assert     isneg(0x80)
    assert     isneg(0xFF)

def test_isneg16():
    assert not isneg(0x0000, signbit=15)
    assert not isneg(0x7FFF, signbit=15)
    assert     isneg(0x8000, signbit=15)
    assert     isneg(0xFFFF, signbit=15)

def test_iszero():
    assert     iszero(0)
    assert not iszero(1)
    assert not iszero(0xFF)

def test_logicNZV():
    ' Covered by data movement and logic opcode tests. '

####################################################################
#   Logic operations

@pytest.mark.parametrize('a,     arg,  res, N, Z', (
                         (0x00, 0x00, 0x00, 0, 1),
                         (0x00, 0xFF, 0x00, 0, 1),
                         (0xFF, 0x00, 0x00, 0, 1),
                         (0xAA, 0x3C, 0x28, 0, 0),
                         (0xAA, 0xF0, 0xA0, 1, 0),
), ids=tmc_tid)
def test_ANDA(a, arg, res, N, Z):
    runop([I.ANDA, arg], initregs=R(a=a), changedregs=R(a=res, N=N, Z=Z, V=0))

####################################################################
#   Shifts and Rotates

@pytest.mark.parametrize('init,  res, N, Z, C', (
                         (0x00, 0x00, 0, 1, 0),
                         (0x21, 0x42, 0, 0, 0),
                         (0x80, 0x00, 0, 1, 1),
                         (0x81, 0x02, 0, 0, 1),
                         (0xC8, 0x90, 1, 0, 1),
                         (0xFF, 0xFE, 1, 0, 1),
                         (0x55, 0xAA, 1, 0, 0),
                         (0xAA, 0x54, 0, 0, 1),
), ids=tmc_tid)
def test_ASLA(init, res, N, Z, C):
    V = N ^ C
    runop([I.ASLA], initregs=R(a=init),
        changedregs=R(a=res, N=N, Z=Z, V=V, C=C))

@pytest.mark.parametrize('init,  res, Z, V, C', (
                         #   XXX see comment in code re V=N⊕C
                         (0x01, 0x00, 1, 1, 1),
                         (0x02, 0x01, 0, 0, 0),
                         (0xAA, 0x55, 0, 0, 0),
                         (0xFF, 0x7F, 0, 1, 1),
), ids=tmc_tid)
def test_LSRA(init, res, Z, V, C):
    N = 0; assert V == N ^ C, 'V = N ⊕ C'
    runop([I.LSRA], initregs=R(a=init),
        changedregs=R(a=res, N=N, Z=Z, V=V, C=C))

@pytest.mark.parametrize('init,  res, N, Z, C', (
                         (0x00, 0x00, 0, 1, 0),
                         (0x01, 0x00, 0, 1, 1),
                         (0x02, 0x01, 0, 0, 0),
                         (0x7F, 0x3F, 0, 0, 1),
                         (0x80, 0xC0, 1, 0, 0),
                         (0x81, 0xC0, 1, 0, 1),
                         (0xFF, 0xFF, 1, 0, 1),
                         (0x55, 0x2A, 0, 0, 1),
                         (0xAA, 0xD5, 1, 0, 0),
), ids=tmc_tid)
def test_ASRA(init, res, N, Z, C):
    V = N ^ C
    assert N == bool(res >> 7)
    runop([I.ASRA], initregs=R(a=init),
        changedregs=R(a=res, N=N, Z=Z, V=V, C=C))

@pytest.mark.parametrize(
    'initC, init,  res, C, N, Z', ( # initC, init,  res, C, N, Z
    (    0, 0x00, 0x00, 0, 0, 1),    (    1, 0x00, 0x80, 0, 1, 0),
    (    0, 0x01, 0x00, 1, 0, 1),    (    1, 0x01, 0x80, 1, 1, 0),
    (    0, 0x02, 0x01, 0, 0, 0),    (    1, 0x02, 0x81, 0, 1, 0),
    (    0, 0x03, 0x01, 1, 0, 0),    (    1, 0x03, 0x81, 1, 1, 0),
    (    0, 0x55, 0x2A, 1, 0, 0),    (    1, 0x55, 0xAA, 1, 1, 0),
    (    0, 0xAA, 0x55, 0, 0, 0),    (    1, 0xAA, 0xD5, 0, 1, 0),
    (    0, 0xFE, 0x7F, 0, 0, 0),    (    1, 0xFE, 0xFF, 0, 1, 0),
    (    0, 0xFF, 0x7F, 1, 0, 0),    (    1, 0xFF, 0xFF, 1, 1, 0),
), ids=tmc_tid)
def test_RORA(initC, init, res, N, Z, C):
    V = N ^ C
    assert N == initC
    assert N == bool(res >> 7)  # shift just to be different from CUT's AND
    runop([I.RORA], initregs=R(a=init, C=initC),
        changedregs=R(a=res, N=N, Z=Z, V=V, C=C))

####################################################################
#   Arithmetic operations

@pytest.mark.parametrize('   n,  dec, N, Z, V', (
                         (0xFF, 0xFE, 1, 0, 0),
                         (0x81, 0x80, 1, 0, 0),
                         (0x80, 0x7F, 0, 0, 1),     # only case where V set
                         (0x7F, 0x7E, 0, 0, 0),
                         (0x01, 0x00, 0, 1, 0),
))
def test_decb(n, dec, N, Z, V):
    runop([I.DECB], initregs=R(b=n), changedregs=R(b=dec, N=N, Z=Z, V=V))

@pytest.mark.parametrize('     n, succ, Z', (
                         (0x0000, 0x0001, 0),
                         (0x00FF, 0x0100, 0),
                         (0xFFFE, 0xFFFF, 0),
                         (0xFFFF, 0x0000, 1),
))
def test_inx(n, succ, Z):
    runop([I.INX], initregs=R(x=n), changedregs=R(x=succ, Z=Z))

@pytest.mark.parametrize('     n, succ, Z', (
                         (0x0001, 0x0000, 1),
                         (0x0100, 0x00FF, 0),
                         (0xFFFF, 0xFFFE, 0),
                         (0x0000, 0xFFFF, 0),
))
def test_dex(n, succ, Z):
    runop([I.DEX], initregs=R(x=n), changedregs=R(x=succ, Z=Z))

@pytest.mark.parametrize(
    'a,     arg,  res, H, N, Z, V, C', (
    (0x00, 0x00, 0x00, 0, 0, 1, 0, 0),
    #   H: half carry determined by bits 3
    (0x0E, 0x01, 0x0F, 0, 0, 0, 0, 0),
    (0x0F, 0x01, 0x10, 1, 0, 0, 0, 0),
    (0x10, 0x01, 0x11, 0, 0, 0, 0, 0),
    #   V: overflow determined by bits 6
    (0x7E, 0x01, 0x7F, 0, 0, 0, 0, 0),
    (0x7F, 0x01, 0x80, 1, 1, 0, 1, 0),
    (0x80, 0x01, 0x81, 0, 1, 0, 0, 0),
    #   C: carry determined by bits 7
    (0xFE, 0x01, 0xFF, 0, 1, 0, 0, 0),
    (0xFF, 0x01, 0x00, 1, 0, 1, 0, 1),
    (0xF0, 0x20, 0x10, 0, 0, 0, 0, 1),  # no half carry
    #   C and V
    (0x40, 0xF0, 0x30, 0, 0, 0, 0, 1),  # 2's comp: subtract from positive
    (0xF0, 0xF0, 0xE0, 0, 1, 0, 0, 1),  # 2's comp: subtract from negative
    (0x80, 0x80, 0x00, 0, 0, 1, 1, 1),
), ids=tmc_tid)
def test_ADDA(a, arg, res, H, N, Z, V, C):
    cr = R(a=res, H=H, N=N, Z=Z, V=V, C=C)
    #   Operation should be the same whether carry set or clear.
    runop([I.ADDA, arg], initregs=R(a=a, C=0), changedregs=cr)
    runop([I.ADDA, arg], initregs=R(a=a, C=1), changedregs=cr)

@pytest.mark.parametrize('minuend, subtrahend, difference, N, Z, V, C', (
    #minu, subt, diff, N, Z, V, C
    (0x00, 0x00, 0x00, 0, 1, 0, 0),
    #   V: overflow determined by bits 6
    (0x81, 0x01, 0x80, 1, 0, 0, 0),
    (0x81, 0x02, 0x7F, 0, 0, 1, 0),
    (0x7F, 0x01, 0x7E, 0, 0, 0, 0),
    #   C: borrow determined by bits 7
    (0x01, 0x01, 0x00, 0, 1, 0, 0),
    (0x01, 0x02, 0xFF, 1, 0, 0, 1),
    (0xFF, 0x01, 0xFE, 1, 0, 0, 0),
), ids=tmc_tid)
def test_SUBA(minuend, subtrahend, difference, N, Z, V, C):
    cr = R(a=difference, N=N, Z=Z, V=V, C=C)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=0), changedregs=cr)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=1), changedregs=cr)

def test_CMPA():
    #   Confirm that A register is unchanged;
    #   test_suba() provides the rest of the coverage.
    runop([I.CMPA, 0x02], initregs=R(a=0x81), changedregs=R(N=0, Z=0, V=1, C=0))

CPXparams = {
    'argnames':     ' addr,      x,    arg, Z, N, V',
    #  Flag register value:                 4  8  2
    'argvalues': (  (0x0F1, 0x0000, 0x0000, 1, 0, 0),     # BEQ taken
                    (0x0F3, 0x0001, 0x0001, 1, 0, 0),
                    (0x0F5, 0x0080, 0x0080, 1, 0, 0),
                    (0x0F7, 0x7FFF, 0x7FFF, 1, 0, 0),
                    (0x0F9, 0x8000, 0x8000, 1, 0, 0),
                    (0x0FB, 0xFFFF, 0xFFFF, 1, 0, 0),

                    (0x0FD, 0x0000, 0x0001, 0, 0, 0),     # BNE taken
                    (0x0FF, 0x0000, 0x00FF, 0, 0, 0),
                    (0x101, 0x0000, 0x0100, 0, 1, 0),

                    (0x103, 0x0000, 0x8100, 0, 0, 0),
                    (0x105, 0x0000, 0x80FF, 0, 1, 1),
                    (0x107, 0x0000, 0x8000, 0, 1, 1),
                    (0x109, 0x0000, 0x7FFF, 0, 1, 0),

                    (0x10B, 0x0000, 0xFFFF, 0, 0, 0),
                    (0x10D, 0x8000, 0x0000, 0, 1, 0),
                    (0x10F, 0x8000, 0x00FF, 0, 1, 0),
                    (0x121, 0x8000, 0x0100, 0, 0, 1),
                ),
    'ids': tmc_tid,
}

@pytest.mark.parametrize(**CPXparams)
def test_CPX(addr, x, arg, N, Z, V):
    runop([I.CPX, MSB(arg), LSB(arg)],
        initregs=R(x=x), changedregs=R(N=N, Z=Z, V=V))

@pytest.mark.parametrize(**CPXparams)
def test_CPXz(addr, x, arg, N, Z, V):
    addr -= 0x40
    runop([I.CPXz, addr], memsize=0xFF,
        initmem     = { addr: MSB(arg), addr+1: LSB(arg) },
        initregs    = R(x=x),
        changedregs = R(N=N, Z=Z, V=V))

@pytest.mark.parametrize(**CPXparams)
def test_CPXm(addr, x, arg, N, Z, V):
    runop([I.CPXm, MSB(addr), LSB(addr)], memsize=0x123,
        initmem     = { addr: MSB(arg), addr+1: LSB(arg) },
        initregs    = R(x=x),
        changedregs = R(N=N, Z=Z, V=V))
