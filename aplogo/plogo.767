(* -*-lisp-*- *)
(*$T-,D+,R15,S5000*)
program LOGO;

(*  General Conventions

   This documentation assumes user-level familiarity with TI LOGO, as
described in the TI LOGO USERS MANUAL and the TI LOGO GLOSSARY.  It
further assumes expert knowledege of TI PASCAL and TI 990 assembly
language, familiarity with contemporary principles of interpreter
design, and total ignorance of IBM HIPO documentation conventions.

   References to Pascal variable and procedure names are capitalized
in our comments.  Pascal code itself is in lower case, EXCEPT that any
Pascal procedure which can invoke the garbage collecter (see below)
has the first letter of its name capitalized.

   Any procedure or variable for which the obvious choice of name has
been hijacked as a Pascal keyword (eg "type") has generally had an "L"
(for LOGO) prefixed to the obvious name (eg "LTYPE").

   The first thing to read is the section called "General Principles
of the TI LOGO Implementation".  This gives a general overview of this
program.  The comments associated with the variable definitions and
procedure definitions of this program will not be readily understood
unless the "General Principles..." section is read first.

THINGS TO DO
* full type conversion
* allocate chunks/nodes from opposite ends?
* arithmetic overflow

* LOCAL

* MAKE INIT'S SATOM REF.S FORMAT-INDEPENDENT (IE USE GET/PUT FUNCTION)
*)

(*   Storage Management

   LOGO allocates various kinds of storage in a machine-language-like
fashion, from a large array called BIGARRAY.  If n is a BIGARRAY
index, we refer to n*2 as the corresponding *pointer*, since, on the
TI 990, BIGARRAY[n] is accessible via BASE(x), where BASE is the
address of BIGARRAY, and register x holds n*2.  We store references to
BIGARRAY entries by their pointers, rather than by their indicies.

   When Pascal integer variable FOO holds a pointer to a LOGO object,
we say that FOO points to that object, or equivalently, that FOO has
or is that object-- ie, we refer to the pointer as the object itself.


   The organization of BIGARRAY is as follows:

Pointer          BIGARRAY

0:            ______________
              *            *
              * nodespace  *
              *            *
              *            *
              *            *
              *____________*
typebase:     *   nodes'   *
              * type codes *
              *____________*
              *            *
              *   unused   *
              *____________*
arraybeg:     *   array    *
              *    space   *
              *____________*
vpdltop:      *            *
              *    vpdl    *
              *____________*
pdltop:       *            *
              *    pdl     *
              *____________*
s_bigarray:

*)

const

(* Overlay Structure

    LOGO needs to be divided into overlays in order to fit in the 990 address space.
    The following scheme is used:

   init overlay:      holds only the initialization & reinitialization code
   error overlay:     holds the error routine, including the text of all error messages
   edit overlay:      holds the line-edit routines
   read_line overlay:  holds the reader
   evaluate overlay:    holds the evaluator and associated utility routines and system
                      function routines, some of which are farmed out to these sub-
                      overlays of the evaluate overlay:

          garbage collect suboverlay: holds the garbage collector
          word suboverlay: holds sfun and utility routines for
                           operating on pnames
          display suboverlay: holds sfun and utility routines used for
                              graphics
          Defun suboverlay: holds sfun and utility routines for
                            defining ufuns, and for obtaining the text
			    of ufuns
   printout overlay: holds the sfun and utility routines for the PO
                     command


   Note that the main overlays are designed so as to be swapped only
on "1-shot" events, such as the user hitting "return" after typing a
line of commands or a line of a ufun definition, or entry into an
error break loop.  Unfortunately, more severe compromises are
reflected in the suboverlay arrangement.  Conceivably, for example, a
ufun could be in a loop which alternates between word functions and
display functions, resulting in frequent swapping.  Thus, the
suboverlay divisions effectively relegate certain classes of sfuns
into "packages", any one of which can be used without penalty (except
for swapping with the garbage collector).  But, the intermingling of
sfuns from different packages can substantially degrade system
performance.  *)
   init_overlay=1; (* Overlay id's *)
   error_overlay=2;
   edit_overlay=3;
   read_line_overlay=3;
   evaluate_overlay=4;
   printout_overlay=9;

   gc_suboverlay=5;
   word_suboverlay=6;
   display_suboverlay=7;
   defun_suboverlay=8;

   vdt=0;
   wfile=1;

                       (* Storage Management Constants *)
   s_inodes=8000;      (* Index of initial end of nodespace *)
   s_maxnodes=8000;    (* Maximum index of end of nodespace *)
   max_num_nodes=2000; (* Maximum number of nodes: s_maxnodes/4 *)
   s_iarray=0;         (* Initial difference between ptrs to end & beginning of array space *)
   s_maxarray=6000;    (* Maximum difference between ptrs to end & beginning of array space *)
   s_ivpdl=200;        (* Initial difference between ptrs to end & beginning of the vpdl *)
   s_maxvpdl=4000;     (* Maximum difference between ptrs to end & beginning of the vpdl *)
   s_ipdl=1800;        (* Initial difference between ptrs to end & beginning of the pdl *)
   s_maxpdl=4000;      (* Maximum difference between ptrs to end & beginning of the pdl *)

   s_bigarray=12000;   (* Difference between ptrs to end & beginning of BIGARRAY *)
   bigarray_words= 6000;  (* For use in BIGARRAY decl. Sigh. *)
   pdlbase= s_bigarray;

   pdl_push_limit=100; (* Minimum # of bytes left on the pdl before panicing *)
   vpdl_push_limit=40; (* Minimum # of bytes left on the vpdl before panicing *)

   pushinc= -2;        (* Amount to add to SP or VSP when pushing: add, then move *)
   popinc=   2;        (* Amount to add to SP or VSP when popping: move, then add *)

   nodesize=4;         (* 4 bytes per node in nodespace *)
   wordsize=2;

   lnil=0;              (* node 0 is always lnil *)
   novalue=nodesize;   (* node 1 is the value which indicates no value *)
   first_node=8;  (* I REALLY CAN'T BELIEVE THIS.  FIRST_NODE CAN'T BE DEFINED SYMBOLICALLY
                     AS NOVALUE+NODESIZE OR EVEN 2*NODESIZE BECAUSE THE DEFINITION OF A
                     CONSTANT IS CONSTRAINED TO BE ANOTHER CONSTANT AND NOT AN EXPRESSION!!!*)

   sarray_max=850;

(* Data type formats

NOTE: Changing a type format entails potential changes to:
  * Utility routines which refer to properties of that type (eg, GET_VALUE for the various
    atomic types).
  * The evaluator: the EVAL case dispatches off object types.
  * GARBAGE_COLLECT (needs to know for which types to recurse on marking the car and/or cdr).
  * S_EQUAL
  * LTYPE

  * Any new format-dependent routines should be entered here.  To be sure none have been
    omitted from this list, search for all instances of GET_TYPE to see if a
    format-dependent dispatch follows.


 ( X===> designates a pointer. )

        ********
list => *  car *
        ********
        *  cdr *
        ********

fix  => ********
        *  #   *
        ********
        *  0   *
        ********

flo  => ?

larray => ?

atom => ********
        * value*
        ********       ********
        *  X==========>* ufun *   (The ufun.pname cell is given type LIST.)
        ********       ********
                       * pname*
                       ********

Note: The low bit of the pname pointer may be set, indicating a "funny pname".  This is
a pname which contains spaces or other weird characters. If a procedure containing
such an atom is written into a file, the pname must appear within ''s to insure
being read back in properly; hence the funny-pname bit.

                       ********
           pname =====>*c2/c1 *   (Each cell in the pname is given type fix.)
                       ********    ********
                       *  X=======>*c4/c3 *
                       ********    ********
                                   *  0   *
                                   ********

datom,qatom,latom:  Each of these is identical in format to an atom, and has type ATOM in
                   the typearray.  A type DATOM, QATOM, or LATOM is distinguished by the
                   low 2 bits of the object's pointer:  0 -> ATOM, 1 -> QATOM, 2 -> DATOM,
                   and 3 -> LATOM.  Thus, FOO, "FOO, :FOO, and FOO: all together occupy
                   no more storage than FOO itself; different pointers to FOO can refer to
                   it as any of the 4 flavors of atom.


To the user, an satom is identical to an atom, except that satoms are "built-in", ie
primitive, functions, and cannot be redefined as user functions.  But the difference
in internal formats between atoms and satoms is invisible to the user.
satom => ********
         * value*
         ********
         * funct*  Funct is an index into SARRAY.
         ********
                          SARRAY[funct+sa_index] contains SI_FOO for this satom.
                          SARRAY[funct+sa_nargs] has nargs for this satom.
                          SARRAY[funct+sa_prec] has the precedence.
                          SARRAY[funct+sa_pname] - ... has the pname for this
                                                   satom, 1 char per SARRAY entry, terminated
                                                   with a 0.
ufun => ********
        * frame*  Ufun object is *4* consecutive words long; last is unused.
        ********
        * body *   Ufun body is in one of 2 possible formats:
        ********    1) List format.  Body is of type list. First element is a list of arg
        * nargs*       atoms.  Each subsequent element is an FLIST, each corresponding to
        ********       a line of the procedure.  See way below.
        * atom *    2) Packed format. Body is of type FPACK. Only the node pointed to by
        ********       BODY has a type code: FPACK.  Pointers are in one contiguous block
                       of words, other Stuff is in a second contiguous block.  See directly
                       below.
(atom entry of ufun is a pointer back to the atom which points to the ufun.)

fpack => ********                ********
         * ptr1 *        ptr1 => * arg1 *  arguments
         ********                ********
         * ptr2 *                   :
         ********                ********
         * ptr3 *                * arg n*
         ********                ********
            :            ptr2 => *  #   *  line number: an IMMEDIATE number, not a pointer to
         ********                ********   a fixnum.
         * ptr n*                * obj1 *  toplevel elements of the procedure line
         ********                ********
         *  0   * fence             :
         ********                ********
                                 * obj n*
                                 ********
                         ptr3 => *  #   *  next line number,
                                 ********   followed by its elements, etc.
                           :        :
                           :     ********
                                 * obj m*  last element of last line
                                 ********
                         ptr n =>

flist => ********
         *  #   *  line number: an IMMEDIATE number, not a pointer to a fixnum
         ********
         * list *  procedure line
         ********
*)

(*
Stack frame conventions.

XFRAME => *  return address   *
          *        .          *
          *        .          *
          *        .          *
          *  bindings:        *  Each "binding" is a pair of words: either a bound atom
          *     atom          *  and its *old* value, or a ufun and its *old* frame
          *     value         *  entry.  These are distinguished by the low bit of the
          * -or-              *  "first" word of the pair (ie the word further up on the
          *     funct+1       *  stack, ie with a *lower* address):  if the bit is zero,
          *     frame         *  it's an atom/value pair; if it's a 1, it's a funct+1/frame
          *        .          *  pair.
          *        .          *
          *        .          *
          * SF_BINDINGS       *
          * SF_TAIL_LEVELS    *
          * SF_NUMBER_BINDINGS*
          * SF_LINE           *
          * SF_LINE_NUMBER    *
          * SF_NEST           *
          * SF_UFUN           *
          * SF_FORMAT         *
          * SF_XFRAME         *
          * SF_PREVIOUS_FRAME *
FRAME => 
*)
   sf_previous_frame= -2;   (* stack frame offsets *)
   sf_xframe= -4;
   sf_format= -6;
   sf_ufun= -8;
   sf_nest= -10;
   sf_line_number= -12;
   sf_line= -14;
   sf_number_bindings= -16;
   sf_tail_levels= -18;
   sf_bindings= -20;

      (* type consts *)
   list=0;	(* regular list structures e.g. [1 2] *)
   atom=1;	(* atoms, further distinguished as qatom, datom and latom below *)
   fix=2;	(* integers e.g. 69 *)
   string=2;    (* NOTE that this is same as fix for now *** *)
   flo=3;	(* floating point numbers e.g. 69.69 *)
   larray=4;	(* arrays *)
   sfun=5;	(* system functions e.g. print *)
   ufun=6;	(* user defined functions *)
   satom=7;
      sa_sindex=0;  (* SARRAY entry offsets *)
      sa_nargs=1;
      sa_prec=2;
      sa_pname=3;

   qatom=8;     (* quoted atom e.g. "foo *)
   datom=9;     (* dotted atom e.g. :foo *)
   latom=10;    (* label atom e.g. foo: *)
   fpack=11;    (* packed ufun format *)
   flist=12;    (* ufun line format: like a regular list but the car is an immediate number. *)

           (* Types QATOM, DATOM and LATOM are stored in the typearray as plain ATOM or
              SATOM, but are distinguished by the lo 2 bits of an atom's pointer:
              0 => type ATOM,1=> type QATOM, 2 => type DATOM, 3=> type LATOM.
              The GET_TYPE utility rtn will
              look at both the typearray & the pointer lo bits, & will return QATOM or
              DATOM or LATOM if appropriate. *)

   si_thingp=1;         (* System function index constants.  If we had functional vars *)
   si_word=2;           (* we wouldn't need these. *)
   si_wordp=3;
   si_sentence=16;
   si_unary_sum=4;
   si_unary_difference=5;
   si_make=6;
   si_output=7;
   si_stop=8;
   si_print=9;
   si_type=10;
   si_define=11;
   si_debug=12;
   si_continue=13;
   si_pause=14;
   si_else=15;

   si_both=17;
   si_either=18;
   si_then=19;
   si_not=20;
   si_lpar=21;
   si_rpar=22;
   si_if=23;
   si_run=24;
   si_go=25;
                  (* Above here dispatches thru X_SF1, below thru X_SF2. *)
   si_bpt=26;
   si_goodbye=27;
   si_gcoll=28;
   si_nodes=29;
   si_butfirst=30;
   si_first=31;
   si_butlast=32;
   si_last=33;
   si_to=34;
   si_edit=35;
   si_end=36;
   si_text=37;

   si_forward=38;
   si_back=39;
   si_right=40;
   si_left=41;
   si_spin=42;
   si_cs=43;
   si_home=44;
   si_penup=45;
   si_pendown=46;
   si_move=47;
   si_snap=48;
   si_display=49;
   si_wipeclean=50;
   
   si_title=51;
   si_fput=52;
   si_printout=53;
   si_all=54;
   si_names=55;
   si_erase=56;
   si_read=57;
   si_write=58;

   si_request=59;
   si_thing=60;

   si_lines=61;

   si_is=62;
   si_sum=63;
   si_difference=64;
   si_product=65;
   si_quotient=66;
   si_greater=67;
   si_less=68;
   si_comment=69;
   si_equal=70;
   si_traceback=71;
   si_pots=72;
   si_titles=73;
   si_procedures=74;

   si_max=74;

            (* error constants *)
   xuop=1;   (* unexpected output *)
   xeol=2;   (* early end of line *)
   xudf=3;   (* undefined function *)
   xhnv=4;   (* atom has no value *)
   xtmo=5;   (* too many outputs *)
   xnop=6;   (* no output *)
   xrpn=7;   (* early right parenthesis *)
   xifx=8;   (* infix operator in prefix position *)
   xvna=9;   (* variable-arg function not parenthesized *)
   xtip=10;  (* too much Stuff inside parentheses *)
   xwta=11;  (* wrong type argument *)
   xubl=12;  (* used by logo *)
   xntl=13;  (* not at top level *)
   xntf=14;  (* not true or false *)
   xels=15;  (* extraneous else *)
   xbrk=16;  (* pause-- not really an error *)
   xlabel=17; (* label in the middle of a line *)
   xthn=18;  (* then out of place *)
   xzap=19;  (* no storage left, STOP key, etc *)
   xlnf=20;  (* label not found *)
   xedt=21;  (* already in edit mode *)
   xdef=22;  (* already defined *)
   xetl=33;  (* edit only at toplevel *)
   xned=34;  (* you're not in edit mode *)
   xopo=35;  (* only in po, etc. *)
   xargtb=36;  (* argument too big, used by 2500 Stuff *)
   xtml=37;    (* Too many lines *)
   xtms=38;    (*Too much snapped *)
   xdbz=39;  (* divide by zero *)
   xnwe=40;  (* not while editing *)

   no_pdl=2; (* zap codes, ie reasons for error XZAP *)
   no_vpdl=4;
   no_nodes=6;
   stop_key=8;
   logout=9;

      evline=2;   (* evaluator case label constants *)
      evline_1=4;
      evline_2=6;
      eval_expression=8;
      ev_ex_1=10;
      eval=12;
      eval_1=14;
      paren_loop=16;
      p_l_1=18;
      var_arg_loop=20;
      v_a_l_1=22;
      arg_loop=24;
      a_l_1=26;
      a_l_2=28;
      run_handler=30;
      r_h_1=32;
      eval_wrap_up=34;
      e_w_1=36;
      eval_return=38;
      funcall=40;
      funcall1=42;
      u_f_1=44;
      u_f_2=46;
      u_f_3=48;
      error_1=50;
      error_2=52;
      s_read_1=54;
      s_read_2=56;

                   (* miscellaneous constants *)
      compact_number_lines=25;  (* S_READ forces a gc after this many lines are read in
                                   in order to mitigate nodespace fragmentation. *)

type
   chfil = packed file of char;
   byte = -128..127;
   bytearray = packed array [0 .. s_bigarray] of byte;
   namarr = packed array [1..8] of char;

   svcptr= ^block; (* Stuff for SVC$ calls *)
   bufptr= ^chars;
   namptr= ^nambuf;
   nambuf= packed record
      n1: byte;
      n2: char;
      n3: char;
      n4: char;
      n5: char;
      n6: char
      end;
   block= packed record
      svcop: byte;
      status: byte;
      ioop: byte;
      iolun: byte;
      sysflg: byte;
      usrflg: byte;
      buf: bufptr;
      size: integer;
      out: integer;
      b7: integer;
      b8: integer;
      alflag: integer;
      b10: integer;
      b11: integer;
      name: namptr;
      b13: integer;
      b14: integer;
      b15: integer;
      end;
   chars= packed array [1..2] of byte;

var
   hello: boolean;    (* False => logout, exit toplevel loop. *)
   workspace: chfil;  (* This is the file used for workspace saving. *)
   terminal: chfil;   (* The 2500 *)

   indev,outdev,      (* VDT or WFILE depending on whether input/output is coming from
                         /going to the terminal, or the workspace file.  This is actually
                         redundant since there will also be some CHFIL-type variable with
                         the appropriate device as value; however the Pascal "=" operator can't
                         be used on such a variable (!), hence the need for the redundancy. *)

   current_overlay,current_suboverlay,  (* Says which overlay/suboverlay is currently swapped
                                           in. *)
   error_flag,        (* Holds 0 if no error, or appropriate user error code. *)
   zap_code,          (* XZAP is the error code signaling unconditional return to top level.
                         ZAP_CODE elaborates on the reason for this, and has no meaning when
                         ERROR_FLAG <> XZAP. *)

   edit_switch,       (* 0 <=> not in edit mode. *)
   edit_body,         (* The fbody (always type FLIST) of the currently-being-edited ufun *)
   edit_atom,         (* The atom corresponding to the curently-being-edited ufun. *)
   number_switch,     (* 0 => no line numbers needed in line edit mode.
                         1 => 11LOGO line edit mode: each user function line must be preceeded
                         by a line number; otherwise, it will be executed as in non-edit mode
                         rather than becoming part of the function definition.
                         EXCEPT, when reading from the workspace file rather than the terminal
                         (as ascertained by INDEV = WFILE rather than = VDT), line numbers are
                         unnecessary regardless of the value of NUMBER_SWITCH. *)
   po_default,        (* The atom whose ufun is the default function to print when no argument
                         is given to PO. *)

   typebase,          (* Pointer to start of type codes. *)
   vpdlbase,          (* Pointer to bottom of vpdl-- ie the word following the highest-address
                         allocated for the vpdl. *)
   pdltop,            (* Pointer to top of pdl-- ie the lowest-address word allocated for the
                         pdl. *)
   vpdltop,           (* Pointer to top of vpdl. *)

   sarray_top,        (* Index of first unused byte in the SARRAY. *)

   soblist,           (* SOBLIST is a pseudo-list of satoms.  It's "pseudo" in that the atoms
                         appear as a large block of consecutive nodes, not as successive car's
                         of a list. *)
   sobtop,            (* Pointer to the first node after the SOBLIST pseudo-list. *)
   freelist,          (* List (real list) of free nodes. *)
   oblist,            (* List of all atoms which have been encountered by the reader, and
                         and which are not satoms. *)
   sp,vsp,            (* Pointers to the top of the pdl/vpdl respectively. *)

   temp1,temp2,temp3,

   mark1,mark2,mark3,mark4,   (* Mark variables garbage-collect-protect the pointers they hold.
*) mark5,                     (* Be sure to init them in INIT and mark them in GARBAGE_COLLECT.
                              When using them, be sure to clobber them to LNIL when through. *)
   cell_ptr, (* Another gc-protect variable, for READ_LINE. *)
   area1,size1,area2,size2,   (* area,size pairs denote SIZE words starting at ptr AREA to
                                 be gc-protected; however, these words are not assumed to
                                 be of any particular type and hence the garbage collector
                                 does not recurse on marking them; ie, nothing is gc-protected
                                 solely by virtue of being pointed to by these words. *)
   arg1,arg2,arg3,arg4,arg5,  (* Sfun routines can pop their arguments into these. *)

   iline,                     (* Current/last typed-in command line. *)
   debug_switch,              (* 0 => all errors return to toplevel except XBRK, which
                                      enters the error break loop.
                                 non-0 => all errors enter the error break loop, except
                                          XZAP, which returns to toplevel. *)
   number_lines_read, (* During a READ, this keeps track of the number of lines read, modulo
                         COMPACT_NUMBER_LINES.  *)
   (* LOGO key words *)
   sum,difference,product,unary_sum,unary_difference,lpar,rpar,lif,ltrue,lfalse,comment,pots,
   lelse,lthen,names,titles,procedures,all,lend,po,printout,erase,er,title,ti,lstop,diff1,

(* Evaluator variables *)

   pc,                        (* Pseudo assembly language program counter-- actually case
                                 clause label. *)
   frame,                     (* Pointer to current stack frame; 0 if none. *)
   xframe,                    (* Pointer to end of current stack frame. *)
   frame_gensym,              (* Starts at 1, gets incremented whenever a new stack frame is
                                 pushed. *)
   uformat,                   (* Format of currently-being-executed ufun's body: LIST
                                 or FPACK. *)
   uline_end,                 (* For ufun body of type fpack, pointes to first token after the
                                 current line. *)
   token_pointer,             (* Remainder of currently-being-executed command line. *)
   current_token,             (* Token before remainder of currently-being-executed line. By
                                 convention, TOKEN_POINTER is always advanced after CURRENT_
                                 TOKEN is assigned TOKEN_POINTER's car. *)
   run_flag,                  (* Non-0 <=> evaluating the argument to "RUN". *)
   stop_flag,                 (* Non-0 <=> return from current ufun. *)
   dont_continue_flag,        (* Non-0 <=> return from current break loop. *)
   line_number,               (* Line number of currently-being-executed ufun line. *)
   level_number,              (* Number of levels of ufun nesting at current execution. 0 is
                                 top level. *)
   tail_levels,               (* Number of tail-recursions included in current LEVEL_NUMBER.
                                 When the tail frame is finally popped, LEVEL_NUMBER needs
                                 to be decremented by TAIL_LEVELS. *)
   nest,                      (* Number of levels of EVAL nesting within the current EVLINE.
                                 Top level for the line is 0.  Note the distinction between
                                 LEVEL_NUMBER and NEST.  If FOO is called from top level and
                                 FOO calls BAR and some line in BAR is PR :A, LEVEL_NUMBER
                                 when :A is evaluated is 2 (top=0, inside FOO=1, inside
                                 BAR=2) and NEST is 1 (PR is called from level 0 of the line,
                                 :A is evaluated in the arg loop of the evaluation of PR). *)
   expected_output,           (* Non0 <=> output from current evaluation expected by caller. *)
   outputn,                   (* How many outputs have been vpushed by the current sfunction.
                                 0 and 1 are the only currently-supported values, ie
                                 multiple outputs are not now supported. *)
   fbody,                     (* Pointer to full body of current ufun. *)
   fptr,                      (* Pointer to remainder of body of current ufun. *)
   go_ptr,                    (* Normally LNIL. Set by S_GO to point to portion of ufun
                                 body whose car is the line to go to. *)
   next_token,                (* Used to look ahead at car of TOKEN_POINTER without advancing
                                 TOKEN_POINTER, as is the convention with CURRENT_TOKEN. *)
   if_level,                  (* Number of IF statement nestings in the current parsing.
                                 Essentially, it says how many "ELSE"s could sensibly appear
                                 in the current evaluation. *)
   funct,                     (* The current UFUN or SATOM. *)
   funtype,                   (* Type of FUNCT: UFUN or SATOM. *)
   fbody1,                    (* The current fbody or sindex. *)
   nargs,                     (* Number of arguments expected by the current function.
                                 A function which takes a variable number of arguments always
                                 has a default expectation (used in case the function is called
                                 without enclosing parentheses) and the nargs value for such a
                                 function is  -(default+1).   *)
   nargs1,                    (* Number of arguments evaluated and vpushed so far for the
                                 current function. *)
   precedence,                (* Precedence of calling ufun or sfun, used for parsing. *)
   var_name,                  (* Temporary variable. *)
   arg_list,                  (* Temporary variable. *)
   pointer,                   (* Temporary variable for pointing into the pdl or vpdl. *)




   column, (* For VDT hacking. *)
   snap_top,display_length  (* For the 2500. *)

   : integer;

   ioblk,getchr: svcptr;

   bigarray : array[0..bigarray_words] of integer;    (* Contains nodespace, pdls, etc. *)
   markarray : packed array [0..max_num_nodes] of boolean;(* Used by GC to mark nodes in use.*)
   sarray: packed array[0..sarray_max] of byte;       (* Satom info: pname,findex,nargs,prec *)
   workname: packed array[1..8] of char;              (* Filename of workspace file. *)
   termname: packed array[1..8] of char;              (* Filename of graphics terminal file. *)

(* pain-in-the-ass forward declarations *)

(*
   procedure ovly$ (load: integer); external;
   procedure svc$ (ptr: svcptr); external;
   procedure break (var foo: chfil); external;
*)

procedure overlay (number: integer); forward;
procedure suboverlay (number: integer); forward;
procedure stop_peek; forward;
procedure brk (var f: chfil); forward;
procedure breakl (var f: chfil); forward;
procedure writech (var f: chfil; ch: char); forward;
procedure do2500 (func,argument: integer; var return_value,error_flag,display_length,
                   snap_pointer: integer); forward;
procedure reinit; forward;
procedure oinit; forward;
procedure initialize; forward;
procedure zap_message; forward;
procedure put_bigarray (pointer,value: integer); forward;
procedure get_bigarray (var ans: integer; pointer: integer); forward;
procedure put_type (var node: integer; typec: integer); forward;
procedure get_type (var ans: integer; node: integer); forward;
procedure push (x: integer); forward;
procedure pop (var ans: integer); forward;
procedure vpush (x: integer); forward;
procedure vpop (var ans: integer); forward;
procedure push_test; forward;
procedure pop_test; forward;
procedure vpush_test; forward;
procedure vpop_test; forward;
procedure get_value (var ans: integer; atomm: integer); forward;
procedure put_value (atomm,value: integer); forward;
procedure get_function (var ans_funct,ans_type: integer; object: integer); forward;
procedure Get_pname (var ans,funny_pname: integer; atomm: integer); forward;
procedure put_strange_pname (atomm: integer); forward;
procedure put_pname (atomm,pname: integer); forward;
procedure Make_sfunction (var atomm: integer; findex,nargs,prec: integer); forward;
procedure Make_atom (var ans: integer; pname,value: integer); forward;
procedure Intern (var ans: integer; string: integer); forward;
procedure Cons (var ans: integer; xcar,xcdr,typ: integer); forward;
procedure Get_words (var ans: integer; size: integer); forward;
procedure car (var ans: integer; node: integer); forward;
procedure cdr (var ans: integer; node: integer); forward;
procedure rplaca (node,x: integer); forward;
procedure rplacd (node,x: integer); forward;
procedure Garbage_collect; forward;
procedure system_bug; forward;
procedure type_number (var f: chfil ; number: integer); forward;
procedure print (thing: integer); forward;
procedure ltype (var f: chfil; thing,toplevelp: integer); forward;
procedure error (errnum,errprint,ep1: integer); forward;

procedure jump (addr: integer); forward;
procedure popj; forward;
procedure get_token (var token: integer; line: integer); forward;
procedure tokn_advance (var line : integer; cflush: boolean); forward;
procedure get_uline (var line: integer; body: integer; cflush: boolean); forward;
procedure ulin_advance (var body: integer); forward;

procedure exit_if_scope (var ans: integer); forward;
procedure skip_past_thing; forward;
procedure pop_to_top; forward;
procedure lescape (xfr: integer); forward;
procedure reset_eval; forward;
procedure restore_bindings; forward;
procedure evaluate; forward;

procedure get_fframe (var ans: integer; funct: integer); forward;
procedure put_fframe (funct,funframe: integer); forward;
procedure get_nargs (var ans: integer; funct,funtype: integer); forward;
procedure put_nargs (funct,nargs: integer); forward;
procedure get_precedence (var ans: integer; funct,funtype: integer); forward;
procedure infix_p (var ans: integer; funct,funtype: integer); forward;
procedure find_line (var line: integer; var found: boolean; body,number: integer); forward;
procedure pread_line (var iline: integer; var f: chfil); forward;
procedure read_line (var iline: integer; var f: chfil); forward;
procedure edline (token_pointer: integer); forward;
procedure toploop (var f: chfil); forward;

procedure   s_sum; forward;
procedure   s_difference; forward;
procedure   s_product; forward;
procedure   s_un_sum; forward;
procedure   s_un_difference; forward;
procedure   s_make; forward;
procedure   s_output; forward;
procedure   s_stop; forward;
procedure   s_print; forward;
procedure   s_type; forward;
procedure   s_define; forward;
procedure   s_debug; forward;
procedure   s_continue; forward;
procedure   s_pause; forward;
procedure   s_else; forward;
procedure   s_not; forward;
procedure   s_either; forward;
procedure   s_both; forward;
procedure   s_equal; forward;
procedure   s_if; forward;
procedure   s_go; forward;
procedure   s_run; forward;
procedure   s_request; forward;
procedure   s_bpt; forward;
procedure   s_nodes; forward;
procedure   s_goodbye; forward;
procedure   s_gcoll; forward;
procedure   s_butfirst; forward;
procedure   s_first; forward;
procedure   s_butlast; forward;
procedure   s_last; forward;
procedure   s_fput; forward;
procedure   s_sentence; forward;
procedure   s_edit; forward;
procedure   s_to; forward;
procedure   s_end; forward;
procedure   s_title; forward;
procedure   s_text; forward;
procedure   s_thing; forward;
procedure   s_pthingp; forward;
procedure   s_word; forward;
procedure   s_pwordp; forward;
(* procedure   s_lines; forward; *)
procedure   do_1_arg_2500; forward;
procedure   do_0_arg_2500; forward;
procedure   s_snap; forward;
procedure   s_po; forward;
procedure   s_erase; forward;
procedure   s_write; forward;
procedure   s_read; forward;

procedure odo2500 (func,argument : integer;
   var return_value,error_flag,display_length,
        snap_pointer : integer; var f: chfil); forward;

procedure odo2500; (* func,argument : integer;
   var return_value,error_flag,display_length,
        snap_pointer : integer; var f: chfil *) begin return_value := 0 end;

(* IO and TI Dependency *)

(* TI Pascal functions: dummies for PDP10 Pascal *)
procedure ovly$ (overlay: integer); begin end;
procedure svc$ (ptr: svcptr); begin getchr^.status := 1 end;
procedure setname (var foo: chfil; name: namarr); begin end;
procedure close (var foo: chfil); begin end;

(* OVERLAY swaps in overlay number NUMBER.
   It also sets CURRENT_OVERLAY to NUMBER. *)
procedure overlay (*number: integer*);
   begin
   if current_overlay <> number then
      begin
      current_overlay := number;
      ovly$ (number)
      end
   end; (* overlay *)


(* SUBOVERLAY swaps in suboverlay number NUMBER.
   It also sets CURRENT_SUBOVERLAY to NUMBER. *)
procedure suboverlay (*number: integer*);
   begin
   if current_suboverlay <> number then
      begin
      current_suboverlay := number;
      ovly$ (number)
      end
   end; (* suboverlay *)

(* STOP_PEEK looks for an event character corresponding to the Stop or Pause key
   (F1 or F2 respectively on the TI VDT).  ERROR is called if either key has been
   typed.  Other event keys are read but otherwise ignored. *)
procedure stop_peek;
   var key: integer;
   procedure get_event_char (var key: integer);
      begin
      svc$ (getchr);
      if getchr^.status = 0 then key := getchr^.ioop
         else key := 0
      end;

   begin
   repeat
      get_event_char (key);	
      case key+128 of
       1: begin (* Stop key *)
            zap_code := stop_key;
            error (xzap,0,0)
            end;
       2: error (xbrk,0,0); (* Pause key *)
         otherwise
         end
      until key=0
   end; (* stop_peek *)


(* BRK does a BREAK (TI Pascal function to output a CRLF) iff output is going to
   the VDT rather than the WFILE. *)
procedure brk (*var f: chfil*);
   begin
   if outdev = vdt then break (f)
   end;


(* BREAKL outputs a CRLF and (on a VDT) forces buffered output to be printed. *)

procedure breakl (*var f: chfil*);
   begin
   if outdev = vdt then
      begin
      write (f,chr (10));
      write (f,chr (13));
      column := 0;
      break (f)
      end
     else writeln (f)
   end; (* breakl *)

(* WRITECH is like WRITE except that, for a VDT, it keeps track of COLUMN and watches
   out for end of line. *)
procedure writech (*var f: chfil; ch: char*);
   begin
   write (f,ch);
   if outdev = vdt then
      if column < 72 then column := column+1
         else breakl (f)
   end; (* writech *)


(* DO2500 interfaces with the 2500 routine; it sends commands (FD etc) and receives
   error codes. *)
procedure do2500 (*func,argument: integer; var return_value,error_flag,display_length,
                   snap_pointer: integer*);
   begin
   suboverlay (display_suboverlay);
   odo2500 (func,argument,return_value,error_flag,display_length,snap_pointer,terminal)
   end;

procedure oinit;      (* Do this once at the beginning of the world. *)
   var temp: integer;
   begin
   hello := true;
   number_switch := 0;

   new (ioblk);  (* Initialize SVC$ crap. *)
   ioblk^.svcop := 0;
   ioblk^.ioop := 1;    (* 1 is code for close. *)
   ioblk^.iolun := 5;   (* luno for vdt *)
   svc$ (ioblk);

   ioblk^.usrflg := 1;  (* Enable event chars bit. *)
   ioblk^.ioop := 0;    (* 0 is code for open. *)
   svc$ (ioblk);

   new (getchr);
   getchr^.svcop := 3*16 + 9;
   getchr^.iolun := 5;

   debug_switch := 0;
   edit_switch := 0;
   edit_body := lnil;

   indev := vdt;
   outdev := vdt;

   workname[1] := 'W'; workname[2] := 'O'; workname[3] := 'R'; workname[4] := 'K';
   workname[5] := 'S'; workname[6] := 'P'; workname[7] := 'A'; workname[8] := 'C';

   termname[1] := 'T'; termname[2] := 'E'; termname[3] := 'R'; termname[4] := 'M';
   termname[5] := 'I'; termname[6] := 'N'; termname[7] := 'A'; termname[8] := 'L';

   setname (terminal,termname);
   rewrite (terminal);

   for temp := 0 to sarray_max do sarray[temp] := 0;

   reinit
   end; (* oinit *)

procedure oreinit;     (* OINIT and Erase All cause this to happen. *)
var ptr1,ptr2,sobptr: integer;

(* SOBSET creates the next sarray & soblist entries, both unabbreviated and
(optionally) abbreviated.

Called with sobptr pointing to the next SOBLIST cell to use, SARRAY_TOP indexing
the next SARRAY entry to use.

Called with NARGS = # of arguments to this function; nargs = -n means variable # of args
                    with n-1 expected if unparenthesized.
            PREC = precedence value for this function
            SFINDEX = system function index
            L0-L11:  characters of the unabbreviated pname of this function, followed by a 
                     space, followed by the characters of the abbreviated pname (if any).
                     Extra args padded with spaces.
*)

   procedure sobset (nargs,prec,sfindex:integer; l0,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11: char);
      var index: integer;
      letter: array [0..11] of char;
      
      procedure sobst1;   (* Create the next sarray & soblist entry *)
         begin
         rplaca (sobptr,novalue);
         rplacd (sobptr,sarray_top);
         put_type (sobptr,satom);
         sarray[sarray_top+sa_sindex] := sfindex;
         sarray[sarray_top+sa_nargs] := nargs;
         sarray[sarray_top+sa_prec] := prec;
         sarray_top := sarray_top+3;
         while (letter[index] <> ' ') and (index < 12) do
            begin
            sarray[sarray_top] := ord (letter[index]);
            index := index + 1;
            sarray_top := sarray_top +1
            end;
         index := index + 1;
         sarray[sarray_top] := 0;
         sarray_top := sarray_top + 1;
         sobptr := sobptr + nodesize
         end;
   
      begin
      letter[0] := l0;
      letter[1] := l1;
      letter[2] := l2;
      letter[3] := l3;
      letter[4] := l4;
      letter[5] := l5;
      letter[6] := l6;
      letter[7] := l7;
      letter[8] := l8;
      letter[9] := l9;
      letter[10] := l10;
      letter[11] := l11;
   
      index := 0;
      sobst1;            (* Create unabbreviated entry. *)
      if (letter[index] <> ' ') and (index < 12) then sobst1; (* Create abbreviated entry, *)
      end; (* sobset *)                                       (* if any. *)

(* ...in the scope of REINIT *)

   procedure sobsort;  (* Alphebetize the SOBLIST. *)
      var searchptr,moveptr,temp,temp1: integer; found,btemp: boolean;

      procedure higher (var ans: boolean; ptr1,ptr2: integer);
         var index,compare: integer;
         begin
	 cdr (ptr1,ptr1); cdr (ptr2,ptr2);
         index := sa_pname;
         compare := 0;
         while (sarray[ptr1+index] <> 0) and (compare = 0) do
            begin
            compare := sarray[ptr1 + index] - sarray[ptr2 + index];
            index := index+1
            end;
         ans := (compare > 0)
         end;

      begin
      sobptr := soblist + nodesize;
      while sobptr <> sobtop do
         begin
         searchptr := soblist;
         found := false;
         while (searchptr <> sobptr) and (not found) do
            begin
            higher (btemp,searchptr,sobptr);
            if btemp then found := true
               else searchptr := searchptr + nodesize
            end;
         cdr (temp,sobptr);                (* TEMP has the currently-being-placed sfun. *)
         moveptr := sobptr - nodesize;
         while moveptr >= searchptr do
            begin
            cdr (temp1,moveptr);
            rplacd (moveptr+nodesize,temp1);  (* Move things up 1 slot. *)
            moveptr := moveptr - nodesize
            end;
         rplacd (searchptr,temp);
         sobptr := sobptr + nodesize
         end
      end;

(* ...in the scope of REINIT *)
   procedure strin (var ans: integer; ch1,ch2,ch3,ch4,ch5,ch6: char);
      begin
      if ch1 = ' ' then ans := 0
         else if ch2 = ' ' then Cons (ans, ord(ch1), 0,string)
            else if ch3 = ' ' then Cons (ans, ord(ch1)+ord(ch2)*256,0,string)
               else if ch4 = ' ' then begin
                                      Cons (ans,ord(ch3),0,string);
                                      Cons (ans,ord(ch1)+ord(ch2)*256,ans,string)
                                      end
                   else if ch5 = ' ' then begin
                                          Cons (ans,ord(ch3)+ord(ch4)*256,0,string);
                                          Cons (ans,ord(ch1)+ord(ch2)*256,ans,string)
                                          end
                      else if ch6 = ' ' then begin
                                             Cons (ans,ord(ch5),0,string);
                                             Cons (ans,ord(ch3)+ord(ch4)*256,ans,string);
                                             Cons (ans,ord(ch1)+ord(ch2)*256,ans,string)
                                             end
                         else begin
                              Cons (ans,ord(ch5)+ord(ch6)*256,0,string);
                              Cons (ans,ord(ch3)+ord(ch4)*256,ans,string);
                              Cons (ans,ord(ch1)+ord(ch2)*256,ans,string)
                              end;
      end; (* string *)

(* ...in the scope of REINIT *)

   (* VARNAM becomes a pointer to the INSTANCE'th satom on the SOBLIST that has
      INDEX as its findex. *)
   procedure sobvar (index: integer; var varnam: integer; instance: integer);
      var flag: boolean; temp: integer;
      begin
      flag := false;
      varnam := soblist - nodesize;
      while (varnam <> sobtop - nodesize*2) and (flag = false) do
         begin
         varnam := varnam + nodesize;
         cdr (temp,varnam);
         if sarray[temp + sa_sindex] = index then if instance <> 1 then instance := instance-1
                                                     else flag := true
         end;
      if flag = false then system_bug
      end; (* sobvar *)

   begin (* oreinit *)

   frame_gensym := 1;

   typebase := s_inodes;	(* Init storage management params *)
(* **** array space *)
   sp := s_bigarray;
   pdltop := s_bigarray - s_ipdl;
   vpdlbase := pdltop;
   vsp := vpdlbase;
   vpdltop := vsp - s_ivpdl;

   soblist := first_node;          (* Grand opening: initialize the SOBLIST and SARRAY. *)
   sobptr := soblist;
   sarray_top := 0;

(* gack. *)

SOBSET ( 0, 0,SI_ALL,'A','L','L',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_BACK,'B','A','C','K',' ','B','K',' ',' ',' ',' ',' ');
SOBSET ( 2, 1,SI_BOTH,'B','O','T','H',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_BUTFIRST,'B','U','T','F','I','R','S','T',' ','B','F',' ');
SOBSET ( 1, 5,SI_BUTLAST,'B','U','T','L','A','S','T',' ','B','L',' ',' ');
SOBSET ( 0, 0,SI_CONTINUE,'C','O','N','T','I','N','U','E',' ','C','O',' ');
SOBSET ( 0, 0,SI_CS,'C','S',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_DEBUG,'D','E','B','U','G',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 2, 0,SI_DEFINE,'D','E','F','I','N','E',' ','D','E',' ',' ',' ');
SOBSET ( 2, 6,SI_DIFFERENCE,'D','I','F','F','E','R','E','N','C','E',' ','-');
SOBSET ( 1, 0,SI_DISPLAY,'D','I','S','P','L','A','Y',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_EDIT,'E','D','I','T',' ','E','D',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_END,'E','N','D',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 2, 1,SI_EITHER,'E','I','T','H','E','R',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_ELSE,'E','L','S','E',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 2, 3,SI_EQUAL,'E','Q','U','A','L',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_ERASE,'E','R','A','S','E',' ','E','R',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_FIRST,'F','I','R','S','T',' ','F',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_FORWARD,'F','O','R','W','A','R','D',' ','F','D',' ',' ');
SOBSET ( 2, 0,SI_FPUT,'F','P','U','T',' ','F','P',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_GO,'G','O',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_GOODBYE,'G','O','O','D','B','Y','E',' ',' ',' ',' ',' ');
SOBSET ( 2, 4,SI_GREATER,'G','R','E','A','T','E','R',' ','>',' ',' ',' ');
SOBSET ( 0, 0,SI_HOME,'H','O','M','E',' ','H',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_IF,'I','F',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 2, 3,SI_IS,'I','S',' ','=',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_LAST,'L','A','S','T',' ','L',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_LEFT,'L','E','F','T',' ','L','T',' ',' ',' ',' ',' ');
SOBSET ( 2, 4,SI_LESS,'L','E','S','S',' ','<',' ',' ',' ',' ',' ',' ');
SOBSET ( 2, 0,SI_MAKE,'M','A','K','E',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_MOVE,'M','O','V','E',' ','M','O',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_NAMES,'N','A','M','E','S',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 2,SI_NOT,'N','O','T',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_OUTPUT,'O','U','T','P','U','T',' ','O','P',' ',' ',' ');
SOBSET ( 0, 0,SI_PAUSE,'P','A','U','S','E',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_PENUP,'P','E','N','U','P',' ','P','U',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_PENDOWN,'P','E','N','D','O','W','N',' ','P','D',' ',' ');
SOBSET ( 0, 0,SI_POTS,'P','O','T','S',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_PRINTOUT,'P','R','I','N','T','O','U','T',' ','P','O',' ');
SOBSET ( 1, 0,SI_PRINT,'P','R','I','N','T',' ','P','R',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_PROCEDURES,'P','R','O','C','E','D','U','R','E','S',' ',' ');
SOBSET ( 2, 7,SI_PRODUCT,'P','R','O','D','U','C','T',' ','*',' ',' ',' ');
SOBSET ( 2, 7,SI_QUOTIENT,'Q','U','O','T','I','E','N','T',' ','/',' ',' ');
SOBSET ( 0, 0,SI_READ,'R','E','A','D',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_REQUEST,'R','E','Q','U','E','S','T',' ','R','Q',' ',' ');
SOBSET ( 1, 0,SI_RIGHT,'R','I','G','H','T',' ','R','T',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_RUN,'R','U','N',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( -3, 5,SI_SENTENCE,'S','E','N','T','E','N','C','E',' ','S','E',' ');
SOBSET ( 0, 5,SI_SNAP,'S','N','A','P',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 0,SI_SPIN,'S','P','I','N',' ','S','P',' ',' ',' ',' ',' ');
SOBSET ( 2, 6,SI_SUM,'S','U','M',' ','+',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_STOP,'S','T','O','P',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_TEXT,'T','E','X','T',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_THEN,'T','H','E','N',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_THING,'T','H','I','N','G',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_THINGP,'T','H','I','N','G','P',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_TITLE,'T','I','T','L','E',' ','T','I',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_TITLES,'T','I','T','L','E','S',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_TO,'T','O',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_TRACEBACK,'T','R','A','C','E','B','A','C','K',' ','T','B');
SOBSET ( 1, 5,SI_TYPE,'T','Y','P','E',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_WIPECLEAN,'W','I','P','E','C','L','E','A','N',' ','W','C');
SOBSET ( -3, 5,SI_WORD,'W','O','R','D',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 1, 5,SI_WORDP,'W','O','R','D','P',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_WRITE,'W','R','I','T','E',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_LPAR,'(',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_RPAR,')',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_COMMENT,';',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_GCOLL,'.','G','C','O','L','L',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_BPT,'.','B','P','T',' ',' ',' ',' ',' ',' ',' ',' ');
SOBSET ( 0, 0,SI_NODES,'.','N','O','D','E','S',' ',' ',' ',' ',' ',' ');

   sobtop := sobptr;
   sobsort;          (* Alphabetize the SOBLIST. *)

   sobvar (si_sum,sum,1);
   sobvar (si_difference,difference,1);
   sobvar (si_product,product,1);
   sobvar (si_lpar,lpar,1);
   sobvar (si_rpar,rpar,1);
   sobvar (si_if,lif,1);
   sobvar (si_else,lelse,1);
   sobvar (si_then,lthen,1);
   sobvar (si_names,names,1);
   sobvar (si_all,all,1);
   sobvar (si_titles,titles,1);
   sobvar (si_procedures,procedures,1);
   sobvar (si_end,lend,1);
   sobvar (si_printout,po,1);
   sobvar (si_printout,printout,2);
   sobvar (si_pots,pots,1);
   sobvar (si_erase,er,1);
   sobvar (si_erase,erase,2);
   sobvar (si_title,ti,1);
   sobvar (si_title,title,2);
   sobvar (si_stop,lstop,1);
   sobvar (si_comment,comment,1);

   ptr1 := sobtop;   (* Init the FREELIST *)
   ptr2 := ptr1 + nodesize;
   rplaca (sobtop,lnil);
   repeat
      rplacd (ptr2,ptr1);
      ptr1 := ptr2;
      ptr2 := ptr2 + nodesize;
   until ptr2 = typebase;
   freelist := ptr1;

   ptr1 := lnil;
   put_type (ptr1,list);   (* node 0 is LNIL *)
   rplaca (lnil,lnil);   (* node 0 is LNIL; make car & cdr LNIL *)
   rplacd (lnil,lnil);

                                         (* UNARY_SUM & UNARY_DIFFERENCE are uninterned *)
   Make_sfunction (unary_sum,si_unary_sum,1,6);
   Make_sfunction (unary_difference,si_unary_difference,1,6);

   mark1 := lnil; mark2 := lnil; mark3 := lnil; mark4 := lnil; mark5 := lnil;
   size1 := 0; size2 := 0;
   cell_ptr := lnil;

   oblist := lnil;      (*init the oblist *)

   strin (temp1,'T','R','U','E',' ',' ');  (* Intern LTRUE and LFALSE. *)
   Intern (ltrue,temp1);

   strin (temp1,'F','A','L','S','E',' ');
   Intern (lfalse,temp1);

   Cons (diff1,-1,0,fix);
end; (* oreinit *)

procedure reinit;
   var caller: integer;
   begin
   caller := current_overlay;
   overlay (init_overlay);
   oreinit;
   overlay (caller)
   end; (* reinit *)

procedure initialize;
   begin
   overlay (init_overlay); (* Always called from main section. *)
   oinit
   end; (* init *)

(* miscellaneous utility routines *)

(* ZAP_MESSAGE is called to print the appropriate error message when an XZAP error
   occurs. *)
procedure zap_message;
   begin
   case zap_code of
      no_pdl,no_vpdl,no_nodes: write (ttyoutput, 'No storage left!');
      stop_key: write (ttyoutput,'Stopped!!!');
      logout: write (ttyoutput,'And a pleasant day to you');
      otherwise system_bug
      end;
   break (ttyoutput)
   end; (* zap_message *)

(* The value VALUE is placed at BIGARRAY location POINTER.
   This should be a MACRO. *)
procedure put_bigarray; (* pointer,value: integer *)
   begin
   bigarray[pointer div 2] := value
   end; (* put_bigarray*)

(* ANS gets the value stored at BIGARRAY location POINTER.
   This should be a MACRO. *)
procedure get_bigarray; (* var ans: integer; pointer: integer *)
   begin
   ans := bigarray[pointer div 2]
   end; (* get_bigarray *)


(* PUT_TYPE gives NODE the type TYPEC:
   1) the appropriate type is stored in the type array.
   2) for those types (QATOM,DATOM, or LATOM) where part of a node's type specification
      is in the pointer to the node (see types documentation), NODE is suitably modified.
      NOTE: PUT_TYPE of QATOM, DATOM, or LATOM should only be done when a type code
      of ATOM or SATOM has already been entered, eg the atom has been interned. *)
procedure put_type; (* var node: integer; typec : integer *)
   var temp: integer;
   begin
   if node <> lnil then
      case typec of
         qatom: node := node + 1;
         datom: node := node + 2;
         latom: node := node + 3;
         otherwise
(*in        bigarray::bytearray[typebase+node div nodesize] := typec
out*)       begin
            get_bigarray (temp,typebase+node div nodesize);
            case (node div nodesize) mod wordsize of
               0: put_bigarray (typebase+node div nodesize, temp div 256 * 256 + typec);
               1: put_bigarray (typebase+node div nodesize, (temp mod 256) + typec*256)
               end
            end
(*end*)
         end
   end; (* put_type *)

(* The type of node NODE is returned in ANS. *)

procedure get_type; (* var ans: integer; node: integer *)
   var temp: integer;
   begin
(*in ans := bigarray::bytearray[typebase+node div nodesize];
out*) get_bigarray (temp,typebase+node div nodesize);
   case (node div nodesize) mod wordsize of
      0: ans := temp mod 256;
      1: ans := temp div 256
      end;
(*end*)
   case ans of
      atom,satom:
            case node mod nodesize of
               0: ;
               1: ans := qatom;
               2: ans := datom;
               3: ans := latom;
               end;
      otherwise 
   end
   end; (* get_type *)

(* Push X onto the pdl. *)
procedure push; (* x: integer *)
   begin
   sp := sp+pushinc;
   put_bigarray(sp,x)
   end; (* push *)

(* Pop a word from the pdl into ANS. *)
procedure pop; (* var ans: integer *)
   begin
   get_bigarray(ans,sp);
   sp := sp+popinc
   end; (* pop *)

(* Push X onto the vpdl. *)
procedure vpush; (* x: integer *)
   begin
   vsp := vsp+pushinc;
   put_bigarray(vsp,x)
   end; (* vpush *)

(* Pop a word from the vpdl into ANS. *)
procedure vpop; (* var ans: integer *)
   begin
   get_bigarray(ans,vsp);
   vsp := vsp+popinc
   end; (* vpop *)

(* Call ERROR if pdl is almost full.  Also, check for event keys.
   PUSH_TEST should be called each time through any recursive PLOGO code. *)
procedure push_test;
   begin
   if sp < pdltop + pdl_push_limit then begin
                                        zap_code := no_pdl;
                                        error (xzap,0,0)
                                        end
      else stop_peek
   end; (* push_test *)

(* (This is for pdl-swapping, which isn't implemented.) *)
procedure pop_test;
   begin
   end; (* pop_test *)

(* Call ERROR if vpdl is almost full. *)
procedure vpush_test;
   begin
   if vsp < vpdltop + vpdl_push_limit then begin
                                           zap_code := no_vpdl;
                                           error (xzap,0,0)
                                           end
   end; (* vpush_test *)

(* (This is for pdl-swapping, which isn't implemented.) *)
procedure vpop_test;
   begin
   end; (* vpop_test *)

(* atomic utility routines *)

(* The value of atom or satom ATOMM is returned in ANS. *)
procedure get_value; (* var ans: integer; atomm: integer *)
   begin
   car (ans,atomm div nodesize * nodesize)
   end; (* get_value *)

(* Gives ATOMM the value VALUE.
   Can also be used with ATOMM as a ufun, VALUE as funframe. In this case ATOMM will
   be the ufun address+1. *)
procedure put_value; (* atomm,value: integer *)
   begin
   rplaca (atomm div nodesize * nodesize,value)
   end; (* put_value *)

(* The function associated with OBJECT is returned in ANS_FUNCT. Its type (ufun or sfun)
   is returned in ANS_TYPE. *)
procedure get_function; (* var ans_funct,ans_type: integer; object: integer *)
   var typ: integer;
   begin
   get_type (typ,object);
   case typ of
      atom:
           begin
           cdr (ans_funct,object);
           car (ans_funct,ans_funct);
           ans_type := ufun
           end;
      satom:
           begin
           cdr (ans_funct,object);
           ans_type := sfun
           end;
      otherwise ans_funct := novalue
      end
   end; (* get_function *)

(* Input ATOMM is an atom or satom. Output ANS is the pname, consed up in the
   case of an satom. *)
procedure Get_pname; (* var ans,funny_pname: integer; atomm: integer *)
   var typ,index,temp,temp1: integer;
   begin
   atomm := atomm div nodesize * nodesize;
   get_type (typ,atomm);
   case typ of
      atom: begin
            cdr (ans,atomm);
            cdr (ans,ans);
            funny_pname := ans mod 2;
            ans := ans div 2 * 2                                    
            end;
      satom:begin
            mark1 := lnil;
            cdr (index,atomm);
            index := index + sa_pname;
            temp := sp;
            while (sarray[index] <> 0) and (error_flag <> xzap) do
               begin
               push_test;
               push (sarray[index]+sarray[index+1]*256);
               if error_flag <> xzap then
                  if sarray[index+1]=0 then index := index+1
                     else index := index + 2
               end;
            if error_flag <> xzap then
               begin
               while temp <> sp do
                  begin
                  pop (temp1);
                  Cons (mark1,temp1,mark1,string)
                  end;
               ans := mark1;
               mark1 := lnil
               end
            end;
      otherwise system_bug
      end
   end; (* Get_pname *)

(* ATOMM's funny pname bit is set. *)
procedure put_strange_pname; (* atomm: integer *)
   var temp1,temp2: integer;
   begin
   cdr (temp1,atomm div nodesize * nodesize);
   cdr (temp2,temp1);
   rplacd (temp1,temp2 div 2 * 2 + 1)
   end; (* put_strange_pname *)

(* ATOMM is given the pname PNAME. *)
procedure put_pname; (* atomm,pname: integer *)
   var temp: integer;
   begin
   cdr (temp,atomm div nodesize * nodesize);
   rplacd (temp,pname)
   end; (* put_pname *)

(* MAKE_SFUNCTION makes an uninterned SATOM with LNIL pname. *)
procedure Make_sfunction; (* var atomm: integer; findex,nargs,prec: integer *)
   var temp: integer;
   begin
   Cons (atomm,novalue,sarray_top,satom);
   sarray[sarray_top + sa_sindex] := findex;
   sarray[sarray_top + sa_nargs] := nargs;
   sarray[sarray_top + sa_prec] := prec;
   sarray[sarray_top + sa_pname] := 0;
   sarray_top := sarray_top + sa_pname + 1
   end; (* Make_sfunction *)

(* The frame number of function FUNCT is returned in ANS. *)
procedure get_fframe; (* var ans: integer; funct: integer *)
   begin
   get_bigarray (ans,funct)
   end;

(* Function FUNCT's frame number becomes FUNFRAME. *)
procedure put_fframe; (* funct,funframe: integer *)
   begin
   put_bigarray (funct,funframe)
   end;

(* The number-of-arguments of function FUNCT is returned in ANS.
   Must be called with FUNTYPE as FUNCT's type (ufun or sfun). *)
procedure get_nargs; (* var ans: integer; funct,funtype: integer *)
   begin
   case funtype of
      ufun: get_bigarray (ans,funct+wordsize*2);
      sfun: ans := sarray[funct + sa_nargs];
      otherwise system_bug
      end
   end; (* get_nargs *)

(* The number-of-arguments of function FUNCT is set to NARGS.
   This can only be used on a ufun, never an sfun. *)
procedure put_nargs; (* funct,nargs: integer *)
   begin
   put_bigarray (funct+wordsize*2,nargs)
   end; (* put_nargs *)

(* The precedence of function FUNCT is returned in ANS.
   Must be called with FUNTYPE as FUNCT's type (ufun or sfun). *)
procedure get_precedence; (* var ans: integer; funct,funtype: integer *)
   begin
   case funtype of
      ufun: ans := 5;  (* Same precedence as =,<,>. Lower than +,-. *)
      sfun: ans := sarray[funct + sa_prec];
      otherwise system_bug
      end
   end; (* get_precedence *)

(* On return, ANS is nonzero iff FUNCT is not an infix function.
   Must be called with FUNTYPE as FUNCT's type (ufun or sfun). *)
procedure infix_p; (* var ans: integer; funct,funtype: integer *)
   var temp: integer;
   begin
   if funct = novalue then ans := 0
      else if funtype <> sfun then ans := 0 else
              begin
              temp := sarray[funct + sa_sindex];
              case temp of
                      si_less,si_quotient,si_greater,si_sum,si_difference,si_product,si_is:
                         ans := 1;
                      otherwise ans := 0
                      end
              end
   end; (* infix_p *)

(* FIND_LINE looks through a list-format ufun body (argument BODY) for line number NUMBER.
   FIND_LINE returns LINE = the portion of BODY whose car is the specified line, if such a
   line exists; or, otherwise,  returns LINE = the portion of BODY whose car is the next
   lowest line number.  FOUND is set to true iff the line was found. *)
procedure find_line; (* var line: integer; var found: boolean; body,number: integer *)
   var temp,lastline: integer;
   begin
   lastline := body;
   cdr (line,lastline);
   temp := -1;
   while (line <> lnil) and (temp < number) do
      begin
      car (temp,line);
      car (temp,temp);
      if temp < number then begin lastline := line; cdr (line,line) end
      end;
   found := (temp=number);
   if not found then line := lastline
   end; (* find_line *)

(* DELETE deletes line number NUMBER from the currently-being-edited procedure. *)
procedure delete (number: integer);
   var lastline,line,temp: integer;
   begin
   lastline := edit_body;                    (* Search for line with that NUMBER. *)
   cdr (line,lastline);
   temp := -1;
   while (line <> lnil) and (temp < number) do
      begin
      car (temp,line);
      car (temp,temp);
      if temp < number then begin lastline := line; cdr (line,line) end
      end;
   if temp = number then                     (* If the line was found, *)
      begin                                  (* then splice it out. *)
      cdr (temp,line);
      rplacd (lastline,temp)
      end
   end; (* delete *)            

(* Creates (but doesn't intern) an atom with value VALUE and pname PNAME.
   Pointer to the atom is returned in ANS. *)
procedure Make_atom; (* var ans: integer; pname,value: integer *)
   begin
   Cons (ans,novalue,pname,list);
   if error_flag <> xzap then
      Cons (ans,value,ans,atom)
   end; (* Make_atom *)

(* INTERN searches the OBLIST, then the SOBLIST for an atom or satom whose pname matches
that of argument STRING.  If not found, INTERN creates a new atom with STRING as its pname,
and CONSes the atom onto the OBLIST.
In any case, INTERN returns with ANS = the (old or new) atom with pname STRING. *)

procedure oIntern (var ans: integer; string: integer);
   var ob_ptr,flag,pname,atom: integer;

   (* SOBFIND searches the SOBLIST for an SATOM with the same pname as argument STRING.
      If found, SOBFIND returns with ANS (scope of INTERN) = the SATOM, FLAG <> 0.
      Otherwise,SOBFIND returns with FLAG = 0. *)
   procedure sObfind (var flag: integer);
      var delta,extra: integer;

      (* MATCH returns FLAG = 0 if PNAME matches SATOMPTR
                       FLAG > 0 if PNAME comes after SATOMPTR
                       FLAG < 0 if PNAME comes before SATOMPTR. *)
      procedure match1 (var flag: integer; pname,satomptr: integer);
         var sobname,temp: integer;
         begin
	 flag := 0;
         cdr (sobname,satomptr);
         sobname := sobname + sa_pname;
	 
         while (pname <> 0) and (flag = 0) do
	    begin
            car (temp,pname);
            flag := (temp mod 256) - sarray[sobname];
            if (flag = 0) then
               begin
               sobname := sobname + 1;
               flag := (temp div 256) - sarray[sobname];
               if flag = 0 then
                  begin
                  cdr (pname,pname);
                  if sarray[sobname] <> 0 then sobname := sobname + 1
                  end
               end
            end;
         if (flag = 0) and (sarray[sobname] <> 0) then flag := -1
         end; (* match1 *)

      begin (* sObfind *)
      ans := soblist;
      flag := 1;
      while (flag > 0) and (ans <> sobtop) do
         begin
         match1 (flag,string,ans);
         if flag <> 0 then ans := ans+nodesize
         end;

(*      ans := sobmid;
      delta := sobdelta;
      while (delta <> 0) do
         begin
         match1 (flag,string,ans);
         if flag <> 0
            then begin
                 extra := delta mod (nodesize*2);
                 delta := delta div 2;
                 delta := (delta div nodesize) * nodesize;
                 if flag < 0
                    then begin
                         ans := ans - delta - extra
                         end
                    else begin
                         ans := ans + delta;
                         end;
                 if delta <> 0 then delta := delta + extra
                 end
	    else begin delta := 0; extra := 0 end
         end;
*)
      if flag = 0 then flag := 1
         else flag := 0
      end; (* sObfind *)

(* ... in the scope of INTERN. *)
   (* OBFIND searches the oblist for an atom whose pname matches STRING (arg to INTERN).
      If found, OBFIND returns with ANS (scope of INTERN) = the atom, FLAG <> 0.
      Otherwise,OBFIND returns with FLAG = 0. *)
   procedure Obfind (var flag: integer);

      (* MATCH returns with FLAG = 0 iff string1 and string2 are not the same. *)
      procedure match2 (var flag: integer; string1, string2 : integer);
         var tstr1,tstr2: integer;
         begin
         while ((string1 <> 0) and (string2 <> 0)) do
               begin
               car (tstr1,string1);
               car (tstr2,string2);
               if tstr1 <> tstr2 then string1 := 0
                  else begin
                       cdr (string1,string1);
                       cdr (string2,string2)
                       end;
               end;
         if (string1 = 0) and (string2 = 0) then flag := 1
         end; (* match2 *)

      begin (* Obfind *)    (* If the atom is already interned, returns with FLAG <> 0 and *)
      flag := 0;
      ob_ptr := oblist; (*  ANS = the atom; else, returns with FLAG = 0. *)
      while ob_ptr <> 0 do
         begin
         car (ans,ob_ptr);
         Get_pname (pname,temp1,ans);
         match2 (flag,pname,string);
         if flag <> 0 then ob_ptr := 0
            else cdr (ob_ptr,ob_ptr)
         end
      end; (* Obfind *)

   begin (* Intern *)
   vpush (string);
   Obfind (flag);          (* Search for atom in OBLIST. *)
   vpop (string);
   if flag = 0 then
      begin
      sObfind (flag);  (* If not there, look on the SOBLIST. *)
      if flag = 0 then
         begin                             (* If pname isn't already interned, *)
         Make_atom (ans,string,novalue);   (* make new atom with undef value. *)
         if error_flag <> xzap then
            Cons (oblist,ans,oblist,list);         (* Stick new atom on the OBLIST. *)
         end
      end
   end; (* ointern *)

procedure Intern; (* var ans: integer; string: integer *)
   begin
   suboverlay (word_suboverlay);
   ointern (ans,string)
   end; (* Intern *)

(* list utility rtns *)

(* CONS creates a node with car XCAR and cdr XCDR.  Pointer to the node is
   returned in ANS. *)
procedure Cons; (*  var ans: integer; xcar,xcdr,typ : integer *)
   begin
   if freelist = lnil then
      begin
      vpush (xcar);
      vpush (xcdr);
      Garbage_collect;
      vpop (xcar);
      vpop (xcdr);
      if freelist = lnil then
         begin
         zap_code := no_nodes;
         error (xzap,0,0)
         end
      end;
   if error_flag <> xzap then
      begin
      ans := freelist;
      cdr (freelist,freelist);
      rplaca (ans,xcar);
      rplacd (ans,xcdr);
      put_type (ans,typ)
      end
   end; (* Cons *)

(* GET_WORDS searches nodespace starting at PTR for a block of SIZE contiguous free words,
   starting on a node boundary.  Returns ANS = ptr to 1st word of the block if found,
   else ANS = LNIL.
   WARNING:  These words are not garbage-collect protected until something gc-protected
   points to them!  The variables AREA1,SIZE1 and AREA2,SIZE2 can be used to protect
   the chunks returned.
*)
procedure Get_words; (* var ans: integer; size: integer *)
   procedure gw_1;
   var sofar,ptr,lastptr,ptr1,lastptr1,temp: integer; contig: boolean;
      begin
      ans := lnil;
      if size <> 0 then
         begin
         ptr := freelist;
         lastptr := lnil;
         ptr1 := ptr;
         lastptr1 := lastptr;
         while (ptr <> lnil) and (ans = lnil) do
            begin
            sofar := 0;
            contig := true;
            while contig and (ptr1 <> lnil) and (sofar < size) do
               begin
               sofar := sofar + 2;  (* We've found 2 more words. *)
               cdr (temp,ptr1);
               contig :=  temp + nodesize = ptr1;
               lastptr1 := ptr1;
               ptr1 := temp
               end;
            if sofar >= size then
               begin
               if lastptr <> lnil then rplacd (lastptr,ptr1) else freelist := ptr1;
               ans := lastptr1
               end
               else begin
                    ptr := ptr1;
                    lastptr := lastptr1
                    end
            end
         end
      end; (* gw_1 *)

   begin (* Get_words *)
   gw_1;   (* First attempt *)
   if (ans = lnil) and (size <> 0) then begin
                      Garbage_collect;
                      gw_1      (* Second attempt *)
                      end
   end; (* Get_words *)

(* ANS gets the car of NODE.
   This should be a MACRO. *)
procedure car; (* var ans: integer; node: integer *)
   begin
   get_bigarray (ans,node);
   end; (* car *)

(* ANS gets the cdr of NODE.
   This should be a MACRO. *)
procedure cdr; (* node: integer *)
   begin
   get_bigarray (ans, node+2);
   end; (* cdr *)

(* NODE's car becomes X.
   This should be a MACRO. *)
procedure rplaca; (* node,x: integer *)
   begin
   put_bigarray (node, x);
   end; (* rplaca *)

(* NODE's cdr becomes X.
   This should be a macro. *)
procedure rplacd; (* node,x: integer *)
   begin
   put_bigarray (node + 2, x);
   end; (* rplacd *)

procedure system_bug;
   begin
   write (ttyoutput,'LOGO bug. ');
   HALT
   end; (*  system_bug *)

(* See nodespace documentation for explanation of garbage collection. *)
procedure oGarbage_collect;
   var index,temp,temp1,nargs,frameptr,ptr1: integer;
   procedure mark (index: integer);
     var typ,icar,icdr,pc,token,line,line_end: integer; firstline: boolean;
     begin
     if error_flag <> xzap then
      begin
      push (-1);
      while (error_flag <> xzap) and (index <> -1) do
         begin
         if not markarray [index div nodesize] then
            begin
            markarray [index div nodesize] := true;
            get_type (typ,index);
            case typ of
               fix,flist: begin cdr (icdr,index); if icdr <> 0 then push (icdr) end;
               ufun: begin
                     cdr (icdr,index);
                     if icdr <> 0 then push (icdr);
                     markarray[(index+nodesize)div nodesize] := true
                     end;
               satom:    begin car (icar,index); if icar <> 0 then push (icar) end;
               list,atom,qatom,datom,latom:
                         begin index := index div nodesize * nodesize;
                               car (icar,index); if icar <> 0 then push (icar);
                               cdr (icdr,index); if icdr <> 0 then push (icdr) end;
               fpack: begin
                      get_bigarray (line,index);
                      get_bigarray (line_end,index + wordsize);
                      firstline := true;(* node boundary. *)
                      while (line_end <> 0) and (error_flag <> xzap) do
                         begin
                         markarray[(index+wordsize) div nodesize] := true;
                         markarray [line div nodesize] := true;  (* Mark the line's
                                                                    first token. *)
                         if not firstline then line := line + wordsize; (* Except for arglist,
                                                    need to skip past immediate line number. *)
                         firstline := false;
                         while (line <> line_end) and (error_flag <> xzap) do
                            begin
                            markarray[line div nodesize] := true;
                            get_bigarray (token,line);
                            push (token); push_test;
                            line := line + wordsize
                            end;
                         index := index + wordsize;
                         get_bigarray (line,index);
                         get_bigarray (line_end,index + wordsize)
                         end;
                      markarray[(index+wordsize) div nodesize] := true
                      end;
               otherwise system_bug;
               end
            end;
         push_test;  (* check for stack overflow *)
         if error_flag = xzap then
            while index <> -1 do begin pop_test; pop (index) end
          else begin pop (index); pop_test end
         end
      end
     end;

(* ...in the scope of GARBAGE_COLLECT *)
   procedure markarea (size,ptr: integer);
      begin
      while size > 0 do
         begin
         markarray[ptr div nodesize] := true;
         ptr := ptr + nodesize;
         size := size-2
         end
      end;

   begin
   (* init the bit table so that all nodes are free *)
   for index := 1 to typebase div nodesize - 1
      do markarray[index] := false;
   markarray[lnil div nodesize] := true;  (* make extra sure lnil is marked *)
   markarray[novalue div nodesize] := true;  (* likewise novalue *)
   (* here goes the mark phase *)
   mark (oblist);                                           (* Mark the OBLIST. *)
   index := soblist;                                        (* Mark the SOBLIST. *)
   while index <> sobtop do
      begin
      mark (index);
      index := index+nodesize
      end;
   mark (unary_sum); mark (unary_difference);           (* Mark UNARY_SUM and _DIFFERENCE. *)
   mark (iline);                                            (* Mark the current input line. *)
   mark (edit_body);                                        (* Mark the EDIT_BODY. *)
   index := vpdlbase+pushinc;
   while index >= vsp do begin				    (* Mark the VPDL. *)
                         get_bigarray (temp,index);
                         mark (temp);
                         index := index+pushinc
                         end;
   frameptr := frame;                                       (* Mark saved bindings in stack *)
   while frameptr <> 0 do                                   (* frame. *)
      begin
      get_bigarray (nargs,frameptr+sf_number_bindings);
      ptr1 := frameptr +sf_bindings;
      while nargs <> 0 do
         begin
         get_bigarray (temp,ptr1);                          (* Get pushed value. *)
         get_bigarray (temp1,ptr1+pushinc);                 (* Mark if not a funframe. *)
         if temp1 mod 2 = 0 then  mark (temp);
         ptr1 := ptr1 + pushinc*2;  (* Go to next value-name pair *)
         nargs := nargs-1
         end;
      get_bigarray (frameptr,frameptr+sf_previous_frame)
      end;

   mark (mark1); mark (mark2); mark (mark3); mark (mark4); mark (mark5);
                                                 (* Mark the mark words *)
   markarea (size1,area1);
   markarea (size2,area2);      
   mark (cell_ptr);
   mark (diff1);

   (* Here is the sweep phase.  Start sweeping at SOBTOP. *)
   if error_flag <> xzap then
      begin
      freelist := lnil;	(* may not be if this is an explict call *)
      for index := 1 to typebase div nodesize - 1 do
        begin
        if not markarray[index] then
           begin
           rplacd (index*nodesize,freelist);
           freelist := index*nodesize
           end
        end;
      if error_flag = xzap then freelist := lnil  (* pdl overflow during the gc *)
      end
   end; (* oGarbage_collect *)

procedure Garbage_collect;
   var caller: integer;
   begin
   caller := current_suboverlay;
   suboverlay (gc_suboverlay);
   oGarbage_collect;
   suboverlay (caller)
   end; (* Garbage_collect *)

(* NUMBER is a Pascal integer, not a LOGO fixnum.
   TYPE_NUMBER outputs the number to the device/file F. *)
procedure type_number; (* var f: chfil; number: integer *)
   var index,digits: integer;
   begin
   if number < 0 then begin number := -number; writech (f,'-') end;
   digits := 0;
   repeat
     push (number mod 10);
     number := number div 10;
     digits := digits + 1
   until number = 0;
   for index := 1 to digits do
      begin
      pop (temp1);
      writech (f,chr(temp1+ord('0')))
      end;
end;

(* THING is any LOGO object.  PRINT outputs it to the VDT, followed by a CRLF. *)
procedure print; (* thing: integer *)
   begin
   ltype (ttyoutput,thing,1);
   breakl (ttyoutput)
   end; (* print *)

(* THING is and LOGO object. LTYPE outputs it to the device/file F.
   If THING is of type list, then if TOPLEVELP is nonzero, outermost brackets will not
   be typed; otherwise they will. *)
procedure ltype; (* var f: chfil thing,toplevelp: integer *)
   const print_thing=2;
         print_list_loop=4;
         p_1=6;
   var pc,newthing,nospace,funny_pname: integer;

   procedure type_atom (thing: integer);
      begin
      thing := thing div nodesize * nodesize;
      Get_pname (thing,funny_pname,thing);
      if outdev <> wfile then funny_pname := 0;
      if funny_pname <> 0 then writech (f,'''');
      while thing <> 0 do
         begin
         car (newthing,thing);
         cdr (thing,thing);
         writech (f,chr(newthing-newthing div 256*256));
         temp1 := newthing div 256;
         if temp1 <> 0 then writech (f,chr (temp1))
         end;
      if funny_pname <> 0 then writech (f,'''')
      end; (* type_atom *)

   procedure type_satom (thing: integer);
      begin
      cdr (thing,thing);
      thing := thing + sa_pname;
      while sarray[thing] <> 0 do
         begin
         writech (f,chr (sarray[thing]));
         thing := thing+1
         end
      end; (* type_satom *)

   begin
   push (0);
   pc := print_thing;
   while pc <> 0 do
      case pc of
         print_thing:
              begin
              get_type (temp1,thing);
              case temp1 of
                 atom:  begin
                        type_atom (thing);
                        pop (pc)
                        end;
                 satom: begin
                        type_satom (thing);
                        pop (pc)
                        end;
                 datom: begin
                        writech (f,':');
                        type_atom (thing);
                        pop (pc)
                        end;
                 qatom: begin
                        writech (f,'"');
                        type_atom (thing);
                        pop (pc)
                        end;
                 latom: begin
                        type_atom (thing);
                        writech (f,':');
                        pop (pc)
                        end;
                 fix:  begin
                       car (thing,thing);
                       type_number (f,thing);
                       pop (pc)
                       end;
                 list: begin
                       nospace := 1;
                       if toplevelp = 0 then writech (f,'[');
                       pc := print_list_loop
                       end;
                 end (* case *)
              end; (* print_thing *)

         print_list_loop: begin
                       push_test; if error_flag = xzap then pc := 0 else
                       if thing = 0 then begin
                                         if toplevelp = 0 then writech (f,']');
                                         pop (pc)
                                         end
                          else begin
                               if nospace <> 0 then nospace := 0
                                  else writech (f,' ');
                               push (thing);
                               push (toplevelp);
                               car (thing,thing);
                               toplevelp := 0;
                               push (p_1);
                               pc := print_thing (* recurse on printing car of list *)
                               end
               end; (* print_list_loop *)
         p_1: begin
                               pop_test;
                               pop (toplevelp);
                               pop (thing);
                               cdr (thing,thing);
                               pc := print_list_loop
              end; (* p_1 *)
         end; (* case *)
   brk (f) (* pdp10 pascal only *)
   end; (* type *)

(* EVALUATOR *)
 
(* General evaluator utilities *)

(* Simulates a jump to the case label provided as input *)
procedure jump (*addr: integer*);
   begin
   pc := addr
   end; (* jump *)

(* Pops a case label from the pdl and simulates a jump to it. *)
procedure popj;
   begin
   pop (pc)
   end; (* popj *)

(* **WARNING**: In the remaining procedures on this page, global variable UFORMAT says whether
   input variable LINE is a list, or a pointer into an FPACK structure; and whether input
   variable BODY is a list, or a pointer into an FPACK structure.  UFORMAT holds the format
   (LIST or FPACK) of the currently-being-executed user function.  So the remaining functions
   on this page are only intended to be used for the currently-being-executed function! *)

(* TOKEN gets the first token from LINE.
   ** SEE ABOVE WARNING! *)
procedure get_token (*var token: integer; line: integer *);
   begin
   case uformat of
     list: car (token,line);
     fpack: get_bigarray (token,line);
     otherwise system_bug
     end
  end; (* get_token *)

(* LINE gets replaced by the CDR of LINE.
   If CFLUSH, then LINE is set to LNIL if the first token is a ;.
   ** SEE ABOVE WARNING! *)
procedure tokn_advance (*var line : integer; cflush: boolean*);
   var temp: integer;
   begin
   case uformat of
      list: cdr (line,line);
      fpack: begin
             line := line + wordsize;
             if line = uline_end then line := lnil
             end;
      otherwise system_bug
      end;
   get_token (temp,line);
   if cflush then if temp = comment then line := lnil
   end; (* tokn_advance *)

(* LINE gets a pointer to the first line in BODY.
   If CFLUSH, then LINE is set to LNIL if the first token is a ;.
   ** SEE ABOVE WARNING! *)
procedure get_uline (*var line: integer; body: integer; cflush: boolean*);
   var temp: integer;
   begin
   case uformat of
      list: car (line,body);
      fpack: begin
             get_bigarray (line,body);
             get_bigarray (uline_end,body+wordsize);
             if line = uline_end then line := lnil
             end;
      otherwise system_bug
      end;
   if cflush then
    if line <> lnil then
      begin
      get_token (temp,line);
      if temp = comment then line := lnil
      end
   end; (* get_uline *)

(* BODY becomes the CDR of BODY.
   ** SEE ABOVE WARNING! *)
procedure ulin_advance (*var body: integer*);
   var temp: integer;
   begin
   case uformat of
      list: cdr (body,body);
      fpack: begin
             get_bigarray (temp,body + nodesize);  (* Look at the entry *after* the one *)
             if temp = lnil then body := lnil      (* we want, to see if it's the fence. *)
                else body := body + wordsize  (* If not, inc BODY. *)
             end;
      otherwise system_bug
      end
   end; (* ulin_advance *)

(* Returns NEXT = 0 iff BODY points to the last line.
   ** SEE ABOVE WARNING! *)
procedure line_peek (var next: integer; body: integer);
   begin
   case uformat of
      list: cdr (next,body);
      fpack: get_bigarray (next,body+nodesize);
      otherwise system_bug
      end
   end;

(* ERRNUM says which error condition has arisen.
   ERRPRINT and EP1 are used by some of the error messages.

   ERROR prints the appropriate error message, sets ERROR_FLAG, resets INDEV to VDT,
   and pseudo-jumps to ERROR_1. *)
procedure oerror (errnum,errprint,ep1: integer);
   var temp: integer;
   begin
   error_flag := errnum;
   indev := vdt;   (* Don't want to keep reading from a file if after an error. *)

   case error_flag of      (* print error message *)
      xuop: begin write (ttyoutput,'You don''t say what to do with '); ltype (ttyoutput,errprint,0) end;
      xeol: begin write (ttyoutput,'Unexpected end of line') end;
      xudf: begin write (ttyoutput,'You haven''t told me how to '); ltype (ttyoutput,errprint,0) end;
      xhnv: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' has no value') end;
      xtmo: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' output too many things') end;
      xnop: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' didn''t output') end;
      xrpn: begin write (ttyoutput,'Unexpected  )') end;
      xifx: begin write (ttyoutput,'There''s nothing before the '); ltype (ttyoutput,errprint,0) end;
      xvna: begin write (ttyoutput,'You need ( )s around '); ltype (ttyoutput,errprint,0) end;
      xtip: begin write (ttyoutput,'You don''t say what to do with '); ltype (ttyoutput,errprint,0) end;
      xwta: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' doesn''t like '); ltype (ttyoutput,ep1,0); write (ttyoutput,' as an input') end;
      xubl: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' is used by LOGO') end;
      xntl: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' should only be called inside a procedure')
                  end;
      xntf: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' was returned instead of TRUE or FALSE')
                  end;
      xels: begin write (ttyoutput,'ELSE  is out of place') end;
      xbrk: begin write (ttyoutput,'I was told to pause') end;
      xlabel: begin write (ttyoutput,'There''s a label in the middle of a line') end;
      xthn: begin write (ttyoutput,'THEN  is out of place') end;
      xzap: begin zap_message end;
      xlnf: begin write (ttyoutput,'I can''t find the label '); ltype (ttyoutput,errprint,0) end;
      xedt: begin write (ttyoutput,'You''re already editing '); ltype (ttyoutput,errprint,0) end;
      xdef: begin ltype (ttyoutput,errprint,0); write (ttyoutput,' is already defined') end;
      xetl: begin write (ttyoutput,'You can only edit at top level') end;
      xned: begin write (ttyoutput,'You''re not in edit mode') end;
      xopo: begin write (ttyoutput,'You can only say '); ltype (ttyoutput,errprint,0); write (ttyoutput,
                  ' to PO, etc.') end;
      xargtb: begin
              type_number (ttyoutput,ep1); write (ttyoutput,' is too big for ');
              ltype (ttyoutput,errprint,0)
              end;
      xtml: begin write (ttyoutput, 'Too many display commands') end;
      xtms: begin write (ttyoutput, 'Too much snapped') end;
      xdbz: begin write (ttyoutput, 'You tried to divide by zero') end;
      xnwe: begin write (ttyoutput, 'You can''t do that while in edit mode') end;
      end;
   if level_number <> 0
      then begin
           breakl (ttyoutput);
           write (ttyoutput,' at level '); type_number (ttyoutput,level_number);
           write (ttyoutput,' line '); type_number (ttyoutput,line_number);
           write (ttyoutput,' of '); get_bigarray(temp,frame+sf_ufun); ltype (ttyoutput,temp,0)
           end;
   breakl (ttyoutput);
   pc := error_1
   end; (* oerror *)

procedure error (*errnum,errprint,ep1: integer*);
   var caller: integer;
   begin
   caller := current_overlay;
   overlay (error_overlay);
   oerror (errnum,errprint,ep1);
   overlay (caller)
   end; (* error *)

(* Pop the current stack frame: restore bindings and saved evaluator variable values.
   Frame is actually popped from the pdl, so the SP is adjusted accordingly. *)
procedure pop_frame;
   begin
   restore_bindings;
   pop (tail_levels);
   sp := sp+popinc;   (* SF_NUMBER_BINDINGS *)
   pop (token_pointer);
   pop (line_number);
   pop (nest);
   pop (current_token);
   pop (uformat);
   pop (xframe);
   pop (frame)
   end; (* pop_frame *)

(* Restores old bindings and funframe associated with the current stack frame.
   Actually pops them off the stack. *)
procedure restore_bindings;
   var var_name,value,nargs: integer;
   begin
   sp := xframe+popinc; (* Pop past return addr. *)
   get_bigarray (nargs,frame+sf_number_bindings);
   while nargs <> 0 do
      begin
      pop (var_name);
      pop (value);
      put_value (var_name,value);
      nargs := nargs-1
      end
   end; (* restore_bindings *)

(* Adjust the SP to point to the end of the current stack frame (ie the topmost part on
   the stack), implicitly popping anything on the pdl above that frame. *)
procedure reset_eval;
   begin
   sp := xframe
   end; (* reset_eval *)

(* Pop stack frames until FRAME = FR. *)
procedure lescape (*fr: integer*);
   var fr,temp: integer;
   begin
   if fr < sp then system_bug;
   while fr <> frame do
      begin
      if frame = 0 then system_bug;
      restore_bindings;
      get_bigarray (xframe,frame+sf_xframe);
      get_bigarray (frame,frame+sf_previous_frame);
      end;
   pc := eval_return
   end; (* lescape *)

(* Pop pdl all the way back to top level. Everything in between is ignored EXCEPT for
   the variable bindings in the stack frame; these are restored. *)
procedure pop_to_top;
   begin
   while frame <> 0 do
      begin
      restore_bindings;
      get_bigarray (xframe,frame+sf_xframe);
      get_bigarray (frame,frame+sf_previous_frame)
      end;
   level_number := 0;
   pc := 0
   end;

(* Advance TOKEN_POINTER past next token or parenthesized expression. *)
procedure skip_past_thing;
   var paren_counter,token: integer;
   begin
   if token_pointer <> lnil then
      begin
      get_token (token,token_pointer);
      tokn_advance (token_pointer,true);
      if token = lpar
         then begin
              paren_counter := 1;
              while (paren_counter > 0) and (token_pointer <> lnil) do
                 begin
                 get_token (token,token_pointer);
                 tokn_advance (token_pointer,true);
                 if token = lpar then paren_counter := paren_counter + 1
                    else if token = rpar then paren_counter := paren_counter -1
                 end
              end
      end
   end; (* skip_past_thing *)


(* EXIT_IF_SCOPE advances TOKEN_POINTER to the next unmatched RPAR or ELSE, or end of line,
   returning the unmatched token if not end of line *)
procedure exit_if_scope (*var ans: integer*);
   var if_counter: integer;
   begin
   if_counter := if_level;
   while (if_counter >= if_level) and (token_pointer <> 0) do
      begin
      get_token (ans,token_pointer);
      if ans = lif
         then begin
              if_counter := if_counter+1;
              tokn_advance (token_pointer,true)
              end
         else if ans = lelse
                 then begin
                      if_counter := if_counter-1;
                      if if_counter >= if_level then tokn_advance (token_pointer,true)
                      end
                 else if ans = rpar
                         then if_counter := if_level -1  (* Just to end the loop *)
                              else skip_past_thing
      end;            (* token. *)
   if_level := if_level-1
   end; (* exit_if_scope *)

(* System function utilities *)

(* POPJ from an sfunction, first CONSing up and eval-returning a fixnum of value N. *)
procedure Outp_fixnum (n: integer);
   var value: integer;
   begin
   Cons (value,n,0,fix);
   if error_flag <> xzap then
      begin
      vpush (value);
      outputn := 1;
      popj
      end
   end; (* Outp_fixnum *)

(* The ufun FUN is given to ATOMM. *)
procedure put_function (atomm,fun: integer);
   var typ: integer;
   begin
   get_type (typ,atomm);
   case typ of
      satom: error (xubl,atomm,0);
      atom:  begin
             cdr (atomm,atomm);
             rplaca (atomm,fun)
             end;
      otherwise system_bug
            end
   end; (* put_function *)

(* The atom ATOMM gets new function body FUNTEXT and nargs value NARGS. *)
procedure Put_ftext (atomm,funtext,nargs: integer);
   var typec,funct,cell: integer;
   begin
   get_type (typec,atomm);
   case typec of
      satom: error (xubl,atomm,0);
      atom:  begin
             cdr (cell,atomm);
             car (funct,cell);
             if funct = novalue then
                begin
                mark1 := funtext;
                Get_words (funct,4);
                if error_flag <> xzap then
                   begin
                   rplaca (cell,funct);
                   put_type (funct,ufun);
                   mark1 := lnil;
                   put_bigarray (funct+wordsize*3,atomm)  (* Back pointer *)
                   end
                end;
             if error_flag <> xzap then
                begin
                put_bigarray (funct,0);                   (* Frame *)
                put_bigarray (funct+wordsize,funtext);    (* Fbody *)
                put_bigarray (funct+wordsize*2,nargs)     (* Nargs *)
                end
             end;
      otherwise system_bug
      end
   end; (* Put_ftext *)

(* Atom (NOT satom!) ATOMM becomes an undefined function. *)
procedure unfunction (atomm: integer);
   begin
   cdr (atomm,atomm);
   rplaca (atomm,novalue)
   end; (* unfunction *)

(* ANS gets the number of toplevel elements of list LIST.
   GET_LENGTH stops counting if a ; is encountered. *)
procedure get_length (var ans: integer; list: integer);
   var temp: integer;
       cflush: boolean;
   begin
   ans := 0;
   cflush := false;
   while (list <> 0) and not cflush do
      begin
      car (temp,list);
      cdr (list,list);
      if temp = comment then cflush := true else ans := ans +1
      end
   end; (* get_length *)

(* arithmetic utility routines *)

(* Converts atom ARG to a fixnum *value* if possible (returned in ARG).
   FLAG gets 1 if conversion worked, 0 otherwise. *)
procedure oatom_to_fixnum (var arg,flag: integer);
   var number,pname,sign,ch,pair: integer;
       sofar: boolean;
   procedure gobble_digit (digit: integer);
      begin
      if (digit < ord ('0') ) or (digit > ord ('9')) then sofar := false else
         number := number*10 + digit - ord ('0')
      end;
   begin
   flag := 1;
   Get_pname (pname,temp1,arg);
   if pname = lnil then flag := 0 else
      begin
      sofar := true;
      number := 0;
      car (pair,pname);
      ch := pair mod 256;
      if ch = ord ('-') then sign := -1 else
         begin
         sign := 1;
         gobble_digit (ch);
         end;
      while (pname <> lnil) and (sofar = true) do
         begin
         cdr (pname,pname);
         ch := pair div 256;
         if ch <> 0 then
            begin
            gobble_digit (ch);
            if sofar = true then
               if pname <> lnil then
                  begin
                  car (pair,pname);
                  ch := pair mod 256;
                  gobble_digit (ch)
                  end
            end
         end
      end;
      number := number * sign;
      if sofar = false then flag := 0 else
         arg := number
   end; (* atom_to_fixnum *)

procedure atom_to_fixnum (var arg,flag: integer);
   begin
   suboverlay (word_suboverlay);
   oatom_to_fixnum (arg,flag)
   end; (* atom_to_fixnum *)

(* ARG is converted from an atom or fixnum, to a fixnum *value*, if possible (returned in ARG).
   FLAG = 1 indicates conversion successful, FLAG = 0 otherwise. *)
procedure get_fixnum (var arg,flag: integer);
   var typ: integer;
   begin
   get_type (typ,arg);
   case typ of
      atom: atom_to_fixnum (arg,flag);
      fix:  begin
            car (arg,arg);
            flag := 1
            end;
      otherwise flag := 0
      end
   end; (* get_fixnum *)

(* VPOPS two eval-arguments and, if possible, converts them to fixnum *values* (*not* the
   logo-object fixnums themselves) which get returned in ARG1 and ARG2.
   If not possible, ERROR XWTA occurs. *)
procedure get_2_fixnum_args;
   var typ1,typ2,flag: integer;
   begin
   vpop (arg2);
   vpop (arg1);
   get_fixnum (arg1,flag);
   if flag = 0 then error (xwta,current_token,arg1) else
      begin
      get_fixnum (arg2,flag);
      if flag = 0 then error (xwta,current_token,arg2)
      end
   end; (* get_fixnum_args *)

(* VPOPS an eval-argument and, if possible, converts it to a fixnum *value* (*not* the
   logo-object fixnum itself) which gets returned in ARG1. *)
procedure get_1_fixnum_arg;
   var typ1,flag: integer;
   begin
   vpop (arg1);
   get_fixnum (arg1,flag);
   if flag = 0 then error (xwta,current_token,arg1)
   end; (* get_1_fixnum_arg *)

(* Procedure definintion utility routines *)

(* Enter edit mode, setting up the appropriate variables. *)
procedure edit_setup;
   var name,typ,temp: integer;
   begin
   outputn := 0;
   if edit_switch <> 0 then error (xedt,edit_atom,0)
    else if level_number <> 0 then error (xetl,0,0)
     else if token_pointer = lnil then error (xeol,0,0)
      else begin
           get_token (arg1,token_pointer);  (* Function name. *)
           tokn_advance (token_pointer,false);
           get_type (typ,arg1);
           if typ = satom then error (xubl,arg1,0)
              else if typ <> atom then error (xwta,current_token,arg1)
                      else begin
                           edit_switch := 1;
                           edit_atom := arg1;
                           po_default := arg1
                           end
           end
   end; (* edit_setup *)

(* Exit edit mode. *)
procedure exit_edit;
   begin
   edit_switch := 0;
   edit_body := lnil;
   edit_atom := lnil;
   outputn := 0
   end; (* exit_edit *)

(* BODY is a function body of format LIST.
   STUFF attempts to convert BODY to the FPACK format and assign the converted form
   to FUNATOM.  If the conversion fails, the LIST form is assigned to FUNATOM. *)
procedure Stuff (body,funatom: integer);
   var token,line,index,index1,ptr,number,size,topnum,nargs,arglist: integer;
   procedure get_size (var size: integer; body: integer);
      var line: integer;
      begin
      size := 0;
      while body <> lnil do
         begin
         car (line,body);
         cdr (body,body);
         while line <> lnil do
            begin
            size := size+1;
            cdr (line,line)
            end
         end
      end; (* get_size *)

   begin (* Stuff *)
   car (line,body);
   get_length (nargs,line);

   get_size (size,body);  (* How many top-level tokens in BODY's lines? *)
   Get_words (ptr,size);
   if ptr = lnil then Put_ftext (funatom,body,nargs)
      else begin
           area1 := ptr; size1 := size;  (* Gc-protect the block of words. *)
           get_length (size,body);  (* How many top-level tokens in BODY, ie how many lines? *)
           Get_words (index,size+2);(* Extra word for last eoln, 2nd extra for fence. *)
           if index = lnil then begin
                                size1 := 0; (* Unprotect. *)
                                Put_ftext (funatom,body,nargs)
                                end
             else
              begin
              area2 := index; size2 := size+2;
              index1 := index;
              while body <> lnil do
                 begin
                 put_bigarray (index1,ptr);
                 index1 := index1 + wordsize;
                 while line <> lnil do
                    begin
                    car (token,line);
                    cdr (line,line);
                    put_bigarray (ptr,token);
                    ptr := ptr + wordsize
                    end;
                 cdr (body,body);
                 car (line,body)
                 end;
              put_bigarray (index1,ptr);  (* Eoln ptr for last line. *)
              put_bigarray (index1+wordsize,lnil);   (* Fence. *)

              put_type (index,fpack);
              Put_ftext (funatom,index,nargs);
              size1 := 0; size2 := 0     (* We no longer need special protection. *)
              end
           end
   end; (* Stuff *)

(* LISTT is the USER-funtext of a function, ie a list of the form:
   [ [arg1 arg2 ...]     [line1][line2]...].

   DEFUN converts LISTT to ufun-body format (FPACK if possible, else list format) and assigns
   the ufun body to atom ATOMM. *)
procedure Defun (atomm,listt: integer);
   var ptr,number,tlist,t1,temp: integer;
   begin
   if listt = lnil then unfunction (atomm) else
      begin   
      vpush (listt); (* gc-protect *)
      number := 0;
      ptr := vsp;
      car (temp,listt);
      vpush (temp);
      cdr (tlist,listt);
      while (tlist <> lnil) and (error_flag = 0) do
         begin
         car (t1,tlist);
         get_type (temp,t1);
         if temp <> list then error (xwta,current_token,listt) else
           begin
           Cons (t1,number,t1,flist);
           if error_flag <> xzap then
              begin
              vpush (t1);
              cdr (tlist,tlist);
              number := number+10
              end
           end
         end;
      if error_flag = 0 then
         begin
         listt := lnil;
         while (ptr <> vsp) and (error_flag = 0) do
            begin
            vpop (t1);
            Cons (listt,t1,listt,list)
            end;
         Stuff (listt,atomm)
         end
      end
   end; (* Defun *)

(* UNSTUFF assembles the body of ufun FUN into a list BODY.
   BODY is a list of flists.  The first is a list of the ufun's variable names.
   The remaining lists are (in proper order) the procedure's lines. Each has a line
   number (or lnil) as its car, and the actual token string as its cdr.
   The line number is immediate, not a pointer of type FIX. *)
procedure Unstuff (var body: integer; fun: integer; textp: boolean);
   var typ,index,ptr,endptr,token,stack: integer;
   begin
   cdr (index,fun);
   get_type (typ,index);
   case typ of
    list: body := index;
    fpack:
      begin
      get_bigarray (ptr,index);
      get_bigarray (endptr,index+wordsize);
      mark1 := lnil;
      stack := sp;
      while (endptr <> 0) and (error_flag <> xzap) do
         begin
         push_test;
	 if error_flag <> xzap then
         begin
            push (ptr);
            index := index + wordsize;
            get_bigarray (ptr,index);
            get_bigarray (endptr,index+wordsize)
            end
         end;
      endptr := ptr;
      while (stack <> sp) and (error_flag <> xzap) do
         begin
         pop_test;
         pop (ptr);
         mark2 := lnil;
         while (endptr <> ptr) and (error_flag <> xzap) do  (* Cons up a line. *)
            begin
            endptr := endptr - wordsize;
            get_bigarray (token,endptr);
            Cons (mark2,token,mark2,list);
            end;
         if error_flag <> xzap then
            begin
            if stack = sp then put_type (mark2,list) else(* First line, arglist, has no line *)
               begin                                     (* number. *)
               put_type (mark2,flist);
               if textp then cdr (mark2,mark2)
               end;
            Cons (mark1,mark2,mark1,list);
            end;
         endptr := ptr
         end;
      body := mark1;
      mark1 := lnil;
      mark2 := lnil
      end;
    otherwise system_bug
    end;
   end; (* Unstuff *)

(* System Functions

System Function Conventions.  (Note: with regard to LOGO functions/procedures, we use the
                               word "function" to describe user/system commands whether or
                               not they output anything.)

   Each sfun must have an associated Pascal procedure of the name S_FOO (where FOO is the
LOGO name of the sfun).  In addition, each sfun must be properly declared. This includes the
following:
   * The function index SI_FOO must be defined with all the other function indexes.
   * A SOBSET call must be made in INIT, establishing the pname, nargs, and precedence
     of the function in SARRAY.  CAUTION: be sure that the bounds of SARRAY are not
     exceeded due to a new SOBSET call. If this happens, change SARRAY_MAX to a
     suitably higher value.
   * The dispatch table in SFUNCALL (procedure X_SF1 or X_SF2) must include the line
        SI_FOO: S_FOO;

   Each sfun is implemented as a Pascal procedure of 0 arguments.

   An sfun is invoked from the evaluator via a case statement, at SFUNCALL:.

   When an sfun is invoked, its evaluated arguments are already pushed on the
VPDL, last argument at the top.  If the function takes a fixed number of
arguments, the correct number of arguments are guaranteed to be there.  If it
takes a variable number of arguments, but was called in the unparenthesized (default
number of args) form, then NARGS is that number; else (parenthesized) NARGS is -n-1, where
n is the number of arguments with which the function was called.

   The procedure VPOP(FOO) will pop a word from the vpdl into FOO.  By convention,
sfun arguments should be popped into the Pascal variables ARG1, ARG2, etc.

   An sfun which outputs should leave its output on the VPDL.  VPUSH(FOO) pushes
FOO onto the VPDL.  All sfuns should set OUTPUTN to 1 or 0 to signify output or
no output (in case of error return, OUTPUTN need not be set).

   A typical return for an sfun consists of a POPJ, or, in case of a user error,
an ERROR.  Atypically, the sfun may end with a JUMP to an evaluator clause; this
should only be necessary if the sfun needs to recursively invoke EVAL.

   An sfun should never be recursive in PASCAL, nor should any routine which it calls.
Rather, recursion should be faked with an EVALUATE-like case hack (eg see LTYPE).

   An sfun which calls CONS should check for ERROR_FLAG = XZAP.  See CONS.

   An sfun which (V)PUSHes/(V)POPs more than five things should do a (V)PUSH/(V)POP TEST
for each five things (V)PUSH/POPped.

   No sfun should be dependent on the internal format of a
LOGO data type.  Rather, utility routines should be used for
format-dependent operations.

*)

                              (* arithmetic funcitons *)
procedure s_sum;
   begin
   get_2_fixnum_args;
   if error_flag = 0 then Outp_fixnum (arg1+arg2)
   end; (* s_sum *)

procedure s_difference;
   begin
   get_2_fixnum_args;
   if error_flag = 0 then Outp_fixnum (arg1-arg2)
   end; (* s_difference *)

procedure s_product;
   begin
   get_2_fixnum_args;
   if error_flag = 0 then Outp_fixnum (arg1*arg2)
   end; (* s_product *)

procedure s_quotient;
   begin
   get_2_fixnum_args;
   if error_flag = 0 then
      if arg2 = 0 then error (xdbz,0,0) else
         Outp_fixnum (arg1 div arg2)
   end; (* s_quotient *)

procedure s_greater;
   begin
   get_2_fixnum_args;
   if error_flag = 0 then
      begin
      if arg1 > arg2 then vpush (ltrue) else vpush (lfalse);
      outputn := 1;
      popj
      end
   end; (* s_greater *)

procedure s_less;
   begin
   get_2_fixnum_args;
   if error_flag = 0 then
      begin
      if arg1 < arg2 then vpush (ltrue) else vpush (lfalse);
      outputn := 1;
      popj
      end
   end; (* s_less *)

procedure s_un_sum;
   begin
   current_token := sum; (* For possible error msg in GET_1_FIXNUM_ARG. *)
   get_1_fixnum_arg;
   if error_flag = 0 then Outp_fixnum (arg1)
   end; (* s_un_sum *)

procedure s_un_difference;
   begin
   current_token := difference;
   get_1_fixnum_arg;
   if error_flag = 0 then Outp_fixnum (- arg1)
   end; (* s_un_difference *)

                               (* Boolean functions: return TRUE or FALSE *)
procedure s_not;
   begin
   vpop (arg1);
   if arg1 = ltrue then begin outputn := 1; vpush (lfalse); popj end
      else if arg1 = lfalse then begin outputn := 1; vpush (ltrue); popj end
              else error (xntf,arg1,0)
   end; (* s_not *)

procedure and_or (lt,lf: integer);
   begin
   vpop (arg2);
   vpop (arg1);
   if arg1 = lt
      then if arg2 = lt
              then begin outputn := 1; vpush (lt); popj end
              else if arg2 = lf
                      then begin outputn := 1; vpush (lf); popj end
                           else error (xntf,arg2,0)
      else if arg1 = lf
              then if (arg2 = ltrue) or (arg2 = lfalse)
                      then begin outputn := 1; vpush (lf); popj end
                      else error (xntf,arg2,0)
              else error (xntf,arg1,0)
   end; (* and_or *)

procedure s_both;
   begin
   and_or (ltrue,lfalse)
   end; (* s_both *)

procedure s_either;
   begin
   and_or (lfalse,ltrue)
   end; (* s_either *)

procedure s_equal;
   const eq=2;
         eq_list=4;
         e_l_1=6;
   var typ1,pred,flag: integer;

   begin
   pred := ltrue;
   vpop (arg2);
   vpop (arg1);
   outputn := 1;

   push (0);
   pc := eq;

   while pc <> 0 do
      case pc of
         eq:   begin
               get_type (typ1,arg1);
               get_type (temp1,arg2);
               case typ1 of
                  fix:   begin
                         car (arg1,arg1);
                         get_fixnum (arg2,flag);
                         if (flag = 0) or (arg1 <> arg2) then pred := lfalse;
                         pop (pc)
                         end;
                  list:  if temp1 <> list then begin
                                               pred := lfalse;
                                               pop (pc)
                                               end
                           else pc := eq_list;
                  atom:  begin
                         if temp1 = fix then
                            begin
                            car (arg2,arg2);
                            get_fixnum (arg1,flag);
                            if (flag = 0) or (arg1 <> arg2) then pred := lfalse
                            end
                           else if (typ1 <> temp1) or (arg1 <> arg2) then
                              pred := lfalse;
                          pop (pc)
                          end;
                  otherwise begin
                          if (typ1 <> temp1) or (arg1 <> arg2) then pred := lfalse;
                          pop (pc)
                          end;
                  end    
               end;
         eq_list: if arg1 = 0
                     then begin
                          if arg2 <> 0 then pred := lfalse;
                          pop (pc)
                          end
                     else if arg2 = 0 then begin pred := lfalse; pop (pc) end
                             else begin
                                  push (arg1); push (arg2);
                                  car (arg1,arg1);
                                  car (arg2,arg2);
                                  push_test;
                                  if error_flag = xzap then pc := 0
                                     else begin push (e_l_1); pc := eq end
                                  end;
         e_l_1:                   begin
                                  pop_test;
                                  if pred = lfalse then begin sp := sp+popinc*2; pop (pc) end
                                     else begin
                                          pop (arg2); pop (arg1);
                                          cdr (arg1,arg1);
                                          get_type (temp1,arg1);
                                          if temp1 <> list then system_bug;
                                          cdr (arg2,arg2);
                                          get_type (temp1,arg2);
                                          if temp1 <> list then system_bug;
                                          pc := eq_list
                                          end
                                  end;
         end;
   vpush (pred);
   popj
end; (* s_equal *)

(* List manipulation functions *)

procedure outp_arg1;	(* commonly-used exit sequence *)
   begin
	vpush (arg1);
	outputn := 1;
	popj
   end;

function  mod256 (x: integer): integer;	(* gets first letter of a two-letter number *)
   begin
	mod256 := x mod 256
   end;

procedure get_last_cell (var ptr: integer);	(* cdr's through a list, giving back *)
   var  ptr_cdr: integer;			(* a pointer to the last cell *)
   begin
	cdr (ptr_cdr,ptr);
	while ptr_cdr <> 0 do begin
		ptr := ptr_cdr;
		cdr (ptr_cdr,ptr)
		end
   end;

procedure oMake_pname (var ans: integer; arg: integer);
   var typ: integer;
   procedure Fixname;
      var sign,digits,cell: integer;
      begin
      car (arg,arg); (* Get fixnum value. *)
      if arg = 0 then Cons (ans,ord ('0'),lnil,string) else
         begin
         if arg > 0 then sign := 1 else
            begin
            sign := -1;
            arg := -arg
            end;
         vpush (lnil); (* Forming string is vpushed to gc-protect it. *)
           cell := arg;  (* If number of digits is odd, last pname cell will have
   				a 0 (fence). *)
         if sign = 1 then digits := 0 else digits := 1;
         repeat
            digits := digits +1;
            cell := cell div 10
            until cell = 0;
         if digits mod 2 = 0 then
            begin
            cell := (ord ('0') + arg mod 10) * 256;
            arg := arg div 10
            end;
         repeat
            if arg = 0 then
               begin
               if sign < 0 then cell := cell + ord ('-')
                  else system_bug;
               get_bigarray (ans,vsp);
               Cons (ans,cell,ans,string);
               put_bigarray (vsp,ans)
               end
              else begin
                   cell := cell + ord ('0') + (arg mod 10);
                   arg := arg div 10;
                   get_bigarray (ans,vsp);
                   Cons (ans,cell,ans,string);
                   put_bigarray (vsp,ans);
                   if error_flag = 0 then
                      if arg = 0 then if sign < 0 then system_bug
                   end;
            cell := 256 * (ord ('0') + arg mod 10);
            arg := arg div 10
            until (arg = 0) or (error_flag <> 0);
         vpop (ans)
         end
      end;
   begin
   get_type (typ,arg);
   case typ of
      atom,satom: Get_pname (ans,temp1,arg);
      fix: Fixname;
      otherwise error (xwta,current_token,arg)
      end
   end; (* Make_pname *)

procedure Make_pname (var ans: integer; arg: integer);
   begin
   suboverlay (word_suboverlay);
   oMake_pname (ans,arg)
   end;

procedure s_butfirst;
   var typ1,old_ptr,old_car,c2,temp,new_ptr: integer;
       beg_of_pname: boolean;
   begin
   vpop (arg1);
   get_type (typ1,arg1);
   case typ1 of
      list: begin
            cdr (arg1,arg1);
            outp_arg1
            end;
      satom,atom,fix:
            begin
            Make_pname (old_ptr,arg1); (* get pname *)
            if error_flag = 0 then
               begin
               vpush (old_ptr); (* Gc-protect. *)
               car (old_car,old_ptr); (* get first two letters *)
                                   (* if the word is empty, it's an error *)
               if old_car = 0 then error (xwta,current_token,arg1) else
                  begin
                  beg_of_pname := true;
                  repeat
                     c2 := old_car div 256;
                     if c2 <> 0 then	(* if this cell has a 2nd *)
                        begin
                        Cons (temp,c2,0,string);	(* letter, make another   *)
                        if error_flag <> xzap then
                           begin
                           if beg_of_pname then
                              begin
                              vpush (temp);  (* For gc-protection of the forming pname. *)
                              beg_of_pname := false
                              end
                             else rplacd (new_ptr,temp);
                           new_ptr := temp
                           end
                        end;
                     cdr (old_ptr,old_ptr);
                     if error_flag = xzap then old_ptr := 0;
                     if old_ptr <> 0 then
                        begin
                        car (old_car,old_ptr);
                        rplaca (new_ptr,c2 + 256 * mod256 (old_car))
                        end
                     until old_ptr = 0;
                  if error_flag = 0 then
                     if beg_of_pname then arg1 := lnil
                        else vpop (arg1);
                  if error_flag = 0 then Intern (arg1,arg1);
                  if error_flag = 0 then outp_arg1
                  end;
               vpop (old_ptr); (* Un-gc-protect. *)
               end
            end;
      otherwise error (xwta,current_token,arg1)
      end
   end; (* s_butfirst *)

procedure s_first;
   var typ1,temp: integer;
   begin
   vpop (arg1);
   get_type (typ1,arg1);
   case typ1 of
      list: begin
            car (arg1,arg1);
            outp_arg1
            end;
      satom,atom,fix:
            begin
            if arg1 = 0 then error (xwta,current_token,arg1) else  (* can't take f of nil *)
               begin
               Make_pname (temp,arg1);	(* get first cell of pname *)
               if error_flag = 0 then
                  begin
                  car (temp,temp);
                  Cons (temp,mod256 (temp),0,fix); (* make cell with first char *)
                  if error_flag = 0 then
                     begin
                     Intern (arg1,temp);
                     if error_flag = 0 then outp_arg1
                     end
                  end
               end
            end;
      otherwise	error (xwta,current_token,arg1)
      end
   end; (* s_first *)

procedure s_butlast;
   var	typ1,temp_car,temp_cdr,temp,new_ptr: integer;
	new_list: boolean;
   begin
   vpop (arg1);
   get_type (typ1,arg1);
   case typ1 of
      list: if arg1 = lnil then error (xwta,current_token,arg1);
      atom,satom,fix: begin
                      Make_pname (temp,arg1);
                      typ1 := atom;
                      car (temp_car,temp);
                      if temp_car = 0 then error (xwta,current_token,arg1)
                         else arg1 := temp
                      end;
      otherwise error (xwta,current_token,arg1)
      end;
   (* At this point, ARG1 holds a list or pname, depending on whether the argument was
      a list or atom respectively. *)
   if error_flag = 0 then
      begin
      new_list := true;       (* If NEW_LIST is true, there's no pending partial answer. *)
      vpush (arg1); (* Gc-protect *)
      cdr (temp_cdr,arg1);    (* TEMP_CDR stays 1 cdr ahead of ARG1. *)
      while temp_cdr <> 0 do  (* Each time around, a new cell is stuck on the end of the *)
         begin                (* pending list or pname to be returned. Stop before copying *)
         car (temp_car,arg1); (* last cell of input list/pname. *)
         Cons (temp,temp_car,0,list);
         if error_flag <> xzap then
            begin
            if typ1 = atom then put_type (temp,string);
            if new_list then
               begin
               vpush (temp);(* For gc-protection. Note that as new cells get RPLACD'ed into *)
               new_list := false (* the end of the list/string, they'll be protected too. *)
               end
              else rplacd (new_ptr,temp);
            new_ptr := temp;
            cdr (arg1,arg1);
            cdr (temp_cdr,arg1);
            end;
         if error_flag = xzap then temp_cdr := 0
         end;
      if error_flag = 0 then
         if typ1 = list then begin
                             if new_list then arg1 := lnil
                                else vpop (arg1);
                             vpop (temp_car); (* Flush gc-protected ptr. *)
                             outp_arg1
                             end
           else
            begin   (* If the argument was an atom, have to hack the last character. *)
            car (temp_car,arg1);
            if temp_car > 256 then
               begin
               Cons (temp,mod256 (temp_car),0,string);
               if new_list then vpush (temp)
                  else rplacd (new_ptr,temp)
               end
              else if new_list then vpush (lnil);
            vpop (arg1);
            vpop (temp_car); (* Flush gc-protected ptr *)
            Intern (arg1,arg1);
            if error_flag = 0 then outp_arg1
            end
      end
   end; (* s_butlast *)

procedure s_last;
   var typ1,temp_cdr,temp_car: integer;
   begin
   vpop (arg1);
   get_type (typ1,arg1);
   case typ1 of
      list: begin
            get_last_cell (arg1);
            car (arg1,arg1);
            outp_arg1
            end;
      atom,satom,fix:
            begin
            Make_pname (arg1,arg1);
            if error_flag <> xzap then
               begin
               get_last_cell (arg1);
               car (temp_car,arg1);
               if temp_car > 256 then Cons (arg1,temp_car div 256,lnil,string);
               if error_flag = 0 then
                  begin
                  Intern (arg1,arg1);
                  if error_flag = 0 then outp_arg1
                  end
               end
            end;
      otherwise error (xwta,current_token,arg1)
      end
   end; (* s_last *)

procedure s_fput;
   var typ2: integer;
   begin
   vpop (arg2);
   vpop (arg1);
   get_type (typ2,arg2);
   if typ2 <> list then error (xwta,current_token,arg2)
      else begin
           Cons (arg1,arg1,arg2,list);
           if error_flag <> xzap then outp_arg1
           end
   end; (* s_fput *)

procedure s_lput;
   var typ,t1,t2: integer;
   begin
   vpop (arg2);
   vpop (arg1);
   get_type (typ,arg2);
   if typ <> list then error (xwta,current_token,arg2)
      else if arg1 = lnil then begin
                               Cons (arg1,arg2,lnil,list);
                               if error_flag <> xzap then outp_arg1
                               end
              else begin
                   mark2 := arg1;  (* MARK2 holds on to the thing to LPUT *)
                   mark3 := arg2;  (* MARK3 is the list MARK2 gets stuck on. *)
                   car (t1,mark3);
                   cdr (mark3,mark3);
                   Cons (mark1,t1,lnil,list); (* MARK1 is the list under construction. *)
                   if error_flag <> xzap then
                      begin
                      while (mark3 <> lnil) and (error_flag <> xzap) do
                         begin
                         car (t1,mark3);
                         Cons (t2,t1,lnil,list); (* Copy the next cell from the input list. *)
                         if error_flag <> xzap then
                            begin
                            rplacd (mark1,t2);(* Splice it into the list under construction. *)
                            mark1 := t2;
                            cdr (mark3,mark3);   (* And go on to the next input cell. *)
                            end
                         end;
                      if error_flag <> xzap then
                         Cons (t2,arg1,lnil,list);
                         if error_flag <> xzap then
                            begin
                            rplacd (mark1,t2);
                            arg1 := mark1;
                            mark1 := lnil; mark2 := lnil;
                            outp_arg1
                            end
                      end
                   end
   end; (* s_lput *)

procedure s_sentence;
   var typ,stack: integer;
   begin
   if nargs < 0 then nargs := -nargs-1;
   mark1 := lnil;
   while (nargs <> 0) and (error_flag <> xzap) do
      begin
      vpop (mark2);
      get_type (typ,mark2);
      if typ <> list then Cons (mark1,mark2,mark1,list)
       else
         begin
         stack := vsp;
         while mark2 <> lnil do
            begin
            car (mark3,mark2);
            cdr (mark2,mark2);
            vpush (mark3);
            end;
         while (stack <> vsp) and (error_flag <> xzap) do
            begin
            vpop (mark3);
            Cons (mark1,mark3,mark1,list);
            if error_flag = xzap then sp := stack
            end
         end;
      nargs := nargs-1
      end;
   arg1 := mark1; mark1 := lnil; mark2 := lnil; mark3 := lnil;
   if error_flag <> xzap then outp_arg1
   end; (* s_sentence *)

                              (* miscellaneous functions *)
procedure s_make;
   begin
   vpop (arg2);
   vpop (arg1);
   get_type (temp1,arg1);
   if (temp1 <> atom) and (temp1 <> satom) then error (xwta,current_token,arg1)
      else begin
           put_value (arg1,arg2);
           outputn := 0;
           popj
           end
   end; (* s_make *)

procedure s_output;
   begin
   if level_number = 0 then error (xntl,current_token,0)
      else begin
           stop_flag := 1;
           outputn := 1;
           popj
           end
   end; (* s_output *)

procedure s_stop;
   begin
   if level_number = 0 then error (xntl,current_token,0)
      else begin
           stop_flag := 1;
           outputn := 0;
           popj
           end
   end; (* s_stop *)

procedure s_pause;
   begin
   error (xbrk,0,0)
   end;

procedure s_comment;
   begin
   token_pointer := lnil;
   outputn := 0;
   if expected_output <> 0 then error (xeol,0,0)
      else popj
   end; (* s_comment *)

procedure s_print;
   begin
   vpop (arg1);
   print (arg1);
   if error_flag <> xzap then
      begin
      outputn := 0;
      popj
      end
   end; (* s_print *)

procedure s_type;
   begin
   vpop (arg1);
   ltype (ttyoutput,arg1,1);
   if error_flag <> xzap then
      begin
      outputn := 0;
      popj
      end
   end; (* s_type *)

procedure os_define;
   var typ1,typ2,temp: integer;
   begin
   vpop (arg2);
   vpop (arg1);
   get_type (typ1,arg1);
   get_type (typ2,arg2);
   if (typ1 <> atom) then error (xwta,current_token,arg1)
      else if (typ2 <> list) then error (xwta,current_token,arg2)
         else begin
              car (temp,arg2);
              get_type (temp,temp);
              if temp <> list then error (xwta,current_token,arg2) else
                begin
                Defun (arg1,arg2);
                if error_flag <> xzap then
                   begin
                   outputn := 0;
                   popj
                   end
                end
              end
   end; (* s_define *)

procedure s_define;
   begin
   suboverlay (defun_suboverlay);
   os_define
   end;

procedure os_text;
   var typ,fun,stack,line,body: integer;
   begin
   vpop (arg1);
   get_type (typ,arg1);
   if typ <> atom then error (xwta,current_token,arg1) else
      begin
      get_function (fun,typ,arg1);
      if fun = novalue then body := lnil else
         begin
         cdr (body,fun);
         get_type (typ,body);
         case typ of
            list: begin
                  fun := body;
                  stack := vsp;
                  car (line,fun);
                  cdr (fun,fun);
                  vpush (line);
                  while fun <> lnil do
                     begin
                     car (line,fun);
                     cdr (fun,fun);
                     cdr (line,line);  (* Skip past line number *)
                     vpush (line)
                     end;
                  mark1 := lnil;
                  while (stack <> vsp) and (error_flag <> xzap) do
                     begin
                     vpop (line);
                     Cons (mark1,line,mark1,list);
                     end;
                  body := mark1; mark1 := lnil
                  end;
            fpack: Unstuff (body,fun,true);
            otherwise system_bug
            end
         end;
      if error_flag <> xzap then
         begin
         vpush (body);
         outputn := 1;
         popj
         end
      end
   end; (* s_text *)

procedure s_text;
   begin
   suboverlay (defun_suboverlay);
   os_text
   end;

procedure os_to;
   var fun,typ,token: integer;
       cflush: boolean;
   begin
   edit_setup;
   if error_flag = 0 then
      begin
      get_function (fun,typ,arg1);
      if fun <> novalue then begin
                             exit_edit;
                             error (xdef,arg1,0)
                             end
         else if error_flag = xzap then exit_edit else
                 begin   (* Set up args list as first element of EDIT_BODY. *)
                 mark1 := token_pointer;
                 nargs := 0;
                 cflush := false;
                 while (token_pointer <> lnil) and (error_flag = 0) and not cflush do
                    begin
                    get_token (token,token_pointer);
                    tokn_advance (token_pointer,false);
                    if token = comment then cflush := true else
                       begin
                       get_type (typ,token);
                       if (typ = atom) or (typ = satom) then nargs := nargs+1 else
                          begin
                          exit_edit;
                          error (xwta,current_token,token)
                          end
                       end
                    end
                 end;
      if error_flag = 0 then
         begin
         token_pointer := lnil;
         Cons (edit_body,mark1,lnil,list);  (* Arglist is the car of the body. *)
         if error_flag = xzap then exit_edit else
            begin
            Put_ftext (edit_atom,edit_body,nargs);
            popj
            end
         end
      end
   end; (* os_to *)

procedure s_to;
   begin
   overlay (edit_overlay);
   os_to;
   overlay (evaluate_overlay)
   end; (* s_to *)

procedure os_edit;
   var fun,typ,args,nargs: integer;
   begin
   edit_setup;
   if error_flag = 0 then
      begin
      get_function (fun,typ,arg1);
      if fun = novalue then begin
                            exit_edit;
                            error (xudf,arg1,0)
                            end
         else begin
              Unstuff (edit_body,fun,false);
              if error_flag = xzap then exit_edit else
                 begin
                 car (args,edit_body);
                 get_length (nargs,args);
                 Put_ftext (arg1,edit_body,nargs);
                 popj
                 end
              end
      end;
   end; (* os_edit *)

procedure s_edit;
   begin
   overlay (edit_overlay);
   os_edit;
   overlay (evaluate_overlay)
   end; (* s_edit *)

procedure os_end;
   var temp: integer;
   begin
   if edit_switch = 0 then error (xned,0,0) else
      if level_number <> 0 then error (xetl,0,0) else
         begin
         Stuff (edit_body,edit_atom);
         if outdev = vdt then
            begin
            ltype (ttyoutput,edit_atom,0);
            write (ttyoutput,' defined');
            breakl (ttyoutput)
            end;
         exit_edit;
         popj
         end
   end; (* os_end *)

procedure s_end;
   begin
   overlay (edit_overlay);
   os_end;
   overlay (evaluate_overlay)
   end; (* s_end *)


procedure os_title;
   var arg,atomm,fun,typ,nargs,arglist,temp: integer;
       cflush: boolean;
   begin
   if edit_switch = 0 then error (xned,0,0) else
      if level_number <> 0 then error (xetl,0,0) else
         begin
         if token_pointer = lnil then begin outputn := 0; popj end else
            begin
            car (atomm,token_pointer);
            cdr (token_pointer,token_pointer);
            arglist := token_pointer;
            get_type (typ,atomm);
            if typ = satom then error (xubl,atomm,0) else
               if typ <> atom then error (xwta,current_token,0) else
                  begin
                  if atomm <> edit_atom then
                     begin
                     get_function (fun,typ,edit_atom);
                     unfunction (edit_atom);
                     edit_atom := atomm;
                     po_default := atomm;
                     put_function (edit_atom,fun)
                     end;
                  nargs := 0;
                  cflush := false;
                  while (token_pointer <> lnil) and (error_flag = 0) and not cflush do
                     begin
                     car (arg,token_pointer);
                     cdr (token_pointer,token_pointer);
                     if arg = comment then cflush := true;
                     if not cflush then
                        begin
                        get_type (typ,arg);
                        if (typ = atom) or (typ = satom) then nargs := nargs+1 else
                           begin
                           exit_edit;
                           error (xwta,current_token,arg)
                           end
                        end
                     end;
                  if error_flag = 0 then
                     begin
                     token_pointer := lnil;
                     rplaca (edit_body,arglist);
                     get_function (temp,typ,edit_atom);
                     put_nargs (temp,nargs);
                     outputn := 0;
                     popj
                     end
                  end
             end
         end
   end; (* os_title *)

procedure s_title;
   begin
   overlay (edit_overlay);
   os_title;
   overlay (evaluate_overlay)
   end; (* s_title *)

procedure po_text (atomm: integer; var f: chfil; full: boolean);
   var line,fun,typ,token,ptr,endptr,temp,temp1: integer;
   begin
   get_function (fun,typ,atomm);
   if fun <> novalue then
      begin
      write (f,'To ');
      ltype (f,atomm,0);
      cdr (fun,fun);
      get_type (typ,fun);
      case typ of
         list: begin
               car (line,fun);
               cdr (fun,fun);
               while (line <> lnil) and (error_flag <> xzap) do (* Type argument names. *)
                  begin
                  car (token,line);
                  cdr (line,line);
                  write (f,' ');
                  ltype (f,token,0)
                  end;
               breakl (f);
               if full then               (* Now type the body, unless we want titles only. *)
                  while fun <> lnil do
                     begin
                     car (line,fun);
                     cdr (fun,fun);
                     car (token,line);
                     cdr (line,line);
                     if (outdev = vdt) or (number_switch <> 0) then type_number (f,token);
                     while (line <> lnil) and (error_flag <> xzap) do
                        begin
                        car (token,line);
                        cdr (line,line);
                        write (f,' ');
                        ltype (f,token,0)
                        end;
                     breakl (f)
                     end
               end;
        fpack: begin
               get_bigarray (ptr,fun);
               fun := fun+wordsize;
               get_bigarray (endptr,fun);
               while ptr <> endptr do   (* Print arg names *)
                  begin
                  get_bigarray (token,ptr);
                  ptr := ptr + wordsize;
                  write (f,' ');
                  ltype (f,token,0)
                  end;
               breakl (f);
               if full then     (* Now print procedure lines unless just titles are wanted. *)
                  while (endptr <> 0) and (error_flag <> xzap) do
                     begin
                     ptr := endptr;
                     fun := fun + wordsize;
                     get_bigarray (endptr,fun);
                     if endptr <> 0 then
                        begin
                        get_bigarray (token,ptr);
                        ptr := ptr + wordsize;
                        if (outdev = vdt) or (number_switch <> 0) then type_number (f,token);
                        while (ptr <> endptr) and (error_flag <> xzap) do
                           begin
                           get_bigarray (token,ptr);
                           ptr := ptr + wordsize;
                           write (f,' ');
                           ltype (f,token,0)
                           end;
                        breakl (f)
                        end
                     end
               end;
         otherwise system_bug
         end;

      if full then
         begin
         write (f,'end');
         breakl (f); breakl (f)
         end
      end
   end; (* po_text *)

procedure po_names (ttyp: boolean; var f: chfil);
   var val,name,names,current_token,typ: integer;
   procedure po_n1 (name: integer);
      begin
      get_value (val,name);
      if (val <> novalue) and (error_flag <> xzap) then
         if ttyp then
            begin
            write (f,'"');
            ltype (f,name,0);
            write (f,' is ');
            ltype (f,val,0);
            breakl (f)
            end
         else
            begin
            write (f,'make "');
            ltype (f,name,0);
            write (f,' ');
	    get_type (typ,val);
	    if typ = atom then write (f,'"');
            ltype (f,val,0);
            breakl (f)
            end
      end; (* po_n1 *)
     begin
   names := oblist;
   while (names <> lnil) and (error_flag <> xzap) do
      begin
      car (name,names);
      cdr (names,names);
      po_n1 (name)
      end;
   name := soblist;
   while (name <> sobtop) and (error_flag <> xzap) do
      begin
      po_n1 (name);
      name := name + nodesize
      end
   end; (* po_names *)
      
procedure po_functions (var f: chfil; full: boolean);
   var temp,temp1: integer;
   begin
   temp := oblist;
   while (temp <> lnil) and (error_flag <> xzap) do
      begin
      car (temp1,temp);
      cdr (temp,temp);
      po_text (temp1,f,full)
      end
   end; (* po_functions *)

procedure po_titles;
   begin
   po_functions (ttyoutput,false)
   end; (* po_titles *)

procedure os_pots;
   begin
   po_titles;
   outputn := 0;
   popj
   end; (* s_pots *)

procedure s_pots;
   begin
   overlay (printout_overlay);
   os_pots;
   overlay (evaluate_overlay)
   end; (* s_pots *)

procedure os_po;
   var typ,fun: integer;
   begin
   if token_pointer = lnil then begin
                                if po_default <> lnil then po_text (po_default,ttyoutput,true)
                                end
                           else
      begin
      get_token (arg1,token_pointer);
      tokn_advance (token_pointer,true);
      if arg1 = all then
         begin
         po_functions (ttyoutput,true);
         po_names (true,ttyoutput)
         end
        else if arg1 = names then po_names (true,ttyoutput)
         else if arg1 = titles then po_titles 
          else if arg1 = procedures then po_functions (ttyoutput,true) else
            begin
            get_type (typ,arg1);
            case typ of
               atom: begin
                     po_default := arg1;
                     po_text (arg1,ttyoutput,true);
                     end;
               satom: error (xubl,arg1,0);
               otherwise error (xwta,current_token,arg1)
               end
            end
      end;
   if error_flag = 0 then begin outputn := 0; popj end
   end; (* os_po *)

procedure s_po;
   begin
   overlay (printout_overlay);
   os_po;
   overlay (evaluate_overlay)
   end; (* s_po *)

procedure os_traceback;
   var name,funct,fr,xfr,ptr,ptr1,bindings: integer; first: boolean;
   begin
   if frame = 0 then write (ttyoutput,'We''re now at top level.')
     else
      begin
      write (ttyoutput,'We''re currently inside ');
      first := true;
      fr := frame;
      xfr := xframe;
      while fr <> 0 do
         begin
         ptr := fr+sf_bindings;
         ptr1 := xfr+popinc;
         while ptr1 < ptr do
            begin
            get_bigarray (funct,ptr1);
            if funct mod 2 <> 0 then             (* Lo bit set means this is a funct/frame *)
               begin                             (* pair, not an atom/binding pair. *)
               if not first then write (ttyoutput,', ')
                  else first := false;
               get_bigarray (name,funct-1 + wordsize*3);
               ltype (ttyoutput,name,0);
               end;
            ptr1 := ptr1+wordsize*2
            end;
         get_bigarray (xfr,fr+sf_xframe);
         get_bigarray (fr,fr+sf_previous_frame)
         end
      end;
   breakl (ttyoutput);
   outputn := 0;
   popj
   end; (* s_traceback *)

procedure s_traceback;
   begin
   overlay (printout_overlay);
   os_traceback;
   overlay (evaluate_overlay)
   end; (* s_traceback *)

procedure s_read;
   begin
   if indev <> wfile then
      begin
      indev := wfile;
      setname (workspace,workname);
      reset (workspace);
      number_lines_read := 0;
      jump (s_read_1)
      end
   end;

procedure os_write;
   begin
   outdev := wfile;
   setname (workspace,workname);
   rewrite (workspace);
   writeln (workspace);
   po_functions (workspace,true);
   po_names (false,workspace);
   close (workspace);
   outdev := vdt
   end;

procedure s_write;
   begin
   overlay (printout_overlay);
   os_write;
   overlay (evaluate_overlay);
   outputn := 0;
   popj
   end; (* s_write *)

procedure erase_names;
   var obl,name: integer;
   begin
   obl := oblist;      (* First clobber all atoms' values. *)
   while obl <> lnil do
      begin
      car (name,obl);
      cdr (obl,obl);
      put_value (name,novalue)
      end;
   obl := soblist;    (* Then clobber satoms' values. *)
   while obl <> sobtop do
      begin
      put_value (obl,novalue);
      obl := obl+nodesize
      end
   end; (* erase_names *)

procedure erase_procedures;      
   var obl,name: integer;
   begin
   obl := oblist;
   while obl <> lnil do
      begin
      car (name,obl);
      cdr (obl,obl);
      unfunction (name)
      end
   end; (* erase_procedures *)

procedure os_erase;
   var typ: integer;
   begin
   if token_pointer = lnil then error (xeol,0,0) else
      begin
      get_token (arg1,token_pointer);
      tokn_advance (token_pointer,true);
      if edit_switch = 0 then
       begin
       if arg1 = all then reinit else
        if arg1 = names then erase_names else
         if (arg1 = titles) or (arg1 = procedures) then erase_procedures else
          begin
          get_type (typ,arg1);
          if typ = atom then unfunction (arg1)
           else if typ = fix then error (xned,0,0)
            else error (xwta,current_token,arg1)
          end
       end else begin   (* This is if EDIT_SWITCH <> 0. *)
                get_type (typ,arg1);
                if typ = fix then
                   begin
                   car (arg1,arg1);
                   delete (arg1)
                   end
                  else error (xnwe,0,0)
                end;
      if error_flag = 0 then
         begin
         outputn := 0;
         popj
         end
      end
   end; (* os_erase *)

procedure s_erase;
   begin
   overlay (printout_overlay);
   os_erase;
   overlay (evaluate_overlay)
   end; (* s_erase *)

procedure s_debug;
   begin
   outputn := 0;
   if debug_switch = 0
      then begin
           debug_switch := 1;
           write (ttyoutput,'ON'); breakl (ttyoutput)
           end
      else begin
           debug_switch := 0;
           write (ttyoutput,'OFF'); breakl (ttyoutput)
           end;
   popj
   end; (* s_debug *)

(* procedure s_lines;
   begin
   outputn := 0;
   if number_switch = 0 then
      begin
      number_switch := 1;
      write (ttyoutput,'USE LINE NUMBERS'); breakl (ttyoutput)
      end
     else
      begin
      number_switch := 0;
      write (ttyoutput,'NO LINE NUMBERS'); breakl (ttyoutput)
      end;
   popj
   end;*) (* s_lines *)

procedure s_continue;
   begin
   stop_flag := 1;
   dont_continue_flag := 1;
   outputn := 0;
   popj
   end; (* s_continue *)

procedure s_if;
   begin
   if_level := if_level+1;

   vpop (arg1);
   outputn := 0;

   get_token (next_token,token_pointer);   (* Skip past optional THEN *)
   if next_token = lthen then tokn_advance (token_pointer,true);
   if arg1 = ltrue
      then popj   (* If pred is TRUE, simply return *)

      else if arg1 = lfalse  (* If FALSE then skip *past* matching ELSE or *)
              then begin      (* *up to* RPAR, or end of line *)
                   exit_if_scope (next_token); (* Goes *up to* matching ELSE or RPAR *)
                   if (token_pointer <> lnil) and (next_token = lelse)
                      then tokn_advance (token_pointer,true);  (* Go past ELSE *)
                   popj
                   end
              else error (xntf,arg1,0);
   end; (* s_if *)

(* S_ELSE is only gotten to if the associated IF was TRUE, or if there was no associated IF.
   If there was no associated IF, that's a user error.
   Otherwise,
    S_ELSE must skip TOKEN_POINTER past the scope of the ELSE clauses, preventing them from
      being executed.  The scope is terminated by end of line, RPAR, or another ELSE.
      TOKEN_POINTER is left pointing to an RPAR or ELSE which ended the scope.
    S_ELSE also decrements IF_LEVEL *)

procedure s_else;
   begin
   if_level := if_level-1;
   if if_level < 0 then error (xels,0,0)
      else begin
           if if_level > 0 then exit_if_scope (temp1) else token_pointer := lnil;
           outputn := 0;
           popj
           end
   end; (* s_else *)

procedure s_go;
   var typ1,linen: integer;
   begin
   stop_peek;
   if error_flag = 0 then
      begin
      vpop (arg1);
      outputn := 0;
      get_type (typ1,arg1);
      if (typ1 <> atom) and (typ1 <> satom) then error (xwta,current_token,arg1)
         else begin
              typ1 := 0;
              put_type (arg1,latom);
              go_ptr := fbody;
              ulin_advance (go_ptr);
              while (go_ptr <> 0) and (typ1 = 0) do
                 begin
                 get_uline (temp1,go_ptr,true);
                 get_token (linen,temp1);
                 tokn_advance (temp1,true);
                 get_token (temp1,temp1);
                 if temp1 = arg1 then typ1 := 1
                    else ulin_advance (go_ptr)
                 end;
              if go_ptr = 0 then error (xlnf,arg1,0)
                 else begin line_number := linen; popj end
              end
      end
   end; (* s_go *)

procedure s_run;
   begin
   stop_peek;
   if error_flag = 0 then
      begin
      vpop (arg1);
      get_type (temp1,arg1);
      if temp1 <> list then error (xwta,current_token,arg1)
         else jump (run_handler)
      end
   end; (* s_run *)

procedure s_thing;
   var typ: integer;
   begin
   vpop (arg2);
   get_type (typ,arg2);
   case typ of
      atom,satom:
         begin
         get_value (arg1,arg2);
         if arg1 = novalue then error (xhnv,arg2,0)
            else outp_arg1
         end;
      otherwise error (xwta,current_token,arg2)
      end
   end; (* s_thing *)

procedure s_pthingp;
   var typ: integer;
   begin
   vpop (arg2);
   get_type (typ,arg2);
   case typ of
      atom,satom:
         begin
         get_value (arg1,arg2);
         if arg1 = novalue then vpush (lfalse)
            else vpush (ltrue)
         end;
      otherwise vpush (lfalse)
      end;
   outputn := 1;
   popj
   end; (* thingp *)

procedure os_word;
   var typ,stack,nargs1: integer;
   procedure count_chars (var ans: integer; str: integer);
      var temp: integer;
      begin
      ans := 0;
      while str <> lnil do
         begin
         ans := ans + 1;
         car (temp,str);
         cdr (str,str);
         if temp div 256 <> 0 then ans := ans + 1
         end
      end; (* count_chars *)
   procedure copy (var str1: integer; str2: integer);
      var temp1,temp2: integer;
      begin
      if str2 = lnil then str1 := lnil else
         begin
         Cons (str1,0,lnil,string);
         temp1 := str1;
         if error_flag <> xzap then
            begin
            vpush (str1);
            while (str2 <> lnil) and (error_flag <> xzap) do
               begin
               car (temp2,str2);
               cdr (str2,str2);
               rplaca (str1,temp2);
               if str2 <> lnil then
                  begin
                  Cons (temp3,0,lnil,string);
                  if error_flag <> xzap then
                     begin
                     rplacd (str1,temp3);
                     str1 := temp3
                     end
                  end
               end;
            vpop (str1)
            end
         end
      end; (* copy *)

(* ...in the scope of S_WORD *)

   procedure concat (var str1: integer; str2: integer);
      var str,num,temp1,temp2,temp3: integer;
      begin
      if str1 = lnil then copy (str1,str2) else
         begin
         vpush (str1);  (* Gc- protect old STR1. *)
         copy (str1,str1); (* VAR STR1 is assumed gc-protected. *)
         if error_flag <> xzap then
            begin
            str := str1;
            get_last_cell (str1);
            count_chars (num,str1);
            if (num mod 2) = 0 then begin  (* Easy case: even # of chars in
   STR1. *)
                                    copy (str2,str2);
                                    if error_flag <> xzap then
                                       begin
                                       rplacd (str1,str2);
                                       str1 := str2
                                       end
                                    end
             else begin             (* Hard case: odd # of chars in STR1. *)
                  car (temp2,str2); (* Put first char of STR2 in last slot of STR1 *)
                  car (temp1,str1);
                  rplaca (str1,temp1+(temp2 mod 256) * 256);

                  while (str2 <> lnil) and (error_flag <> xzap) do
                     begin
                     temp2 := temp2 div 256;
                     cdr (str2,str2);
                     if temp2 <> 0 then
                        begin
                        if str2 = lnil then Cons (temp1,temp2,lnil,string) else
                           begin
                           car (temp3,str2);
                           Cons (temp1,temp2 + (temp3 mod 256) * 256,lnil,string)
                           end;
                        if error_flag <> xzap then
                           begin
                           rplacd (str1,temp1);
                           str1 := temp1
                           end
                        end;
                     temp2 := temp3
                     end
                  end;
            str1 := str; (* Un-cdr STR1 back to its saved beginning. *)
            end;
         vsp := vsp+popinc  (* Flush the saved original STR1. *)
         end
      end; (* concat *)

   begin
   if nargs < 0 then nargs := -nargs-1;
   nargs1 := nargs;
   mark5 := lnil;  (* MARK5 will hold the pname under construction. *)
   stack := vsp + (nargs-1)*popinc;
   while (nargs1 <> 0) and (error_flag = 0) do
      begin
      get_bigarray (mark4,stack);
      stack := stack+pushinc;
      nargs1 := nargs1-1;
      Make_pname (mark4,mark4);
      if (error_flag = 0) and (mark4 <> lnil) then concat (mark5,mark4)
      end;
   vsp := vsp+nargs*popinc;
   if error_flag = 0 then
      begin
      Intern (arg1,mark5);
      if error_flag = 0 then outp_arg1
      end;
   mark4 := lnil; mark5 := lnil
   end; (* os_word *)

procedure s_word;
   begin
   suboverlay (word_suboverlay);
   os_word
   end;

procedure s_pwordp;
   var typ: integer;
   begin
   vpop (arg1);
   get_type (typ,arg1);
   case typ of
      atom,satom,fix: vpush (ltrue);
      otherwise vpush (lfalse)
      end;
   outputn := 1;
   popj
   end; (* s_wordp *)

procedure s_nodes;
   var count,ptr: integer;
   begin
   count := 0;
   ptr := freelist;
   while ptr <> 0 do
      begin
      count := count+1;
      cdr (ptr,ptr)
      end;
   Outp_fixnum (count)
   end; (* s_nodes *)

procedure s_request;
   begin
   read_line (arg1,tty);
   if error_flag = 0 then outp_arg1
   end; (* s_request *)

procedure s_bpt;
   begin
   HALT;
   outputn := 0;
   popj
   end;

procedure s_goodbye;
   begin
   hello := false;
   zap_code := logout;
   error (xzap,0,0)
   end;

procedure s_gcoll;
   begin
   Garbage_collect;
   outputn := 0;
   popj
   end;

procedure s_snap;
    begin
       do2500 (fbody1-si_forward,temp1,temp2,error_flag,display_length,snap_top);
       if error_flag <>0 then error(error_flag,current_token,arg1)
           else Outp_fixnum (temp2)
    end;

procedure do_0_arg_2500;
    begin
       do2500 (fbody1-si_forward,temp1,temp2,error_flag,display_length,snap_top);
       if error_flag <>0 then error(error_flag,current_token,arg1)
          else begin outputn := 0; popj end
    end;

procedure do_1_arg_2500;
    begin
    get_1_fixnum_arg;
    if error_flag = 0 then
       begin
       do2500 (fbody1-si_forward,arg1,temp1,error_flag,display_length,snap_top);
       if error_flag <>0 then error(error_flag,current_token,arg1)
          else begin outputn := 0; popj end
       end
    end;


(* EVALUATE case routines, removed from EVALUATE so you-know-what can compile it. Sigh. *)
procedure x_eval;
   begin
   push (current_token);
   if frame <> 0 then nest := nest+1;
         
   (* Note that EVAL_WRAPUP will unwind all that EVLINE has done up to this point. *)

   if token_pointer = lnil then error (xeol,0,0)
      else
         begin
         get_token (current_token,token_pointer);
                                        (* CURRENT_TOKEN is our point of departure *)
         tokn_advance (token_pointer,true);  (* TOKEN_POINTER moves past CURRENT_TOKEN *)
         get_token (next_token,token_pointer);
                                        (* NEXT_TOKEN is held for possible auxiliary use. *)
         get_type (temp1, current_token);
         case temp1 of                      (* dispatch off CURRENT_TOKEN type *)
            latom:		(* label should have been flushed if at beg of line
                                   If we get here with it, it was in the middle *)
                error (xlabel,0,0);	(* unexpected label *)
            qatom,fix,flo,list:  (* these types are simply vpushed, with quote type bits *)
               begin             (* stripped off for a qatom *)
               current_token := current_token div nodesize * nodesize;
               vpush (current_token);
               outputn := 1;
               jump (eval_wrap_up)
               end;
            datom:               (* :atom has its value vpushed *)
               begin
               get_value (temp1,current_token);
               if temp1 = novalue then error (xhnv,
                                              current_token div nodesize * nodesize,
                                              0)
                  else begin
                       vpush (temp1);
                       outputn := 1;
                       jump (eval_wrap_up)
                       end
               end;

(* EVAL c't'd. We're inside a case of the CURRENT_TOKEN type *)

            atom,satom:
                  begin                 (* a plain atom designates a function *)
                  get_function (funct,funtype,current_token);
                  if funct = novalue then error (xudf,current_token,0)
                     else
                     begin
                     infix_p (temp1,funct,funtype); (* The functions + or -, appearing at *)
                     if temp1 <> 0 (* this point in the parsing, should *)
                                   (* be treated as unary 1-arg prefix ops *)
                        then if current_token = sum then
                             begin
                             current_token := unary_sum;
                             get_function (funct,funtype,current_token)
                             end
                        else if current_token = difference
                                then begin
                                     current_token := unary_difference;
                                     get_function (funct,funtype,current_token)
                                     end
                                else error (xifx,current_token,0);
                     if error_flag = 0 then
                        case funtype of
                           ufun,sfun:
                              begin
                              push (precedence);
                              get_precedence (precedence,funct,funtype);
                              get_nargs (nargs,funct,funtype);
                              if nargs < 0 then nargs := -nargs-1;
                              push (eval_1);
                              jump (arg_loop); (* Call ARG_LOOP *)
                              end;
                           otherwise system_bug
                           end
                     end
                  end
       end (* case temp1 ... *)
    end (* else begin ... *)
end;  (* x_eval *)

procedure x_ev_wrap_up;
begin
if (token_pointer <> lnil) and (outputn <> 0) and (stop_flag = 0)
   then begin
        get_token (current_token,token_pointer);
        if current_token <> rpar
           then begin
                get_function (funct,funtype,current_token);
                infix_p (temp1,funct,funtype);
                if temp1 <> 0
                   then begin
                        get_precedence (temp1,funct,funtype);
                        if temp1 > precedence
                           then begin
                                tokn_advance (token_pointer,true);
                                get_token (next_token,token_pointer);
                                push (next_token);
                                push (funct);
                                push (funtype);
                                push (expected_output);
                                expected_output := 1;
                                push (if_level);
                                push (precedence);
                                precedence := temp1;
                                push (e_w_1);
                                jump (eval)
                                end
                           else jump (eval_return)
                        end
                   else jump (eval_return)
                end
           else jump (eval_return)
        end
   else jump (eval_return)
   end; (* x_ev_wrap_up *)

procedure x_sf1;
begin
case fbody1 of   (* sigh. sure would be nice to have functional variables. *)
   si_unary_sum: s_un_sum;
   si_unary_difference: s_un_difference;
   si_make: s_make;
   si_output: s_output;
   si_stop: s_stop;
   si_print: s_print;
   si_type: s_type;
   si_define: s_define;
   si_debug: s_debug;
   si_continue: s_continue;
   si_pause: s_pause;
   si_else: s_else;
   si_then: error (xthn,0,0);
   si_not: s_not;
   si_either: s_either;
   si_both: s_both;
   si_if: s_if;
   si_go: s_go;
   si_run: s_run;
   si_rpar: error (xrpn,0,0);
   si_lpar: jump (paren_loop);

   si_sentence: s_sentence;
   si_thingp: s_pthingp;
   si_word: s_word;
   si_wordp: s_pwordp;

   otherwise system_bug
   end;
end;

procedure x_sf2;
begin
case fbody1 of
   si_sum: s_sum;
   si_difference: s_difference;
   si_product: s_product;
   si_quotient: s_quotient;
   si_equal,si_is: s_equal;
   si_greater: s_greater;
   si_less: s_less;

   si_request: s_request;
   si_bpt: s_bpt;
   si_nodes: s_nodes;
   si_goodbye: s_goodbye;
   si_gcoll: s_gcoll;
   si_butfirst: s_butfirst;
   si_first: s_first;
   si_butlast: s_butlast;
   si_last: s_last;
   si_fput: s_fput;

   si_edit: s_edit;  (* These are in the edit overlay. *)
   si_to: s_to;
   si_end: s_end;
   si_title: s_title;
   si_text: s_text;

   si_thing: s_thing;

(*   si_lines: s_lines;*)

   si_forward,si_back,si_right,si_left,si_spin,si_move,si_display:
    do_1_arg_2500;

   si_cs,si_home,si_penup,si_pendown,si_wipeclean:
    do_0_arg_2500;

   si_snap: s_snap;

   si_printout: s_po;
   si_all,si_names,si_titles,si_procedures: error (xopo,current_token,0);
   si_erase: s_erase;
   si_write: s_write;
   si_read: s_read;

   si_comment: s_comment;
   si_traceback: s_traceback;
   si_pots: s_pots;

   (* etc. *)
   otherwise system_bug
   end;
end; (* x_sfuncall *)

procedure x_sfuncall;
   begin
   if fbody1 > si_go then x_sf2 else x_sf1
   end;

procedure x_tail;
   var bindings,temp1,pointer,arg_list: integer;
   begin
   line_number := 0;
   nest := -1;
   level_number := level_number + 1;
   tail_levels := tail_levels + 1;
   pointer := vsp + (nargs - 1) * popinc;
   get_bigarray (bindings,frame+sf_number_bindings);
   get_uline (arg_list,fbody,true);
   sp := sp+popinc;             (* Pop the return addr. U_F_1 will supply a new one. *)
   put_bigarray (frame+sf_ufun,current_token);  (* New ufun for this frame. *)
   put_bigarray (frame+sf_format,uformat);      (*  ...and corresponding new uformat. *)

   get_fframe (temp1,funct);(* See if FUNCT already has its old bindings in this *)
                                   (* frame. *)
   if temp1 = frame_gensym then
      begin                        (* If so, just clobber the variables' shallow bindings. *)
      while arg_list <> lnil do
         begin
         if pointer < vsp then system_bug;
         get_token (var_name,arg_list);
         tokn_advance (arg_list,true);
         get_bigarray (temp1,pointer);
         pointer := pointer + pushinc;
         put_value (var_name,temp1)
         end;
      put_bigarray (frame+sf_number_bindings,bindings)
      end
     else
      begin                        (* FUNCT isn't already here, must extend the frame. *)
      while arg_list <> lnil do
         begin
         if pointer < vsp then system_bug;
         get_token (var_name,arg_list);
         tokn_advance (arg_list,true);
         get_value (temp1,var_name);
         push (temp1);
         get_bigarray (temp1,pointer);
         pointer := pointer+pushinc;
         put_value (var_name,temp1);
         push (var_name)
         end;
      get_fframe (temp1,funct);
      push (temp1);      (* This funct/funframe pair is treated just like a var *)
      push (funct+1);    (* binding. PUT_VALUE will do the right thing upon restoration. *)
      put_fframe (funct,frame_gensym);
      put_bigarray (frame+sf_number_bindings,bindings+nargs+1);
                                                      (* The 1 is for the funframe binding*)
      xframe := sp+pushinc  (* A new top of the frame. *)
      end;

   vsp := vsp + nargs*popinc;   (* Pop the arg values from the VPDL *)
   jump (u_f_1)                 (* Now act like we came from UFUNCALL. *)
   end; (* x_tail *)

(* Called with function body in FBODY1, number of arguments in NARGS,
   argument values on the top of the VPDL. *)
procedure x_ufuncall;
var last_line,temp: integer;
   begin
   line_peek (last_line,fptr);
   push_test;
   if error_flag = 0 then
      begin
      push (uline_end);
      push (uformat);
      push (fbody);
      push (fptr);
      push (run_flag);

      stop_flag := 0;
      run_flag := 0;
      go_ptr := lnil;
      fbody := fbody1;
      fptr := fbody;

      temp := lnil;      (* Figure out whether to tail-recurse. *)
      if (nest = 0) and (level_number <> 0) then
         if last_line = lnil then
            begin
            if token_pointer = lnil then temp := lstop else get_token (temp,token_pointer);
            end
           else if token_pointer <> lnil then get_token (temp,token_pointer);
      get_type (uformat,fbody);
      if (temp = lstop) then
         begin
         sp := xframe; (* Tail recurse: pop back to the caller's ufun loop-- *)
         x_tail;       (*  remember, this is the beginning of the tail function's ufun loop. *)
         end
       else
         begin   (* push a new frame *)
         frame_gensym := frame_gensym+1;
         push (frame);         (* sf: PREVIOUS_FRAME *)
         frame := sp+popinc;
         push (xframe);        (* sf: XFRAME *)
         push (uformat);       (* sf: FORMAT *)
         push (current_token); (* sf: UFUN *)
         push (nest);          (* sf: NEST *)
         push (line_number);   (* sf: LINE_NUMBER *)
         push (token_pointer); (* sf: LINE *)
         push (nargs+1);       (* sf: NUMBER_BINDINGS-- the +1 is for the funct/funframe pair. *)
         push (tail_levels);   (* sf: TAIL_LEVELS *)
         get_fframe (temp1,funct);
         push (temp1);         (* sf: BINDINGS-- funct/funframe pair is pseudo-binding. *)
         push (funct+1);       (* +1 is to distinguish from real binding (for gc). *)
   
         line_number := 0;
         nest := -1;
         level_number := level_number + 1;
         tail_levels := 1;
         put_fframe (funct,frame_gensym);
   
         pointer := vsp + (nargs - 1) * popinc;
                                    (* Arg values are sitting on the VPDL, last at top *)
         get_uline (arg_list,fbody,true);
         while arg_list <> lnil do  (* sf: BINDINGS, continued. *)
            begin
            if pointer < vsp then system_bug;
            get_token (var_name,arg_list);
            tokn_advance (arg_list,true);
            get_value (temp1,var_name);
            push (temp1);
            get_bigarray (temp1,pointer);
            pointer := pointer + pushinc;
            put_value (var_name,temp1);
            push (var_name)
            end;
         xframe := sp+pushinc;        (* XFRAME points to where return address will go. *)
         vsp := vsp + nargs*popinc;   (* Pop the arg values from the VPDL *)
         jump (u_f_1)
         end
      end
   end;  (* x_ufuncall *)

procedure x_uf1;
   begin
   if go_ptr <> lnil then begin fptr := go_ptr; go_ptr := 0 end
      else ulin_advance (fptr);
   if (fptr = lnil) or (stop_flag <> 0) then jump (u_f_2)
      else begin                (* if frame merge is flagged, do it *)
           get_uline (token_pointer,fptr,true);
           get_token (line_number,token_pointer);
           tokn_advance (token_pointer,true);
           push (u_f_1);
           jump (evline)
           end
   end; (* x_uf1 *)

procedure x_uf2;
   begin      (* here we pop a stack frame and return from ufuncall *)
           if stop_flag = 0 then outputn := 0;  (* S_OUTPUT would have set STOP_FLAG. *)
(* remember tail level Stuff... *)
           level_number := level_number - tail_levels;
           stop_flag := 0;
           pop_frame;
           pop (run_flag);
           pop (fptr);
           pop (fbody);
           pop (uformat);
           pop (uline_end);
           popj
   end; (* x_uf2 *)

procedure x_er1;
   begin
      run_flag := 0;
      if ((debug_switch = 0) and (error_flag <> xbrk))
          or (error_flag = xzap) or (level_number = 0)
         then begin error_flag := 0; pop_to_top end   (* Simple case: just exit for good *)
         else begin   (* Harder case: reset this frame and enter break (ttyoutput) loop *)
              error_flag := 0;
              reset_eval;
              expected_output := 0;
              jump (error_2)
              end
   end; (* x_er1 *)

procedure x_er2;
   begin
              if (dont_continue_flag <> 0)
                 then begin
                      stop_flag := 0;
                      dont_continue_flag := 0;
                      token_pointer := lnil;  (* Abort the remainder of erroneous line *)
                      get_bigarray (uformat,frame+sf_format);
                      popj                 (* This returns from the EVLINE in *)
                      end                  (* which the error occurred. *)
                 else if (stop_flag <> 0) then
                         begin
                         get_bigarray (uformat,frame+sf_format);
                         popj
                         end  (* Ditto. *)
                        else  begin
                              write (ttyoutput,'L');
                              type_number (ttyoutput,level_number);
                              pread_line (token_pointer,tty);
                              if error_flag = 0 then
                                 begin
                                 push (error_2);
                                 uformat := list;
                                 jump (evline)    (* Do a break (ttyoutput)-loop EVLINE *)
                                 end
                              end
   end; (* x_er2 *)

procedure x_sr1;
   begin
   if (eof (workspace)) or (indev <> wfile) then jump (s_read_2) else
      begin
(*      if number_lines_read > compact_number_lines then
         begin
         number_lines_read := 0;
         garbage_collect
         end
       else number_lines_read := number_lines_read + 1; *)
      pread_line (iline,workspace);
      if error_flag <> 0 then begin error_flag := 0; jump (s_read_2) end else
         begin
         token_pointer := iline;   (* EVALUATE evaluates global variable TOKEN_POINTER. *)
         if edit_switch = 0 then begin push (s_read_1); jump (evline) end
            else begin
                 car (temp1,iline);
                 get_type (temp2,temp1);
                 if temp2 = fix then edline (iline)
                    else if ((indev = vdt) and (number_switch <> 0)) or (temp1 = pots)
                            or (temp1 = lend) or (temp1 = po) or (temp1 = printout)
                            or (temp1 = title) or (temp1 = erase)  or (temp1 = er)
                            or (temp1 = ti)
                           then begin push (s_read_1); jump (evline) end
                          else begin 
                               Cons (iline,diff1,iline,flist);
                               if error_flag = xzap then begin
                                                         push (s_read_1);
                                                         jump (evline)
                                                         end
                                  else begin edline (iline); jump (s_read_1) end
                               end
                 end
         end
      end
   end; (* x_sr1 *)

(* EVALUATE evaluates global variable TOKEN_POINTER. *)

procedure oevaluate;

   begin (* evaluate *)
if error_flag = 0 then
   begin
   sp := pdlbase;
   vsp := vpdlbase;
   expected_output := 0;
   run_flag := 0;
   stop_flag := 0;
   dont_continue_flag := 0;
   error_flag := 0;
   level_number := 0;
   line_number := 0;
   frame := 0;
   xframe := 0;
   uformat := list;
   push (0);      (* top-level return address *)
   jump (evline); (* execute the line of code pointed to by TOKEN_POINTER *)

   while pc <> 0 do   (* main EVALUATE case dispatch to simulate flexible control structure *)
      case pc of

                     (* EVLINE is called with TOKEN_POINTER pointing to a line of code to
                        evaluate.  This may be either at top-level, where the line was typed
                        in by the user, or within some nesting of user functions.
                        
                        EVLINE will either return via POPJ or will escape to top-level,
                        popping the pdl (including stack-frames) and vpdl as necessary. *)

evline: begin
   push_test;
   vpush_test; if error_flag = 0 then
      begin
      vpop_test;

      push (expected_output);
      expected_output := 0;
      push (if_level);
      if_level := 0;
      if (token_pointer <> lnil)
         then begin
              get_token (temp1,token_pointer);	(* first thing on the line *)       
              get_type (temp1,temp1);
              if (temp1 = latom) then tokn_advance (token_pointer,true);
              end;
      jump (evline_1)
      end
 end;
evline_1: begin
   if (token_pointer = lnil) or (stop_flag <> 0) then begin
                                                   pop (if_level);
                                                   pop (expected_output);
                                                   popj
                                                   end
      else begin
           push (evline_1);
           jump (eval_expression)
           end
 end;

(* ...in the scope of EVALUATE *)
                           (* EVAL_EXPRESSION is called with argument IF_LEVEL. This routine
                              executes the first expression in the line pointed to by
                              TOKEN_POINTER, advancing TOKEN_POINTER past the evaluated
                              expression.
                              A value may be left on the vpdl. OUTPUTN is set
                              accordingly. *)
eval_expression: begin
   push (precedence);  (* Call EVAL with arguments IF_LEVEL=IF_LEVEL, PRECEDENCE=0 *)
   precedence := 0;
   push (ev_ex_1);
   jump (eval)
 end;
ev_ex_1: begin
   pop (precedence);   (* restore old args *)
   popj   (* and return *)
end;

(* We are gathered here in the scope of EVALUATE. EVAL, the core of the evaluator,
   follows as a case of EVALUATE.

   EVAL is called with arguments PRECEDENCE and IF_LEVEL.
   EVAL evaluates the first expression in the line pointed to by TOKEN_POINTER, advancing
   TOKEN_POINTER past the evaluated expression.
   A value may be left on the vpdl. OUTPUTN is set accordingly.

  EVAL dispatches to one of the following:
   EVAL_WRAP_UP
   PAREN_LOOP
   UFUNCALL
   SFUNCALL
each of which pushes 0 or 1 values onto the value stack and sets OUTPUTN accordingly.
All of the above routines converge to EVAL_WRAP_UP *)

eval: x_eval;

eval_1: begin
        pop (precedence);
        jump (funcall)
        end;

paren_loop: begin
get_function (funct,funtype,next_token);
if funct <> novalue then get_nargs (nargs,funct,funtype);
if (funct <> novalue)
    and (nargs < 0)
   then begin   (* variable-arg expression *)
        get_precedence (precedence,funct,funtype);
        current_token := next_token;
        tokn_advance (token_pointer,true);
        nargs := 0;
        push (funct); push (funtype);
        jump (var_arg_loop)
        end
   else begin   (* infix-expression *)
        push (expected_output);
        expected_output := 1;
        push (if_level);
        if_level := 0;
        push (p_l_1);
        jump (eval_expression)
        end
end;

p_l_1:  begin
        pop (if_level);
        pop (expected_output);
        if token_pointer = lnil then error (xeol,0,0) else
           begin
           get_token (next_token,token_pointer);
           if next_token = rpar
              then begin
                   tokn_advance (token_pointer,true);
                   popj
                   end
              else error (xtip,next_token,0)
           end
end;

(* ...in the scope of EVALUATE *)

var_arg_loop: begin
get_token (next_token,token_pointer);
if next_token = rpar
   then begin
        pop (funtype); pop (funct);
        tokn_advance (token_pointer,true);
        nargs := -nargs-1;
        jump (funcall1)
        end
   else begin
        push (nargs);
        push (next_token);
        push (expected_output);
        expected_output := 1;
        push (if_level);
        if_level := 0;
        push (precedence);
        push (v_a_l_1);
        jump (eval)
        end
end;

v_a_l_1: begin
        pop (precedence);
        pop (if_level);
        pop (expected_output);
        pop (next_token);
        pop (nargs);
        if outputn = 0 then error (xnop,next_token,0)
           else begin
                nargs := nargs + outputn;
                jump (var_arg_loop)
                end
end;

(* ...in the scope of EVALUATE *)

arg_loop: begin
if nargs = 0 then popj
   else begin
        nargs1 := nargs;
        push (nargs); push (funct); push (funtype);
        push (expected_output);
        push (if_level);
        jump (a_l_1)
        end
 end;
a_l_1: begin
        get_token (next_token,token_pointer);
        push (next_token);
        push (nargs1);

        expected_output := 1;
        if_level := 0;
        push (precedence);
        push (a_l_2);
        jump (eval)
 end;
a_l_2: begin
        pop (precedence);
        pop (nargs1);
        pop (next_token);
        if outputn = 0 then error (xnop,next_token,0)
           else begin
                nargs1 := nargs1 - outputn;
                if nargs1 = 0 then begin
                                   pop (if_level);
                                   pop (expected_output);
                                   pop (funtype); pop (funct); pop (nargs);
                                   popj
                                   end
                   else if nargs1 < 0 then error (xtmo,next_token,0)
                           else jump (a_l_1)
                end
end;

(* ...in the scope of EVALUATE *)

run_handler: begin
   push (uformat);
   push (uline_end);
   uformat := list;
   vpush (token_pointer);
   token_pointer := arg1;
   push (run_flag);
   run_flag := 1;
   push (r_h_1);
   jump (evline)
 end;
r_h_1: begin
   pop (run_flag);
   vpop (token_pointer);
   pop (uline_end);
   pop (uformat);
   popj
end; (* run_handler *)

s_read_1:
   begin
   x_sr1
   end; (* s_read_1 *)

s_read_2:
   begin
   close (workspace);
   indev := vdt;
   if error_flag = 0 then
      begin
      outputn := 0;
      popj
      end
   end; (* s_read_2 *)

(* ...in the scope of EVALUATE *)

eval_wrap_up: x_ev_wrap_up;

e_w_1: begin
                                pop (precedence);
                                pop (if_level);
                                pop (expected_output);
                                pop (funtype);
                                pop (funct);
                                pop (next_token);
                                if outputn = 0 then error (xnop,next_token,0)
                                   else begin
                                        nargs := 2;
                                        jump (funcall)
                                        end
end;

eval_return: begin
if frame <> 0 then nest := nest-1;
pop_test;
if (outputn <> 0) and (expected_output = 0) and (stop_flag = 0) and (run_flag = 0)
then begin
        vpop (next_token);
        error (xuop,next_token,0)
        end
   else begin
        pop (current_token);
        popj
        end
end;

(* ...in the scope of EVALUATE *)

(* FUNCALL is called with FUNCT => an sfun or a ufun.  FUNTYPE sez which.  FUNCALL changes *)
(* FBODY1 to hold either the function text (ufun) or function # (sfun), and dispatches to *)
(* SFUNCALL or UFUNCALL *)

funcall: begin
push (eval_wrap_up);
case funtype of
   sfun: begin
         fbody1 := sarray[funct + sa_sindex];
         x_sfuncall
         end;
   ufun: begin
         cdr (fbody1,funct);
         x_ufuncall
         end;
   otherwise system_bug
end
end;

funcall1: begin     (* FUNCALL1 is like FUNCALL except it gets called when already *)
                    (* immediately inside an sfun (eg LPAR calls FUNCALL1). The only *)
case funtype of     (* difference is that EVAL_WRAP_UP isn't pushed on the stack here *)
   sfun: begin
         fbody1 := sarray[funct + sa_sindex];
         x_sfuncall   (* cuz it's already there. *)
         end;
   ufun: begin
         cdr (fbody1,funct);
         x_ufuncall
         end;
   otherwise system_bug
end
end;

u_f_1: x_uf1;

u_f_2: x_uf2;

(* ...in the scope of EVALUATE *)

error_1: x_er1;

error_2: x_er2; (* last EVALUATE case statement *)

otherwise system_bug (* except for this one *)


end (* main EVALUATE case statement *)
end
end; (* oevaluate *)

procedure evaluate;
   var caller: integer;
   begin
   caller := current_overlay;
   overlay (evaluate_overlay);
   oevaluate;
   overlay (caller)
   end; (* evaluate *)

(* program to tokenize a logo line *)

procedure oread_line (var iline: integer; var f: chfil);

const	maxchars = 250;			(* size of line buffer *)
	max_num_levels = 10;		(* max depth of nested lists in input string *)
	new_line = 100;			(* case indexes in 'allocate_list_cell' *)
	new_list = 200;
	regular_cell = 300;

var 	charindex, tokenlength, linelength, list_level,
		temp, curr_cell_type : integer;
	level_array : array[1..max_num_levels] of integer;
	linearray : array[1..maxchars] of char;
	tokenarray : array[1..maxchars] of char;
	token_is_self_delim,funny_pname,qflag : boolean;

procedure getline;  (* this proc. puts an input line into 'linearray' *)
	var onechar: char;
	begin
		linelength := 0;
		readln (f);
		while (not eoln (f)) and (not eof (f)) and (linelength < maxchars - 1) do
			begin
			linelength := linelength + 1;
                        read (f,onechar);
                        if (ord (onechar) >= ord ('a')) and  (* Upper-casify *)
                           (ord (onechar) <= ord ('z'))
                         then onechar := chr (ord (onechar) + ord ('A') - ord ('a'));
                        linearray[linelength] := onechar
			end;
                if linelength < maxchars-1 then linearray[linelength+1]:=' '; (* Fence. *)
                stop_peek;
                if (eof (f)) and (indev = vdt) then reset (tty)
	end;


function self_delimiter_p (var onechar: char): boolean;
   begin
   if qflag then self_delimiter_p := (onechar = ' ') else (* QATOMS are terminated only
                                                             by a space. *)
      case onechar of
         ' ', '<', '>', '=', ';', '(', ')',
         '+', '-', '*', '/', '[', ']':
         self_delimiter_p := true;
         otherwise self_delimiter_p := false
         end
   end;

procedure t_get_token;
   var got_it: boolean;
   begin
   tokenlength := 0;
   token_is_self_delim := false;
   funny_pname := false;
   got_it := false;
   qflag := false;    (* QFLAG is true iff building a quoted atom.  In that case, only
                         space counts as a self_delimiter. *)
   while (linearray[charindex] = ' ') and
         (charindex <= linelength) do
         charindex := charindex + 1;   (* skip over blanks *)
   if not (charindex > linelength) then
      if self_delimiter_p(linearray[charindex]) then
         begin
         tokenlength := 1;
         tokenarray[1] := linearray[charindex];
         charindex := charindex + 1;
         token_is_self_delim := true;
         end
        else begin
             if linearray[charindex] = '"' then qflag := true;
             if linearray[charindex] = '''' then begin
                                                 funny_pname := true;
                                                 charindex := charindex+1
                                                 end
               else
                begin
                if ((linearray[charindex]=':') or (linearray[charindex]='"'))
                    and (linearray[charindex+1]='''') then
                   begin
                   funny_pname := true;
                   tokenarray[1] := linearray[charindex];
                   tokenlength := 1;
                   charindex := charindex+2;
                   end
                end;
             repeat  (* Gobble new character each time around. *)
                tokenlength := tokenlength + 1; (* TOKENLENGTH indexes into the token-being- *)
                if funny_pname and (linearray[charindex]='''')(*built, CHARINDEX indexes *)
                   and (linearray[charindex+1]='''') then     (*into the line whence it comes*)
                   charindex := charindex+1; (* Watch out for '' *)
                tokenarray[tokenlength] := linearray[charindex];
                charindex := charindex + 1;
                if funny_pname and (linearray[charindex]='''') and
                   (linearray[charindex+1]<>'''') then
                   begin
                   got_it := true;
		   charindex := charindex+1
		   end;
                until ((not funny_pname) and
                       (self_delimiter_p(linearray[charindex]))) or 
                      got_it or
                      (charindex > linelength)
             end
   end;

(* The procedure 'Atomize' takes the token in 'tokenarray' of length 'tokenlength' and *)
(* does things like creating an atom out of it, calling the 'Intern' procedure, etc... *)
(* 'Atomize' is called with one integer arg, 'cell_ptr', which is a pointer to a Cons  *)
(* cell.  When Atomize finishes, the car of this cell points to the atom created. *)
(* 'Atomize' recognizes fixnums, atoms, qatoms, and datoms. *)
(* global variables used: tokenarray[], tokenlength, fix, qatom, datom, atom *)
procedure Atomize;

	var	p, val_tok, pointer, temp, token_type, char_ptr, head_of_atom: integer;
		token_is_number_p: boolean;

	(* this subprocedure takes the next one or two chars in tokenarray and creates *)
	(* a Cons cell with the one or two chars in the car of the Cons cell *)
	procedure next_two_chars (var ans: integer);
		begin
		if char_ptr = tokenlength then
			Cons (ans, ord(tokenarray[char_ptr]), 0,string)
		else if char_ptr < tokenlength then
			Cons (ans,
			     ord(tokenarray[char_ptr]) + ord(tokenarray[char_ptr + 1]) * 256,
			     0,
                             string);
                if error_flag <> xzap then char_ptr := char_ptr + 2
		end;

	(* this function tests whether a character is a digit *)
	function digitp (onechar: char): boolean;
                begin
         		digitp := ( ord(onechar) >= ord('0') ) and ( ord(onechar) <= ord('9') )
                end;

begin
	token_is_number_p := true;	(* let us assume the token is a fixnum *)
	p := 1;
	val_tok := 0;
	while	token_is_number_p and	(* try to construct value of the fixnum *)
		not (p > tokenlength) do
		if digitp(tokenarray[p]) then
			begin
			val_tok := val_tok * 10 + ord(tokenarray[p]) - ord('0');
			p := p + 1
			end
		else token_is_number_p := false;
	if token_is_number_p then begin	(* if we have a fixnum, make a Cons cell *)
                Cons (pointer, val_tok, 0,fix);
                if error_flag <> xzap then rplaca(cell_ptr, pointer)
		end
	else begin
		if tokenarray[1] = '"' then begin	(* check for quoted atom *)
			token_type := qatom;
			char_ptr := 2		(* ignore first char *)
			end
		else if tokenarray[1] = ':' then begin	(* check for dotted atom *)
			token_type := datom;
			char_ptr := 2
			end
		else if tokenarray[tokenlength] = ':' then begin (* check for label atom *)
			token_type := latom;
			char_ptr := 1;
			tokenlength := tokenlength - 1  (* ignore the : from now on *)
			end
		else begin
			token_type := atom;		(* 'normal' atom *)
			char_ptr := 1
			end;

		(* now, build up the atom pname. *)

		if char_ptr > tokenlength then 	(* take care of empty word *)
                   begin
                   pointer := lnil;
                   head_of_atom := lnil;
                   rplaca (cell_ptr,lnil)
                   end
		else begin
                        next_two_chars(pointer);
                        if error_flag <> xzap then
                           begin
                           rplaca(cell_ptr, pointer);
                           head_of_atom := pointer;
                           while (char_ptr <= tokenlength) and (error_flag <> xzap) do begin
                                next_two_chars(temp);
                                if error_flag <> xzap then
                                   begin
                                   rplacd(pointer, temp);
                                   pointer := temp
                                   end
				end
                           end
			end;

		(* at this point, 'head_of_atom' points to first cell of atom pname *)

                if error_flag <> xzap then
                   begin
                   Intern (head_of_atom, head_of_atom);
                   if error_flag <> xzap then
                      begin
                      if token_type <> atom then put_type (head_of_atom, token_type);
                      rplaca(cell_ptr, head_of_atom);	(* in case 'Intern' changed the *)
                                                        (* value of 'head_of_atom' *)
                      if funny_pname then put_strange_pname (head_of_atom)
                      end
                   end
		end
end;

(* The procedure 'allocate_list_cell' calls Cons to allocate a cell, and then links this *)
(* cell back into the token list that 'read_line' builds.  Depending on whether the list *)
(* cell was the beginning of the line (iline), the beginning of a new sublist, or a regular *)
(* token, this procedure 'hooks up' the new cell in different ways. *)
procedure allocate_list_cell (var ans: integer);

	var temp: integer;

begin
        Cons (temp, 0, 0, list);		(* allocate a new list cell *)
        if error_flag <> xzap then
           begin
           case curr_cell_type of      (* 'Hook up' the new cell in one of a few ways *)
		new_line:
			iline := temp;
		new_list:
			rplaca(ans, temp);
		otherwise
			rplacd(ans, temp)
		end;
           ans := temp;			(* new current cell *)
           curr_cell_type := regular_cell
           end
end;

begin (* read_line *)
	charindex := 1;
	list_level := 0;
	iline := 0;
	cell_ptr := 0;
	curr_cell_type := new_line;

	getline;
	t_get_token;

	while (tokenlength > 0) and (error_flag <> xzap) do begin  (* process all tokens *)
		if token_is_self_delim and (tokenarray[1] = '[') then	(* new sublist *)
			begin
			list_level := list_level + 1;
			if list_level > max_num_levels then begin
				write (ttyoutput, 'Reader error: too many sublists');
                                breakl (ttyoutput) end;
                        allocate_list_cell(cell_ptr);
                        if error_flag <> xzap then
                           begin
                           level_array[list_level] := cell_ptr;
                           curr_cell_type := new_list
                           end
			end
	   else if token_is_self_delim and (tokenarray[1] = ']') then	(* end of sublist *)
			begin
			if list_level = 0 then begin
				write (ttyoutput, 'You have mismatched brackets');
                                breakl (ttyoutput) end;
			cell_ptr := level_array[list_level];
			list_level := list_level - 1;
			curr_cell_type := regular_cell
			end
	   else begin
                        allocate_list_cell(cell_ptr);
                        if error_flag <> xzap then
                           begin
                           Atomize;  (* Pass value in CELL_PTR *)
                           if error_flag <> xzap then curr_cell_type := regular_cell
                           end
			end;
                if error_flag <> xzap then t_get_token
		end;

        cell_ptr := lnil;
        if error_flag <> xzap then
           begin
           for temp := list_level downto 1 do write (ttyoutput, ']');
           if list_level <> 0 then print (lnil)
           end
end; (* oread_line *)

procedure pread_line; (* var iline: integer; var f: chfil *)
   begin
   if indev = vdt then
      begin
      if edit_switch = 0 then write (ttyoutput,'?')
         else write (ttyoutput,'>');
      break (ttyoutput);
      end;
   read_line (iline,f)
   end; (* pread_line *)

procedure read_line; (* var iline: integer; var f: chfil *)
   var caller: integer;
   begin
   caller := current_overlay;
   overlay (read_line_overlay);
   oread_line (iline,f);
   overlay (caller)
   end; (* read_line *)

(* EDLINE is called by TOPLOOP when in edit mode.
   TOKEN_POINTER is not to be evaluated, but rather added to the definition
   of the procedure being defined.  If a line number is supplied explicitly,
   that's the one that's used; otherwise, the default line number is 10 greater
   than the previous highest line number-- ie, the new line goes at the end. *)
procedure oedline (token_pointer: integer);
   var number,temp: integer; found: boolean;
   procedure put_line (number,token_pointer: integer);
      var line: integer;
      begin
      find_line (line,found,edit_body,number);
      if found then rplaca (line,token_pointer)
         else begin
              cdr (temp,line);
              Cons (temp,token_pointer,temp,list);
              if error_flag <> xzap then rplacd (line,temp)
                 else begin breakl (ttyoutput); zap_message; breakl (ttyoutput) end
              end
      end; (* put_line *)

   procedure get_highest (var ans: integer; body: integer);
      var line,number: integer;
      begin
      ans := 0;
      cdr (body,body);  (* Skip past arg list *)
      while body <> lnil do
         begin
         car (line,body);
         cdr (body,body);
         car (number,line);
         if number > ans then ans := number
         end
      end; (* get_highest *)

   begin (* oedline *)
   car (number,token_pointer);
   car (number,number);
   if number = -1 then
      begin
      get_highest (number,edit_body);
      number := number + 10
      end;
   rplaca (token_pointer,number);
   put_type (token_pointer,flist);
   put_line (number,token_pointer)
   end; (* oedline *)

procedure edline; (* token_pointer: integer *)
   var caller: integer;
   begin
   caller := current_overlay;
   overlay (edit_overlay);
   oedline (token_pointer);
   overlay (caller)
   end; (* edline *)

(* TOPLOOP is the main loop. It alternately calls PREAD_LINE and EVALUATE; except, in
   edit mode, EDLINE is called instead of EVALUATE (except for END, PO, etc, which are
   evaluated even in edit mode). *)
procedure toploop; (* var f: chfil *)
   begin
   pread_line (iline,f);
   if error_flag <> 0 then error_flag := 0 else
      begin
      token_pointer := iline;           (* EVALUATE evaluates global variable TOKEN_POINTER. *)
      if edit_switch = 0 then evaluate
         else begin
              car (temp1,iline);
              get_type (temp2,temp1);
              if temp2 = fix then edline (iline)
                 else if ((indev = vdt) and (number_switch <> 0)) or (temp1 = pots)
                         or (temp1 = lend) or (temp1 = po) or (temp1 = printout)
                         or (temp1 = title) or (temp1 = erase)  or (temp1 = er) or (temp1 = ti)
                        then evaluate
                    else begin 
                         Cons (iline,diff1,iline,flist);
                         if error_flag = xzap then evaluate
                            else edline (iline)
                         end
              end
      end
   end; (* toploop *)

begin (* top level *)
ovly$ (0);
current_overlay := -1; current_suboverlay := -1;
initialize;
write (ttyoutput,'Welcome to LOGO'); breakl (ttyoutput);
while hello do toploop (tty)
end.
