from    testmc  import tmc_tid
from    testmc.mc6800  import  Machine, Instructions as I
import  pytest

object_file = 'src/mc68/cjsmon.p'

def loadbios(m, input=None, output=None):
    bioscode = '.build/obj/src/tmc68/bioscode.p'
    S = m.symtab
    m.load(bioscode, mergestyle='prefcur', setPC=False)
    assert S['charinport'] == S['charoutport']
    return m.setiostreams(S.charinport, input, output)

####################################################################
#   pr* - printing output

@pytest.mark.parametrize('val, char', (
    (0x00, b'0'), (0x01, b'1'), (0x0E, b'E'), (0x0F, b'F'),
    (0x10, b'0'), (0xFE, b'E'),
), ids=tmc_tid)
def test_prnyb(m, S, R, val, char):
    _, output = loadbios(m)
    m.call(S.prnyb, R(a=val))
    assert char == output.getvalue()

@pytest.mark.parametrize('val, chars', (
    (0x00, b'00'), (0x0F, b'0F'), (0xA0, b'A0'), (0xFF, b'FF'),
), ids=tmc_tid)
def test_prhex(m, S, R, val, chars):
    _, outchars = loadbios(m)
    m.call(S.prhex, R(a=val))
    assert chars == outchars.getvalue()

####################################################################
#   q* - parsing

@pytest.mark.parametrize('testno, N, result, consumed, input', (
    ( 0,  1, 0xDEAD,  0, b''),
    ( 1,  1, 0xDEAD,  0, b'G'),
    ( 2,  1, 0xDEAD,  0, b'g'),
    ( 3,  0, 0x000F,  1, b'F'),
    ( 4,  0, 0x00A0,  2, b'A0'),
    ( 5,  0, 0x0B19,  3, b'B19'),
    ( 6,  0, 0x1234,  4, b'1234'),
    ( 7,  0, 0x0123,  4, b'01234'),
    ( 8,  0, 0xabcd,  4, b'aBcdE'),
), ids=tmc_tid)
def test_qhexword(m, S, R, testno, N, result, consumed, input):
    #   We re-use another routine's space.
    #   Change the address from test to test.
    buf = S.rdlinebuf + testno
    m.deposit(buf, input + b'\x00')
    print('buf=${:04X} {}'.format(buf, m.bytes(buf, len(input))), end='')
    m.depword(S.hexword, 0x9999)    # definitely not our output value

    m.call(S.qhexword, R(x=buf))
    hexword = m.word(S.hexword)
    print('\t\tX={:04X} N={} hexword=${:04X}'.format(m.x, m.N, hexword))

    assert R(x=buf+consumed) == m.regs
    assert R(N=N) == m.regs
    if N == 0: assert result == hexword

####################################################################
#   rd* - read input

def test_rdchar(m, R, S):
    ' Mostly confirms that our test framework works. '
    chars = b'!\x00\x7F'
    inchars, _ = loadbios(m, chars)
    for char in chars:
        m.call(S.rdchar, R(a=0xEA))
        assert R(a=char) == m.regs

    #   Document how an attempt to read past available input fails.
    with pytest.raises(EOFError) as ex:
        m.call(S.rdchar)
    assert ex.match('No more input available')

@pytest.mark.parametrize('buf, input', (
    (b'',                   b'\r'),
    (b'a',                  b'a\r'),
    (b'jklm',               b'j_\bk_\x7Fl__\b\bm\r'),
    (b'',                   b'\b\x7F\b\r'),
    (b'ij',                 b'\b\x7Fgh\b\b\b\bij\r'),
    (b'\x01\n\x1F\x7E',     b'\x01\x00\n\x00\x1F\x00\x7E\r'),
))
def test_rdline(m, R, S, input, buf):
    TERM = b'END'
    istream, ostream = loadbios(m, input + TERM)
    m.deposit(S.rdlinebuf, b'\xA5'*40)
    m.call(S.rdline)

    assert R(x=S.rdlinebuf, C=0) == m.regs
    assert buf + b'\x00' == m.bytes(m.regs.x, len(buf)+1)

    assert TERM == istream.read(len(TERM))  # no unconsumed input

    def echo_of(readchars):
        out = []
        for i in readchars:
            if   i == 0:    pass                # NUL not echoed
            elif i == 0x7F: out.append(0x08)    # DEL echoes backspace
            elif i == 0x0D: out.append(0x0A)    # CR echos newline
            else:           out.append(i)
        return bytes(out)

    assert echo_of(input) == ostream.getvalue()

def test_rdline_ctrlC(m, R, S):
    istream, ostream = loadbios(m, b'pqr\bqp\x03END')
    m.call(S.rdline)
    assert [ R(x=S.rdlinebuf, C=1), b'pqqp\x00'             ] \
        == [ m.regs,                m.bytes(m.regs.x, 5)    ]
    assert b'END' == istream.read(3)
    assert b'pqr\bqp\a\n' == ostream.getvalue()   # BEL char sent

def test_rdline_rubout_at_beginning(m, R, S):
    istream, ostream = loadbios(m, b'\b\b\babc\b\r')

    #   Whatever happens to be just before the buffer may not be
    #   the best sentinel bytes, but we can't overwrite it because
    #   we don't know if something important might be there.
    prebuf = m.bytes(S.rdlinebuf - 4, 4)
    m.deposit(S.rdlinebuf, b'\xA5'*40)

    m.call(S.rdline)
    assert R(x=S.rdlinebuf, C=0) == m.regs
    assert prebuf + b'ab\x00' == m.bytes(m.regs.x - 4, 7)

def test_rdline_overflow(m, R, S):
    buflen = S.rdlinebuf_end - S.rdlinebuf
    bufinput = b'_' * (buflen - 3) + b'yz'
    istream, ostream = loadbios(m, bufinput + b'AB\r')

    postbuf = m.bytes(S.rdlinebuf_end, 4)
    m.call(S.rdline)

    expected_buf = bufinput + b'\x00' + postbuf
    actual_buf   = m.bytes(m.regs.x, len(expected_buf))
    assert [ R(x=S.rdlinebuf, C=0), expected_buf,   ] \
        == [ m.regs,                actual_buf,     ]

    #   A BEL for each char rejected when the buffer was full.
    assert bufinput + b'\a\a\n' == ostream.getvalue()

####################################################################
#   Command loop

def test_cmdloop_quitcmd(m, S, R):
    ' Minimal path that gets us through to exit. '
    #   Quit doesn't return to the parser loop; it manually removes the
    #   return address that .parse added. This means our JSRs/RTSs will
    #   match, so in this one case we can use m.call().
    istream, ostream = loadbios(m, b'Q\r')
    m.call(S.cmdloop)
    assert b'\n> Q\n' ==  ostream.getvalue()
    #   Make sure we exited at the point where we expected.
    assert R(pc=S.rtscmd) == m.regs

def test_cmdloop_cancel(m, S, R):
    ' Confirm that ctrl-C terminates input, ignores line. '
    istream, ostream = loadbios(m, b'^~123~^\x03' b'Q\r')
    m.call(S.cmdloop)
    assert b'\n> ^~123~^\x07\n' b'> Q\n' ==  ostream.getvalue()
    #   Make sure we exited at the point where we expected.
    assert R(pc=S.rtscmd) == m.regs

#   Because the parser loop sets up return addresses with PSH (continuation
#   passing style), m.call() will not see a JSR to match to each command's
#   RTS and thus exit after the first command. We get around this by
#   instead adding a quit command at the end of every test input and running
#   until we reach quitcmd, a unique location before monitor exit. (rtscmd
#   cannot be used for this because it's also used as a convenient branch
#   target for conditional RTS by other code.)

def cmdloop(m, S, R):
    m.setregs(R(pc=S.cmdloop))
    m.stepto(stopat=[S['quitcmd']], stopon=[0x00], maxsteps=10000)

def test_cmdloop_multicmd(m, S, R):
    ' Multiple command processing of the simplest possible commands. '
    istream, ostream = loadbios(m, b'^^ ^Q\r')
    cmdloop(m, S, R)
    assert b'\n> ^^ ^Q\n' b'\n\n\n' ==  ostream.getvalue()

def test_cmdloop_dump(m, S, R):
    istream, ostream = loadbios(m, b'a800\r 3Q\r')
    m.deposit(0xA800, b'ABCDEFGH')
    cmdloop(m, S, R)

    print(m.regs); print(m.bytes(m.regs.sp-8, 8))
    output = ostream.getvalue(); print(output)
    assert b'\nA800: 41 42 43 44 45 46 47 48\n' in output
    assert b'\n0003: ' in output

@pytest.mark.skip
def test_cmdloop_eachrts(m, S, R):
    ''' A (currently non-working) hack to do "selective trace," printing
        the current instruction, stack contents and buffer contents at a
        few points during execution.
    '''
    input = b'a800\r3Q\r'
    input = b'^ ^^Q\r'
    istream, ostream = loadbios(m, input)
    m.deposit(0xA800, b'ABCDEFGH')

    stackbase = m.regs.sp + 1
    def showstack():
        return '{:02X}{:02X} {:02X}{:02X} {:02X}{:02X} {:02X}{:02X}' \
            .format(*m.bytes(stackbase-8, 8))

    m.setregs(R(pc=S.cmdloop))
    level = 0
    print('{}                {}'.format(m.regs, showstack()))
    while True:
        m.stepto(stopon=[I.JSR, I.BSR, I.RTS, I.PSHA],
            stopat=[ S['rtscmd'], S['cmdloop.parse'] - 1 ])
        r = m.regs
        opcode = m.byte(r.pc)
        if   opcode == I.PSHA:
            level += 1
            inst = 'PSH'
            dest = S['cmdloop.parse']
        elif opcode == I.JSR:
            level += 1
            inst = 'JSR'
            dest = m.word(r.pc+1)
        elif opcode == I.BSR:
            level += 1
            inst = 'BSR'
            dest = r.pc + 2 + m.byte(r.pc+1)
        else:
            level -= 1
            inst = 'RTS'
            dest = 0
        print('{} {:3d} {} {:04X}   {}   {}'
            .format(r, level, inst, dest, showstack(), m.bytes(r.x, 6)))

    assert 0
