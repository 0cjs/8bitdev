from    testmc  import *
from    testmc.mc6800  import *
import  pytest

R = Machine.Registers

test_rig = '''
            cpu 6800
            org $1000

pmon_ramlo  equ $0080
pmon_org    equ $1000
            include src/mc68/std.a68
            include src/tmc68/bios.a68
            include src/pmon/pmon.a68

; ----------------------------------------------------------------------
;   Mock command table(s) for testing

            org $4FFF
cmdtbl_1
cmdentry_a  db  'a'             ; command character
            dw  $0000           ; command entrypoint (testing zeros here)
            db  'x',CTP_WORD    ; parameters
            db  'y',CTP_BYTE
            db  CTP_END

            db  CT_CONTINUE
            dw  cmdtbl_2

            org $5EEE
cmdtbl_2
cmdentry_n  db  'n'             ; command with no parameters
            dw  $1234
            db CTP_END

cmdentry_b  db  'b'
            dw  $100B
            db  'x',CTP_BYTE
            db  'y',CTP_WORD
            db  'n',CTP_NYBBLE
            db  'u',CTP_UVAR
            db  CTP_END

cmdentry_c  db  'c'
            dw  $100C
            db  CTP_END

cmdentry_X  db $18
            dw  $1018
            db  CTP_END

cmdentry_d  db  'd'
            dw  $100D
            db  CTP_END

            db  CT_END

;   $7FFF onward is pmon RAM areas, set up by tests

; ----------------------------------------------------------------------
'''

param       = pytest.mark.parametrize
WSNTNL      = 0xDEAD                    # word sentinel; 57005 decimal

####################################################################
#   Utility routines

@param('result, x, b', (
    ( 0x1000, 0x1000, 0x00 ),
    ( 0x2001, 0x2000, 0x01 ),
    ( 0x30FF, 0x3000, 0xFF ),
    ( 0x4100, 0x40FF, 0x01 ),
    ( 0x0001, 0xFFFF, 0x02 ),
))
def test_addXB(m, S, R, result, x, b):
    a = b ^ 0xA5
    inputs = R(x=x, b=b, a=a)
    print(inputs)
    m.call(S.addXB, inputs)
    assert R(x=result, a=a) == m.regs

@param('ctp_type_sym, ctp_len', [
    ('CTP_WORD', 2),
    ('CTP_BYTE', 1), ('CTP_NYBBLE', 1), ('CTP_UVAR', 1),
    #   XXX how to deal with boolean? need to look at _prev_ entry
    #       but how do we know if we have a previous entry?
])
def test_addBpvsize(m, R, S, ctp_type_sym, ctp_len):
    ctp_type = S[ctp_type_sym]
    addr = 0xA000 + ctp_type
    print('{}=${:02X} len={} addr=${:04X}'.format(
        ctp_type_sym, ctp_type, ctp_len, addr))
    m.deposit(addr, [ord('a'), ctp_type])   # param entry is paramchar, valtype
    m.call(S.addBpvsize, R(a=0xEA, b=0x10, x=addr))
    assert R(a=0xEA, b=0x10 + ctp_len, x=addr) == m.regs

@param('routine, pricount_in, pricount_out, output', [
    ('bs1', 0, 0, b''  ),   ('bsN', 0, 0, b''),
    ('bs1', 1, 0, b'\b'),   ('bsN', 1, 0, b'\b'),
    ('bs1', 2, 1, b'\b'),   ('bsN', 2, 0, b'\b\b'),
    ('bs1', 3, 2, b'\b'),   ('bsN', 3, 0, b'\b\b\b'),
])
def test_pri_bs(m, R, S, loadbios, routine, pricount_in, output, pricount_out):
    m.deposit(S.pricount, pricount_in)
    _, ostream = loadbios('tmc68')
    m.call(S['pri_' + routine])
    assert (pricount_out, output) == (m.byte(S.pricount), ostream.getvalue())

#   XXX possibly this can be merged somehow with test_pri_bs,
#       even if just the @param data?
@param('routine, pricount_in, pricount_out, output', [
    ('bs1', 0, 0, b'\a'),   ('bsN', 0, 0, b'\a'),
    ('bs1', 1, 0, b'\b\a'), ('bsN', 1, 0, b'\b\a'),
    ('bs1', 2, 1, b'\b\a'), ('bsN', 2, 0, b'\b\b\a'),
    ('bs1', 3, 2, b'\b\a'), ('bsN', 3, 0, b'\b\b\b\a'),
])
def test_errorbs(m, R, S, loadbios, routine, pricount_in, pricount_out, output):
    m.deposit(S.pricount, pricount_in)
    _, ostream = loadbios('tmc68')
    m.call(S['error' + routine])
    assert (pricount_out, output) == (m.byte(S.pricount), ostream.getvalue())

####################################################################
#   Command line, parameter and value parsing

@param('parser,   input,        valword, output', [
      #   Confirmed inputs
      ('byte',    b'fe ',       0xFEad,  b'e \b'            ),
      ('byte',    b'DC ',       0xDCad,  b'C \b'            ),
      ('word',    b'8 ',        0x0008,  b' \b'             ),
      ('word',    b'8765 ',     0x8765,  b'765 \b'          ),
      ('nyb',     b'F ',        0x0Fad,  b' \b'             ),
      #   Cancelled inputs of varying sizes
      ('byte',    b'\b',        WSNTNL,  b'\b'              ),
      ('byte',    b'9\b',       WSNTNL,  b'\b\b'            ),
      ('byte',    b'93\b',      WSNTNL,  b'3\b\b\b'         ),
      ('word',    b'\b',        WSNTNL,  b'\b'              ),
      ('word',    b'8\b',       WSNTNL,  b'\b\b'            ),
      ('word',    b'87\b',      WSNTNL,  b'7\b\b\b'         ),
      ('word',    b'8765\b',    WSNTNL,  b'765\b\b\b\b\b'   ),
      ('nyb',     b'\b',        WSNTNL,  b'\b'              ),
      ('nyb',     b'7\b',       WSNTNL,  b'\b\b'            ),
      #   Overrun errors
      ('byte',    b'9AB\b',     WSNTNL,  b'AB\b\a'          + b'\b\b\b' ),
      ('byte',    b'9ABCD\b',   WSNTNL,  b'AB\b\aC\b\aD\b\a' + b'\b\b\b'  ),
      #   Bad char errors
      ('byte',    b'9G ',       0x09ad,  b'G\b\a \b')   # XXX BROKEN
])
def test_qpval(m, R, S, loadbios, parser, input, valword, output):
    valaddr = 0x7000 + sum(input)
    m.depword(S.pvalp, valaddr)
    m.depword(valaddr, WSNTNL)

    #   pricount = number of printing chars echoed so far
    pricount = 1                            # the paramchar
    if input[0] >= ord(' '): pricount += 1  # first value char, if echoed

    m.deposit(S.pricount, pricount)
    istream, ostream = loadbios('tmc68', input[1:])

    m.call(S['qpval_' + parser], R(a=input[0]))
    assert (valword, output) == (m.word(valaddr), ostream.getvalue())

@param('cmdentry_sym, paramchar, valtype_sym, valoff', [
    ('cmdentry_b', 'n', 'CTP_NYBBLE', 3),
])
def test_paramlookup_success(m, R, S,
        cmdentry_sym, paramchar, valtype_sym, valoff):
    pchar = ord(paramchar)
    valstart = 0x9000 + pchar
    m.depword(S.cmdentry, S[cmdentry_sym])
    m.depword(S.cmdpvals, valstart)
    m.call(S.paramlookup, R(a=pchar, b=0x7F, C=True))
    assert (R(a=pchar, C=False, b=S[valtype_sym]), valstart + valoff) \
        == (m.regs,                                m.word(S.pvalp))

def test_paramlookup_failure(m, R, S):
    m.depword(S.cmdentry, S.cmdentry_b)
    m.call(S.paramlookup, R(a=0xFF))
    assert R(C=True) == m.regs

@param('cmdchar, cpvals_offset', [
    #   The vals offsets are calculated by hand from the test command tbl above.
    ('a', 0), ('b', 3), ('c', 8), ('d', 8),
    ('\x18', 8),    # Ctrl-X
])
def test_cmdlookup_success(m, S, R, cmdchar, cpvals_offset):
    if cmdchar >= ' ':
        symname = 'cmdentry_' + cmdchar
    else:
        #   Control-char commands use upper case equiv. for test symbol
        symname = 'cmdentry_' + chr(ord(cmdchar) + ord('@'))

    m.depword(S.cmdtbl, S.cmdtbl_1)
    m.depword(S.cmdpvbase, 0x7FFD)

    m.call(S.cmdlookup, R(a=ord(cmdchar), x=0xFFFF, C=1))

    cmdentry = m.word(S.cmdentry); print('entry:', m.hexdump(cmdentry, 9))
    cmdpvals = m.word(S.cmdpvals); print('pvals:', m.hexdump(cmdpvals, 9))
    assert (ord(cmdchar), False, S[symname], 0x7FFD+cpvals_offset) \
        == (m.a,          m.C,   cmdentry,   cmdpvals)

@param('cmdchar', [0xFF, 0x00, 0x01, ord('Z')])
def test_cmdlookup_failure(m, S, R, cmdchar):
    m.depword(S.cmdtbl, S.cmdtbl_1)
    cmdpvbase = 0x7FFF + cmdchar    # test at different locations
    m.depword(S.cmdpvbase, cmdpvbase)
    #   Length of variables area below manually calculated
    #   from CTP_* values in test command table above.
    cmdpvals_end = cmdpvbase + 8

    m.call(S.cmdlookup, R(a=cmdchar, x=0xFFFF, C=0))
    assert (R(C=1, a=cmdchar), cmdpvals_end) == (m.regs,  m.word(S.cmdpvals))

####################################################################
#   Commands

def test_Cexamine(m, S, R, loadbios):
    _, ostream = loadbios('tmc68')
    data = 0x7161; params = 0x7061

    m.deposit(data, range(0x30, 0x60, 3))
    expected = b'''\
7161: 30 33 36 39 3C
7166: 3F 42 45 48 4B
716B: 4E 51 54 57 5A
'''

    m.depword(S.cmdpvals, params)
    m.depword(params, data)     # start addr
    m.deposit(params+2, 3, 5)   # lines, bytes per line

    m.call(S.Cexamine)
    assert expected == ostream.getvalue()

def test_Cregs(m, S, R, loadbios):
    _, ostream = loadbios('tmc68')
    m.deposit(0x5000, [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x12])
    m.depword(S.cmdpvals, 0x5000)
    m.call(S.Cregs)
    assert b'p0123 s4567 f89 aAB bCD xEF12 \n' \
        == ostream.getvalue()
