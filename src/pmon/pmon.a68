;   pmon: a machine-language monitor

; ----------------------------------------------------------------------
;   Memory Configuration

;   The memory areas used by the monitor are configured by constants that
;   must be defined before this file included.
;
;   `pmon_ramlo` and `pmon_ramhi` are the two blocks of RAM storage
;   required by the monitor. Each may be anywhere in memory, but there is a
;   slight code size and performance benefit to having `pmon_ramlo` in the
;   direct page.
;
;   `pmon_ramhi` may be left undefined to place that area immediately after
;   `pmon_ramlo`
;
;   `pmon_org` sets the start of the code.
;
;   XXX define pmon_ramlo_end and pmon_ramhi_end? Test usefulness with
;   usage of these forward definitions.

;   Abort assembly with a clear message if an essential definition is missing.
    set ______,
    pushv , pmon_ramlo, pmon_org
    popv  , ______,     ______

; ----------------------------------------------------------------------
;   Standard functions, macros and definitions
;   (Much of this should probably be moved to `stddef`.)

;   ASCII character definitions
BEL         equ $07             ; bell ('\a')
BS          equ $08             ; backspace ('\b')
LF          equ $0A             ; line feed ('\n')
CR          equ $0D             ; carriage return ('\r')
CAN         equ $18             ; cancel (Ctrl-X)

;   Monitor definitions
PROMPT      equ '_'

;   Command table entries types
CT_END      equ $00             ; end of table/end of entry
CT_CONTINUE equ $01             ; continuation "command"
;   Command parameter value (paramval) types
;   XXX commented out ones below cannot be used until the unit tests
;       for addBpvsize() tests them
CTP_END     equ $00             ; end of parameters
CTP_WORD    equ $FF             ; parameter with word value
CTP_BYTE    equ $FE             ;     "      "   byte value
CTP_NYBBLE  equ $FD             ;     "      "   nybble value
CTP_UVAR    equ $FC             ;     "      "   user variable letter
;CTP_B7      equ %10000000       ;     "      "   boolean value stored in bit 7
;CTP_B6      equ %01000000       ;     "      "      "      "      "   "   "  6
;CTP_B5      equ %00100000       ;     "      "      "      "      "   "   "  5
;CTP_B4      equ %00010000       ;     "      "      "      "      "   "   "  4
;CTP_B3      equ %00001000       ;     "      "      "      "      "   "   "  3
;CTP_B2      equ %00000100       ;     "      "      "      "      "   "   "  2
;CTP_B1      equ %00000010       ;     "      "      "      "      "   "   "  1
;CTP_B0      equ %00000001       ;     "      "      "      "      "   "   "  0

; ----------------------------------------
;   "Low" area aimed at maximum gain from minimum direct page usage.
;   This does not actually _have_ to be in the direct page, however.
;
            org pmon_ramlo

;   It's a convention in this repo to have _[axbyij] zero pages words
;   defined for arithmetic routine parameters/returns/counters so we re-use
;   this here for temp space for non-arithemtic routines.
_a          ds  2
_x          ds  2               ; used by many generic `pr*` routines
_i          ds  1

tmpx        equ _a              ; for use within one routine only

pmon_ramlo_end equ *
;   Here we could check for and warn about direct page overflow, but
;   perhaps that's better left to the machine-specific code.

; ----------------------------------------
;   "High" area that gains little from being in the direct page.
;   (This may be because few instructions access it or because accesses are
;   usually with instructions that have no shorter direct page version.)
;   If `pmon_ramhi` is not defined, this starts immediately after `pmon_ramlo`.

    .ifdef pmon_ramhi
            org pmon_ramhi
    .endif

cmdtbl      ds  2       ; pointer to command table (see below)
cmdpvbase   ds  2       ; pointer to start of parameter values for all cmds
;   Saved register values (same memory order as interrupt stack frame):
Rcc         ds  1       ; condition codes
Rb          ds  1       ; accumulator B
Ra          ds  1       ; accumulator A
Rx          ds  2       ; index register X
Rpc         ds  2       ; program counter
Rsp         ds  2       ; stack pointer

pricount    ds  1       ; printed input count: how far we need to backspace to
                        ;   clear the currently pending or previous input value
cmdentry    ds  2       ; pointer to entry found by cmdlookup
cmdpvals    ds  2       ; pointer to start of parameter values for cmd above
pvalp       ds  2       ; printer to one particular value to read/print
                        ;   (don't use _x; that's used by printing routines)
qhex_out    ds  2       ; value we're building from user input


pmon_ramhi_end equ *

; ----------------------------------------
;   Parameter values, user variables, etc. start at pmon_ramhi_end unless
;   otherwise specified.

    .ifdef pmon_vars
            org pmon_vars
    .endif

cmdpvbase_default   equ     *

; ----------------------------------------------------------------------
;   Code

            org pmon_org

;   Our entry point is at the start, but immediately after that we place
;   (ROM-able) data that the user may want to easily view.
start       jmp init

banner      db 'pmon 2022-05-30 cjs',0

; ----------------------------------------------------------------------
;   Fixed ("ROM") command table. This is our default command table, but
;   users may override it by changing `cmdtbl` to point to their own
;   command table which usually would continue back to this after they
;   define their own commands.
;
cmdtbl_rom
            db  CAN             ; Ctrl-X. It might be nice if this were an
            dw  Cclearline      ;   "immediate effect" command, but not sure
            db  CTP_END         ;   it's worth it just for this.

            db  'b'
            dw  Cbanner
            db  CTP_END

            db  'x'
            dw  Cexit
            db  CTP_END

            db  'o'
            dw  Cout
            db  'a', CTP_WORD
            db  'v', CTP_BYTE   ; value to write
          ; db  'm', CTP_B7     ; use memory-mapped I/O; not present on 6800
            db CTP_END

            db  'r'
            dw  Cregs
            db  'p', CTP_WORD
            db  's', CTP_WORD
            db  'f', CTP_BYTE
            db  'a', CTP_BYTE
            db  'b', CTP_BYTE
            db  'x', CTP_WORD
            db  CTP_END

            db  CT_END

; ----------------------------------------------------------------------
;   Initialisation and command loop

init        ;   The machine state at this entry point may not be particularly
            ;   meaningful, but has some potentially useful information.
            psh A               ; cannot STA until flags are saved
            tpa
            sta A,Rcc
            pul A
            sta A,Ra
            sta B,Rb
            stx Rx
            tsx
            stx Rsp             ; just our own stack pointer
            lda A,1,X           ; saved PC shows where exit command will return
            sta A,Rpc
            lda A,2,X
            sta A,Rpc+1

            ldx #banner
            jsr prstr0
            jsr prnl

            ;   No need to init pricount since our first lineCR will do it.
            ldx #cmdtbl_rom
            stx cmdtbl
            ldx #cmdpvbase_default
            stx cmdpvbase
            ;   XXX Clear memory from cmdpvbase through length of params.
            ;       Possibly we should be testing it too, to ensure that
            ;       it's not accidentally overflowed RAM or whatever.

qcommand    ;   Commands RTS when done, so we set up the stack with a return to
            ;   here and JMP to the command. (Continuation-passing style.)
            lda A,#LB(qcommand)
            psh A
            lda A,#MB(qcommand)
            psh A

            jsr lineCR          ; ensure we're at beginning of line
            lda A,#PROMPT
            jsr prchar
            jsr rdcharep0
            jsr cmdlookup
            bcc .foundcmd
            ;   Backspace over the bad character (if it was printed),
            ;   signal error with a beep and continue with qcommand
            ;   via stacked continuation.
            bra errorbsN        ; RTS TCO

.foundcmd   jsr qparams         ; parse parameters
            bcc .execute        ; got CR to execute
            rts                 ; got cancel; use continuation to start parsing
                                ;   new command on this same line

.execute    jsr lineCR          ; we overwrite command entry
            ;   XXX Should we try to wipe the line with some spaces? Or just
            ;   leave it to output routines to decide how much to clear
            ;   after what they print?
            ldx cmdentry        ; load pointer to command table entry
            ldx 1,X             ; load execution addr of that command
            jmp ,X              ; command will RTS to above

; ----------------------------------------------------------------------
;   Backspace and error routines

;   Backspace over bad input characters (all N or just 1 chars echoed by
;   `rdcharep` since calling `rdcharep0` or `pricount` was last cleared)
;   and generate an error tone. The backspace does not overwrite the bad
;   input so that you see under the cursor the char that caused the error.
errorbsN    bsr pri_bsN
errorbs1    bsr pri_bs1         ; no effect if bsN ate all the pricount
errorbel    lda A,#BEL
            jsr prchar
            rts

;   ♣A Backspace over one "pending input" printed character, if we have one.
pri_bs1     tst pricount        ; did we print something we need to BS over?
            bne pribs_dec       ;   yes: print a backspace
pribs_rts   rts
pribs_dec   dec pricount
            lda A,#BS
            jmp prchar          ; RTS TCO
;   ♣A Backspace over all "pending input" printed characters, if any.
pri_bsN     tst pricount        ; "pending" input still printed?
            beq pribs_rts
            bsr pribs_dec       ;   yes: backspace over it
            bra pri_bsN         ;     and check again

; ----------------------------------------------------------------------
;   ♠Xc ♡A ♣B Starting at command table pointed to by `cmdtbl`, find the
;       entry in that table for char given in A, which is preserved.
;   • Failure: returns with carry set.
;   • Success: carry clear; `cmdentry` points to the entry in the command
;     table; `cmdpvals` points to the start of the parameter values for
;     that command.
;
cmdlookup   ldx cmdpvbase
            stx cmdpvals
            ldx cmdtbl

            ;   parse type of command table entry
.qentry     stx cmdentry        ; save the command entry we're checking
            lda B,,X            ; CT_END?
            beq .notfound       ;   yes: failure to match
            dec B               ; was 1, CT_CONTINUE?
            bne .cmd_entry      ;   no: it's a regular command entry
            ldx 1,X             ; load continuation address
            bra .qentry         ; continue parsing table

            ;   command entry
.cmd_entry  cmp A,,X            ; matches command letter?
            beq .found          ;   yes: we're done
            inx                 ; increment past command char
            inx                 ; increment past command exec addr
            inx                 ;   (may contain $00 values)
            lda B,#0            ; init size of paramvals
.next_param tst ,X              ; end of parameters (CT_END)?
            beq .param_end      ;   yes: get ready for next entry
            bsr addBpvsize      ; add this paramval size
            inx                 ; move past this parameter
            inx
            bra .next_param

.param_end  inx                 ; move forward to next entry
            stx cmdentry
            ldx cmdpvals        ; move cmdpvals
            bsr addXB           ;   forward to
            stx cmdpvals        ;   start of next command's values
            ldx cmdentry        ; XXX we have unnecessary loads/stores
                                ;   in this routine: refactor it
            bra .qentry

.notfound   sec                 ; indicate failure, X is don't-care
.found      ;   if found, carry clear on entry because we arrived via `beq`,
            ;   thus success already indicated
            rts

;   ♠B ♡AX  Add to B the storage size of the command table paramval spec
;           (paramchar byte followed by CTP_* paramtype byte) to which X points.
addBpvsize  psh A
            ;   XXX currently handles only byte and word lengths
            lda A,1,X
            cmp A,#CTP_WORD
            bne .notword
            inc B
.notword    inc B
            pul A
            rts

;   ♠B,pvalp ♣X ♡A  Look up command parameter given in A.
;
;   Enter with `cmdentry` pointing to the entry in the command table and
;   `cmdpvals` pointing to the first value entry for that command. (This is
;   the output of `cmdlookup`.)
;
;   If the char in A does not match a paramchar in `cmdentry` this will
;   return failure indicated by carry set. Otherwise, carry is clear, B
;   contains the value type (CPT_*) and `pvalp` points to the value location
;   at the appropriate offset past cmdpvals.
;
;   A, `cmdentry` and `paramval` are preserved.
;   XXX Possibly A need not be preserved, and perhaps should be retval.
;
paramlookup ldx cmdentry
            lda B,#0            ; offset to paramval
            inx                 ; skip command character
.next       inx                 ; skip paramchar (1st time: entrypoint MSB)
            inx                 ; skip paramtype (1st time: entrypoint LSB)
            cmp A,,X            ; this parameter matches?
            beq .match          ;   yes: collect information
            bsr addBpvsize      ; move to next parameter value
            tst ,X              ; CTP_END?
            bne .next           ;   no: try matching next param spec
            sec                 ; error flag
            rts
.match
            psh A
            lda A,1,X           ; param type
            ldx cmdpvals        ; to base of this command's paramval area
            bsr addXB           ;   add offset for this parameter
            stx pvalp
            tab                 ; param type to proper return register
            pul A
            clc
            rts

; ----------------------------------------------------------------------
;   Utility routines used nearby (so we can BSR instead of JSR)

;   ♠X♣B,tmpx  X ← X + B unsigned
addXB       stx     tmpx
            add     B,tmpx+1
            sta     B,tmpx+1
            bcc     .done
            lda     B,tmpx
            inc     B
            sta     B,tmpx
.done       ldx     tmpx
            rts

; ----------------------------------------------------------------------
;   Parameter parsing

;   Parse all parameters for a command, returning with carry clear
;   on execute or carry set if the command is cancelled.
;
;   This routine is responsible for reading the paramchar and interpreting
;   "non-parameter" command read at that point: space, execute, and cancel
;   command. Otherwise it passes the character on to qparamval which is
;   responsible for any further parameter input and errors, returning to
;   this when all is complete and we are ready to start paramchar input
;   again. (This routine does not know or care if the qparamval generated
;   an error or not.)
;
qparams     clr pricount        ; start of input is char we're about to read
            jsr rdcharep
            cmp A,#BS           ; we may still backspace over the command
            beq .cancel         ;   which will cancel the entire command
.checkchar  cmp A,#' '          ; when looking for a new param char, spaces
            beq .nextpchar      ;   are accepted and printed
            cmp A,#CAN
            beq .cancel
            cmp A,#CR
            beq .rts            ; = carry cleared: execute command
            bsr qparamval       ; process paramchar and further input,
                                ;   also handiling/displaying any errors
.nextpchar  jsr rdcharep0       ; start a new parameter read
            bra .checkchar

.cancel     lda #BS             ; we must also backspace over the command char
            jsr prchar          ;   XXX but broken if command char was non-print
            sec                 ; cancel indicator
.rts        rts

;   Parse character in A as a parameter, including any following value.
;   This assumes that the character has been echoed and handles backspacing
;   over it if it's not a valid paramchar.
;
;   Returns nothing. This handles all error checking and display, including
;   when the paramchar is bad, the value is bad, or the user cancels
;   paramval input.
;
;   Note that `qparams` above handles command execute/cancel (Return/Ctrl-X)
;   inputs; this does not. It's not clear if this should since the paramval
;   input then not only has to pass that information back up somehow but also
;   decide, e.g., does Ctrl-X cancel the paramval input?
;
qparamval   jsr paramlookup     ; valid parameter char?
            bcc .readvalue      ;   yes: read value
            jsr errorbsN        ;   no: indicate error and we're done
            rts

.readvalue  jsr rdcharep        ; first character of value
            ;   Space prints the current value of the param
            cmp A,#' '
            bne +
            jsr pri_bs1         ; backspace over the space and
            jsr ppval           ;   print the current value of that param
            rts
            ;   Value input; dispatch based on type.
            ;   (This also handles a backspace that cancels this parameter.)
+           com B               ; B from `paramlookup` above:
                                ; $FF,$FE,$FD,... → $00,$01,$02,...
                                ; XXX sets carry, do we need EOR B,#$FF ?
            asl B               ; double it to get index
            ldx #qpvaltab
            bsr addXB           ; add index
            ldx ,X              ; look up parser for this type
            clr qhex_out        ; clear area where we'll build the input value
            clr qhex_out+1
            jmp ,X              ; and start it (RTS TCO)

;   Parsers for the different types of parameter values. These are entered
;   with the first character already read into A and echoed, the value type
;   (CPT_*) in B and `pvalp` pointing to the value's location. (These
;   latter two are the return state of `paramlookup`.)
;
;   These are essentially the "bottom half" of `qparamval` and return
;   directly to qparams. Though they have a little bit in common (e.g.,
;   handling backspace to cancel paramval input), there's not enough there
;   to make it worth trying to push any of this up into the top half;
;   things like how we store the paramval we've read vary a lot with the
;   data type.
;
;   These use `qhex_out` for temporary storage while building the input
;   value. (XXX This is partly because that symbols is required by
;   `qhexword` etc. from qhex.a68, which we routines we actually dont' use
;   and should not include.)
;
;   XXX These need unit tests and then can probably be optimised into
;   something smaller.

qpvaltab    dw  qpval_word      ; $FF CTP_WORD
            dw  qpval_byte      ; $FE CTP_BYTE
            dw  qpval_nyb       ; $FC CTP_NYBBLE
            dw  qpval_uvar      ; $FD CTP_UVAR

qpval_word  lda B,#4            ; read up to four digits
            jsr qpval_hex       ; completed read returns here;
                                ;   canceled read returns to our caller
            jsr pri_bs1         ; back over the space that finished input
            ldx pvalp           ; to the paramval location
            lda A,qhex_out      ;   save the MSB
            sta ,X
            lda A,qhex_out+1    ;   and the LSB
            sta 1,X
            rts                 ; to `qparamval` caller

qpval_nyb   lda B,#1
            db  $7D             ; TST skips next two bytes
qpval_byte  lda B,#2            ; read up to two digits
            jsr qpval_hex       ; completed read returns here;
                                ;   canceled read returns to our caller
            jsr pri_bs1         ; back over the space that finished input
            ldx pvalp           ; to the paramval location
            lda qhex_out+1      ;   save the value we built
            sta ,X
            rts                 ; to `qparamval` caller

qpval_hex   cmp A,#BS           ; cancel entry?
            bne +               ;   no: skip
            pul A               ; remove caller's address from stack so it
            pul A               ;    doesn't try to store partial paramval read
            jmp pri_bsN         ; clear entry/paramchar (RTS TCO)

+           cmp A,#' '          ; completed entry?
            bne +               ;   no: continue entry
            rts                 ;   yes: caller will save the paramval
+           tst B               ; full on digits?
            bne +               ;   no: we can try to parse this one
            jsr errorbs1        ;   yes: don't accept it (waiting for space)
            bra .rdnext
+           jsr qhexdigit       ; valid digit?
            bpl +               ;   yes (N clear): add to value we're building
            jsr errorbs1        ;   no (N set): bad digit
                                ;   XXX prints BS even if rdcharep didn't echo
            bra ++
+           bsr add_digit
+           dec B               ; one less to read
.rdnext     jsr rdcharep
            bra qpval_hex

;   Add value in low nybble of A as next hex digit of qhex_out.
add_digit   ;   move value to high nybble
            asl A
            asl A
            asl A
            asl A
            ;   shift value into qhex_out
            asl A
            rol qhex_out+1
            rol qhex_out
            asl A               ; bit 2
            rol qhex_out+1
            rol qhex_out
            asl A               ; bit 3
            rol qhex_out+1
            rol qhex_out
            asl A               ; bit 4
            rol qhex_out+1
            rol qhex_out
            rts

qpval_uvar
            jsr pristr
            db  ":qpval_uvar:",0
            clc
            rts

            include "src/mc68/qhex.a68"     ; XXX should ifdef out unused stuff

; ----------------------------------------------------------------------
;   Print a paramval.
;
;   Enter with the the value type (CPT_*) in B and `pvalp` pointing to the
;   value's location. (This is the return state of `paramlookup`.)
;
ppval       ldx pvalp
            cmp B,#$81          ; ≤$80 is a boolean bit
            bcs .bitval

            inc B               ; $FF (CTP_WORD) → $00?
            bne +
            ldx ,X              ; print word
            jmp prhexX          ; RTS TCO

+           lda A,,X            ; all following ≤byte value from A
            inc B               ; $FE (CTP_BYTE) → $00?
            bne +
            jmp prhex           ; RTS TCO

+           inc B               ; $FD (CTP_NYBBLE) → $00?
            bne +
            jmp prnyb           ; RTS TCO

+           inc B               ; $FC (CTP_UVAR) → $00?
            bne +
            jmp prvischar       ; RTS TCO

+           jsr pristr          ; XXX
            db  "ppval BADTYPE",0
            rts

.bitval     jsr pristr          ; XXX
            db  ":ppval:BITVAL:",0
            rts

; ----------------------------------------------------------------------
;   Command implementations

;   Exit the monitor back to whatever called it.
Cexit       jsr prnl            ; leave prompt and command char on the screen
                                ;   so we see why we exited
            pul A               ; remove continuation return address so we
            pul A               ;   return to whatever called the monitor
            rts

;   Print spaces to clear off any text on the current line.
;   This is handy if you want to clear the command input line after
;   a ^X to cancel a previous command.
Cclearline  lda #' '
            ldb #30             ; avoid scrolling 32-column displays
-           jsr prchar
            dec B
            bne -
            lda #CR
            jsr prchar
            rts

;   Print the banner (XXX just for testing)
Cbanner     ldx #banner
            jsr prstr0
            jsr prspace         ; a few spaces to ensure end of string is clear
            jsr prspace         ;   if we had lots of parameters on line
            jmp prnl            ; RTS TCO

;   Send byte to output port etc.
Cout        db $02              ; end simulator w/invalid instruction

;   Modify/print registers
Cregs       db $03              ; end simulator w/invalid instruction


; ----------------------------------------------------------------------
;   pr* - printing output

            include "src/mc68/pr.a68"

;   ♡ABX Move to the start of the _current_ line, as a CR usually does.
;        Also clears `pricount` since we now have no printed input to BS over.
lineCR      psh a
            clr pricount
            lda A,#CR
            jsr prchar
            pul a
            rts

; ----------------------------------------------------------------------
;   rd* - reading input

;   ♠A  Blocking read and echo of one character with increment of
;   characters printed count `pricount`. Non-printing chars are not echoed
;   and pricount is not incremented, but the character is still returned.
;
;   The `rdcharep0` entry point will clear pricount before reading, indicating
;   that everything read before this read is to be consider valid, completed
;   input that should not be backspaced over if there's an error.
;
;   This converts DEL to BS because we have no special use for separating
;   the two in this system and it makes printable determination easier.
;
rdcharep0   clr pricount
rdcharep    jsr rdchar
            cmp A,#DEL          ; convert DEL to BS
            bne +
            lda A,#BS
+           cmp A,#' '          ; printable?
            bcs .rts            ;   no: we're done
            inc pricount
            jmp prchar          ; RTS TCO
.rts        rts
