;   Apple II monitor extension for doing hex+ASCII dumps.
;
;   The following routines are designed to extend the Monitor via the
;   Ctrl-Y command. To connect code starting at $HHLL to Ctrl-Y, enter a
;   JMP to its start point $HHLL at $3F8: `3F8: 4C LL HH`.
;
;   Most of the routines are PIC (Position-Independent Code) and may be
;   loaded anywhere. The $300-$3CF area is a common place for these. (Note
;   that EDASM claims to use this entire page, though I've seen it use only
;   the first dozen or so bytes of it.)
;
;   __Output from the monitor.__ The Monitor prompts and gets an input line
;   with GETLNZ, which always prints a newline before prompting, and not
;   after input. Therefore commands generating output always print a
;   newline first and do not print one after, and we follow this
;   convention. While this annoyingly generates a blank line after every
;   monitor input command, it ensures that multiple commands on an input
;   line generate output on their own lines.
;
;   For more details on how the Monitor works, see:
;   https://github.com/0cjs/sedoc/blob/master/8bit/apple2/monitor.md

            cpu     6502
            include "src/a2/def.a65"

            ;   The routine is location independent; we do not specify
            ;   the location here because we want to let the framework
            ;   that loads it do that. But here's a suggestion:
            ;org     $300

;   Argument and temporary address storage. See
;   https://github.com/0cjs/sedoc/blob/master/8bit/apple2/monitor.md

mnext       equ A1L         ; Next location to be printed;
                            ;    set by entering an address.
mend        equ A2L         ; End address; set to mnext when mnext set;
                            ;    `.` command changes it to following addr;
                            ;    cleared after following command.
mdest       equ A3L         ; Dest address copied from mnext by `<` command;
                            ;    cleared after any non-`.` command.
;PCL        equ PCL         ; Current PC set by `L` and `G` commands.

;---------------------------------------------------------------------
;   (PIC) Ctrl-Y entry: call one of our user commands
;
;   This should be entered via the Monitor user command, Ctrl-Y. On entry,
;   YSAV will have been set by the Monitor to point to the current position
;   in the input buffer.
;
;   Note that we must consume the char after the Ctrl-Y command if we take
;   it as a valid option for us, otherwise we must leave it so the Monitor
;   can carry on executing commands from that point in the line. (If it's a
;   CR that's no issue; the monitor executes that as a command to dump
;   memory only if it's the first char on the line.)
;
;   Not always consuming the following char is a convenient way to let us
;   have a "default" command and also ensure that the Monitor has a CR to
;   "execute" as termination of command-line parsing, but to avoid user
;   confusion it's best if the option char is never also a valid command to
;   the monitor.
;
;   This performs only relative branches to the selected subroutine, which
;   returns directly to the monitor with its RTS.

usrcmd      ; Ctrl-Y command entry point
            ldy YSAV
            lda IN,y        ; next char after the Ctrl-Y that got us here
            cmp #AA('A')
            beq dumpmonvar1
            bne hexdump     ; (BRA) nothing above matched

;---------------------------------------------------------------------
;   (PIC) dumpmonvar: print monitor UI variables
;
;   This prints the saved PC and the addresses/16-bit values stored in  A1
;   through A5. These are variables used by the monitor user interface for
;   command handling and "remembered" addresses.
;
;   This depends on COUT preserving X and Y. This is true for the screen
;   (PR#0), but may not be for other char switch (CSW) routines.
;

dumpmonvar1 ;   Entry point from usrcmd command dispatcher.
            ;   It matched the char following Ctrl-Y telling us to run this
            ;   routine, leaving the offset in Y, so we must skip past that
            ;   in the input buffer to have the Monitor start processing at
            ;   the following chars after we return.
            inc YSAV

dumpmonvar  jsr CROUT
            ldy #6              ; 6 words to display (PC, A1, ..., A5)
            ldx #PCL            ; first word to display
.nextA      lda #AA(' ')
            jsr COUT
            lda 1,x             ; high byte
            jsr PRBYTE
            lda 0,x             ; low byte
            jsr PRBYTE
            inx                 ; next word
            inx
            dey                 ; decrement count
            bne .nextA
            rts

;---------------------------------------------------------------------
;   (PIC) Memory dump in hexadecimal and characters.
;
;   In order to make life a bit more convenient, this differs from the
;   Monitor's standard memory dump command in the following ways:
;
;   * The "end" address argument is not the last address to be dumped, but
;     _one past_ the last address to be dumped. (This also makes the code
;     simpler.
;   * The saved PC is set to the start address of the dump, so that a
;     subsequent L or G command will use that location.
;
;   Notes:
;   * This depends on COUT preserving X and Y. This is true for the screen
;     (PR#0), but may not be for other char switch (CSW) routines.

hexdump
            ldy #0          ; Constant value for indexed addressing.

            ;   Set the PC (next address for the G and L commands)
            ;   to our start address, to make it convenient to list
            ;   or run what we just looked at.
            ;   This also serves as our saved start value for printing
            ;   the characters after the hex dump.
            lda mnext
            sta PCL
            lda mnext+1
            sta PCH

            ;   Print current address (followed by hyphen) and hex bytes
            ;   up to mod-8 boundary.
.nextline   jsr PRA1        ; generates required newline
.nexthex    lda #AA(' ')    ; space before every hex byte
            jsr COUT
            lda (mnext),y   ; and the data itself
            jsr PRBYTE
            inc mnext
            bne .checkend
            inc mnext+1
.checkend   ;   Check to see if we've reached the end.
            lda mend
            cmp mnext
            bne .checkline
            lda mend+1
            cmp mnext+1
            beq .finish
.checkline  lda mnext
            and #$07        ; A mod 8 == 0?
            beq .nextline
            bne .nexthex

.finish     rts

            ; XXX print the char values somehow.
