from    testmc  import tmc_tid
from    testmc.mos65  import  Machine
from    b8tool  import path
import  pytest

test_rig = '''
            cpu 6502
            org $1000
            include src/mos65/std.a65
            include src/mos65/reader.a65
'''

def qset(m, input):
    ''' Set `input` as the parser input, returning the ``q_point`` value. This
        does not explicitly terminate the input with 0, though that will
        happen "automatically" when the simulator started with zeroed memory.

        This also sets ``q_value`` to the sentinel $DEAD (57005), since any
        test about to do a parse probably would be doing this anyway.
    '''
    buf = 0x300 - 2 - len(input)
    m.deposit(buf, input)
    m.depword(m.symtab.q_point, buf)
    m.depword(m.symtab.q_value, 0xDEAD)
    return buf

@pytest.mark.parametrize('start, y, end', [
    (0x7123,    0, 0x7123),
    (0x7220,    1, 0x7221),
    (0x7FFF,    2, 0x8001),
    (0x8003, 0xFF, 0x8102),
], ids=tmc_tid)
def test_qYconsume(m, R, S, start, y, end):
    m.depword(S.q_point, start)
    m.call(S.qYconsume, R(y=y))
    assert (start, y, end) == (start, y, m.word(S.q_point))

#   Values to be returned by parsers
Alloc   = 'Alloc'           # Special: we expect an allocation from startcons

#   Parse success indicators
qA      = 'A'               # Always sucessful; ignore Z flag
qS      = 'S'               # Success: Z=1
qF      = 'F'               # Failure, Z=0

@pytest.mark.parametrize('qf, value, success, consumed, input', [
    #   qf: parser function
    #   value: expected value from the parser, `None` if failure (Z=0) expected
    #   success: qA, qS, qF (see above)
    #   consumed: the number input characters consumed (moving foward `q_point`)
    #   input: the input (bytestring) on which to run the parser function
    ('qspaces',     None,       qA,  0,  b'_'),
    ('qspaces',     None,       qA,  1,  b' _'),
    ('qspaces',     None,       qA,  3,  b'   _'),
    ('qLR',         None,       qF,  0,  b'_()'),
    ('qLR',         None,       qF,  0,  b'(('),
    ('qLR',         'nil',      qS,  2,  b'()'),
    ('qLR',         'nil',      qS,  4,  b'(  )'),
], ids=tmc_tid)
def testq(m, R, S, qf, value, success, consumed, input):
    if value is None: value = 0xDEAD    # sentinel set by qset
    if isinstance(value, str): value = S[value]
    start = qset(m, input)
    flags = { qA: R(), qS: R(Z=1), qF: R(Z=0) }[success]

    print('qf={} value={} start={} consumed={} input={}' \
        .format( qf, value, start, consumed, input))
    m.call(S[qf], R(Z=0))
    assert (flags,   start + consumed,             value) \
        == (m.regs, m.word(S.q_point), m.word(S.q_value))
