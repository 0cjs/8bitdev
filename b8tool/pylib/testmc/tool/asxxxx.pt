from    testmc.tool.asxxxx import *
from    b8tool.path  import pylib

from    io import BytesIO, StringIO
from    pathlib import Path
import  pytest

####################################################################
#   Object file parsing

#   Records in "Tandy CoCo Disk BASIC binary" (.bin) format as
#   generated by the ASxxxx assembler's `aslink` program.
BINDATA = bytes.fromhex(''
    # typ  len addr data
    + '00 0001 0123 ee'
    + '00 0009 0400 8a 8c09 0418 6d09 0460'
    + 'ff 0000 0403'    # final record has entry point
    )

def test_parse_cocobin():
    mi = parse_cocobin(BytesIO(BINDATA))
    rec0data = b'\xEE'
    rec1data = b'\x8A\x8C\x09\x04\x18\x6D\x09\x04\x60'
    assert (0x0123, rec0data) == mi[0]
    assert (0x0400, rec1data) == mi[1]
    #   Entries only for data records, not the entrypoint record
    assert 2 == len(mi)
    assert 0x0403 == mi.entrypoint


####################################################################
#   AxSymTab - Parse symbol table from ASxxxx listing file

def test_AxSymTab_parse_symline_wide():
    s = AxSymTab.parse_symline(
        '  3 ar_local0                                                   0FE3 R'
        )
    assert      'ar_local0' == s.name
    assert           0x0fe3 == s.value
    assert                3 == s.section

def test_AxSymTab_parse_symline_narrow():
    s = AxSymTab.parse_symline('0 n_longsym_1234     0041 GR')
    assert     'n_longsym_1234' == s.name       # XXX truncated!
    assert               0x0041 == s.value
    assert                    0 == s.section

def test_AxSymTab_parse_symline_equate():
    s = AxSymTab.parse_symline('    .__.$$$.       =   2710 L')
    assert           '.__.$$$.' == s.name
    assert               0x2710 == s.value
    assert                 None is s.section

def test_AxSymTab_parse_symline_noflags():
    s = AxSymTab.parse_symline('    valF123        =   F123')
    assert            'valF123' == s.name
    assert               0xf123 == s.value
    assert                 None is s.section

def test_AxSymTab_parse_arealine_wide():
    a = AxSymTab.parse_arealine(
        '   2 area_abs                              size 8012   flags  908')
    assert            2 == a.number
    assert   'area_abs' == a.name
    assert       0x0908 == a.flags
    assert not a.isrelative()

def test_AxSymTab_parse_arealine_narrow():
    a = AxSymTab.parse_arealine('   0 _CODE            size   69   flags C180')
    assert            0 == a.number
    assert      '_CODE' == a.name
    assert       0xC180 == a.flags
    assert a.isrelative()

def tdatafile(filename):
    ''' Return a ByteStream reading from the given test file.
        This returns a context manager and so can be used with ``with``.
    '''
    dir = 'testmc/testfiles/asxxxx'
    return open(str(pylib(dir, filename)), 'r')

@pytest.mark.parametrize('filename',
    ['wide.sym', 'wide.lst', 'wide.rst' ])
def test_AxSymTab_symtab_lines_wide(filename):
    with tdatafile(filename) as f:
        sl, al = AxSymTab.symtab_lines(f)
    s0  = '    .__.$$$.                                                =   2710 L'
    s4  = '  2 aa_local0                                                   8000 R'
    s12 = '  0 w_longsym_123456789_123456789_123456789_123456789_12345     003B GR'
    assert  s4 == sl[4]
    assert s12 == sl[12]
    assert  13 == len(sl)
    a0 = '   0 _CODE                                 size   3D   flags C180'
    a1 = '   2 area_abs                              size 8012   flags  908'
    a2 = '   3 area_rel                              size   11   flags  D00'
    a3 = '   1 _DATA                                 size    0   flags C0C0'
    assert a0 == al[0]
    assert a1 == al[1]
    assert a2 == al[2]
    assert a3 == al[3]
    assert  4 == len(al)

@pytest.mark.parametrize('filename',
    ['narrow.sym', 'narrow.lst', 'narrow.rst', ])
def test_AxSymTab_symtab_lines_narrow(filename):
    with tdatafile(filename) as f:
        sl, al = AxSymTab.symtab_lines(f)

    assert '    .__.$$$.       =   2710 L'                  == sl[0]
    assert '    .__.ABS.       =   0000 G'                  == sl[1]
    assert '  0 n_longsym_1234     0041 GR'                 == sl[9]
    #   We test with an odd number of symbols to ensure that we
    #   correctly handle a last line with a single symbol on it.
    assert '  0 oddsym             0043 R'                  == sl[10]
    assert  11 == len(sl)

    assert '   0 _CODE            size   69   flags C180'   == al[0]
    assert '   1 _DATA            size    0   flags C0C0'   == al[1]
    assert  2 == len(al)

def test_AxSymTab_symtab_lines_empty():
    with open('/dev/null') as f:
        sl, al = AxSymTab.symtab_lines(f)
    assert len(sl) == 0

def test_AxSymTab_readsymtabpath_nonexistent_file():
    #   No files exist at all
    with pytest.raises(FileNotFoundError):
        AxSymTab.readsymtabpath('/foo/bar/baz/quux')
    #   One or more files exist, but none contain a symbol table
    with pytest.raises(FileNotFoundError):
        AxSymTab.readsymtabpath('/dev/null')

def test_AxSymTab_readsymtabpath():
    assert AxSymTab.readsymtabpath(pylib('testmc/testfiles/asxxxx/wide.rst'))
    assert AxSymTab.readsymtabpath(pylib('testmc/testfiles/asxxxx/wide'))

def test_AxSymTab_readsymtabstream():
    #   Here we deliberately use a file that does not list the areas
    #   in numerical order.
    with tdatafile('wide.sym') as f:
        stab = AxSymTab.readsymtabstream(f)

    with pytest.raises(KeyError):
        stab.areanamed('this is not an area name')
    for i in range(0, len(stab.areas)):
        area = stab.areas[i]
        assert i == area.number     # Index must be same as area number
        assert i == stab.areanamed(area.name).number
        assert area.name == stab.areanamed(area.name).name
        #   These are just a sanity check on parsing covered above
        assert isinstance(area.name, str)
        assert 5 <= len(area.name)
        assert 0 <= area.flags
    #   Also just sanity check for parsing covered above
    assert 'area_abs' == stab.areas[2].name
    assert           not stab.areas[2].isrelative()
    assert 'area_rel' == stab.areas[3].name
    assert               stab.areas[3].isrelative()

    Sym = SymTab.Symbol
    assert Sym('aa_local0', 0x8000, 2) == stab.sym('aa_local0')
    assert                   0x8000 ==     stab['aa_local0']
    assert                   0x8000 ==     stab.aa_local0
    #   Symbols are not yet relocated
    assert Sym('ar_local0', 0x0000, 3) == stab.sym('ar_local0')
    assert                   0x0000 ==     stab['ar_local0']
    assert                   0x0000 ==     stab.ar_local0

def test_AxSymTab_parse_maparealine():
    line = '_CODE                      0800        003D ' \
           '=          61. bytes (REL,CON,CSEG)'
    name, addr = AxSymTab.parse_maparealine(line)
    assert      '_CODE' == name
    assert       0x0800 == addr

def test_AxSymTab_parse_maparealine_withspace():
    #   Some area names seem to have spaces in them?
    #   This nearly matches a non-area symbol in the .sym/.lst file.
    #   Tweaked for testing; the .__.ABS. value in real map files is 0.
    line = '.  .ABS.                   1001        0000 ' \
           '=           0. bytes (ABS,OVR,CSEG)'
    name, addr = AxSymTab.parse_maparealine(line)
    assert   '.  .ABS.' == name
    assert       0x1001 == addr

@pytest.mark.parametrize('filename',
    ['narrow.map', 'wide.map', ])
def test_AxSymTab_mapfile_arealines(filename):
    parseline = AxSymTab.parse_maparealine
    with tdatafile(filename) as f:
        lines = AxSymTab.mapfile_arealines(f)

    assert 2 <= len(lines)
    assert '.  .ABS.', 0 == parseline(lines[0])    # Same in all files

    for line in lines:
        name, addr = parseline(line)
        assert isinstance(name, str),   line
        assert 4 <= len(name),          line
        assert 0 <= addr,               line

def test_AxSymTab_relocate():
    with tdatafile('wide.sym') as f:
        s = AxSymTab.readsymtabstream(f)
    assert (0xf123,    0x002c,   0x0039,  0x8000,      0x0000, ) \
        == (s.valF123, s.c_wide, s.c_vec, s.aa_local0, s.ar_local0, )

    with tdatafile('wide.map') as f:
        s.relocate(f)
    assert (0xf123,    0x082c,   0x0839,  0x8000,      0x1A2B, ) \
        == (s.valF123, s.c_wide, s.c_vec, s.aa_local0, s.ar_local0, )

    with pytest.raises(TypeError) as e:
        s.relocate(None)             # Cannot relocate if already relocated
    assert e.match('Already relocated')
