;-*-MIDAS-*-

.NLIST SEQ
.ENABL LC
.TITLE APPLE LOGO
MUSINC	=1		;Nonzero means include music.
GRPINC	=0		;Nonzero means include graphics.

;  Logo Language Interpreter for the Apple-II-Plus Personal Microcomputer

;  Written and developed by Stephen L. Hain, Patrick G. Sobalvarro,
;  and Leigh L. Klotz with the M.I.T. Logo Group, at the Massachusetts
;  Institute of Technology.

;  Property of the M.I.T. Logo Laboratory,
;  545 Technology Square, Cambridge, MA 02139.
;  Copyright (C) 1980 Massachusetts Institute of Technology
;  All rights reserved.
.PAGE
.SBTTL		Assembly Data
;	Page Zero Variables:
LNIL	= $00	;The NIL node
PRECED	= $04	;Current function's precedence
NARGS	= $05	;No. of arguments for current function
EXPOUT	= $06	;Output expected if nonzero
OTPUTN	= $07	;Number of outputs given
DEFFLG	= $08	;Defining a ufun if nonzero
RUNFLG	= $09	;Evaluating RUN or REPEAT if nonzero
STPFLG	= $0A	;Stop executing current ufun if nonzero
COFLG	= $0B	;Return from current break-loop nonzero
FUNTYP	= $0C	;Typecode of current function (ufun or sfun)
UFRMAT	= $0D	;Format (list or fpack) of current ufun
ERRFLG	= $0E	;Error code of last error
RETADR	= $0F	;Holds stack pointer reset value for error recovery
ERRRET	= $10	;Holds program counter reset value for error recovery
SP	= $12	;Stack pointer
VSP	= $14	;Value-stack pointer
SIZE1	= $16	;Size of area pointed to by AREA1
SIZE2	= $18	;Size of area pointed to by AREA2
AREA1	= $1A	;Pointer to g.c.-protected area of SIZE1 contiguous nodes
AREA2	= $1C	;Pointer to g.c.-protected area of SIZE2 contiguous nodes
NNODES	= $1E	;Number of nodes allocated
;	Monitor variables:
WNDLFT	= $20
WNDWTH	= $21
WNDTOP	= $22
WNDBTM	= $23
CH	= $24
CV	= $25
	;DOS wants $26,$27
HBASLN	= $26
BASLIN	= $28
	;DOS wants $2A,$2B,$2C,$2D,$2E,$2F
BSLTMP	= $2A
X0L	= $2C	;Graphics, Screen X location
X0H	= $2D	;	"
Y0	= $2E	;Graphics, Screen Y location
HNDX	= $2F	;Graphics, running index variable
HMASK	= $30	;Graphics, bit mask
MODE	= $31
INVFLG	= $32
	;DOS wants $33
DOSFL1	= $33
BKGND	= $33	;Graphics, background color
PINDEX	= $34	;Index for list-parser
	;DOS wants $35,$36,$37,$38,$39
YSAV1	= $35
OTPDEV	= $36	;Output device driver address
INPDEV	= $38	;Input device driver address
TSHOWN	= $3A	;Graphics, Turtle shown if nonzero
IFTEST	= $3B	;Local TEST pointer (TRUE if nonzero)
	;DOS wants $3E,$3F,$40,$41,$42,$43,$44,$45,$46,$47,$48
;Don't modify $3E,$3F
A1L	= $40	;Temporary variable
A1H	= $41	;	"
A2L	= $42	;	"
A2H	= $43	;	"
A3L	= $44	;	"
A3H	= $45	;	"
A4L	= $46	;	"
A4H	= $47	;	"
A5L	= $48	;	"
HCOLOR	= $49	;Graphics, current line color
	;DOS wants $4A,$4B,$4C,$4D
RNDL	= $4A
RNDH	= $4B
SHAPE	= $4C	;Graphics, shape address

LTRUE	= $4E	;TRUE atom pointer
LFALSE	= $50	;FALSE atom pointer
RANDOM	= $52	;Random number
CHBUFR	= $54	;Character buffer next-char-to-read pointer
CHBUFS	= $55	;Character buffer next-free-loc pointer
PRSFLG	= $56	;Indicates the parser is executing, for CONS
INPFLG	= $57	;Nonzero means evaluating from the edit buffer
OTPFLG	= $58	;Nonzero means print-to-buffer mode
SOBLST	= $59	;Pointer to start of System Object List
SOBTOP	= $5B	;Pointer to end of System Object List
SARTOP	= $5D	;Pointer to end of System Array
FRLIST	= $5F	;Pointer to start of Freelist
TOKPTR	= $61	;Token Pointer
CURTOK	= $63	;Curent Token pointer
NEXTOK	= $65	;Next Token pointer
FUNCT	= $67	;Points to current Function
IFLEVL	= $69	;IF nesting level
FRAME	= $6B	;Pointer to current stack frame
XFRAME	= $6D	;Pointer to end of current stack frame
FBODY	= $6F	;Pointer to full body of current Ufun
FBODY1	= $71	;Current ufun body or system function index
FPTR	= $73	;Pointer to remainder of Ufun being executed
GOPTR	= $75	;Pointer to location of Ufun line to GO to
ULNEND	= $77	;Pointer to end of current line of Fpack Ufun
LEVNUM	= $79	;Ufun nesting level
NEST	= $7B	;EVAL nesting of current EVLINE
TLLEVS	= $7D	;Number of tail recursions included in LEVNUM
	;DOS wants $7F
PEN	= $7F	;Graphics, indicates pen down if nonzero
DOSFL2	= $7F
DEFATM	= $80	;Pointer to atom of Ufun currently being edited
MARK1	= $82	;Garbage collector protected variable
MARK2	= $84	;		"
MARK3	= $86	;		"
MARK4	= $88	;		"
MARK5	= $8A	;		"
CELPTR	= $8C	;Garbage collector protected variable
OBLIST	= $8E	;Pointer to Object List
UNSUM	= $90	;Unary Sum pointer
UNDIF	= $92	;Unary Difference pointer
ILINE	= $94	;Pointer to current or last command line
DEFBOD	= $96	;Pointer to body of ufun currently being defined
PODEFL	= $98	;Default ufun atom
EPOINT	= $9A	;Editor point
ENDBUF	= $9C	;Location after last character in edit buffer
ARG2	= $9E	;Primitive's second argument
NARG2	= $9E	;Primitive's second argument (numerical - 4 bytes)
ARG1	= $A2	;Primitive's first argument
NARG1	= $A2	;Primitive's first argument (numerical - 4 bytes)
TEMPNH	= $A6	;Temporary variable (first swapped; must follow NARG1 for flt. pt. routines)
TEMPN	= $A8	;Temporary variable
TEMPN1	= $AA	;Temporary variable (must follow TEMPN for XDIVID,SRANDM routines)
TEMPN2	= $AC	;Temporary variable (must follow TEMPN1)
TEMPN3	= $AE	;Temporary variable
TEMPN4	= $B0	;Temporary variable (must follow TEMPN4)
ANSN	= $B2	;Temporary variable
ANSN1	= $B3	;Temporary variable
TEMPN5	= $B4	;Temporary variable (last swapped)
TEMPN6	= $B6	;Temporary variable (must follow TEMPN5)
TEMPN7	= $B8	;Temporary variable
TEMPN8	= $BA	;Temporary variable (must follow TEMPN7)
TEMPX1	= $BC	;Temporary variable
TEMPX2	= $BE	;Temporary variable (must follow TEMPX1)
TEMPX3	= $C0	;Temporary variable
ANSN2	= $C2	;Temporary variable
ANSN3	= $C3	;Temporary variable
ANSN4	= $C4	;Temporary variable

GRPHCS	= $C5	;Indicates graphics mode if nonzero
XCOR	= $C6	;X-Coordinate, floating pt.
YCOR	= $CA	;Y-Coordinate, floating pt. (must follow XCOR fo TTLHOM)
HEADNG	= $CE	;Heading, floating pt. (must follow YCOR for TTLHOM)

PARPNT	= $D2   ;Pointer to the buffer for the current music part
NARGX	= $D4	;General numeric temporary, 4 bytes

	;DOS wants $D8
DOSERR	= $D8	;DOS "ONERR GOTO" flag - set high bit to turn on
SFSTCH	= $D9	;pointer to first char on screen
SLSTCH	= $DB	;pointer to char after last char on screen
NPARTS	= $DD	;number of music parts, or 0 for no music.
.PAGE
	;Page 3 storage:

;	Logo primitive pointers:
ALL	=$340
COMMNT	=$342	;Comment
ER	=$344
ERASE	=$346
LELSE	=$348	;Else
LEND	=$34A	;End
LIF	=$34C	;If
LPAR	=$34E	;(Left-parenthesis)
LSTOP	=$350	;Stop
LTHEN	=$352	;Then
LTITLE	=$354	;Title
NAMES	=$356
PO	=$358
POTS	=$35A
PRNTOT	=$35C	;Printout
PROCS	=$35E	;Procedures
RPAR	=$360	;(Right-parenthesis)
TI	=$362
TITLES	=$364
INFSUM	=$366	;(Infix Sum)
INFDIF	=$368	;(Infix Difference)
LGO	=$370

;music state vars.
MEACTP	=$372
MPACTP	=$374
MEPRT	=$376

TMPTAB	=$396		;Start of temporary storage area
SVXCOR	=TMPTAB		;Graphics intermediary values
SVYCOR	=TMPTAB+4
SHEDNG	=TMPTAB+8
SPEN	=TMPTAB+12
.PAGE
;	Type code constants:
LIST	=0	;List
ATOM	=1	;Atom
STRING	=2	;Alphanumeric linked-list
FIX	=3	;Integer (GT1NUM,GT2NUM require that FIX < FLO)
FLO	=4	;Floating point number
SFUN	=5	;System function
UFUN	=6	;User function
SATOM	=7	;Primitive
QATOM	=8	;Quoted atom
DATOM	=9	;Dotted atom
LATOM	=10	;Label atom
FPACK	=11	;Packed ufun
HITYP	=FPACK	;Highest type, for dispatch tables.
;	Parser constants:
NEWLIN	=1	;Start of input line
NEWLST	=2	;Start of sublist
REGCEL	=3	;Regular linked cell
;	General constants:
FULCHR	=$06	;Full-screen graphics character (Control-F)
STPKEY	=$07	;Stop-key character code (Control-G)
MIXCHR	=$0C	;Mixed-screen graphics character (Control-L)
PULCHR	=$10	;Redisplay last line typed (Control-P)
LSTKEY	=$13	;Interrupt output listing (Control-S)
PAUSKY	=$1A	;Pause-key character code (Control-Z)
RPRMPT	='<	;REQUEST prompt
QPRMPT	='?	;Regular prompt
LBRAK	='^	;Left-bracket replacement character
GCVST	=MARK1	;Start of Garbage Collecor protected variable area
GCVND	=DEFBOD+2;End of Garbage Collector protected variable area
RANDA	=5353	;Random transform constant "A"
RANDC	=43277	;Random transform constant "C"
;	Storage Parameters:
LINARY	=$200		;Input line buffer (page 2)
CHBSTT	=$300		;Start of character buffer
CHBLEN	=64		;Length of character buffer
TMPNUM	=TEMPN5-TMPSTT+2;Number of temporary bytes to swap
TMPSTT	=TEMPNH		;Start of page-zero swapped temporaries
GRPSTT	=$2000		;Start of hires graphics area
GRPEND	=$4000		;End of Hires graphics area
EDBUF	=$2000		;Start of editor buffer
EBFEND	=$3FFB		;End of edit buffer (with room for CR and EOF marker)
SYSTAB	=$30		;Page no. of System tables (after loading)
GHOMEM	=$D0		;Page no. of Ghost-memory
TDIFF	=$A000		;Difference between above storage areas
;	Mapped I/O locations:
GETRM1	=$C08B	;Enable high RAM (with first 4K bank)
GETRM2	=$C083	;Enable high RAM (with second 4K bank)
KILRAM	=$C08A	;Deselect high RAM (enable Monitor/BASIC)
KBDBYT	=$C000	;Keyboard input byte
KBDCLR	=$C010	;Keyboard clear strobe
GSW	=$C050	;Graphics mode
FULLGR	=$C052	;Full Graphics screen
MIXGR	=$C053	;Mixed Text/Graphics switch
GPAGE	=$C054	;Graphics page (Primary = $C054)
HGSW	=$C057	;High-res mode
SPKR	=$C030	;Toggle speaker
;	Interrupt Vector areas:
RSTVEC	=$FFFC	;Location of RESET vector
IRQVEC	=$FFFE	;Location of IRQ vector
NMIVEC	=$FFFA	;Location of NMI vector (BRK command)
;	System vectors:
RESETV	=MONBRK	;RESET Vector (either MONBRK, or LOGO1)
ROMMON	=$FA4C	;ROM Monitor entry point BREAK
ROMSTN	=$FE84	;ROM Monitor SETNORM routine
ROMNIT	=$FB2F	;ROM Monitor INIT routine
ROMSTV	=$FE93	;ROM Monitor SETVID routine
ROMSTK	=$FE89	;ROM Monitor SETKBD routine
MONACC	=$45	;ROM Monitor ACC location
MONBKV	=$03F0	;ROM Monitor BRKV vector
MONOBK	=$FA59	;ROM Monitor OLDBRK routine
;	DOS sacred locations
DOSEAT	=$A851	;DOS subroutine to give DOS control of input
DSERET	=$9D5A	;DOS error return address location
DLNGFG	=$AAB6	;DOS language flag -- stuff a $40 for Applesoft
FILLEN	=$AA60	;length of last file loaded
APCOUT	=$FDED	;location of COUT routine in monitor (DOS calls it)
.PAGE
;	System Function Constants:
INDSPL	=0	;Nodisplay
ITHNGP	=1	;Thingp
IWORD	=2
IWORDP	=3
IUNSUM	=4	;Unary sum
IUNDIF	=5	;Unary difference
IMAKE	=6
IOTPUT	=7	;Output
ISTOP	=8
IPRINT	=9
ITYPE	=10
IDEFIN	=11	;Define
ICLEAR	=12
ICNTIN	=13	;Continue
IPAUSE	=14
IELSE	=15
ISNTNC	=16	;Sentence
IBOTH	=17
IEITHR	=18	;Either
ITHEN	=19
INOT	=20
ILPAR	=21	;(Left parenthesis)
IRPAR	=22	;(Right parenthesis)
IIF	=23
IRUN	=24
IGO	=25
IBPT	=26	;.bpt
IGDBYE	=27	;Goodbye
IGCOLL	=28	;.gcoll
INODES	=29	;.nodes
IBTFST	=30	;Butfirst
IFIRST	=31
IBTLST	=32	;Butlast
ILAST	=33
ITO	=34
IEDIT	=35
IEND	=36
ITEXT	=37
IFORWD	=38	;Forward
IBACK	=39
IRIGHT	=40
ILEFT	=41
ILIST	=42
ICS	=43
IHOME	=44
IPENUP	=45
IPENDN	=46	;Pendown
IRMNDR	=47	;Remainder
ISHOWT	=48	;Showturtle
IHIDET	=49	;Hideturtle
ITSTAT	=50	;Turtlestate
IINT	=51
IFPUT	=52
IPO	=53
IALL	=54
INAMES	=55
IERASE	=56
IREAD	=57
ISAVE	=58
IREQST	=59	;Request
ITHING	=60
ITTYP	=61
ISUM	=62
IDIF	=63	;Difference
IPROD	=64	;Product
IQUOT	=65	;Quotient
IGREAT	=66	;Greater
ILESS	=67
ICOMNT	=68	;Comment
IEQUAL	=69
ITRCBK	=70	;Traceback
IPOTS	=71
ITITLS	=72	;Titles
IPROCS	=73	;Procedures
IPEEK	=74
IPOKE	=75
INSUM	=76	;Infix Sum
INDIF	=77	;Infix Difference
INPROD	=78	;Infix Product
INQUOT	=79	;Infix quotient
INGRTR	=80	;Infix Greater
INLESS	=81	;Infix Less
INEQUL	=82	;Infix Equal
ILPUT	=83
IRANDM	=84	;Random
ICTYI	=85
ICURSR	=86	;Cursor
IRNDMZ	=87	;Randomize
ICALL	=88
ILISTP	=89
INMBRP	=90	;Numberp
ICLINP	=91
IVOICE	=92
IRPEAT	=93
ISETX	=94
ISETY	=95
ISETXY	=96
ISETH	=97
ISETT	=98
IXCOR	=99
IYCOR	=100
IHDING	=101	;Heading
IFULL	=102
IMIX	=103
IDELET	=104	;Delete
ICATLG	=105	;Catalog
INVOIC	=106
IPLAYM	=107
INOTE	=108
IAD	=109	;attack/decay
IVS	=110	;volume/sustain
IRG	=111	;release/gap
IFZ	=112	;fuuz
IQTENT	=113	;Quotient
ITEST	=114
IIFT	=115
IIFF	=116
ISINE	=117
ICOS	=118
INDXR	=119	;Re-entry primitive index
.PAGE
;	Error Codes:
XUOP	=1
XEOL	=2
XUDF	=3
XHNV	=4
XNIP	=5
XNOP	=6
XRPN	=7
XIFX	=8
XNTMUS	=9
XTIP	=10
XWTA	=11
XUBL	=12
XNTL	=13
XNTF	=14
XELS	=15
XBRK	=16
XLABEL	=17
XTHN	=18
XLNF	=19
XETL	=20
XNED	=21
XOPO	=22
XDBZ	=23
XOFLOW	=24
XNDF	=25
XCRSR	=26
XOOB	=27
XIOR	=28
XWTP	=29
XFNF	=30
XDKF	=31
XLKF	=32
XTMN	=33
XSYN	=34
XRNG	=35
XNOMUS	=36

XZAP	=100	;(Not in dispatch table)

XNSTOR	=0	;(XZAP Quantifiers)
XNSTRN	=1
XSTOP	=2
XEXCED	=3
.PAGE
;	Storage Parameters and Map:

;	Miscellaneous:	Page 0 - Variables
;			Page 1 - Processor Stack
;			Page 2 - Input line buffer
;			Page 3 - Pointers, variable storage, character buffer
;			Pages 4 to 7 - Text screen page
;			Pages 8 to 13 - System Primitive Array
;			Pages 14 to 31 - Stacks (PDL, VPDL)
;			Pages 32 to 63 - Hi-res. graphics screen/Screen editor buffer

;	MISC.:    $0000 - $07FF: $ 800 bytes (2K bytes)
;	SARRAY:   $0800 - $0DFF: $ 600 bytes (1.5K characters)
;	STACKS:   $0E00 - $1FF9: $11F9 bytes (about 2.25K words) PDL, VDPL
;	VECTORS:  $1FFA - $1FFF: $   6 bytes (2 vectors) Start address, restart address
;	BUFFER:   $2000 - $3FFF: $2000 bytes (8K bytes) Screen Editor, Graphics, boot buffer
;	LOGO:     $4000 - $95FF: $5600 bytes (21.5K bytes)
;	DOS:      $9600 - $BFFF: $2A00 bytes (10.5K bytes)
;	I/O:      $C000 - $CFFF: $1000 bytes (4K bytes)
;	BIGARRAY: $D000 - $F65F: $2660 bytes (2456. nodes)
;	TYPBASE:  $F660 - $FFF7: $ 998 bytes (2456. typecodes)
;	UNUSED:   $FFF8 - $FFF9: $   2 bytes
;	INTRPTS.: $FFFA - $FFFF: $   6 bytes (3 vectors) NMI, RESET, IRQ vectors

;	GHOSTMEM: $D000 - $DFFF: $1000 bytes (4K bytes)

BIGBAS	=$D000		;Nodespace beginning
BBASX	=BIGBAS-4
BIGLEN	=$2660		;Nodespace length
SINODS	=BIGBAS+BIGLEN	;Nodespace end
;OFSET1	=BIGBAS/4 but the stupid cross assembler can't divide correctly so we have to do it...
OFSET1	=$3400		;Offset constant
TYPBAS	=SINODS-OFSET1	;Typebase offset
TYPLEN	=BIGLEN/4	;Typebase length
TYPEND	=SINODS+TYPLEN	;Typebase end
NODTST	=50		;Minimum free nodes for parser
NODLIM	=TYPLEN-NODTST	;Node allocation limit
BASARY	=$800		;SARRAY beginning
SARLEN	=$600		;SARRAY length
STKLEN	=$11F9		;Combined stack length
PDLBAS	=BASARY+SARLEN	;PDL beginning (grows upwards, Push-then-incr.)
VPDLBA	=PDLBAS+STKLEN-2;VPDL beginning (grows downwards, Push-then-decr.)
STKLIM	=80		;Minimum unused stack space before panicking
.PAGE
.SBTTL	Top Level
.=$4000

;Calling point for the Logo Interpreter

LOGO:	LDA #RESETV&$FF
	STA RSTVEC	;Set up the RESET key vector
	LDA #RESETV^
	STA RSTVEC+1
	LDA GETRM2	;Select Ghost-memory bank 2 for writing
	LDA GETRM2
	LDA #$00
	STA TEMPNH
	STA TEMPN
	LDA #SYSTAB	;Page no. of tables
	STA TEMPNH+1
	LDA #GHOMEM	;Page no. of ghost-memory
	STA TEMPN+1
	LDY #$00
MOVLOP:	LDA (TEMPNH),Y
	STA (TEMPN),Y
	INY
	BNE MOVLOP
	INC TEMPNH+1
	INC TEMPN+1
	LDA #ENDTAB^
	CMP TEMPNH+1	;See if last page transferred
	BCS MOVLOP
	;falls through

;Re-entry point for GOODBYE:
	;falls in
LOGO1:	SEI		;Disable interrupts
	CLD		;Disable decimal mode
	LDX #$00
	TXS		;Initialize processor stack
	STX $00		;Define LNIL as $0000 at $0000
	STX $01
	STX $02
	STX $03
	LDA GETRM1
	LDA GETRM1	;Disable Ghost-memory bank 2
	LDA #MONBRK&$FF
	STA IRQVEC
	STA NMIVEC	;Interrupts cause a break to Monitor
	LDA #MONBRK^
	STA IRQVEC+1
	STA NMIVEC+1
	JSR INITLZ
	LDX #HELSTR&$FF
	LDY #HELSTR^
	JSR PRTSTR	;Types Hello-String
TOPLOP:	LDX #ILINE
	JSR PRDLIN	;Get a line
	LDA ILINE+1
	BEQ TOPLOP	;Ignore if line is empty
	STA TOKPTR+1
	LDA ILINE
	STA TOKPTR
	;falls through
.PAGE
.SBTTL	Evaluator Routines
;EVLUAT initializes the Evaluator variables, starts EVLINE.
	;falls in
EVLUAT:	LDA #PDLBAS&$FF
	STA SP
	LDA #PDLBAS^
	STA SP+1
	LDA #VPDLBA&$FF
	STA VSP
	LDA #VPDLBA^
	STA VSP+1
	LDA #$00
	STA EXPOUT
	STA RUNFLG
	STA STPFLG
	STA COFLG
	STA ERRFLG
	STA LEVNUM
	STA LEVNUM+1
	STA TLLEVS
	STA TLLEVS+1
	STA FRAME+1
	STA XFRAME+1
	STA UFRMAT
	LDX #TOPLOP&$FF
	LDY #TOPLOP^
	JSR PUSH	;Top-level Return Address
	;falls through
.PAGE
;EVLINE called with TOKPTR pointing to line of code to execute.
; Pushes IFLEVEL and EXPOUT and then resets them.

	;falls in
EVLINE:	JSR TSTSTK
	JSR POLLZ
	LDA EXPOUT
	JSR PUSHB
	LDX #IFLEVL
	JSR PUSHP
	LDA #$00
	STA EXPOUT
	STA IFLEVL
	STA IFLEVL+1
	LDA TOKPTR+1
	BEQ EVLN1P
EVLN1:	LDY #$00
	LDA (TOKPTR),Y
	STA TEMPN
	INY
	LDA (TOKPTR),Y
	STA TEMPN+1
	LDX #TEMPN
	JSR GETTYP
	CMP #LATOM
	BNE EVLIN1
	LDX #TOKPTR
	JSR TTKADV
	;falls through

;EVLIN1 keeps calling EVLEXP until EOL.

	;falls in
EVLIN1:	LDA TOKPTR+1
	BNE EVLN1A
EVLN1P:	LDX #IFLEVL
	JSR POP
	JSR POPB
	STA EXPOUT
POPJ:	LDX #TEMPN
	JSR POP
	JMP (TEMPN)
EVLN1A:	LDA STPFLG
	BNE EVLN1P
	LDX #EVLIN1&$FF
	LDY #EVLIN1^
	JSR PUSH	;Push EVLIN1 return address
	;falls through

;EVLEXP calls EVAL with PRECED = 0. EVAL returns to EVEX1,
;which restores old PRECED.

	;falls in
EVLEXP:	LDA PRECED
	JSR PUSHB
	LDA #$00
	STA PRECED
	LDX #EVEX1&$FF
	LDY #EVEX1^
	JSR PUSH
	;falls through
.PAGE
;EVAL dispatches to either EVWRAP, PARLOP, UFUNCL, or SFUNCL.
;All return eventually to EVWRAP.

	;falls in
EVAL:	JSR POLL	;Poll at every token to be evaluated
	LDX #CURTOK	;Push CURTOK and increment NEST if FRAME <> 0
	JSR PUSHP
	LDA FRAME+1
	BEQ XEVL2
XEVL1:	INC NEST
	BNE XEVL2
	INC NEST+1
	BPL XEVL2
	JMP EXCED
XEVL2:	LDA TOKPTR+1
	BNE XEVL3
	JMP ERXEOL
XEVL3:	LDY #$00	;Get CURTOK and NEXTOK
	LDA (TOKPTR),Y
	STA CURTOK
	INY
	LDA (TOKPTR),Y
	STA CURTOK+1
	LDX #TOKPTR
	JSR TTKADV
	JSR GTNXTK
	LDX #CURTOK
	JSR GETTYP	;Dispatch off Type of CURTOK
	LDX #EVLTB1&$FF
	LDY #EVLTB1^
	JMP TYPDSP

XCASL:	LDX #CURTOK
	LDA $00,X
	AND #$FC	;Strip off label bits
	STA $00,X
	LDA #XLABEL	;ERROR, can't execute a label
	JMP ERROR
XCASD:	LDY #CURTOK	;DATOM, so VPush it unless it's Novalue (then Error)
	LDX #TEMPN
	JSR GETVAL
	LDX #TEMPN	;For VPUSHP in XCASQ1
	LDA TEMPN+1
	BNE XCASQ1
	LDA TEMPN
	BEQ XCASQ1
	LDA CURTOK
	AND #$FC
	STA CURTOK
	LDY #CURTOK
	LDA #XHNV
	JMP ERROR
XCASQ:	LDA CURTOK	;QATOM, FIX, FLO, LIST: Just push it and set OTPUTN
	AND #$FC	;Strip off last two bits
	STA CURTOK
	LDX #CURTOK
XCASQ1:	JSR VPUSHP
	LDA #$01
	STA OTPUTN
	JMP EVWRAP
XCASA:	LDX #CURTOK	;ATOM, SATOM: It's some sort of Function
	LDA #FUNCT
	JSR GETFUN
	STA FUNTYP
	LDA FUNCT+1
	BNE XCASA1
	LDY #CURTOK
	LDA #XUDF
	JMP ERROR	;Error if GETFUN couldn't find it
XCASA1:	LDA FUNTYP
	LDX #FUNCT
	JSR INFIXP
	BCC XCASA2
	CMP #INSUM
	BNE XCASA3
	LDX UNSUM
	LDY UNSUM+1
	BNE XCASA4	;(Always)
XCASA5:	LDY #CURTOK
	LDA #XIFX
	JMP ERROR
XCASA3:	CMP #INDIF
	BNE XCASA5
	LDX UNDIF
	LDY UNDIF+1
XCASA4:	STX CURTOK
	STY CURTOK+1
	LDX #CURTOK
	LDA #FUNCT
	JSR GETFUN
	STA FUNTYP
XCASA2:	LDA PRECED	;It should be a UFUN or SFUN
	JSR PUSHB
	LDY FUNTYP
	LDX #FUNCT
	JSR GETPRC
	STA PRECED
	LDA FUNTYP
	LDX #FUNCT
	JSR GETNGS
	BPL XCASF1
	EOR #$FF	;NARGS := - NARGS - 1
XCASF1:	STA NARGS
	LDX #EVAL1&$FF
	LDY #EVAL1^
	JSR PUSH
	;falls through
.PAGE
	;falls in
ARGLOP:	LDA NARGS	;ARGLOP gets the args for a function
	BNE ARGLP1
	JMP POPJ	;Exit if no args to be gotten
ARGLP1:	LDA NARGS
	STA ANSN	;AL1 will push this
	JSR PUSHB
	LDX #FUNCT
	JSR PUSHP
	LDA FUNTYP
	JSR PUSHB
	LDA EXPOUT
	JSR PUSHB
	LDX #IFLEVL
	JSR PUSHP
	;falls through

	;falls in
AL1:	JSR GTNXTK
	LDX #NEXTOK
	JSR PUSHP
	LDA ANSN
	JSR PUSHB
	LDA PRECED
	JSR PUSHB
	LDX #$00
	STX IFLEVL
	STX IFLEVL+1
	INX
	STX EXPOUT
	LDX #AL2&$FF
	LDY #AL2^
	JSR PUSH
	JMP EVAL
ERXNPJ:	JMP ERXNOP

AL2:	JSR POPB
	STA PRECED
	JSR POPB
	STA ANSN
	LDX #NEXTOK
	JSR POP
	LDA OTPUTN
	BEQ ERXNPJ
	DEC ANSN
	BNE AL1		;Get another arg if not done
	LDX #IFLEVL
	JSR POP
	JSR POPB
	STA EXPOUT
	JSR POPB
	STA FUNTYP
	LDX #FUNCT
	JSR POP
	JSR POPB
	STA NARGS
	JMP POPJ

EVEX1:	JSR POPB
	STA PRECED
	JMP POPJ
.PAGE
PARLOP:	LDX #NEXTOK	;Executed when an LPAR is encountered
	LDA #FUNCT
	JSR GETFUN
	STA FUNTYP
	CMP #SFUN
	BNE PARLPA
	LDA NEXTOK
	CMP RPAR
	BNE PARLPA
	LDA NEXTOK+1
	CMP RPAR+1
	BNE PARLPA
	LDA #XNIP	;"Nothing inside parenthesis"
	JMP ERROR
PARLPA:	LDA FUNCT+1
	BEQ PARLP7
PARLP1:	LDA FUNTYP
	LDX #FUNCT
	JSR GETNGS
	STA NARGS
PARLP4:	LDA NARGS
	BMI PARLP3
PARLP7:	LDA EXPOUT
	JSR PUSHB
	LDX #IFLEVL
	JSR PUSHP
	LDX #$00
	STX IFLEVL
	STX IFLEVL+1
	INX
	STX EXPOUT
	LDX #PLOP1&$FF
	LDY #PLOP1^
	JSR PUSH
	JMP EVLEXP
PARLP3:	LDY FUNTYP
	LDX #FUNCT
	JSR GETPRC
	STA PRECED
	LDA NEXTOK
	STA CURTOK
	LDA NEXTOK+1
	STA CURTOK+1
	LDX #TOKPTR
	JSR TTKADV
	LDA #$00
	STA NARGS
	LDX #FUNCT
	JSR PUSHP
	LDA FUNTYP
	JSR PUSHB
	;falls through
.PAGE
	;falls in
VARGLP:	JSR GTNXTK
	LDA NEXTOK
	CMP RPAR
	BNE VRGLP1
	LDA NEXTOK+1
	CMP RPAR+1
	BNE VRGLP1
	JSR POPB	;Call POP (FUNTYPE)
	STA FUNTYP
	LDX #FUNCT
	JSR POP
	LDX #TOKPTR
	JSR TTKADV
	LDA NARGS
	EOR #$FF
	STA NARGS	;NARGS := - NARGS - 1
	JMP FNCAL1
VRGLP1:	LDA NARGS
	JSR PUSHB
	LDX #NEXTOK
	JSR PUSHP
	LDA EXPOUT
	JSR PUSHB
	LDX #IFLEVL
	JSR PUSHP
	LDX #$00
	STX IFLEVL
	STX IFLEVL+1
	INX
	STX EXPOUT
	LDA PRECED
	JSR PUSHB
	LDX #VAL1&$FF
	LDY #VAL1^
	JSR PUSH
	JMP EVAL
.PAGE
VAL1:	JSR POPB
	STA PRECED
	LDX #IFLEVL
	JSR POP
	JSR POPB
	STA EXPOUT
	LDX #NEXTOK
	JSR POP
	JSR POPB
	STA NARGS
	LDA OTPUTN
	BEQ ERXNOP
	INC NARGS
	BNE VARGLP
EXCED:	LDA #XZAP
	LDX #XEXCED
	JMP ERROR
ERXNOP:	LDA #XNOP
	LDY #NEXTOK
	JMP ERROR
.PAGE
;PLOP1 cleans up after a parenthesized expression.

PLOP1:	LDX #IFLEVL
	JSR POP
	JSR POPB
	STA EXPOUT
	LDA TOKPTR+1
	BEQ ERXELJ
	JSR GTNXTK
	LDA NEXTOK
	CMP RPAR	;Next token must be an RPAR, else Error
	BNE PLOP1B
	LDA NEXTOK+1
	CMP RPAR+1
	BNE PLOP1B
	LDX #TOKPTR	;Everything OK, get the next token and exit
	JSR TTKADV
	JMP POPJ
PLOP1B:	LDA #XTIP
	JMP ERROR
ERXELJ:	JMP ERXEOL

;Executes the list in TOKPTR.
RUNHAN:	LDA UFRMAT
	JSR PUSHB
	LDX #ULNEND
	JSR PUSHP
	LDA RUNFLG
	JSR PUSHB
	LDX #$00
	STX UFRMAT
	INX
	STX RUNFLG
	LDX #RH1&$FF
	LDY #RH1^
	JSR PUSH
	JMP EVLINE

RH1:	JSR POPB
	STA RUNFLG
	LDX #ULNEND
	JSR POP
	JSR POPB
	STA UFRMAT
	JMP POPJ
.PAGE
;Evaluates the edit buffer.
EVLBUF:	LDA INPFLG	;If something reset it to default,
	BEQ SREAD3	;then break out, don't check for EOF.
SRED1A:	LDA ENDBUF+1
	CMP EPOINT+1
	BNE EDIN
	LDA ENDBUF
	CMP EPOINT
	BEQ SREAD2
EDIN:	LDX #$00
EDIN2:	LDY #$00
	LDA (EPOINT),Y
	STA LINARY,X
	JSR INCPNT
	LDA LINARY,X
	CMP #$0D
	BEQ EDIN1
	INX
	BNE EDIN2
	LDA #XZAP
	LDX #XEXCED
	JMP ERROR	;Too much on a line (??zap when parser expanded)
EDIN1:	STX TEMPN7
	LDA #ILINE
	STA TEMPX2
	JSR PRDLNX	;Read a line.
	LDA ILINE+1
	BEQ SRED1A
	STA TOKPTR+1
	LDA ILINE
	STA TOKPTR
	LDA DEFFLG
	BEQ SRD1E
	LDY #$00
	LDA (TOKPTR),Y
	CMP LEND
	BNE SRD1F
	INY
	LDA (TOKPTR),Y
	CMP LEND+1
	BNE SRD1F
SRD1E:	LDX #EVLBUF&$FF
	LDY #EVLBUF^
	JSR PUSH
	JMP EVLINE
SRD1F:	JSR EDLINE
	JMP EVLBUF
.PAGE
SREAD2:	LDA DEFFLG
	BEQ SRD2A
	LDX #SRD2A&$FF	;Call END to end the procedure
	LDY #SRD2A^
	JSR PUSH
	JMP SEND
SRD2A:	JSR RSTIO	;Break out of read-loop
SREAD3:	LDA #$00
	STA OTPUTN
	STA TOKPTR+1
	JMP POPJ	;Return to superior
.PAGE
EVWRAP:	LDA TOKPTR+1
	BEQ EVRETN
	LDA OTPUTN
	BEQ EVRETN
	LDA STPFLG
	BNE EVRETN
	LDY #$00
	LDA (TOKPTR),Y
	STA CURTOK
	INY
	LDA (TOKPTR),Y
	STA CURTOK+1
	LDA CURTOK
	CMP RPAR
	BNE EVW2
	LDA CURTOK+1
	CMP RPAR+1
	BEQ EVRETN
EVW2:	LDX #CURTOK
	LDA #FUNCT
	JSR GETFUN
	STA FUNTYP
	LDX #FUNCT
	JSR INFIXP
	BCC EVRETN
	LDY FUNTYP
	LDX #FUNCT
	JSR GETPRC
	STA ANSN2
	CMP PRECED
	BCC EVRETN
	BEQ EVRETN
	LDX #TOKPTR
	JSR TTKADV
	JSR GTNXTK
	LDX #NEXTOK
	JSR PUSHP
	LDX #FUNCT
	JSR PUSHP
	LDA FUNTYP
	JSR PUSHB
	LDA EXPOUT
	JSR PUSHB
	LDX #IFLEVL
	JSR PUSHP
	LDA PRECED
	JSR PUSHB
	LDA #$01
	STA EXPOUT
	LDA ANSN2
	STA PRECED
	LDX #EW1&$FF
	LDY #EW1^
	JSR PUSH
	JMP EVAL

EVRETN:	LDA FRAME+1
	BEQ EVRET1
EVRTN1:	SEC
	LDA NEST
	SBC #$01
	STA NEST
	BCS EVRET1
	DEC NEST+1
EVRET1:	LDA OTPUTN
	BEQ EVRET2
	LDA EXPOUT
	BNE EVRET2
	LDA STPFLG
	BNE EVRET2
	LDA RUNFLG
	BNE EVRET2
	LDX #NEXTOK
	JSR VPOP
	LDY #NEXTOK
	LDA #XUOP
	JMP ERROR
EVRET2:	LDX #CURTOK
	JSR POP
	JMP POPJ
.PAGE
;EW1 pops everything EVWRAP pushed, checks for output (error if none),
;then goes to FUNCAL with NARGS = 2.

EW1:	JSR POPB
	STA PRECED
	LDX #IFLEVL
	JSR POP
	JSR POPB
	STA EXPOUT
	JSR POPB
	STA FUNTYP
	LDX #FUNCT
	JSR POP
	LDX #NEXTOK
	JSR POP
	LDA OTPUTN
	BNE EW1A
	JMP ERXNOP
EW1A:	LDA #$02
	STA NARGS	;NARGS := 2
	BNE FUNCAL	;(Always)

EVAL1:	JSR POPB	;Now that we have the args, get the old PRECED
	STA PRECED	; back and do the function
	;falls through

;FUNCAL calls either SFUNCL (with FBODY1 = Funct. #) or UFUNCL (with FBODY1
; pointing to text). Both return to EVWRAP. (FNCAL1 is same, except U&SFNCL
; don't return to EVWRAP).

	;falls in
FUNCAL:	LDX #EVWRAP&$FF
	LDY #EVWRAP^
	JSR PUSH
FNCAL1:	LDA FUNTYP
	CMP #SFUN
	BEQ FUN1
	LDY #$02	;UFUN, get text pointer
	LDA (FUNCT),Y
	STA FBODY1
	INY
	LDA (FUNCT),Y
	STA FBODY1+1
	JMP UFUNCL
FUN1:	LDY #$02	;SFUN, get Function # from Sarray (index=2)
	LDA (FUNCT),Y
	STA FBODY1
	;falls through
.PAGE
	;falls in
SFUNCL:	LDA #$00
	STA OTPUTN	;Default, no outputs
	LDA #GHOMEM	;Page no. of dispatch addresses
	STA TEMPN+1
	LDA FBODY1
	ASL A
	STA TEMPN
	BCC XSFNC1
	INC TEMPN+1
XSFNC1:	LDA GETRM2	;Ghost-memory bank 2, System table
	LDY #$00
	LDA (TEMPN),Y
	STA TEMPNH
	INY
	LDA (TEMPN),Y
	STA TEMPNH+1
	LDA GETRM1	;Ghost-memory bank 2 disable
	LDA GETRM1
	JMP (TEMPNH)	;Execute the routine

;FBODY1 contains a one-byte index to a table of pointers to system routines
;The table starts at GHOMEM, and the index is multiplied by two for indexing
;the sixteen-bit addresses. Adresses in the table are stored low byte first,
;high byte next.

;For THEN, pointer points to XXSFR1
;For RPAR, pointer points to XXSFR2
;For LPAR, pointer points to PARLOP
;For ALL, NAMES, TITLES, and PROCEDURES, pointers all point to XXSFR3

XXSFR1:	LDA #XTHN
	JMP ERROR
XXSFR2:	LDA #XRPN
	JMP ERROR
XXSFR3:	LDY #CURTOK
	LDA #XOPO
	JMP ERROR
.PAGE
;UFUNCL calls a ufun, storing a new stack frame or calling XTAIL to tail-recurse.
;This is a stack frame:
;	Entry	Index
;
;	FRAME	0	(when entered, ie "previous")
;	XFRAME	2
;	UFRMAT	4
;	CURTOK	5
;	NEST	7
;	IFTEST	9
;	TOKPTR	10
;	NARGS	12
;	TLLEVS	13
;
;	Binding Pairs:
;	BINDGS	15
;	FUNCT	17
;	VALUEn	19+2*n
;	NAMEn	21+2*n
;XFRAME points above last binding pair.

UFUNCL:	LDY #$03
	LDA UFRMAT
	BEQ LPK1
	INY
	INY
LPK1:	LDA (FPTR),Y
	STA TEMPN	;Lastline
	JSR TSTSTK
	LDX #ULNEND
	JSR PUSHP
	LDA UFRMAT
	JSR PUSHB
	LDX #FBODY
	JSR PUSHP
	LDX #FPTR
	JSR PUSHP
	LDA RUNFLG
	JSR PUSHB
	LDA #$00
	STA STPFLG
	STA RUNFLG
	STA GOPTR+1
	STA TEMPN1+1
	LDA FBODY1
	STA FBODY
	STA FPTR
	LDA FBODY1+1
	STA FBODY+1
	STA FPTR+1
	LDA NEST
	BNE XUFN1
	LDA NEST+1
	BNE XUFN1
	LDA LEVNUM
	BNE XUFN2
	LDA LEVNUM+1
	BEQ XUFN1
XUFN2:	LDA TEMPN	;Lastline
	BNE XUFN3
	LDA TOKPTR+1
	BNE XUFN5
	JMP XUFN1A
XUFN3:	LDA TOKPTR+1
	BEQ XUFN1
XUFN5:	LDY #$00
	LDA (TOKPTR),Y
	STA TEMPN1
	INY
	LDA (TOKPTR),Y
	STA TEMPN1+1
XUFN1:	LDX #FBODY
	JSR GETTYP
	STA UFRMAT
	LDA TEMPN1
	CMP LSTOP
	BNE XUFN6
	LDA TEMPN1+1
	CMP LSTOP+1
	BNE XUFN6
XUFN1A:	LDA XFRAME
	STA SP
	LDA XFRAME+1
	STA SP+1
	JMP XTAIL
XUFN6:	LDX FRAME
	LDY FRAME+1
	LDA SP
	STA FRAME
	LDA SP+1
	STA FRAME+1	;FRAME points to previous frame
	JSR PUSH
	LDX #XFRAME
	JSR PUSHP
	LDA UFRMAT
	JSR PUSHB
	LDX #CURTOK
	JSR PUSHP
	LDX #NEST
	JSR PUSHP
	LDA IFTEST
	JSR PUSHB
	LDX #TOKPTR
	JSR PUSHP
	LDX NARGS
	INX
	TXA
	JSR PUSHB	;Push NARGS+1
	LDX #TLLEVS
	JSR PUSHP
	LDY #$00
	STY IFTEST	;Default is FALSE
	LDA (FUNCT),Y
	TAX
	INY
	LDA (FUNCT),Y
	TAY
	JSR PUSH
	LDX FUNCT
	LDY FUNCT+1
	INX
	JSR PUSH	;Push FUNCT+1
	LDY #$01
	STY TLLEVS
	DEY
	STY TLLEVS+1
	DEY
	STY NEST
	STY NEST+1
	INC LEVNUM
	BNE XUFN6C
	INC LEVNUM+1
	BNE XUFN6C
	JMP EXCED
XUFN6C:	INY
	LDA FRAME
	STA (FUNCT),Y
	INY
	LDA FRAME+1
	STA (FUNCT),Y
	JSR STPTR1
	LDY #FBODY
	LDX #TEMPN1	;TEMPN1 gets ARGLIST
	JSR GETULN
XUFNW:	LDA TEMPN1+1
	BEQ XUFNWE
	JSR PTVTST
	LDY #$00
	LDA (TEMPN1),Y
	STA TEMPN2	;TEMPN2 is VARNAM
	INY
	LDA (TEMPN1),Y
	STA TEMPN2+1
	LDX #TEMPN1
	JSR TTKADV
	LDY #TEMPN2
	LDX #TEMPN	;TEMPN is TEMP1
	JSR GETVAL
	LDX #TEMPN
	JSR PUSHP
	LDY #$00
	LDA (TEMPN5),Y	;TEMPN5 is POINTER
	STA TEMPN
	INY
	LDA (TEMPN5),Y
	STA TEMPN+1
	JSR PTRDEC
	LDX #TEMPN
	LDY #TEMPN2
	JSR PUTVAL
	LDX #TEMPN2
	JSR PUSHP
	JMP XUFNW
XUFNWE:	LDA SP
	STA XFRAME	;XFRAME points to location after last binding pair
	LDA SP+1
	STA XFRAME+1
	JSR INCVSP
	;falls through
.PAGE
;UF1 does a line of the procedure.

	;falls in
UF1:	LDA GOPTR+1
	BNE UF1A
	LDX #FPTR
	JSR ULNADV
	JMP UF1C
UF1A:	LDA GOPTR	;GOPTR <> NIL, so FPTR := GOPTR, reset GOPTR.
	STA FPTR
	LDA GOPTR+1
	STA FPTR+1
	LDA #$00
	STA GOPTR+1
UF1C:	LDA STPFLG
	BNE UF2A
	LDA FPTR+1
	BEQ UF2
UF1D:	LDY #FPTR
	LDX #TOKPTR
	JSR GETULN
	LDX #UF1&$FF
	LDY #UF1^
	JSR PUSH
	JMP EVLINE

;End of a procedure.

UF2:	LDA STPFLG
	BNE UF2A
	STA OTPUTN
UF2A:	SEC
	LDA LEVNUM
	SBC TLLEVS
	STA LEVNUM
	LDA LEVNUM+1
	SBC TLLEVS+1
	STA LEVNUM+1
	LDA #$00
	STA STPFLG
	JSR POPFRM
	JSR POPB
	STA RUNFLG
	LDX #FPTR
	JSR POP
	LDX #FBODY
	JSR POP
	JSR POPB
	STA UFRMAT
	LDX #ULNEND
	JSR POP
	JMP POPJ
.PAGE
;Tail-recursive ufun handler.
XTAIL:	LDA #$FF
	STA NEST
	STA NEST+1
	INC LEVNUM
	BNE XTAIL1
	INC LEVNUM+1
	BNE XTAIL1
	JMP EXCED
XTAIL1:	INC TLLEVS
	BNE XTAIL2
	INC TLLEVS+1
	BNE XTAIL2
	JMP EXCED
XTAIL2:	JSR STPTR1	;POINTER is TEMPN1
	LDY #$0C	;Frame index for Number-of-bindings is 12
	LDA (FRAME),Y
	STA TEMPN3	;BINDINGS
	LDY #FBODY
	LDX #TEMPN2	;ARGLIST
	JSR GETULN
	LDY #$04	;Frame index for Format is 4
	LDA UFRMAT
	STA (FRAME),Y
	INY		;Frame index for UFUN (CURTOK) is 5
	LDA CURTOK
	STA (FRAME),Y
	INY
	LDA CURTOK+1
	STA (FRAME),Y
	LDY #$00	;Frame index for FRAME is 0
	LDA (FUNCT),Y
	CMP FRAME
	BNE XTALWB
	INY
	LDA (FUNCT),Y
	CMP FRAME+1
	BNE XTALWB
XTALWA:	LDA TEMPN2+1
	BEQ XTLWAE
XTALW1:	JSR PTVTST
	LDY #$00
	LDA (TEMPN2),Y
	STA TEMPN4	;VARNAME
	INY
	LDA (TEMPN2),Y
	STA TEMPN4+1
	LDX #TEMPN2
	JSR TTKADV
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPN1
	INY
	LDA (TEMPN5),Y
	STA TEMPN1+1
	JSR PTRDEC
	LDX #TEMPN1
	LDY #TEMPN4
	JSR PUTVAL
	JMP XTALWA
XTLWAE:	LDY #$0C	;Frame index for Number-of-bindings is 12
	LDA TEMPN3
	STA (FRAME),Y
	JMP XTAIL4
XTALWB:	LDA TEMPN2+1
	BEQ XTLWBE
XTALW2:	JSR PTVTST
	LDY #$00
	LDA (TEMPN2),Y
	STA TEMPN4
	INY
	LDA (TEMPN2),Y
	STA TEMPN4+1
	LDX #TEMPN2
	JSR TTKADV
	LDY #TEMPN4
	LDX #TEMPN1
	JSR GETVAL
	LDX #TEMPN1
	JSR PUSHP
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPN1
	INY
	LDA (TEMPN5),Y
	STA TEMPN1+1
	JSR PTRDEC
	LDX #TEMPN1
	LDY #TEMPN4
	JSR PUTVAL
	LDX #TEMPN4
	JSR PUSHP
	JMP XTALWB
XTLWBE:	LDY #$00
	LDA (FUNCT),Y
	STA TEMPN1
	INY
	LDA (FUNCT),Y
	STA TEMPN1+1
	LDX #TEMPN1
	JSR PUSHP
	LDX FUNCT
	LDY FUNCT+1
	INX
	JSR PUSH	;Push FUNCT+1
	LDY #$00
	LDA FRAME
	STA (FUNCT),Y
	INY
	LDA FRAME+1
	STA (FUNCT),Y
	LDY #$0C	;Frame index for Number-bindings is 12.
	SEC		;Carry added in (BINDINGS + NARGS + 1)
	LDA TEMPN3
	ADC NARGS
	STA (FRAME),Y
	LDA SP
	STA XFRAME
	LDA SP+1
	STA XFRAME+1	;XFRAME := SP (right above last binding pair)
XTAIL4:	JSR INCVSP
	JMP UF1
.PAGE
STPTR1:	LDA NARGS
	ASL A
	CLC
	ADC VSP
	STA TEMPN5
	LDA VSP+1
	ADC #$00
	STA TEMPN5+1	;POINTR := VSP + (NARGS * 2)
	RTS

PTVTST:	LDA VSP+1
	CMP TEMPN5+1
	BNE SBHAK1
	LDA VSP
	CMP TEMPN5
	BNE SBHAK1
PTVBUG:	JSR SYSBUG	;Error if POINTER = VSP

PTRDEC:	SEC
	LDA TEMPN5
	SBC #$02
	STA TEMPN5
	BCS SBHAK1
	DEC TEMPN5+1	;POINTR := POINTR - 2
SBHAK1:	RTS

INCVSP:	LDA NARGS
	ASL A
	CLC
	ADC VSP
	STA VSP
	BCC INCVE
	INC VSP+1	;VSP := VSP + NARGS * 2
INCVE:	RTS
.PAGE
;General error-handler routine.
ERROR1:	LDX #$00
	STX RUNFLG
	LDA ERRFLG
	STA ANSN4
	STX ERRFLG
	CMP #XZAP
	BEQ PPTTP
	LDX LEVNUM
	BNE ERR1A
	LDX LEVNUM+1
	BEQ PPTTP
ERR1A:	CMP #XBRK
	BEQ ERR1B
PPTTP:	LDA FRAME+1
	BEQ PPTT2
PPTTP1:	JSR RSTBND
	LDY #$02	;XFRAME index is 2
	LDA (FRAME),Y
	STA XFRAME
	INY
	LDA (FRAME),Y
	STA XFRAME+1
	LDY #$00	;Previous-frame index is 0
	LDA (FRAME),Y
	TAX
	INY
	LDA (FRAME),Y
	STA FRAME+1
	STX FRAME
	BNE PPTTP1
PPTT2:	LDA #$00
	STA LEVNUM
	STA LEVNUM+1
	LDA ANSN4
	CMP #XZAP
	BNE JTOP
	LDA ANSN3
	CMP #XNSTRN
	BNE JTOP
	LDA #VPDLBA&$FF
	STA VSP		;If error was "out-of-nodes",
	LDA #VPDLBA^	;reset VPDL, do a garbage collect,
	STA VSP+1	;and check remaining nodes. If low,
	JSR GARCOL	;ask user to delete something.
	LDA NNODES+1
	CMP #NODLIM^
	BCC JTOP
	BNE NWARN
	LDA NNODES
	CMP #NODLIM&$FF
	BCC JTOP
NWARN:	LDX #WRNMSG&$FF
	LDY #WRNMSG^	;"Please delete something"
	JSR PRTSTR
JTOP:	JMP TOPLOP
ERR1B:	LDX #ULNEND
	JSR PUSHP	;Push the state where the PAUSE occurred
	LDX #FBODY
	JSR PUSHP
	LDX #FPTR
	JSR PUSHP
	LDA RUNFLG
	JSR PUSHB
	LDX #TOKPTR
	JSR PUSHP
	LDA OTPUTN
	JSR PUSHB
	LDX #IFLEVL
	JSR PUSHP
	LDA EXPOUT
	JSR PUSHB
	LDA STPFLG
	JSR PUSHB
	LDA UFRMAT
	JSR PUSHB	;That should be enough
	;falls through
.PAGE
;Break-loop error handler.
	;falls in
BRKLOP:	LDA COFLG
	BEQ ERR2A
	DEC COFLG	;Nonzero means break out, so reset it
	JSR POPB	;Pop back the state at which the PAUSE occurred
	STA UFRMAT
	JSR POPB
	STA STPFLG
	JSR POPB
	STA EXPOUT
	LDX #IFLEVL
	JSR POP
	JSR POPB
	STA OTPUTN
	LDX #TOKPTR
	JSR POP
	JSR POPB
	STA RUNFLG
	LDX #FPTR
	JSR POP
	LDX #FBODY
	JSR POP
	LDX #ULNEND
	JSR POP		;And that's the state
	JMP EVLINE	;Go back where you came from
ERR2A:	LDA #'L		;Both flags = 0, it's a Pause.
	JSR TPCHR	;Type an "L"
	LDX #LEVNUM
	JSR TYPFIX
	LDX #TOKPTR
	JSR PRDLIN	;Get a line
ERR2A2:	LDX #BRKLOP&$FF
	LDY #BRKLOP^
	JSR PUSH
	LDA #LIST
	STA UFRMAT
	LDA #$00
	STA FBODY+1	;Tells ERROR that we're now at toplevel of a break-loop
	JMP EVLINE
.PAGE
.SBTTL	Reader and Parser
READLN:	STX TEMPX2	;Input line pointer location
	BNE REDLN1	;(Always)
PRDLIN:	STX TEMPX2
	LDA #QPRMPT	;Reqular prompt
	JSR TPCHR
REDLN1:	JSR GETLN	;Get a line into the Line buffer
	STX TEMPN7
PRDLNX:	LDA #$00	;(??expand so input-line can be anywhere)
	STA TEMPN8	;List-nesting counter
	STA TEMPN8+1	;Character buffer pointer
	STA CELPTR
	STA CELPTR+1
	LDX TEMPX2
	STA $00,X	;Initialize ANS to Lnil
	STA $01,X
	INC PRSFLG
	LDA #NEWLIN
	STA TEMPX2+1	;Current cell type
RDLNW:	LDA TEMPN8+1	;Loop processes line, token by token
	CMP TEMPN7
	BNE TGTTOK	;Process the next token
RDLNWE:	JSR POPLST
	LDA #$00
	STA CELPTR
	STA CELPTR+1
	STA PRSFLG
	RTS
TGTTOK:	LDA #$00
	STA ANSN3	;No typecode yet (for SELFDL)
	STA TEMPN7+1	;Funny-pname if non-zero
	STA TEMPN4+1	;Indicates quoted atom if non-zero
	LDX TEMPN8+1
TGT1:	LDA LINARY,X
	CMP #$20
	BNE TGT2
	INX
	CPX TEMPN7
	BNE TGT1	;Skip spaces
	BEQ RDLNWE	;(always)
JNTNUM:	LDA #ATOM	;In a list,
	STA ANSN3	;everything's an atom
	JMP NOTNUM
TGT2:	STX TEMPN8+1
	CMP #']
	BEQ TKRBR
	PHA
	JSR ALLSTC
	PLA
	CMP #'[
	BEQ TKLBR
	LDY PRSFLG
	BMI JNTNUM	;If PRSFLG negative, then REQUEST set it, parse as a list
	LDY TEMPN8	;List nesting counter
	BNE JNTNUM	;If in a list, just make a string element
	JSR SELFDL
	BCC TKNDL
	INC TEMPN8+1
TKDLM:	STA TEMPN5
	LDX #$00
	STX TEMPN5+1
	LDY #TEMPN5	;Cons up a pname
	LDA #TEMPN6
	STA ANSN
	LDA #STRING
	JSR CONS
	LDA #ATOM
	STA ANSN3
	JMP ADDTOK
TKLBR:	INC TEMPN8	;Start list - increment list nesting counter
	INC TEMPN8+1	;Skip to next character
	LDX #CELPTR
	JSR PUSHP	;Push the list-pointer cell
	LDA #NEWLST
	STA TEMPX2+1	;Next cell allocated will be New-list type
	JMP RDLNW	;Continue processing line
TKRBR:	DEC TEMPN8	;End list - decrement list nesting counter
	BMI TKRBR1	;Error if unbalanced brackets
	INC TEMPN8+1	;Skip to next character
	LDX #CELPTR
	JSR POP		;Pop list pointer
	LDA #REGCEL
	STA TEMPX2+1
	JMP RDLNW	;Continue processing line
TKRBR1:	LDX #RDRER2&$FF
	LDY #RDRER2^
	JSR PRTSTR	;Print "You have mismatched brackets" error
	INC TEMPN8	;Reset brackets counter
	INC TEMPN8+1	;Skip this bracket
	JMP RDLNW	;Continue processing line
TKNDL:	CMP #'"
	BNE TGT3A
	INC TEMPN4+1	;Quoted atom
	INC TEMPN8+1	;Skip to next character
	LDA #QATOM
	STA ANSN3
	JMP TGT3B1	;Check for funny-pname
TGT3A:	CMP #$27	;(Single Quote)
	BNE TGT3B
	INC TEMPN8+1	;Skip to next character
	INC TEMPN7+1	;Token is a funny-pname
TKAORL:	LDA #ATOM	;Token is an Atom or Label
	STA ANSN3
	JMP TKATOM	;Tokenize it
TGT3B:	CMP #':
	BNE TKAORL
	INC TEMPN8+1	;Skip to next character
	LDA #DATOM
	STA ANSN3
TGT3B1:	LDX TEMPN8+1
	LDA LINARY,X
	CMP #$27
	BNE TKATOM
	INC TEMPN7+1	;Token is funny-pname
	INC TEMPN8+1	;Skip to next character
TKATOM:	LDX TEMPN8+1
	CPX TEMPN7	;Check for empty word at end-of-line
	BEQ EMPTWD
	LDA TEMPN7+1
	BNE NOTNUM	;Funny-pname, not fixnum then
TKATM2:	LDA LINARY,X
	CMP #$20	;Check for empty word inside line
	BNE TKATM1
	INC TEMPN8+1	;Skip space if necessary
EMPTWD:	JMP ADDTK4	;Make an empty word node and link it
TKATM1:	JSR SELFDL
	BCS EMPTWD	;Delimiter encountered immediately, so empty word
	LDA ANSN3
	CMP #ATOM
	BNE NOTNUM	;Only atoms can be numbers now
	JSR CNUML0	;Attempt to compute numerical value, clear indicators
ATM1:	STX TEMPN2	;Save temporary character pointer
	CPX TEMPN7
	BEQ ATM2	;End of line encountered, must be numerical
	LDA LINARY,X
	JSR SELFDL
	BCC ATM1A	;Continue if not self delimiter
	LDY ANSN3
	CPY #LATOM
	BNE ATM2	;Self-delimiter, not colon, so clean up
	JMP NTNUMA	;It's a label, treat it as a word
ATM1A:	JSR CNUML1	;Process the next digit
	BCC NOTNUM	;Carry clear means not a number
	LDX TEMPN2
	INX		;Get next digit
	JMP ATM1
ATM2:	STX TEMPN2	;All characters processed - save character pointer
	JSR CNUML2	;Finish numerical processing
	BCC NOTNUM
	LDX TEMPN2
	STX TEMPN8+1	;Numerically ok, reset real character pointer
	LDX #TEMPN6
	STX ANSN
	LDX #NARG1+2	;High word
	LDY #NARG1	;Low word
	JSR CONS	;Cons a numerical cell with the value in it
	LDY #$00
	LDA TEMPN6
	STA (CELPTR),Y	;Link the cell on to the input line
	INY
	LDA TEMPN6+1
	STA (CELPTR),Y
	JMP RDLNW	;Continue processing line
NTNUMA:	LDA #ATOM
	STA ANSN3	;Don't say it's a label yet
NOTNUM:	LDX #TEMPX1	;cons up a pname (original pointer)
	LDA #$00
	STA TEMPN6	;Zero pointer in case it's nil
	STA TEMPN6+1
	STA ANSN4	;Indicates end of pname if non-zero
	PHA		;First time around, push zero
	BEQ NXTCHS	;(Always)
NXTTWO:	LDA ANSN4	;Next two characters
	BNE ADDTOK	;Link up token if end of pname
	LDA #$02
	PHA		;Not first time around, push 2
	LDX #TEMPN5	;Next pointer
NXTCHS:	STX ANSN
	LDX TEMPN8+1
	CPX TEMPN7
	BEQ ADDTK1	;Finish token (end of line), even no. chars.
	LDA LINARY,X
	STA TEMPN1	;First character in pair
	JSR SELFDL
	BCS ADDTK2	;Finish token (delimiter hit), even no. chars.
	INX		;Skip to next character
	CPX TEMPN7
	BEQ FINTK1	;Finish token (end of line), odd no. chars.
	LDA LINARY,X
	STA TEMPN1+1	;Second character in pair
	JSR SELFDL
	BCS FINTK1	;Finish token (delimiter hit), odd no. chars.
	INX
	BCC CNSSTR	;(Always) Cons new pair on to pname string
FINTK1:	LDA #$00
	STA TEMPN1+1	;Odd no. chars. in pname, zero last character
	INC ANSN4	;Indicates end of pname
CNSSTR:	STX TEMPN8+1	;Skip the last character (if not delimiter)
	LDY #TEMPN1
	LDX #$00
	LDA #STRING
	JSR CONS	;Cons up the new pname pair
	PLA
	TAY		;0 first time, 2 otherwise
	BNE NTFRST
	LDA TEMPX1
	STA (CELPTR),Y	;(Linking garbage-collect-protects it)
	STA TEMPN6	;Atom pointer
	INY
	LDA TEMPX1+1
	STA (CELPTR),Y
	STA TEMPN6+1
	JMP NXTTWO	;Continue making the pname
NTFRST:	LDA TEMPN5	;Link cell onto pname string
	TAX
	STA (TEMPX1),Y
	INY
	LDA TEMPN5+1
	STA (TEMPX1),Y
	STA TEMPX1+1
	STX TEMPX1
	JMP NXTTWO	;Continue making the pname
ADDTK2:	STX TEMPN8+1	;In case colon or quote skipped
ADDTK1:	PLA		;Pop chain indicator if loop exit
ADDTOK:	LDA TEMPN6+1
	BNE ADDTK3
ADDTK4:	LDA #TEMPN6
	JSR MAKMTW	;If pointer is zero, make an empty word pointer
ADDTK3:	LDX #TEMPN6
	LDY #TEMPX1
	JSR INTERN	;Intern atom
ATM12B:	LDA ANSN3
	CMP #ATOM
	BEQ ATM12A
	LDX #TEMPX1
	JSR PUTTYP	;Give atom a type if not Atom
ATM12A:	LDY #$00
	LDA TEMPX1
	STA (CELPTR),Y	;Link atom onto input line
	INY
	LDA TEMPX1+1
	STA (CELPTR),Y
	LDA TEMPN7+1
	BEQ NXTE
	LDX #TEMPX1
	JSR PTSPNM	;Put-strange-pname if funny-pname indicated
NXTE:	JMP RDLNW	;Continue processing line
.PAGE
POPLST:	LDA TEMPN8
	BEQ PPLRTS
POPLS1:	LDA INPFLG
	BNE RDL1A2
	LDA #']		;Close the list (unless in read-eval loop)
	JSR TPCHR
RDL1A2:	LDX #TEMPN1
	JSR POP		;Discard pushed list pointers
	DEC TEMPN8	;Decrement list nesting counter
	BNE POPLS1
	LDA INPFLG
	BNE PPLRTS
	JMP BREAK1

ALLSTC:	LDA #TEMPN	;Allocate a new list cell
	STA ANSN
	LDA #$00
	TAX
	TAY
	JSR CONS	;(Type list)
	LDY #$00
	LDA TEMPX2+1
	CMP #NEWLIN
	BNE ALSTC1
	LDX TEMPX2	;New line, ANS pointer points to cell
	LDA TEMPN
	STA $00,X
	LDA TEMPN+1
	STA $01,X
	BNE ALSTC3	;(Always)
ALSTC1:	CMP #NEWLST
	BEQ ALSTC4	;For new-list, rplaca onto input line
	INY		;Regular cell, link onto input line
	INY
ALSTC4:	LDA TEMPN
	STA (CELPTR),Y	;Rplaca or Rplacd for new-list or regular-cell
	INY
	LDA TEMPN+1
	STA (CELPTR),Y
ALSTC3:	LDA TEMPN
	STA CELPTR	;New input line end pointer
	LDA TEMPN+1
	STA CELPTR+1
	LDA #REGCEL
	STA TEMPX2+1	;Next cell allocated will be regular-cell
PPLRTS:	RTS
.PAGE
SELFDL:	LDY TEMPN8	;Checks for self-delimiter
	BNE SLF2A	;Treat list elements like Qatoms
	LDY PRSFLG
	BMI SLF2A	;(Also if REQUEST set PRSFLG negative)
	LDY TEMPN7+1
	BEQ SLF2	;Not funny-pname
	CMP #$27	;If funny-pname, look for quote
	BNE DIGN	;Not delimiter if no quote
	INX
	LDA LINARY,X
	CMP #$27	;Look for pair of quotes
	BEQ DIGN	;If pair, skip over one, not delimiter
	JMP DIGY	;If no pair, the quote is a delimiter, skip it
SLF2:	LDY TEMPN4+1	;Check for quoted atom
	BEQ SLF1
SLF2A:	CMP #$20	;Quoted atoms can be terminated by a space,
	BEQ DIGY
	CMP #']		;or a closing bracket,
	BEQ DIGY
	CMP #'[
	BEQ DIGY
	BNE DIGN	;(Always)
SLF1:	LDY ANSN3	;Check for type Atom
	CPY #ATOM
	BNE SLF3
	CMP #':		;If Atom, check for colon (for Label atom)
	BNE SLF3
	INX		;If colon, skip over it and change type to Latom
	LDY #LATOM
	STY ANSN3
	JMP DIGY
SLF3:	CMP #$20	;Compare character to all delimiters
	BEQ DIGY
	CMP #'<
	BEQ DIGY
	CMP #'>
	BEQ DIGY
	CMP #'=
	BEQ DIGY
	CMP #$3B	;(Semicolon)
	BEQ DIGY
	CMP #')
	BEQ DIGY
	CMP #'(
	BEQ DIGY
	CMP #'+
	BEQ DIGY
	CMP #'-
	BEQ DIGY
	CMP #'*
	BEQ DIGY
	CMP #'/
	BEQ DIGY
	CMP #']
	BEQ DIGY
	CMP #'[
	BNE DIGN
DIGY:	SEC		;Carry set means true
	RTS

DIGITP:	CMP #':		;Checks to see if character is a digit (0-9)
	BCC DIGP1
DIGN:	CLC		;Carry clear means not true
	RTS
DIGP1:	CMP #'0		;(Sets carry correctly)
	RTS
.PAGE
.SBTTL	Number Parsing Utilities:
;Process a character, number-building
CNUML1:	LDX TEMPN5	;Flonum indicator
	BNE NFLDIG	;Process next flonum character
	JSR DIGITP	;Still a fixnum
	BCC NTFIX1	;Not a digit, isn't a fixnum then
	INC TEMPN6+1	;Indicate presence of digit
	PHA		;Save digit
	JSR NMROL1	;Multiply by 2 first
	BMI NTFIX3	;Not a fixnum if value overflow
	LDY #A1L
	JSR XN1TOY	;Copy doubled number
	JSR NMROL1	;Multiplied by 4
	BMI NTFIX2
	JSR NMROL1	;Multiplied by 8
	BMI NTFIX2
	JSR ADDNUM	;Multiplied by 10.
	BMI NTFIX2
	PLA
	PHA
	JSR ADDDIG	;Add value of current digit to subtotal
	BMI NTFIX2
	PLA		;Retrieve digit
NUMOK:	SEC		;Indicate number OK
	RTS
NTFIX2:	LDY #A1L
	JSR XYTON1	;Fixnum overflow, doubled number is in A1L-A2H, transfer
NTFIX3:	JSR NMROR1	;Halve it
	INC TEMPN5	;Indicate flonum (1)
	JSR FLOTN1	;Convert to floating pt.
	PLA		;Get the digit back
FADNML:	INC TEMPN6+1	;Indicate prescence of digit
	JSR MULN10	;Shift number before adding
	BCS NTNUM	;Balk if overflow
	JSR FADDIG	;Add it to the number (left of point)
	JMP NUMOK
FNDIGD:	INC TEMPN6+1	;Indicate presence of digit
	JSR FADDGN	;Add it to the number (right of point)
	JMP NUMOK
NFLDIG:	CPX #$02	;New flonum digit
	BNE NFLDG1
	JSR DIGITP	;In decimal mode
	BCS FNDIGD	;If digit, add to number
	BCC FCKEN	;Else check for E or N
NFLDG1:	CPX #$03	;See if exponent mode
	BEQ FXDIG
	JSR DIGITP	;Normal mode, check for digit
	BCS FADNML	;Add it if it is, else
NTFIX1:	CMP #'.		;See if digit is legal
	BEQ FMDECI
FCKEN:	CMP #'E		;Check for E or N
	BEQ FXPOS
	CMP #'N
	BNE NTNUM
	INC TEMPN5+1	;Indicate negative exponent
FXPOS:	LDA TEMPN6+1
	BEQ NTNUM	;Check that a digit was typed (so ".Ex" is illegal)
	LDX TEMPN5
	LDA #$03
	STA TEMPN5	;Indicate exponent mode (3)
	LDA #$00
	STA TEMPN6+1	;Now, indicates exponent digit presence
	BEQ MAKFLO	;(Always)
FXDIG:	JSR DIGITP	;Exponent mode, must be a digit
	BCC CNMR
	INC TEMPN6+1	;Indicate presence of exponent digit
	JSR INCEXP	;Exponentiate by vA
	JMP NUMOK
FMDECI:	LDX #$03
FMDCL:	LDA KDECI,X	;Decimal mode, set up place multiplier (0.1)
	STA NARGX,X
	DEX
	BPL FMDCL
	LDX TEMPN5
	LDA #$02
	STA TEMPN5	;Indicate decimal mode (2)
MAKFLO:	TXA
	BNE NUMOK	;Exit OK if flonum, else...
	JSR FLOTN1	;make it one
	JMP NUMOK
NTNUM:	CLC		;Not a number
CNMR:	RTS

;Number gobbled, finish number-building.
CNUML2:	LDX TEMPN5
	BEQ CNUM2X
	LDA TEMPN6+1	;If floating pt., make sure that there's a digit
	BEQ NTNUM
	LDA TEMPX1	;Check for exponent
	BEQ CNUM2R
	LDA TEMPN5+1	;Check its sign
	BNE CNUM2D
CNUM2C:	JSR MULN10	;Multiply by 10 according to (positive) exponent value
	BCS NTNUM
	DEC TEMPX1
	BNE CNUM2C
	BEQ CNUM2R	;(Always)
CNUM2D:	JSR FDVD10	;Divide by 10 according to (negative) exponent value
	DEC TEMPX1
	BNE CNUM2D
CNUM2R:	LDA #FLO
	SEC
	RTS
CNUM2X:	LDA #FIX
	SEC
	RTS

CNUML0:	LDA #$00
	STA NARG1	;Initialize number to 0
	STA NARG1+1
	STA NARG1+2
	STA NARG1+3
	STA TEMPN5	;Flonum indicator
	STA TEMPN5+1	;Exponent sign indicator
	STA TEMPN6+1	;Indicates the presence of a mant. or exp. digit
	STA TEMPX1	;Exponent counter
	RTS

NMROL1:	ASL NARG1	;Double number in NARG1
	ROL NARG1+1
	ROL NARG1+2
	ROL NARG1+3
	RTS

NMROR1:	LSR NARG1+3	;Halve number in NARG1
	ROR NARG1+2
	ROR NARG1+1
	ROR NARG1
	RTS

XN1TOY:	LDX #$FC
XN1YL:	LDA NARG1+4,X
	STA $00,Y
	INY
	INX
	BMI XN1YL
	RTS

XYTON1:	LDX #$FC
XYN1L:	LDA $00,Y
	STA NARG1+4,X
	INY
	INX
	BMI XYN1L
	RTS

XYTON2:	LDX #$FC
XYN2L:	LDA $00,Y
	STA NARG2+4,X
	INY
	INX
	BMI XYN2L
	RTS

XN2TOY:	LDX #$FC
XN2YL:	LDA NARG2+4,X
	STA $00,Y
	INY
	INX
	BMI XN2YL
	RTS

ADDNUM:	LDX #$FC	;Add A1L to NARG1
	CLC
ADDNML:	LDA A1L+4,X
	ADC NARG1+4,X
	STA NARG1+4,X
	INX
	BMI ADDNML
	TAX
	RTS

ADDDIG:	SEC		;Add Ascii digit in A to NARG1
	SBC #'0
	CLC
	LDX #$FC
	BNE ADDL1A	;(Always)
ADDLP1:	LDA #$00
ADDL1A:	ADC NARG1+4,X
	STA NARG1+4,X
	INX
	BMI ADDLP1
	TAX
	RTS

FADDGX:	SEC
	SBC #'0		;Get the digit's value
	STA NARG2	;Add A to NARG1, floating pt.
	LDA #$00
	STA NARG2+1	;Put A in NARG2, make it floating pt., and add
	STA NARG2+2
	STA NARG2+3
	JSR FLOTN2
	JMP FADD

FADDIG:	JSR FADDGX
	BCS NUMOVF
	RTS

FADDGN:	PHA		;Add decimal digit to floating pt. number
	LDY #A1L
	JSR XN1TOY	;Save NARG1
	PLA
	SEC
	SBC #'0
	STA NARG2	;Put digit in NARG2
	LDA #$00
	STA NARG2+1
	STA NARG2+2
	STA NARG2+3
	JSR FLOTN2
	LDY #NARGX	;Get decimal place constant
	JSR XYTON1
	JSR FMUL	;Multiply digit by decimal place (10^-N)
	LDY #A1L
	JSR XYTON2	;Get orig. number back
	JSR FADD	;and add new placed digit
	LDY #A1L
	JSR XN1TOY	;Save it
	LDY #NARGX
	JSR XYTON1	;Get place multiplier
	JSR FDVD10     	;Divide by ten
	LDY #NARGX
	JSR XN1TOY	;And put back
	LDY #A1L
	JMP XYTON1	;Get number back

MULN10:	LDX #$03	;Multiply NARG1 by 10., floating pt.
MLN10L:	LDA FLT10,X	;Put 10. (floating pt. constant) in NARG2
	STA NARG2,X
	DEX
	BPL MLN10L
	JMP FMUL	;and multiply (calling procedure checks for overflow)

FDVD10:	LDX #$03	;Divide NARG1 by 10., floating pt.
FDV10L:	LDA FLT10,X	;Put 10. (floating pt. constant) in NARG2
	STA NARG2,X
	DEX
	BPL FDV10L
	JMP FDIV

INCEXP:	SEC
	SBC #'0
	TAY		;Multiply exponent by ten and add new digit
	ASL TEMPX1
	BMI NUMOVF
	LDA TEMPX1
	ASL A
	BMI NUMOVF
	ASL A
	BMI NUMOVF
	ADC TEMPX1
	BMI NUMOVF
	STA TEMPX1
	TYA
	ADC TEMPX1
	BMI NUMOVF
	STA TEMPX1
	RTS

NUMOVF:	PLA		;Overflow, pop past subroutine
	PLA
	CLC		;Indicate not a number
	RTS
.PAGE
.SBTTL	Initializations
INITLZ:	LDA #$00
	STA NPARTS
	STA GRPHCS
	STA DEFFLG
	STA DEFBOD
	STA DEFBOD+1
	STA LEVNUM	;Clear LEVNUM so ERROR doesn't choke initially
	STA LEVNUM+1
	STA IFTEST	;Default is FALSE
	JSR RSTERR
	JSR QUIETM	;Make the ALF card shut up.
	JSR CLRMRK	;Reset G.C. Array (Typebase bits)
	JSR DOSSTP	;Possibly this
	LDA KILRAM	;will stop
	LDA #$8D	;DOS from
	JSR TPCHR	;crashing at
	LDA GETRM1	;the beginning
	LDA GETRM1	;with errors
	JSR RSTIO	;Set I/O to to default
	JSR RESETT	;Clear screen, etc.
	LDA #BASARY&$FF
	STA TEMPN
	LDA #BASARY^
	STA TEMPN+1
	LDY #$00
	TYA		;Clear the SARRAY, 4 at a time
CLRLP1:	STA (TEMPN),Y
	INC TEMPN
	BNE ADHAK4
	INC TEMPN+1
ADHAK4:	LDX TEMPN
	CPX #PDLBAS&$FF	;PDL starts right after SARRAY
	BNE CLRLP1
	LDX TEMPN+1
	CPX #PDLBAS^
	BNE CLRLP1
	;falls through
.PAGE
	;falls in
REINIT:	LDX #$00
	STX NNODES	;Node allocation counter
	STX NNODES+1
	STX PODEFL+1
	JSR CLRCBF
	LDA #BASARY&$FF
	STA SARTOP
	LDA #BASARY^
	STA SARTOP+1
	LDA #PDLBAS&$FF
	STA SP
	LDA #PDLBAS^
	STA SP+1
	LDA #VPDLBA&$FF
	STA VSP
	LDA #VPDLBA^
	STA VSP+1
	LDA #EDBUF&$FF	;Tell RETRIEVE that buffer is not retrievable
	STA ENDBUF
	LDA #EDBUF^
	STA ENDBUF+1
	LDA #BIGBAS&$FF
	STA SOBLST
	STA SOBTOP
	LDA #BIGBAS^
	STA SOBLST+1
	STA SOBTOP+1	;SOBTOP is SOBPTR for now
	LDA #PRMTAB&$FF	;Points to first byte of Primitive-table
	STA TEMPN
	LDA #PRMTAB^
	STA TEMPN+1
SOBLP1:	JSR SOBST1
	LDA TEMPN+1
	CMP #VPRMTB^
	BNE SOBLP1
	LDA TEMPN
	CMP #VPRMTB&$FF
	BNE SOBLP1
	SEC
	LDA SOBTOP
	SBC #$08
	STA TEMPN1	;TEMPN1 is SOBTOP - 8, for comparison
	LDA SOBTOP+1
	SBC #$00
	STA TEMPN1+1
SBVLP1:	LDA GETRM2	;Ghost-memory bank 2, VPrim table
	LDY #$00
	LDA (TEMPN),Y
	STA ANSN	;ANSN is INDEX constant
	INY
	LDA (TEMPN),Y
	STA TEMPN3+1	;TEMPN3 is Primitive's pointer address
	INY
	LDA (TEMPN),Y
	STA TEMPN3
	INY
	LDA (TEMPN),Y
	STA ANSN3	;ANSN3 is INSTANCE counter
	LDA GETRM1	;Ghost-memory disable
	LDA GETRM1
	CLC
	LDA TEMPN
	ADC #$04
	STA TEMPN
	BCC ADHAK8
	INC TEMPN+1
ADHAK8:	LDA #BBASX&$FF
	STA TEMPN2	;TEMPN2 is temporary VARNAM pointer
	LDA #BBASX^
	STA TEMPN2+1
SBVRW:	LDA TEMPN1+1
	CMP TEMPN2+1
	BNE SBVRW1
	LDA TEMPN1
	CMP TEMPN2
	BNE SBVRW1
	JSR SYSBUG
SBVRW1:	CLC
	LDA TEMPN2
	ADC #$04
	STA TEMPN2
	BCC ADHAK9
	INC TEMPN2+1
ADHAK9:	LDY #$02
	LDA (TEMPN2),Y
	STA TEMPNH
	INY
	LDA (TEMPN2),Y
	STA TEMPNH+1
	DEY
	LDA (TEMPNH),Y
	CMP ANSN
	BNE SBVRW
	DEC ANSN3
	BNE SBVRW
SBVRWE:	LDY #$00
	LDA TEMPN2	;Put TEMPN2 in the right variable
	STA (TEMPN3),Y
	INY
	LDA TEMPN2+1
	STA (TEMPN3),Y
	LDA TEMPN+1
	CMP #VPRMTE^
	BNE SBVLPJ
	LDA TEMPN
	CMP #VPRMTE&$FF
	BEQ SBVLL1
SBVLPJ:	JMP SBVLP1
SBVLL1:	CLC
	LDA SOBTOP
	STA FRLIST
	ADC #$04
	STA TEMPN
	LDA SOBTOP+1
	STA FRLIST+1
	ADC #$00
	STA TEMPN+1
	LDY #$02
	LDA #$00
	STA (SOBTOP),Y
	INY
	STA (SOBTOP),Y
	DEY
RINLP2:	LDA FRLIST
	STA (TEMPN),Y
	INY
	LDA FRLIST+1
	STA (TEMPN),Y
	DEY
	CLC
	LDA TEMPN
	STA FRLIST
	ADC #$04
	STA TEMPN
	LDA TEMPN+1
	STA FRLIST+1
	ADC #$00
	STA TEMPN+1
	CMP #SINODS^	;(Ptr. to byte after last node)
	BNE RINLP2
	LDA TEMPN
	CMP #SINODS&$FF
	BNE RINLP2
	LDX #$00
	STX TEMPN1+1
	INX
	STX TEMPN1	;Set to Novalue for MKSFUN
	LDX #UNSUM
	LDA #IUNSUM
	JSR MKSFUN
	LDX #UNDIF
	LDA #IUNDIF
	JSR MKSFUN
	LDA #$00
	JSR CLMK5
	STA CELPTR
	STA CELPTR+1
	STA OBLIST+1
	STA SIZE1
	STA SIZE1+1
	STA SIZE2
	STA SIZE2+1
	LDY #$00
	STY ANSN1
TRUEL:	LDA PTRUE,Y
	BEQ TRUELE
	JSR PUSHB
	INC ANSN1
	LDY ANSN1
	BNE TRUEL	;(Always)
TRUELE:	LDA #TEMPN3
	JSR CNSPDL
	LDX #TEMPN3
	LDA #LTRUE
	STA ANSN2
	JSR INTRNX
	LDY #$00
	STY ANSN1
FALSL:	LDA PFALSE,Y
	BEQ FALSLE
	JSR PUSHB
	INC ANSN1
	LDY ANSN1
	BNE FALSL	;(Always)
FALSLE:	LDA #TEMPN3
	JSR CNSPDL
	LDX #TEMPN3
	LDA #LFALSE
	STA ANSN2
	JMP INTRNX
.PAGE
SOBST1:	LDY #$01
	TYA
	DEY
	STA (SOBTOP),Y
	TYA
	INY
	STA (SOBTOP),Y
	INY
	LDA SARTOP
	STA (SOBTOP),Y
	INY
	LDA SARTOP+1
	STA (SOBTOP),Y
	LDA #SATOM
	LDX #SOBTOP
	JSR PUTTYP
	LDA GETRM2	;Ghost-memory bank 2, Prim table
	LDY #$00
	LDA (TEMPN),Y
	STA (SARTOP),Y
	INY
	LDA (TEMPN),Y
	STA (SARTOP),Y
	INY
	LDA (TEMPN),Y
	STA (SARTOP),Y
SBST1A:	INY
	LDA (TEMPN),Y
	STA (SARTOP),Y
	CMP #$20	;See if the last byte was transferred
	BNE SBST1A	;Yes.
	LDA GETRM1	;Ghost-memory bank 2 disable
	LDA GETRM1
	LDA #$00
	STA (SARTOP),Y
	INY
	CLC
	TYA
	ADC SARTOP
	STA SARTOP
	BCC ADHAK5
	INC SARTOP+1
ADHAK5:	CLC
	TYA
	ADC TEMPN
	STA TEMPN
	BCC ADHAK6
	INC TEMPN+1
ADHAK6:	CLC
	LDA SOBTOP
	ADC #$04
	STA SOBTOP
	BCC ADHAK7
	INC SOBTOP+1
ADHAK7:	INC NNODES
	BNE ADHK7A
	INC NNODES+1
ADHK7A:	RTS
.PAGE
.SBTTL	Miscellaneous and Evaluator Utility Routines
;	Toplevel Evaluator Utility Routines:

;Called with typecode in A; table address in XY. Checks for illegal typecodes.
TYPDSP:	CMP #HITYP+1
	BCS TYPBUG
;Called with dispatch code in A, table address in XY.
GENDSP:	STX TEMPNH
	STY TEMPNH+1
	ASL A
	TAY
	LDA (TEMPNH),Y
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	JMP (TEMPNH)
TYPBUG:	JSR SYSBUG

;Add ILINE to procedure DEFBOD. Simple, huh?
EDLINE:	LDX DEFBOD
	LDA DEFBOD+1
EDL1:	STX TEMPN
	STA TEMPN+1
	LDY #$02
	LDA (TEMPN),Y	;CDR through DEFBOD
	TAX
	INY
	LDA (TEMPN),Y
	BNE EDL1	;until we hit an LNIL
	LDA #TEMPN1
	STA ANSN
	LDY #ILINE
	LDX #$00
	TXA		;(type LIST)
	JSR CONS	;Make a node for the new line
	LDY #$02
	LDA TEMPN1
	STA (TEMPN),Y	;Link it on to DEFBOD
	INY
	LDA TEMPN1+1
	STA (TEMPN),Y
	RTS

GTNXTK:	LDY #$00
	LDA (TOKPTR),Y
	STA NEXTOK
	INY
	LDA (TOKPTR),Y
	STA NEXTOK+1
	RTS
.PAGE
MKSFUN:	LDY #$02
	STA (SARTOP),Y
	DEY
	LDA #$08	;(PREC = 8)
	STA (SARTOP),Y
	TYA		;(NARGS = 1)
	DEY
	STA (SARTOP),Y
	TYA
	LDY #$03
	STA (SARTOP),Y
	STX ANSN
	LDX #SARTOP
	LDY #TEMPN1	;TEMPN1 Set to Novalue by the calling procedure
	LDA #SATOM
	JSR CONS
	CLC
	LDA SARTOP
	ADC #$04
	STA SARTOP
	BCC ADHK11
	INC SARTOP+1
ADHK11:	RTS
.PAGE
;	Frame Utility Routines:

POPFRM:	JSR RSTBND
	LDX #TLLEVS
	JSR POP
	JSR POPB	;Skip NUMBER-BINDINGS
	LDX #TOKPTR
	JSR POP
	JSR POPB
	STA IFTEST
	LDX #NEST
	JSR POP
	LDX #CURTOK
	JSR POP
	JSR POPB
	STA UFRMAT
	LDX #XFRAME
	JSR POP
	LDX #FRAME
	JMP POP

RSTBND:	LDA XFRAME
	STA SP
	LDA XFRAME+1
	STA SP+1
	LDY #$0C	;Frame index for NUMBER-BINDINGS is 12
	LDA (FRAME),Y
	BEQ RSTBWE
	STA ANSN
RSTBW:	LDX #TEMPN1
	JSR POP
	LDX #TEMPN
	JSR POP
	LDX #TEMPN
	LDY #TEMPN1
	JSR PUTVAL
	DEC ANSN
	BNE RSTBW
RSTBWE:	RTS
.PAGE
;	Stack Routines:

;PUSHP is given the location of a page-zero variable in X,
;and pushes the contents of the variable onto the Logo stack.
PUSHP:	LDY #$00
	LDA $00,X
	STA (SP),Y
	INY
	LDA $01,X
	STA (SP),Y
	CLC
	LDA SP
	ADC #$02
	STA SP
	BCC PSHP1
	INC SP+1
PSHP1:	RTS

;PUSH pushes onto the stack the sixteen-bit value in the X and Y registers.
PUSH:	TYA
	LDY #$01
	STA (SP),Y
	DEY
	TXA
	STA (SP),Y
	CLC
	LDA SP
	ADC #$02
	STA SP
	BCC PSHP2
	INC SP+1
PSHP2:	RTS

;PUSHB pushes onto the stack the eight-bit value in the A register.
PUSHB:	LDY #$00
	STA (SP),Y
	INC SP
	BNE PUSHBR
	INC SP+1
PUSHBR:	RTS

;VPUSHP is given the address of a page-zero variable in X,
;and pushes the contents of that variable onto the Value stack.
VPUSHP:	LDY #$00
	LDA $00,X
	STA (VSP),Y
	INY
	LDA $01,X
	STA (VSP),Y
	SEC
	LDA VSP
	SBC #$02
	STA VSP
	BCS VPSH1
	DEC VSP+1
VPSH1:	RTS
.PAGE
;POP pops a value off of the Logo stack and into the page-zero variable
;whose address is in X.
POP:	SEC
	LDA SP
	SBC #$02
	STA SP
	BCS POP1
	DEC SP+1
POP1:	LDY #$00
	LDA (SP),Y
	STA $00,X
	INY
	LDA (SP),Y
	STA $01,X
	RTS

;VPOP pops a value off of the Value stack and into the page-zero variable
;whose address is in X. Doesn't destroy X.
VPOP:	CLC
	LDA VSP
	ADC #$02
	STA VSP
	BCC VPOP1
	INC VSP+1
VPOP1:	LDY #$00
	LDA (VSP),Y
	STA $00,X
	INY
	LDA (VSP),Y
	STA $01,X
	RTS

;POPB pops a one-byte value off of the Logo stack and returns with it in A.
POPB:	SEC
	LDA SP
	SBC #$01
	STA SP
	BCS POPB1
	DEC SP+1
POPB1:	LDY #$00
	LDA (SP),Y
	RTS
.PAGE
;TSTSTK tests to see if the Logo stack test limit has been exceeded,
;and gives an error if so. It doesn't poll for interrupts.
TSTSTK:	LDA VSP+1
	CMP SP+1
	BCC STKTZ
	BNE STKTR
	SEC
	LDA VSP
	SBC SP
	CMP #STKLIM
	BCC STKTZ
STKTR:	RTS
STKTZ:	LDA #PDLBAS&$FF
	STA SP
	LDA #PDLBAS^
	STA SP+1	;Reset the stack for reader/tokenizer
	LDX #XNSTOR	;(No Stack) "No storage left" zapcode
	LDA #XZAP
	JMP ERROR

;TSTPOL tests to see if the Logo stack test limit has been exceeded,
;and gives an error if so. Polls for interrupts.
TSTPOL:	JSR TSTSTK
	;falls through

;POLL is the polling routine for user interrupts.
	;falls in
POLL:	JSR TSTCHR
	BCC PRTS
	CMP #PAUSKY
	BEQ PRTS	;If PAUSE, don't reset flag, just exit
	BIT KBDCLR
STPPKX:	CMP #STPKEY
	BEQ STPPK1
	CMP #LSTKEY
	BEQ PRTS
	CMP #FULCHR	;Full-screen graphics character
	BEQ STPFUL
	CMP #MIXCHR	;Mixed-screen graphics character
	BEQ STPMIX
	TAY		;Save character
	SEC
	LDA CHBUFR
	SBC CHBUFS	;Check for buffer-full
	AND #$3F
	CMP #$01
	BEQ BOFL	;Buffer overflow if next-free loc right before next-to-read
	LDA CHBUFS
	AND #$3F
	TAX
	TYA
	STA CHBSTT,X	;Store character in buffer
	INC CHBUFS	;Increment next-free-loc
PRTS:	RTS
BOFL:	JMP BELL	;Ding-dong if buffer overflow
STPPK1:	LDX #ERROR1&$FF
	LDY #ERROR1^
	JSR PUSH
	LDX #XSTOP
	LDA #XZAP
	JMP ERROR
STPFUL:	LDA GRPHCS
	BEQ PRTS
	LDA FULLGR
	RTS
STPMIX:	LDA GRPHCS
	BEQ PRTS
	LDA MIXGR
	RTS

;POLLZ is the special polling routine which also checks for Pause key.

POLLZ:	JSR TSTCHR
	BCC PRTS
	BIT KBDCLR
	CMP #PAUSKY
	BNE STPPKX
STPPKZ:	LDA #XBRK
	JMP ERROR
.PAGE
;	Atomic Value Routines:

GETVAL:	LDA $00,Y	;Get value into X's pointer from Y's pointer
	AND #$FC	;Strip off last two bits
	STA TEMPNH
	LDA $01,Y
	STA TEMPNH+1
	LDY #$00
	LDA (TEMPNH),Y
	STA $00,X
	INY
	LDA (TEMPNH),Y
	STA $01,X
	RTS

PUTVAL:	LDA $00,Y
	AND #$FC
	STA TEMPNH
	LDA $01,Y
	STA TEMPNH+1
	LDY #$00
	LDA $00,X
	STA (TEMPNH),Y
	INY
	LDA $01,X
	STA (TEMPNH),Y
	RTS
.PAGE
;	Function Utility Routines:

GETFUN:	STA ANSN	;Save ANS-FUNCT pointer
	LDA $00,X
	STA TEMPN	;Get OBJECT pointer
	LDA $01,X
	STA TEMPN+1
	JSR GETTYP
	LDX ANSN
	LDY #$02
	CMP #ATOM
	BEQ GTFN1
	CMP #SATOM
	BEQ GTFN2
	LDA #$00
	STA $01,X
	RTS
GTFN1:	LDA (TEMPN),Y
	PHA
	INY
	LDA (TEMPN),Y
	STA TEMPN+1
	PLA
	STA TEMPN
	LDY #$00
	LDA (TEMPN),Y
	PHA
	INY
	LDA (TEMPN),Y
	STA $01,X
	PLA
	STA $00,X
	LDA #UFUN
	RTS
GTFN2:	LDA (TEMPN),Y
	STA $00,X
	INY
	LDA (TEMPN),Y
	STA $01,X
	LDA #SFUN
	RTS
.PAGE
PUTFUN:	STY ANSN
	STX ANSN1
	JSR GETTYP
	CMP #ATOM
	BEQ PTFN2
PTFN1:	LDY ANSN1
	JSR PTRYOK
	LDA #XUBL
	JMP ERROR
PTFN2:	LDX ANSN1
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	LDX ANSN
	LDY #$00
	LDA $00,X
	STA (TEMPNH),Y
	INY
	LDA $01,X
	STA (TEMPNH),Y
	RTS
.PAGE
;GETPRC returns the precedence (in A) of the function in Y,
;given the funtype in X.
GETPRC:	LDA #$05	;Assume Ufun, precedence 5
	CPY #UFUN
	BEQ GPRCU
GPRCS:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$01
	LDA (TEMPNH),Y
GPRCU:	RTS

GETNGS:	CMP #SFUN
	BEQ GTNG2
GTNG1:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$04
	LDA (TEMPNH),Y
	RTS
GTNG2:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$00
	LDA (TEMPNH),Y
	RTS
.PAGE
INFIXP:	CMP #SFUN
	BNE IFP1
	LDA $01,X
	BNE IFP2
IFP1:	CLC		;Not infix
	RTS
IFP2:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	CMP #INSUM
	BEQ IFP3
	CMP #INDIF
	BEQ IFP3
	CMP #INPROD
	BEQ IFP3
	CMP #INQUOT
	BEQ IFP3
	CMP #INGRTR
	BEQ IFP3
	CMP #INLESS
	BEQ IFP3
	CMP #INEQUL
	BNE IFP1
IFP3:	SEC		;Infix.
	RTS		;Return with proper index in A
.PAGE
PTFTXT:	STY ANSN4	;FUNTEXT
	STA ANSN3	;NARGS
	STX TEMPN7	;ATOMM
	JSR GETTYP
	CMP #ATOM
	BEQ PTFTX2
	LDY TEMPN7
	LDA #XUBL
	JMP ERROR
PTFTX2:	LDX TEMPN7
	LDA $00,X
	STA TEMPNH	;TEMPNH is ATOMM
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	STA TEMPN5	;TEMPN5 is CELL
	INY
	LDA (TEMPNH),Y
	STA TEMPN5+1
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPN6	;TEMPN6 is FUNCT
	INY
	LDA (TEMPN5),Y
	STA TEMPN6+1
	BNE PTFTX3
	LDX ANSN4	;FUNTEXT ptr.
	LDA $00,X
	STA MARK1
	LDA $01,X
	STA MARK1+1
	LDA #$04
	STA TEMPN8
	LDA #$00
	STA TEMPN8+1
	LDY #TEMPN8
	LDX #TEMPN6
	JSR GETWDS
	LDY #$01
	LDA TEMPN6+1	;FUNCT
	BEQ PTFER
	STA (TEMPN5),Y	;CELL
	DEY
	LDA TEMPN6
	STA (TEMPN5),Y
	LDX #TEMPN6
	LDA #UFUN
	JSR PUTTYP
	LDY #$06
	LDX TEMPN7	;ATOMM
	LDA $00,X
	STA (TEMPN6),Y
	INY
	LDA $01,X
	STA (TEMPN6),Y
	LDA #$00
	STA MARK1
	STA MARK1+1
PTFTX3:	LDY #$00
	TYA
	STA (TEMPN6),Y
	INY
	STA (TEMPN6),Y
	INY
	LDX ANSN4
	LDA $00,X	;FUNTEXT
	STA (TEMPN6),Y
	INY
	LDA $01,X
	STA (TEMPN6),Y
	INY
	LDX ANSN3	;NARGS
	LDA $00,X
	STA (TEMPN6),Y
	INY
	LDA $01,X
	STA (TEMPN6),Y
PTFTXE:	RTS
PTFER:	JMP CONSR	;(No Nodes, most likely) "No storage left" zapcode
.PAGE
UNFUNC:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	LDY #$00
	LDA #$01
	STA (TEMPNH),Y
	TYA
	INY
	STA (TEMPNH),Y
	RTS
.PAGE
;	Nodespace Routines:

;CONS creates a new node from the freelist. X points to the Cdr,
;Y to the Car, ANSN to the node's pointer, and A holds the typecode.
CONS:	PHA
	CMP #LIST
	BEQ FCONS
	CMP #STRING
	BEQ SCONS
	CMP #FIX
	BEQ NCONS
	CMP #FLO
	BEQ NCONS
	CMP #ATOM
	BEQ SCONS
	CMP #SATOM
	BEQ S1CONS
	JSR SYSBUG

;"F" CONS - Protect both CAR and CDR. Used for Lists.
FCONS:	JSR XCONS
	LDX TEMPNH
	JSR VPUSHP	;VPUSHP Xcar
	LDX TEMPNH+1
	JSR VPUSHP	;VPUSHP Xcdr
	JSR GARCOL
	CLC		;Reset the VPDL
	LDA VSP
	ADC #$04
	JMP SCONS2

;"N" CONS - Doesn't protect either CAR or CDR. Used for numbers.
NCONS:	JSR XCONS
	JSR GARCOL
	JMP CONSG1

;"S" CONS - Protects only CDR. Used for strings.
SCONS:	JSR XCONS
	LDX TEMPNH+1
	JSR VPUSHP	;VPUSHP Xcdr
	JSR GARCOL
	JMP SCONS1	;Reset the VPDL

;"S1" CONS - Protects only CAR. Used for Satoms.
S1CONS:	JSR XCONS
	LDX TEMPNH
	JSR VPUSHP
	JSR GARCOL
SCONS1:	CLC
	LDA VSP
	ADC #$02
SCONS2:	STA VSP
	BCC CONSG1
	INC VSP+1
	BNE CONSG1	;(Always)

XCONS:	STY TEMPNH	;TEMPNH.L is XCAR
	STX TEMPNH+1	;TEMPNH.H is XCDR
	LDA FRLIST+1
	BEQ XCONSG
	LDA PRSFLG
	BNE XCONS2	;Don't check limit for parser calls
	LDA NNODES+1
	CMP #NODLIM^
	BCC XCONS2
	BNE XCONSG
	LDA NNODES
	CMP #NODLIM&$FF
	BCC XCONS2
XCONSG:	RTS
XCONS2:	PLA
	PLA
	JMP CONS2

CONSG1:	LDA PRSFLG
	BEQ CONST2
	LDA FRLIST+1
	BNE CONS2
	BEQ CONSR
CONST2:	LDA NNODES+1
	CMP #NODLIM^
	BCC CONS2
	BNE CONSR
	LDA NNODES
	CMP #NODLIM&$FF
	BCC CONS2
CONSR:	LDX #XNSTRN	;Error "No storage left" (No nodes)
	LDA #XZAP
	JMP ERROR
CONS2:	INC NNODES
	BNE CONS2A
	INC NNODES+1	;Increment node counter
CONS2A:	LDY #$00
	LDX TEMPNH
	LDA $00,X
	STA (FRLIST),Y
	INY
	LDA $01,X
	STA (FRLIST),Y
	INY
	LDX TEMPNH+1
	LDA (FRLIST),Y
	PHA
	LDA $00,X
	STA (FRLIST),Y
	INY
	LDA (FRLIST),Y
	PHA
	LDA $01,X
	STA (FRLIST),Y
	LDX ANSN
	LDA FRLIST
	STA $00,X
	LDA FRLIST+1
	STA $01,X
	PLA
	STA FRLIST+1
	PLA
	STA FRLIST
	PLA		;GET TYPE
	;falls through

	;falls in
PUTTYP:	CMP #LATOM+1
	BCS PUTTP2
	CMP #QATOM
	BCC PUTTP2
	SBC #$07
	CLC
	ADC $00,X
	STA $00,X
PUTTPE:	RTS
PUTTP2:	LDY $01,X
	BEQ PUTTPE
	STY TEMPNH+1
	LDY $00,X
	STY TEMPNH
	TAX
	JSR TYPACS
	TXA
	STA (TEMPNH),Y
	RTS

GETTYP:	LDA $01,X
	BEQ GETTPE
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	JSR TYPACS
	CMP #ATOM
	BEQ GETTP4
	CMP #SATOM
	BNE GETTPE
GETTP4:	TAY
	LDA $00,X
	AND #$03
	BEQ GETTPF
	CLC
	ADC #$07
GETTPE:	RTS
GETTPF:	TYA
	RTS

TYPACS:	LSR TEMPNH+1
	ROR TEMPNH
	LSR TEMPNH+1
	ROR TEMPNH
	CLC
	LDA TEMPNH
	ADC #TYPBAS&$FF
	STA TEMPNH
	LDA TEMPNH+1
	ADC #TYPBAS^
	STA TEMPNH+1
	LDY #$00
	LDA (TEMPNH),Y
	RTS
.PAGE
PTSPNM:	LDA $00,X
	AND #$FC
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	DEY
	LDA (TEMPNH),Y
	ORA #$01
	STA (TEMPNH),Y
RTS2:	RTS
.PAGE
;Tries to find a block of (Y) contiguous free words in nodespace.
;If successful, return the start addr in (X). If not, return LNIL.
GETWDS:	STX ANSN		;ANSN is ans
	STY ANSN1		;ANSN1 is size
	LDA #$00
	STA $00,X		;zero ans
	STA $01,X
	LDA $00,Y
	BNE GW1A
	LDA $01,Y
	BEQ RTS2		;If size=0, just return with ANS = 0
GW1A:	JSR GW1			;try once
	LDX ANSN
	LDA $01,X
	BNE RTS2		;if found something, quit.
	JSR GARCOL		;otherwise, try again after a GC
	;falls through

	;falls in
GW1:	LDA #$00
	STA TEMPN+1		;Zero lastptr (TEMPN)
	STA TEMPN4+1		;and lastptr1 (TEMPN4)
	LDA FRLIST		;init ptr (TEMPN1) and
	STA TEMPN1		;ptr1 (TEMPN3) to freelist
	STA TEMPN3
	LDA FRLIST+1
	STA TEMPN1+1
	STA TEMPN3+1
GW1W:	LDX ANSN
	LDA $01,X		;if ans neq LNIL, done
	BEQ GW1WA		;cuz found something
GWRTS:	LDX ANSN1
	CLC
	LDA NNODES
	ADC $00,X
	STA NNODES		;Adjust allocation pointer
	LDA NNODES+1
	ADC $01,X
	STA NNODES+1
	RTS
GW1WA:	LDA TEMPN1+1		;if ptr1 = LNIL, done cuz been thru whole
	BEQ RTS2		;freelist, found nothing
GW1W1:	LDA #$00
	STA TEMPN2		;sofar (TEMPN2) := 0
	STA TEMPN2+1
	STA ANSN2		;contig (ANSN2) := 0 (T)
GW1X:	LDX ANSN1
	LDA TEMPN2+1
	CMP $01,X
	BCC GW1X2		;if sofar >= size, go if2
	BNE GWIF2
	LDA TEMPN2
	CMP $00,X
	BCS GWIF2
	LDA ANSN2		;if contig = false, go else
	BNE GWELSE
	LDA TEMPN3
	BNE GW1X2		;if ptr1 = LNIL, goto else
	LDA TEMPN3+1
	BEQ GWELSE
GW1X2:	CLC
	LDA TEMPN2
	ADC #$02		;sofar := sofar + 2
	STA TEMPN2
	BCC GW1X3
	INC TEMPN2+1
GW1X3:	LDY #$02
	LDA (TEMPN3),Y
	STA TEMPNH		;temp (TEMPNH) := (cdr ptr1)
	INY
	LDA (TEMPN3),Y
	STA TEMPNH+1
	CLC
	LDA TEMPNH		;add 4 to temp and see if
	ADC #$04		;result is = ptr1
	TAX
	LDA TEMPNH+1
	ADC #$00
	CMP TEMPN3+1
	BNE NCNTIG
	CPX TEMPN3
	BEQ CONTIG		;if so, contig := 1 (false)
NCNTIG:	INC ANSN2
CONTIG:	LDA TEMPN3
	STA TEMPN4		;lastptr1 := ptr1
	LDA TEMPN3+1
	STA TEMPN4+1
	LDA TEMPNH
	STA TEMPN3		;ptr1 := temp
	LDA TEMPNH+1
	STA TEMPN3+1
	JMP GW1X		;round the while loop
GWIF2:	LDA TEMPN+1		;if lastptr = LNIL, freelist := ptr1
	BNE GWIF3
	LDA TEMPN3
	STA FRLIST		;freelist := ptr1
	LDA TEMPN3+1
	STA FRLIST+1
	JMP GWIF4
GWIF3:	LDY #$02		;else (rplacd lasptr ptr1)
	LDA TEMPN3
	STA (TEMPN),Y
	INY
	LDA TEMPN3+1
	STA (TEMPN),Y
GWIF4:	LDX ANSN
	LDA TEMPN4
	STA $00,X		;ans := lastptr1
	LDA TEMPN4+1
	STA $01,X
	JMP GW1W		;back to top
GWELSE:	LDA TEMPN3
	STA TEMPN1		;ptr := ptr1
	LDA TEMPN3+1
	STA TEMPN1+1
	LDA TEMPN4
	STA TEMPN		;lastptr := lastptr1
	LDA TEMPN4+1
	STA TEMPN+1
	JMP GW1W		;back to top
.PAGE
;	Ufun Line Utility Routines:

GETULN:	LDA $00,Y
	STA TEMPNH
	LDA $01,Y
	STA TEMPNH+1	;BODY
	LDY #$00
	LDA (TEMPNH),Y
	STA $00,X
	INY
	LDA (TEMPNH),Y
	STA $01,X
	LDA UFRMAT
	BNE GTTFPK
	LDA $01,X
	BNE GTTCK
	RTS
GTTFPK:	INY
	LDA (TEMPNH),Y
	STA ULNEND
	INY
	LDA (TEMPNH),Y
	STA ULNEND+1
	CMP $01,X
	BNE GTTCK
	LDA ULNEND
	CMP $00,X
	BEQ GTTNIL
GTTCK:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$00
	LDA (TEMPNH),Y
	CMP COMMNT
	BNE GTTRTS
	INY
	LDA (TEMPNH),Y
	CMP COMMNT+1
	BNE GTTRTS
GTTNIL:	LDA #$00
	STA $01,X
GTTRTS:	RTS
.PAGE
ULNADV:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1	;BODY
	LDY #$02
	LDA UFRMAT
	BNE ULDV2
ULDV1:	LDA (TEMPNH),Y
	PHA
	INY
	LDA (TEMPNH),Y
	STA $01,X
	PLA
	STA $00,X
	RTS
ULDV2:	INY
	INY
	LDA (TEMPNH),Y
	PHA
	INY
	LDA (TEMPNH),Y
	BNE ULDV3
	PLA
	BNE ULDV3A
	STA $00,X
	STA $01,X
	RTS
ULDV3:	PLA
ULDV3A:	CLC
	LDA $00,X
	ADC #$02
	STA $00,X
	BCC ADHK13
	INC $01,X
ADHK13:	RTS
.PAGE
;	Token-list Routines:

TTKADV:	JSR TFKADV
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$00
	LDA (TEMPNH),Y
	CMP COMMNT
	BNE TTKE
	INY
	LDA (TEMPNH),Y
	CMP COMMNT+1
	BNE TTKE
	LDA #$00
	STA $01,X
TTKE:	RTS

TFKADV:	LDA UFRMAT
	CMP #FPACK
	BEQ TFK2
TFK1:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	STA $00,X
	INY
	LDA (TEMPNH),Y
	STA $01,X
	RTS
TFK2:	CLC
	LDA $00,X
	ADC #$02
	STA $00,X
	BCC TFK2A
	INC $01,X
TFK2A:	CMP ULNEND
	BNE TFK3
	LDA $01,X
	CMP ULNEND+1
	BNE TFK3
	LDA #$00
	STA $01,X
TFK3:	RTS
.PAGE
SKPPTH:	LDA TOKPTR+1
	BEQ RTSA2X
	LDY #$00
	LDA (TOKPTR),Y
	STA TEMPN
	INY
	LDA (TOKPTR),Y
	STA TEMPN+1
	LDX #TOKPTR
	JSR TTKADV
	LDA TEMPN
	CMP LPAR
	BNE RTSA2X
	LDA TEMPN+1
	CMP LPAR+1
	BNE RTSA2X
	LDA #$01
	STA ANSN	;ANSN is PARENCOUNTER
SKPPW:	LDA TOKPTR+1
	BEQ RTSA2X
	LDY #$00
	LDA (TOKPTR),Y
	STA TEMPN
	INY
	LDA (TOKPTR),Y
	STA TEMPN+1
	LDX #TOKPTR
	JSR TTKADV
	LDX TEMPN
	LDY TEMPN+1
	CPX LPAR
	BNE SKPPW2
	CPY LPAR+1
	BNE SKPPW2
	INC ANSN
	JMP SKPPW
SKPPW2:	CPX RPAR
	BNE SKPPW
	CPY RPAR+1
	BNE SKPPW
	DEC ANSN
	BNE SKPPW
RTSA2X:	RTS
.PAGE
EXIFSC:	STX ANSN1	;ANSN1 is ANS
	LDA IFLEVL
	STA TEMPN1	;TEMPN2 is IFCOUNTER
	LDA IFLEVL+1
	STA TEMPN1+1
EXFW:	LDA TEMPN1+1
	CMP IFLEVL+1
	BCC EXFWE
	BNE EXFWA1
	LDA TEMPN1
	CMP IFLEVL
	BCS EXFWA1
EXFWE:	SEC
	LDA IFLEVL
	SBC #$01
	STA IFLEVL
	BCS EXFWR
	DEC IFLEVL+1
EXFWR:	RTS
EXFWA1:	LDA TOKPTR+1
	BEQ EXFWE
	LDY #$00
	LDX ANSN1
	LDA (TOKPTR),Y
	STA $00,X
	INY
	LDA (TOKPTR),Y
	STA $01,X
	TAY
	LDA $00,X
	TAX
	CPX LIF
	BNE EXFW2
	CPY LIF+1
	BNE EXFW2
	INC TEMPN1
	BNE EXIFWB
	INC TEMPN1+1
EXIFWB:	LDX #TOKPTR
	JSR TTKADV
	JMP EXFW
EXFW2:	CPX LELSE
	BNE EXFW3
	CPY LELSE+1
	BNE EXFW3
	SEC
	LDA TEMPN1
	SBC #$01
	STA TEMPN1
	BCS EXFWC
	DEC TEMPN1+1
EXFWC:	LDA TEMPN1+1
	CMP IFLEVL+1
	BCC EXFWE
	BNE EXFWD
	LDA TEMPN1
	CMP IFLEVL
	BCC EXFWE
EXFWD:	LDX #TOKPTR
	JSR TTKADV
	JMP EXFWA1
EXFW3:	CPX RPAR
	BNE EXFW4
	CPY RPAR+1
	BEQ EXFWE
EXFW4:	JSR SKPPTH
	JMP EXFW
.PAGE
;	Edit mode Utility Routines:

DEFSTP:	LDA TOKPTR+1
	BEQ ERELJ1
	LDY #$00
	LDA (TOKPTR),Y
	STA ARG1
	INY
	LDA (TOKPTR),Y
	STA ARG1+1
	LDX #TOKPTR
	JSR TTKADV
	LDX #ARG1
	JSR GETTYP
	CMP #SATOM
	BEQ EDTSR4
	CMP #ATOM
	BNE EDTSR5
	LDA ARG1
	STA DEFATM
	STA PODEFL
	LDA ARG1+1
	STA DEFATM+1
	STA PODEFL+1
	RTS
ERELJ1:	JMP ERXEOL
EDTSR4:	JMP ERXUBL
EDTSR5:	JMP ERXWT1

EXTDEF:	LDA #$00
	STA DEFFLG
	STA DEFBOD
	STA DEFBOD+1
	STA DEFATM
	STA DEFATM+1
RTS9:	RTS
.PAGE
;	Stuffed stuff Routines:

STUFF:	STA ANSN3		;try to associate the name (ATOM)
	STX ANSN4		;definition with the function (BODY).
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1		;TEMPNH is BODY
	LDY #$00
	LDA (TEMPNH),Y
	STA TEMPN7
	INY
	LDA (TEMPNH),Y
	STA TEMPN7+1	;(CAR) to LINE
	LDX #TEMPX2	;TEMPX2 becomes NARGS
	LDY #TEMPN7
	JSR GETLEN
	LDA #$00
	STA TEMPN6	;TEMPN6 is SIZE
	STA TEMPN6+1
	LDX ANSN4
	LDA $00,X
	STA TEMPNH	;TEMPNH is BODY
	LDA $01,X
	STA TEMPNH+1
GTSZW:	LDA TEMPNH+1
	BEQ GTSZND
	LDY #$00
	LDA (TEMPNH),Y
	STA TEMPN
	INY
	LDA (TEMPNH),Y
	STA TEMPN+1	;(CAR) to LINE (GETSIZ local)
	INY
	LDA (TEMPNH),Y
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
GTSZX:	LDA TEMPN+1
	BEQ GTSZW
GTSZX1:	INC TEMPN6
	BNE GTSZX2
	INC TEMPN6+1
GTSZX2:	LDY #$02
	LDA (TEMPN),Y
	TAX
	INY
	LDA (TEMPN),Y
	STA TEMPN+1
	STX TEMPN
	BNE GTSZX1
	BEQ GTSZW
GTSZND:	LDX #TEMPN5	;TEMPN5 becomes PTR
	LDY #TEMPN6	;SIZE
	JSR GETWDS
	LDA TEMPN5+1
	BNE STFF1
STFFA:	LDA #TEMPX2
	LDY ANSN4
	LDX ANSN3
	JMP PTFTXT	;PUTFTEXT (FUNATOM, BODY, NARGS) (X,Y,A)
STFF1:	LDA TEMPN5
	STA AREA1
	LDA TEMPN5+1
	STA AREA1+1
	LDA TEMPN6
	STA SIZE1
	LDA TEMPN6+1
	STA SIZE1+1
	LDX #TEMPN6
	LDY ANSN4	;BODY
	JSR GETLEN
	CLC
	LDA TEMPN6
	ADC #$02
	STA TEMPN6
	BCC ADHK55
	INC TEMPN6+1
ADHK55:	LDX #TEMPX1	;TEMPX1 becomes INDEX
	LDY #TEMPN6
	JSR GETWDS
	LDA TEMPX1+1
	BNE STFF2
	STA SIZE1
	STA SIZE1+1
	JMP STFFA
STFF2:	LDA TEMPX1
	STA AREA2
	STA TEMPN1	;TEMPN1 is INDEX1
	LDA TEMPX1+1
	STA AREA2+1
	STA TEMPN1+1
	CLC
	LDA TEMPN6
	ADC #$02
	STA SIZE2
	LDA TEMPN6+1
	ADC #$00
	STA SIZE2+1
	LDX ANSN4
	LDA $00,X
	STA TEMPNH	;TEMPNH is BODY
	LDA $01,X
	STA TEMPNH+1
STFFW:	LDA TEMPNH+1
	BEQ STFFWE
STFFW1:	LDY #$00
	LDA TEMPN5	;PTR
	STA (TEMPN1),Y
	INY
	LDA TEMPN5+1
	STA (TEMPN1),Y
	CLC
	LDA TEMPN1
	ADC #$02
	STA TEMPN1
	BCC STFFX
	INC TEMPN1+1
STFFX:	LDA TEMPN7+1	;LINE
	BEQ STFFXE
	LDY #$00
	LDA (TEMPN7),Y
	STA TEMPN3	;TEMPN3 is TOKEN
	INY
	LDA (TEMPN7),Y
	STA TEMPN3+1
	INY
	LDA (TEMPN7),Y
	TAX
	INY
	LDA (TEMPN7),Y
	STA TEMPN7+1
	STX TEMPN7
	LDY #$00
	LDA TEMPN3
	STA (TEMPN5),Y
	INY
	LDA TEMPN3+1
	STA (TEMPN5),Y
	CLC
	LDA TEMPN5
	ADC #$02
	STA TEMPN5
	BCC STFFX
	INC TEMPN5+1
	BNE STFFX	;(Always)
STFFXE:	LDY #$03
	LDA (TEMPNH),Y
	TAX
	DEY
	LDA (TEMPNH),Y
	STA TEMPNH
	STX TEMPNH+1
	DEY
	LDA (TEMPNH),Y
	STA TEMPN7+1
	DEY
	LDA (TEMPNH),Y
	STA TEMPN7
	JMP STFFW
STFFWE:	LDY #$00
	LDA TEMPN5
	STA (TEMPN1),Y	;TEMPN1 is INDEX1
	INY
	LDA TEMPN5+1
	STA (TEMPN1),Y
	INY
	LDA #$00
	STA (TEMPN1),Y
	INY
	STA (TEMPN1),Y
	LDX #TEMPX1	;INDEX
	LDA #FPACK
	JSR PUTTYP
	LDA #TEMPX2
	LDY #TEMPX1
	LDX ANSN3
	JSR PTFTXT
	LDA #$00
	STA SIZE1
	STA SIZE1+1
	STA SIZE2
	STA SIZE2+1
RTS3:	RTS
.PAGE
UNSTUF:	STY ANSN1	;ANSN1 is BODY ptr. (X is FUN ptr.)
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	STA TEMPN1	;TEMPN1 is INDEX
	INY
	LDA (TEMPNH),Y
	STA TEMPN1+1
	LDX #TEMPN1
	JSR GETTYP
	CMP #FPACK
	BEQ USTF2
USTF1:	LDX ANSN1
	LDA TEMPN1
	STA $00,X
	LDA TEMPN1+1
	STA $01,X
USTFE1:	RTS
USTF2:	LDA #$00
	STA MARK1
	STA MARK1+1
	LDA SP
	STA TEMPN4	;TEMPN4 is STACK
	LDA SP+1
	STA TEMPN4+1
USTFW2:	LDY #$00
	LDA (TEMPN1),Y
	STA TEMPN2	;TEMPN2 is PTR
	INY
	LDA (TEMPN1),Y
	STA TEMPN2+1
	INY
	LDA (TEMPN1),Y
	STA TEMPN3	;TEMPN3 is ENDPTR
	INY
	LDA (TEMPN1),Y
	STA TEMPN3+1
USTFW:	LDA TEMPN3+1
	BEQ USTFWE
	JSR TSTPOL
	LDX #TEMPN2
	JSR PUSHP
	CLC
	LDA TEMPN1
	ADC #$02
	STA TEMPN1
	BCC USTFW2
	INC TEMPN1+1
	JMP USTFW2
USTFWE:	LDA TEMPN2
	STA TEMPN3
	LDA TEMPN2+1
	STA TEMPN3+1
USTFX:	LDA TEMPN4
	CMP SP
	BNE USTFX1
	LDA TEMPN4+1
	CMP SP+1
	BEQ USTFXE
USTFX1:	LDX #TEMPN2
	JSR POP
	LDA #$00
	STA MARK2
	STA MARK2+1
USTFY:	LDA TEMPN3
	CMP TEMPN2
	BNE USTFY1
	LDA TEMPN3+1
	CMP TEMPN2+1
	BEQ USTFYE
USTFY1:	SEC
	LDA TEMPN3
	SBC #$02
	STA TEMPN3
	BCS USTFY2
	DEC TEMPN3+1
USTFY2:	LDY #$00
	LDA (TEMPN3),Y
	STA TEMPN
	INY
	LDA (TEMPN3),Y
	STA TEMPN+1
	LDA #LIST
	LDX #MARK2
	STX ANSN
	LDY #TEMPN
	JSR CONS
	JMP USTFY
USTFYE:	LDX #MARK2
	LDA #LIST
	JSR PUTTYP
	LDX #MARK1
	STX ANSN
	LDY #MARK2
	LDA #LIST
	JSR CONS
	JMP USTFWE
USTFXE:	LDX ANSN1	;BODY
	LDA MARK1
	STA $00,X
	LDA MARK1+1
	STA $01,X
	LDA #$00
	JMP CLMK2	;Clear MARK1, MARK2
USTFE:	RTS
.PAGE
;	Oblist Interning Routine:

INTERN:	STX ANSN1	;ANSN1 is STRING ptr.
	STY ANSN2	;ANSN2 is ANS ptr.
	JSR VPUSHP
	LDA OBLIST	;OBFIND starts
	STA TEMPN4
	LDA OBLIST+1
	STA TEMPN4+1	;TEMPN4 is OBPTR
	BEQ OBFNFE
OBFW:	LDY #$00
	LDX ANSN2
	LDA (TEMPN4),Y
	STA $00,X
	INY
	LDA (TEMPN4),Y
	STA $01,X	;Assume it's this Oblist object
	LDY #TEMPN5	;TEMPN5 is PNAME
	JSR GETPNM
	LDX ANSN1	;MATCH2 starts (STRING1 is TEMPN5)
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1	;TEMPNH is STRING2
MTC2W:	LDA TEMPNH+1
	BNE MTC2W1
	LDA TEMPN5+1	;If STRING2 is 0 and STRING1 isn't, not FOUND
	BNE OBFNF
	LDX #TEMPN5
	JMP VPOP	;Pop the Vpushed string (we found it, since both are 0)
MTC2W1:	LDY #$00
	LDA (TEMPNH),Y
	CMP (TEMPN5),Y
	BNE OBFNF
	INY
	LDA (TEMPNH),Y
	CMP (TEMPN5),Y
	BNE OBFNF
	INY
	LDA (TEMPNH),Y
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	DEY
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	JMP MTC2W	;try next two characters
OBFNF:	LDY #$02	;try next Oblist object
	LDA (TEMPN4),Y	;OBPTR
	TAX
	INY
	LDA (TEMPN4),Y
	STA TEMPN4+1
	STX TEMPN4
	BNE OBFW
OBFNFE:	LDX ANSN1	;it's not on the oblist
	JSR VPOP	;get string back
	LDA SOBLST	;SOBFIND starts
	LDX ANSN2	;ANS becomes soblist pointer
	STA $00,X
	LDA SOBLST+1
	STA $01,X
SBFW:	LDX ANSN2	;object pointer
SBFWX:	LDA $00,X
	CMP SOBTOP
	BNE SBFW1
	LDA $01,X
	CMP SOBTOP+1
	BNE SBFW1
SBFWEN:	LDX ANSN1	;STRING
INTRNX:	LDY #$00	;Not found anywhere
	STY TEMPN1+1
	INY
	STY TEMPN1
	LDA ANSN2
	STA ANSN
	LDY #TEMPN1	;(NOVALUE)
	LDA #LIST
	JSR CONS
	LDA ANSN2
	STA ANSN	;(ANS)
	TAX
	LDY #TEMPN1	;(NOVALUE)
	LDA #ATOM
	JSR CONS
	LDA #LIST
	LDX #OBLIST
	STX ANSN
	LDY ANSN2	;ANS
	JMP CONS
SBFW1:	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$02
	LDA (TEMPNH),Y
	INY
	CLC
	ADC #$03
	STA TEMPN2	;TEMPN2 is sobname
	LDA (TEMPNH),Y
	ADC #$00
	STA TEMPN2+1
	LDX ANSN1	;ANSN1 points to string
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1	;TEMPNH becomes pname
MTC1W:	LDA TEMPNH+1
	BEQ SBFNF
MTC1W1:	LDY #$00
	LDA (TEMPNH),Y
	STA TEMPN	;TEMPN is TEMP
	INY
	LDA (TEMPNH),Y
	STA TEMPN+1
	DEY
	LDA (TEMPN2),Y
	CMP TEMPN
	BNE SBFNF
	INC TEMPN2
	BNE ADHK21
	INC TEMPN2+1
ADHK21:	LDA (TEMPN2),Y
	CMP TEMPN+1
	BNE SBFNF
	LDY #$02
	LDA (TEMPNH),Y	;TEMPNH is pname
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	LDY #$00
	LDA (TEMPN2),Y
	BEQ MTC1WF
	INC TEMPN2
	BNE MTC1WE
	INC TEMPN2+1
MTC1WE:	LDA TEMPNH+1
	BNE MTC1W1
	LDA (TEMPN2),Y
	BNE SBFNF
MTC1WF:	RTS
SBFNF:	CLC		;not this soblist object
	LDX ANSN2	;ANS
	LDA $00,X
	ADC #$04
	STA $00,X
	BCC SBFWJ
	INC $01,X
SBFWJ:	JMP SBFWX
.PAGE
;	Linked-list Utility Routines:

GETLEN:	LDA $00,Y
	STA TEMPNH	;LIST
	LDA $01,Y
	STA TEMPNH+1
	LDA #$00
	STA $00,X	;NARGS
	STA $01,X
GLENW:	LDA TEMPNH+1
	BEQ GTLCR
GLENW1:	LDY #$00
	LDA (TEMPNH),Y
	STA TEMPN
	INY
	LDA (TEMPNH),Y
	STA TEMPN+1
	INY
	LDA (TEMPNH),Y
	PHA
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	PLA
	STA TEMPNH
	LDA TEMPN
	CMP COMMNT
	BNE GLENW2
	LDA TEMPN+1
	CMP COMMNT+1
	BEQ GTLCR
GLENW2:	INC $00,X
	BNE GLENW
	INC $01,X
	BNE GLENW	;(Always)

GTLSTC:	STX ANSN
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1	;PTR
	LDY #$02
GTLC2:	LDA (TEMPNH),Y
	TAX
	BEQ GTLC3
	INY
	LDA (TEMPNH),Y
GTLC2A:	STA TEMPNH+1
	STX TEMPNH
	DEY
	JMP GTLC2
GTLC3:	INY
	LDA (TEMPNH),Y
	BNE GTLC2A
	LDX ANSN
	LDA TEMPNH
	STA $00,X
	LDA TEMPNH+1
	STA $01,X
GTLCR:	RTS

MAKMTW:	STA ANSN
	LDX #$00	;Make A the empty word
	LDY #$00
	LDA #STRING
	JMP CONS
.PAGE
;	Error Routines:

;Note - the only temporary variables which can be passed to ERROR
;as pointers are TEMPN6, TEMPN7, TEMPX1, and TEMPX2. PTRXOK and
;PTRYOK insure that the X or Y args point to safe temporaries.

PTRXOK:	LDA $00,X
	STA TEMPX2
	LDA $01,X
	STA TEMPX2+1
	LDX #TEMPX2
	RTS

PTRYOK:	LDA $00,Y
	STA TEMPX2
	LDA $01,Y
	STA TEMPX2+1
	LDY #TEMPX2
	RTS

ERROR:	STA ERRFLG
	PHA
	STA ANSN2
	ASL ANSN2	;Error pointers are stored two bytes apart
	STX ANSN3
	STY ANSN1
	LDA GRPHCS
	BEQ ERRO1
	LDA MIXGR	;If FULL Graphics, make MIXED
ERRO1:	JSR RSTIO
	JSR EXTDEF	;Zap out of EDIT or CHANGE mode if necessary
	JSR QUIETM	;Shut off the music if it's on (when the music's over...)
	PLA
	LDX RETADR
	TXS		;Restore all necessary return addresses
	CMP #XZAP
	BEQ ERRZ1
	CLC		;The Error-table holds pointers to the error-strings
	LDA #ERRTBL&$FF
	ADC ANSN2
	STA TEMPN8
	LDA #ERRTBL^
	ADC #$00
	STA TEMPN8+1
	LDA GETRM2	;Ghost-memory bank 2, error table
	LDY #$00
	LDA (TEMPN8),Y
	TAX
	INY
	LDA (TEMPN8),Y
	STA TEMPN8+1
	STX TEMPN8
ERRW:	LDA GETRM2	;Ghost-memory bank 2, error messages
	LDY #$00
	LDA (TEMPN8),Y
	LDX GETRM1	;Ghost-memory bank 2 disable
	LDX GETRM1
	TAX
	BEQ ERRW2
	CMP #$FF
	BEQ ERRWE
	CMP #$01
	BEQ ERRW1
	JSR TPCHR
	JMP ERRW4
ERRZ1:	JSR ZAPMSG
	JMP ERRWE
ERRW1:	LDX ANSN3
	JMP ERRW3
ERRW2:	LDX ANSN1
ERRW3:	LDA #$00
	JSR LTYPE
ERRW4:	INC TEMPN8
	BNE ERRW
	INC TEMPN8+1
	BNE ERRW	;(Always)
ERRWE:	LDA #$00
	JSR CLMK5	;Clear all the MARK pointers
	LDA LEVNUM
	BNE ERRWE1
	LDA LEVNUM+1
	BNE ERRWE1
JERR1:	JMP ERR1
ERRWE1:	LDA FBODY+1
	BEQ JERR1	;Toplevel of a break-loop if this is zero
	LDX #ERRM2&$FF
	LDY #ERRM2^
	JSR PRTSTR
	LDY #$00
	LDA (FPTR),Y
	STA TEMPN8
	INY
	LDA (FPTR),Y
	STA TEMPN8+1	;Get the line from the rest of the body
	LDA RUNFLG	;If RUNFLAG is zero,
	BEQ ERRWE2	;the UFRMAT is correct, else
	LDX #FBODY	;get UFRMAT from FBODY pointer
	JSR GETTYP
	STA UFRMAT
ERRWE2:	LDA UFRMAT
	BEQ TPLINE
	LDY #$02
	LDA (FPTR),Y
	STA TEMPX2
	INY
	LDA (FPTR),Y
	STA TEMPX2+1
TPLINL:	LDA TEMPN8	;Type an Fpacked line
	CMP TEMPX2
	BNE TPLIN1
	LDA TEMPN8+1
	CMP TEMPX2+1
	BEQ ERWE1B
TPLIN1:	LDY #$00
	LDA (TEMPN8),Y
	STA TEMPX1
	INY
	LDA (TEMPN8),Y
	STA TEMPX1+1
	CLC
	LDA TEMPN8
	ADC #$02
	STA TEMPN8
	BCC TPLIN2
	INC TEMPN8+1
TPLIN2:	LDA #$20
	JSR TPCHR
	LDA #$00
	LDX #TEMPX1
	JSR LTYPE
	JMP TPLINL
TPLINE:	LDA #$20
	JSR TPCHR
	LDX #TEMPN8
	LDA #$01
	JSR LTYPE
ERWE1B:	LDX #ERRM1&$FF
	LDY #ERRM1^
	JSR PRTSTR
	LDX #LEVNUM
	JSR TYPFIX
	LDX #ERRM3&$FF
	LDY #ERRM3^
	JSR PRTSTR
	LDY #$05	;Frame UFUN (CURTOK) index is 5
	LDA (FRAME),Y
	STA TEMPN8
	INY
	LDA (FRAME),Y
	STA TEMPN8+1
	LDA #$00
	LDX #TEMPN8
	JSR LTYPE
ERR1:	JSR BREAK1
	LDA ERRRET
	LDY ERRRET+1
	JSR RSTERR
	STA TEMPNH
	STY TEMPNH+1
	JMP (TEMPNH)
.PAGE
;ZAPMSG is a special case of ERROR, for error XZAP. It displays the
;appropriate error message.

ZAPMSG:	JSR BREAK1
	LDA ANSN3
	CMP #XNSTRN
	BEQ ZPC1
	CMP #XNSTOR
	BEQ ZPC1
	CMP #XSTOP
	BEQ ZPC2
	CMP #XEXCED
	BEQ ZPC3
	JSR SYSBUG
ZPC1:	LDX #ZPMSG1&$FF
	LDY #ZPMSG1^	;"No Storage Left!"
	JMP PRTSTR
ZPC2:	LDX #ZPMSG2&$FF
	LDY #ZPMSG2^	;"Stopped!"
	JMP PRTSTR
ZPC3:	LDX #ZPMSG3&$FF
	LDY #ZPMSG3^	;"Evaluator Overflow"
	JMP PRTSTR

;SYSBUG prints an error message and exits.
SYSBUG:	STA $02
	PLA
	STA $01		;Store calling point in locations $00,$01
	PLA
	STA $00
	TXA
	PHA
	TYA
	PHA
	JSR RSTIO
	LDX #LBUG1&$FF
	LDY #LBUG1^
	JSR PRTSTR	;Print "LOGO BUG!"
	LDX #ERROR1&$FF	;Just in case the error isn't too serious,
	LDY #ERROR1^	;we can re-enter with "G" command from monitor
	JSR PUSH
	PLA
	TAY
	PLA
	TAX
	LDA $02
	;falls through

	;falls in
SBPT:	BRK
	NOP
	NOP
	LDA GETRM1	;Monitor "G" command re-enters here
	LDA GETRM1	;Enable high RAM
	JSR RSTIO	;Restore I/O Drivers
	JMP POPJ
.PAGE
.SBTTL	Garbage Collector
GARCOL:	TSX
	STX RETADR
	LDA #GCLERR&$FF
	STA ERRRET
	LDA #GCLERR^
	STA ERRRET+1
	JSR SWAPT1
	LDA SOBLST
	STA TEMPN3	;TEMPN3 is INDEX
	LDA SOBLST+1
	STA TEMPN3+1
GCLP2:	LDX #TEMPN3
	JSR MARK
	CLC
	LDA TEMPN3
	ADC #$04
	STA TEMPN3
	BCC GCLP2A
	INC TEMPN3+1
GCLP2A:	LDA TEMPN3
	CMP SOBTOP
	BNE GCLP2
	LDA TEMPN3+1
	CMP SOBTOP+1
	BNE GCLP2
	LDA #VPDLBA&$FF
	STA TEMPN3
	LDA #VPDLBA^
	STA TEMPN3+1
GCLP3:	LDA TEMPN3
	CMP VSP
	BNE GCLP3X
	LDA TEMPN3+1
	CMP VSP+1
	BEQ GCLP3A
GCLP3X:	LDY #$00
	LDA (TEMPN3),Y
	STA TEMPN
	INY
	LDA (TEMPN3),Y
	STA TEMPN+1
	JSR MARKX	;Expects TEMPN as node
	SEC
	LDA TEMPN3
	SBC #$02
	STA TEMPN3
	BCS GCLP3
	DEC TEMPN3+1
	BNE GCLP3	;(Always)
GCLP3A:	LDA FRAME+1
	BEQ GCOL1
	STA TEMPN3+1
	LDA FRAME
	STA TEMPN3	;TEMPN3 is FRAMEPTR
GCLP4:	LDY #$0C	;Frame NUMBER-BINDINGS index is 12
	LDA (TEMPN3),Y
	BEQ GCLP5E
	STA ANSN1	;ANSN1 is NARGS
	CLC
	LDA TEMPN3
	ADC #$0F	;PTR1 points to first binding pair (Frameptr+15.)
	STA TEMPN4	;TEMPN4 is PTR1
	LDA TEMPN3+1
	ADC #$00
	STA TEMPN4+1
GCLP5:	LDY #$02
	LDA (TEMPN4),Y	;See if it's a fun/frame pair
	ROR A
	BCS GCLP5A
	LDY #$00	;Nope, get value and mark
	LDA (TEMPN4),Y
	STA TEMPN
	INY
	LDA (TEMPN4),Y
	STA TEMPN+1
	JSR MARKX	;Expects TEMPN as node
GCLP5A:	CLC
	LDA TEMPN4
	ADC #$04
	STA TEMPN4
	BCC GCLP5B
	INC TEMPN4+1
GCLP5B:	DEC ANSN1
	BNE GCLP5
GCLP5E:	LDY #$00	;Previous-frame index is 0
	LDA (TEMPN3),Y
	TAX
	INY
	LDA (TEMPN3),Y
	STA TEMPN3+1
	STX TEMPN3
	BNE GCLP4
GCOL1:	LDA #GCVST	;Mark all G.C.-protected variables
	STA ANSN1
GCOL1L:	LDX ANSN1
	JSR MARK
	INC ANSN1
	INC ANSN1
	LDA ANSN1
	CMP #GCVND
	BNE GCOL1L
	LDX #SIZE1
	LDY #AREA1
	JSR MARKA
	LDX #SIZE2
	LDY #AREA2
	JSR MARKA
	LDA #$00
	STA FRLIST
	STA FRLIST+1
	STA NNODES
	STA NNODES+1
	LDA #BIGBAS&$FF
	STA TEMPNH
	LDA #BIGBAS^
	STA TEMPNH+1	;Nodespace pointer
	LDA #SINODS&$FF
	STA TEMPN
	LDA #SINODS^
	STA TEMPN+1	;Typebase pointer
GCLP6:	LDY #$00
	LDA (TEMPN),Y
	ROL A		;Type bit
	BCS GCLP6C
	LDY #$02
	LDA FRLIST
	STA (TEMPNH),Y
	INY
	LDA FRLIST+1
	STA (TEMPNH),Y
	LDA TEMPNH
	STA FRLIST
	LDA TEMPNH+1
	STA FRLIST+1
	JMP GCLP6F
GCLP6C:	INC NNODES
	BNE GCLP6F
	INC NNODES+1
GCLP6F:	CLC
	LDA TEMPNH
	ADC #$04
	STA TEMPNH
	BCC GCLP6D
	INC TEMPNH+1
GCLP6D:	INC TEMPN
	BNE GCLP6E
	INC TEMPN+1
GCLP6E:	LDA TEMPN
	CMP #TYPEND&$FF
	BNE GCLP6
	LDA TEMPN+1
	CMP #TYPEND^
	BNE GCLP6
	JSR CLRMRK
	JSR SWAPT2
RSTERR:	LDX #$00	;General reset-error routine
	STX RETADR
	LDX #ERROR1&$FF
	STX ERRRET
	LDX #ERROR1^
	STX ERRRET+1
	RTS
GCLERR:	LDA #$00
	STA FRLIST
	STA FRLIST+1
	JSR CLRMRK
	JSR SWAPT2
	JMP ERROR1
.PAGE
CLRMRK:	LDA #SINODS&$FF
	STA TEMPNH
	LDA #SINODS^
	STA TEMPNH+1	;TEMPN is pointer to Typebase
	LDY #$00
GCLP1:	LDA (TEMPNH),Y
	AND #$7F	;Set Mark bit to 0 (False)
	STA (TEMPNH),Y
	INC TEMPNH
	BNE GCLP1A
	INC TEMPNH+1
GCLP1A:	LDA TEMPNH
	CMP #TYPEND&$FF
	BNE GCLP1
	LDA TEMPNH+1
	CMP #TYPEND^
	BNE GCLP1
MRKRTS:	RTS

MARKA:	LDA $00,X
	STA TEMPN
	LDA $01,X
	STA TEMPN+1	;TEMPN is SIZE
	LDA $00,Y
	STA TEMPNH
	LDA $01,Y
	STA TEMPNH+1
	JSR TYPACS	;TEMPNH becomes address of typecodes
MRKAW:	LDA TEMPN+1
	BMI MRKRTS
	BNE MRKAW1
	LDA TEMPN
	BEQ MRKRTS
MRKAW1:	LDA (TEMPNH),Y
	ORA #$80	;Mark the word
	STA (TEMPNH),Y
	INC TEMPNH
	BNE MRKAW2
	INC TEMPNH+1
MRKAW2:	SEC
	LDA TEMPN
	SBC #$01
	STA TEMPN
	BCS MRKAW
	DEC TEMPN+1
	JMP MRKAW
.PAGE
MARK:	LDA $00,X
	STA TEMPN
	LDA $01,X
	STA TEMPN+1	;TEMPN is INDEX
MARKX:	LDX #$FF
	LDY #$FF
	JSR PUSH
MRKW:	LDA #$FF
	CMP TEMPN
	BNE MRKW1
	CMP TEMPN+1
	BEQ MRKRTS
MRKW1:	LDA TEMPN+1
	BEQ MRKW3
	STA TEMPNH+1
	LDA TEMPN
	STA TEMPNH
	JSR TYPACS
	STA ANSN
	ROL A
	BCC MRKW2
MRKW3:	LDX #TEMPN
	JSR POP
	JMP MRKW
MRKW2:	JSR TSTSTK
	LDA ANSN
	ORA #$80
	STA (TEMPNH),Y
	AND #$7F
	LDX #GCLTAB&$FF
	LDY #GCLTAB^
	JMP TYPDSP

MRKCF:	LDY #$02
MRKCN:	LDA (TEMPN),Y
	AND #$FC	;In case it's a funny-pname bit
	TAX
	INY
	LDA (TEMPN),Y
	BEQ MRKW3
	TAY
MRKCF1:	JSR PUSH
	JMP MRKW3
MRKCS:	LDY #$00
	JMP MRKCN
MRKCL:	LDA TEMPN
	AND #$FC
	STA TEMPN
	LDY #$00
	LDA (TEMPN),Y
	TAX
	INY
	LDA (TEMPN),Y
	BEQ MRKCF
	TAY
MRKCL1:	JSR PUSH
	JMP MRKCF
MRKCU:	CLC
	LDA TEMPN
	ADC #$04
	STA TEMPNH
	LDA TEMPN+1
	ADC #$00
	STA TEMPNH+1
	JSR TYPACS
	ORA #$80
	STA (TEMPNH),Y
	JMP MRKCF
MRKCP:	LDY #$01
	STY ANSN	;ANSN is FIRSTLINE
	DEY
MRKCP1:	LDA (TEMPN),Y
	STA TEMPN1	;TEMPN1 is LINE
	INY
	LDA (TEMPN),Y
	STA TEMPN1+1
	INY
	LDA (TEMPN),Y
	STA TEMPN2	;TEMPN2 is LINEEND
	INY
	LDA (TEMPN),Y
	STA TEMPN2+1
MRKPW:	LDA TEMPN2+1
	BNE MRKPW1
	CLC
	LDA TEMPN
	ADC #$02
	STA TEMPNH
	LDA TEMPN+1
	ADC #$00
	STA TEMPNH+1
	JSR TYPACS
	ORA #$80
	STA (TEMPNH),Y
	JMP MRKW3
MRKPW1:	CLC
	LDA TEMPN
	ADC #$02
	STA TEMPNH
	LDA TEMPN+1
	ADC #$00
	STA TEMPNH+1
	JSR TYPACS
	ORA #$80
	STA (TEMPNH),Y
	LDA TEMPN1
	STA TEMPNH
	LDA TEMPN1+1
	STA TEMPNH+1
	JSR TYPACS
	ORA #$80
	STA (TEMPNH),Y
	LDA ANSN
	BNE MRKPW2
	CLC
	LDA TEMPN1
	ADC #$02
	STA TEMPN1
	BCC MRKPW2
	INC TEMPN1+1
MRKPW2:	LDA #$00
	STA ANSN
MRKPX:	LDA TEMPN1
	CMP TEMPN2
	BNE MRKPX1
	LDA TEMPN1+1
	CMP TEMPN2+1
	BNE MRKPX1
MRKPXE:	CLC
	LDA TEMPN
	ADC #$02
	STA TEMPN
	BCC MRKCP1
	INC TEMPN+1
	BNE MRKCP1	;(Always)
MRKPX1:	LDA TEMPN1
	STA TEMPNH
	LDA TEMPN1+1
	STA TEMPNH+1
	JSR TYPACS
	ORA #$80
	STA (TEMPNH),Y
	LDA (TEMPN1),Y
	TAX
	INY
	LDA (TEMPN1),Y
	TAY
	JSR PUSH
	JSR TSTSTK
	CLC
	LDA TEMPN1
	ADC #$02
	STA TEMPN1
	BCC MRKPX
	INC TEMPN1+1
	BNE MRKPX	;(Always)
.PAGE
CLMK5:	STA MARK5
	STA MARK5+1
CLMK4:	STA MARK4
	STA MARK4+1
CLMK3:	STA MARK3
	STA MARK3+1
CLMK2:	STA MARK2
	STA MARK2+1
CLMK1:	STA MARK1
	STA MARK1+1
	RTS

SWAPT1:	LDY #TMPNUM-1
	LDX #TMPSTT
SWPLP1:	LDA $00,X
	STA TMPTAB,Y
	INX
	DEY
	BPL SWPLP1
	RTS

SWAPT2:	LDY #TMPNUM-1
	LDX #TMPSTT
SWPLP2:	LDA TMPTAB,Y
	STA $00,X
	INX
	DEY
	BPL SWPLP2
	RTS
.PAGE
.SBTTL	Output Routines:
;PRTSTR prints the Ascii string whose address is in the X and Y registers.
;The string is terminated with a 0.
PRTSTR: STX TEMPNH
	STY TEMPNH+1
	LDA GETRM2	;Ghost-memory bank 2, Text strings
	LDY #$00
PTSTR1:	LDA (TEMPNH),Y
	BEQ PTRRTS
	JSR TPCHR
	INY
	BNE PTSTR1	;(Always)
PTRRTS:	LDA GETRM1	;Ghost-memory bank 2 disable
	LDA GETRM1
	RTS

SPRINT:	LDA #$20
	JSR SPRNT
	JSR BREAK1
	JMP POPJ

STYPE:	LDA #$00
	JSR SPRNT
	JMP POPJ
.PAGE
SPRNT:	PHA		;Space-between-args flag
	LDA NARGS
	BPL SPRNT1
	EOR #$FF
	STA NARGS
SPRNT1:	BEQ SPRNT2
	JSR STPTR1	;TEMPN5 := VSP + (NARGS * 2)
SPRNTW:	LDA TEMPN5
	CMP VSP
	BNE PRNTW1
	LDA TEMPN5+1
	CMP VSP+1
	BEQ PRNTWE
PRNTW1:	LDY #$00
	LDA (TEMPN5),Y
	STA ARG1
	INY
	LDA (TEMPN5),Y
	STA ARG1+1
	SEC
	LDA TEMPN5
	SBC #$02
	PHA
	LDA TEMPN5+1
	SBC #$00
	PHA
	LDX #ARG1
	LDA #$01
	JSR LTYPE
	PLA
	STA TEMPN5+1
	PLA
	STA TEMPN5
	PLA
	PHA
	BEQ SPRNTW
	JSR TPCHR
	JMP SPRNTW
PRNTWE:	JSR INCVSP	;VSP := VSP + (NARGS * 2)
SPRNT2:	PLA
	RTS
.PAGE
LTYPE:	STA TEMPN4	;TOPLEVELP
	LDA $00,X
	STA TEMPN5
	LDA $01,X
	STA TEMPN5+1	;THING
	LDX #LTPRTS&$FF
	LDY #LTPRTS^
	JSR PUSH
PRTHNG:	LDX #TEMPN5
	JSR GETTYP
	LDX #LTPTAB&$FF
	LDY #LTPTAB^
	JMP TYPDSP

LTPFX:	LDY #$00
	LDX #$03
LTYPL1:	LDA (TEMPN5),Y
	STA NARG1,Y
	INY
	DEX
	BPL LTYPL1
	RTS

LTPQ:	LDA #'"
	BNE LTPD1	;(Always)
LTPD:	LDA #':
LTPD1:	JSR TPCHR
LTPA:	JSR TYPATM
	JMP POPJ
LTPS:	JSR TPSATM
	JMP POPJ
LTPL:	JSR TYPATM
	LDA #':
	JSR TPCHR
	JMP POPJ
LTPF:	JSR LTPFX
	JSR TPBFIX
	JMP POPJ
LTPF1:	JSR LTPFX
	JSR TYPFLO
	JMP POPJ
LTPLS:	LDA #$01
	STA TEMPN4+1	;NOSPACE
	LDA TEMPN4	;TOPLEVELP
	BNE PLSTLP
	LDA #'[
	JSR TPCHR
PLSTLP:	JSR TSTPOL
	LDA TEMPN5+1
	BNE PLLP1
	LDA TEMPN4	;TOPLEVELP
	BNE PLLP2
	STA TEMPN4+1	;Print a space after Sublists
	LDA #']
	JSR TPCHR
PLLP2:	JMP POPJ
PLLP1:	LDA TEMPN4+1	;NOSPACE
	BNE PLLP1A
	LDA #$20	;(Space)
	JSR TPCHR
PLLP1A:	LDX #TEMPN5
	JSR PUSHP
	LDA TEMPN4
	JSR PUSHB
	LDY #$00
	STY TEMPN4
	STY TEMPN4+1
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	LDX #TPP1&$FF
	LDY #TPP1^
	JSR PUSH
	JMP PRTHNG
TPP1:	JSR POPB
	STA TEMPN4
	LDX #TEMPN5
	JSR POP
	LDY #$02
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	JMP PLSTLP
.PAGE
TYPATM:	LDA TEMPN5
	AND #$FC
	STA TEMPN5
	LDX #TEMPN5
	LDY #TEMPN5
	JSR GETPNM	;Returns with A nonzero if Funny-pname
	STA ANSN
	TAX
	BEQ TPATMW
	LDA OTPFLG
	BEQ TPATMW
	LDA #$27	;Type quote if printing to buffer
	JSR TPCHR
TPATMW:	LDA TEMPN5+1
	BEQ TPTMWE
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPNH
	INY
	LDA (TEMPN5),Y
	STA TEMPNH+1
	INY
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	LDA TEMPNH
	BEQ TPTMWE
	JSR TPCHR
	LDA TEMPNH+1
	BEQ TPTMWE
	JSR TPCHR
	JMP TPATMW
TPTMWE:	LDA ANSN
	BEQ LTPRTS
	LDA OTPFLG
	BEQ LTPRTS
	LDA #$27	;Type quote if printing to buffer
	JMP TPCHR
.PAGE
TPSATM:	LDY #$02
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	LDY #$03
TPSTMW:	LDA (TEMPN5),Y
	BEQ LTPRTS
	STY ANSN
	JSR TPCHR
	LDY ANSN
	INY
	BNE TPSTMW	;(Always)
LTPRTS:	RTS

;Types a two-byte fixnum, always positive.
TYPFIX:	JSR CVFIX	;Get string on PDL
	JMP PRTPDL	;Type string on PDL

;Types a four-byte fixnum in NARG1.
TPBFIX:	JSR CVBFIX	;Get string on PDL
	JMP PRTPDL	;Type string on PDL

;Type the flonum in NARG1.
TYPFLO:	JSR CVFLO	;Get String on PDL
	;falls through

;Type the string on the PDL, ANSN1 holds character count.
	;falls in
PRTPDL:	LDA #$00
	PHA		;Push stop indicator
PRTPL1:	JSR POPB	;Pop chars off PDL and onto stack
	PHA
	DEC ANSN1
	BNE PRTPL1
PRTPL2:	PLA		;Pop chars from stack and type them
	BEQ LTPRTS	;until stop indicator popped
	JSR TPCHR
	JMP PRTPL2
.PAGE
PONAMS:	LDA OBLIST
	STA TEMPN8
	LDA OBLIST+1
	STA TEMPN8+1	;TEMPN8 is OBLIST pointer
PONW1:	LDA TEMPN8+1
	BEQ PONW1E	;See if done
	LDY #$00
	LDA (TEMPN8),Y
	STA TEMPN6	;Get name pointer
	INY
	LDA (TEMPN8),Y
	STA TEMPN6+1
	INY
	LDA (TEMPN8),Y
	TAX
	INY
	LDA (TEMPN8),Y
	STA TEMPN8+1
	STX TEMPN8	;(CDR) to next OBLIST object
	JSR PONAME	;Print the name and value
	JMP PONW1
PONW1E:	LDA SOBLST
	STA TEMPN6	;TEMPN6 is SOBLIST pointer
	LDA SOBLST+1
	STA TEMPN6+1
PONW2:	LDA TEMPN6
	CMP SOBTOP
	BNE PONW2A	;See if done
	LDA TEMPN6+1
	CMP SOBTOP+1
	BNE PONW2A
PONRTS:	RTS
PONW2A:	JSR PONAME	;Print the name and value
	CLC
	LDA TEMPN6
	ADC #$04
	STA TEMPN6
	BCC PONW2
	INC TEMPN6+1
	BNE PONW2	;(Always)
.PAGE
PONAME:	LDX #TEMPN7	;TEMPN7 is value
	LDY #TEMPN6	;TEMPN6 is NAME
	JSR GETVAL
	LDA TEMPN7+1
	BNE PON1A
	LDA TEMPN7
	BNE PONRTS	;Skip if NOVALUE
PON1A:	LDA OTPFLG
	BNE PON1B	;Use MAKE if printing to buffer
	LDA #'"
	JSR TPCHR
	LDA #$00
	LDX #TEMPN6
	JSR LTYPE
	LDX #PNMSG1&$FF		;"IS "
	LDY #PNMSG1^
	JSR PRTSTR
	LDA #$00
	LDX #TEMPN7
	JSR LTYPE
	JMP BREAK1
PON1B:	LDX #PNMSG2&$FF		;"MAKE "
	LDY #PNMSG2^
	JSR PRTSTR
	LDA #'"
	JSR TPCHR
	LDA #$00
	LDX #TEMPN6
	JSR LTYPE
	LDA #$20
	JSR TPCHR
	LDX #TEMPN7
	JSR GETTYP
	CMP #ATOM
	BNE PON1C
	LDA #'"
	JSR TPCHR
PON1C:	LDA #$00
	LDX #TEMPN7
	JSR LTYPE
	JMP BREAK1
.PAGE
POFUNS:	STA ANSN4	;ANSN4 is FULL
	LDA OBLIST
	STA TEMPX2	;TEMPN7 is OBLIST pointer
	LDA OBLIST+1
	STA TEMPX2+1
POFNSW:	LDY #$03
	LDA (TEMPX2),Y
	PHA
	DEY
	LDA (TEMPX2),Y
	PHA
	DEY
	LDA (TEMPX2),Y
	TAX
	DEY
	LDA (TEMPX2),Y
	STA TEMPX2
	STX TEMPX2+1
	LDA #TEMPX2
	JSR POFUNX
	PLA
	STA TEMPX2
	PLA
	STA TEMPX2+1
	BNE POFNSW
PTXRTS:	RTS
.PAGE
POFUN:	STX ANSN4	;ANSN4 is FULL
POFUNX:	STA ANSN1	;Save ATOMM (Entry point for POFUNS)
	TAX
	LDA #TEMPN6	;TEMPN6 becomes FUN
	JSR GETFUN
	LDA TEMPN6+1
	BEQ PTXRTS
	LDX #TOMSG&$FF	;"TO "
	LDY #TOMSG^
	JSR PRTSTR
	LDX ANSN1	;Retrieve ATOMM
	LDA #$00
	JSR LTYPE	;Print the title
	LDY #$02
	LDA (TEMPN6),Y
	TAX
	INY
	LDA (TEMPN6),Y
	STA TEMPN6+1
	STX TEMPN6
	LDX #TEMPN6
	JSR GETTYP
	CMP #LIST
	BEQ POTXTL
	JMP POTXTF
POTXTL:	LDY #$00
	LDA (TEMPN6),Y
	STA TEMPN8	;TEMPN8 is LINE
	INY
	LDA (TEMPN6),Y
	STA TEMPN8+1
	INY
	LDA (TEMPN6),Y
	TAX
	INY
	LDA (TEMPN6),Y
	STA TEMPN6+1
	STX TEMPN6
PTXLW:	LDA TEMPN8+1
	BEQ PTXLWE
	LDY #$00
	LDA (TEMPN8),Y
	STA TEMPX1
	INY
	LDA (TEMPN8),Y
	STA TEMPX1+1
	INY
	LDA (TEMPN8),Y
	TAX
	INY
	LDA (TEMPN8),Y
	STA TEMPN8+1
	STX TEMPN8
	LDA #$20	;(Space)
	JSR TPCHR
	LDA #$00
	LDX #TEMPX1
	JSR LTYPE
	JMP PTXLW
PTXLWE:	JSR BREAK1
	LDA ANSN4	;FULL
	BEQ PTXRTS
PTXLX:	LDA TEMPN6+1
	BEQ PTXEND
PTXLX1:	LDY #$00
	LDA (TEMPN6),Y
	STA TEMPN8
	INY
	LDA (TEMPN6),Y
	STA TEMPN8+1
	INY
	LDA (TEMPN6),Y
	TAX
	INY
	LDA (TEMPN6),Y
	STA TEMPN6+1
	STX TEMPN6
	LDY #$00
	LDA (TEMPN8),Y
	STA TEMPN8
	INY
	LDA (TEMPN8),Y
	STA TEMPN8+1
PTXLY:	LDX #TEMPN8	;LTYPE the list-line
	JSR BREAK1
	JSR LTYPE
	JMP PTXLX
PTXEND:	LDX #ENDMSG&$FF
	LDY #ENDMSG^
	JMP PRTSTR
POTXTF:	LDY #$00
	LDA (TEMPN6),Y
	STA TEMPN8	;TEMPN8 is PTR
	INY
	LDA (TEMPN6),Y
	STA TEMPN8+1
	INY
	LDA (TEMPN6),Y
	STA TEMPN7	;TEMPN7 is ENDPTR
	INY
	LDA (TEMPN6),Y
	STA TEMPN7+1
	CLC
	LDA TEMPN6
	ADC #$02
	STA TEMPN6
	BCC PTXFW
	INC TEMPN6+1
PTXFW:	LDA TEMPN7
	CMP TEMPN8
	BNE PTXFW1
	LDA TEMPN7+1
	CMP TEMPN8+1
	BEQ PTXFWE
PTXFW1:	LDY #$00
	LDA (TEMPN8),Y
	STA TEMPX1
	INY
	LDA (TEMPN8),Y
	STA TEMPX1+1
	CLC
	LDA TEMPN8
	ADC #$02
	STA TEMPN8
	BCC PTXFW2
	INC TEMPN8+1
PTXFW2:	LDA #$20
	JSR TPCHR
	LDA #$00
	LDX #TEMPX1
	JSR LTYPE
	JMP PTXFW
PTXFWE:	JSR BREAK1
	LDA ANSN4
	BNE PTXFX
	RTS
PTXFX:	LDA TEMPN7+1
	BNE PTXFX1
	JMP PTXEND
PTXFX1:	LDA TEMPN7
	STA TEMPN8
	LDA TEMPN7+1
	STA TEMPN8+1
	LDY #$02
	LDA (TEMPN6),Y
	STA TEMPN7
	INY
	LDA (TEMPN6),Y
	STA TEMPN7+1
	CLC
	LDA TEMPN6
	ADC #$02
	STA TEMPN6
	BCC PTXFX2
	INC TEMPN6+1
PTXFX2:	LDA TEMPN7+1
	BNE PTXFY
	JMP PTXEND
PTXFY:	LDA TEMPN7
	CMP TEMPN8
	BNE PTXFY1
	LDA TEMPN7+1
	CMP TEMPN8+1
	BEQ PTXFYE
PTXFY1:	LDY #$00
	LDA (TEMPN8),Y
	STA TEMPX1
	INY
	LDA (TEMPN8),Y
	STA TEMPX1+1
	CLC
	LDA TEMPN8
	ADC #$02
	STA TEMPN8
	BCC PTXFY2
	INC TEMPN8+1
PTXFY2:	LDA #$20
	JSR TPCHR
	LDA #$00
	LDX #TEMPX1
	JSR LTYPE
	JMP PTXFY
PTXFYE:	JSR BREAK1
	JMP PTXFX
.PAGE
.SBTTL	Arithmetic Routines:
	;Floating Point routines:

FLOTN2:	JSR SWAP
	JSR FLOTN1
	JMP SWAP

FLOTN1:	LDA NARG1+3
	BPL XFLOAT
	LDX #NARG1
	JSR COMPL
	JSR XFLOAT
	JMP FCOMPL

XFLOAT:	LDA #$9E
	STA ANSN	;Shift counter (exponent)
XFLT1:	LDA NARG1+3
	CMP #$C0
	BMI XFLT2
	ASL NARG1
	ROL NARG1+1	;Rotate left to left-justify
	ROL NARG1+2
	ROL NARG1+3
	DEC ANSN
	BNE XFLT1	;Stop if exponent is zero
XFLT2:	LDA NARG1+1	;Reverse LSB, MSB for floating pt. format
	LDY NARG1+3
	STY NARG1+1
	STA NARG1+3
	LDA ANSN
	STA NARG1	;Put in exponent
	RTS

;Add M1 and M2, result in M1.
ADD:	CLC		;Clear carry
	LDX #$02	;Index for 3-byte add
ADD1:	LDA NARG1+1,X
	ADC NARG2+1,X	;Add a byte of Mant2 to Mant1
	STA NARG1+1,X
	DEX		;Index to next more signif. byte
	BPL ADD1	;Loop until done
	RTS		;Return

;Makes X/M1 and X/M2 positive. Returns with LSB of SIGN equal to XOR of
;signs of original numbers. Copies (positive) mantissa of X/M1 into E.
MD1:	ASL ANSN	;Clear LSB of Sign
	JSR ABSWAP	;Abs. val. of M1, then swap with M2
ABSWAP:	BIT NARG1+1	;Is Mant1 negative...
	BPL ABSWP1	;No, swap with Mant2 and return
	JSR FCOMPL	;Yes, complement it.
	INC ANSN	;Increment sign, complementing LSB
ABSWP1:	SEC		;Set carry for return to MUL/DIV
	;falls through

;Swaps X/M1 and X/M2 and leaves a copy of M1 in E.
	;falls in
SWAP:	LDX #$04	;Index for 4-byte swap
SWAP1:	STY TEMPNH-1,X
	LDA NARG1-1,X	;Swap a byte of Exp/Mant1 with
	LDY NARG2-1,X	;Exp/Mant2 and leave a copy of
	STY NARG1-1,X	;Mant1 in E (3 bytes). (E+3 is destroyed.)
	STA NARG2-1,X
	DEX		;Advance index to next byte
	BNE SWAP1	;Loop until done
	RTS		;Return

;Normalize M1 and X1 to standard format floating pt. (left-justified mantissa,
;exponent tells how much so).
NORM1:	LDA NARG1+1	;High-order Mant1 byte
	CMP #$C0	;Are Upper two bits unequal...
	BMI RTS1	;Yes, return with Mant1 normalized.
	DEC NARG1	;Decrement X1
	ASL NARG1+3
	ROL NARG1+2	;Shift Mant1 3 bytes left
	ROL NARG1+1
FNORM:	LDA NARG1	;Is Exp1 zero...
	BNE NORM1	;No, continue normalizing.
RTS1:	RTS		;Return

;Floating pt. add. X/M1 becomes X/M2 + X/M1.
FADD:	JSR FADD1
	CLC		;If it returns, then no overflow
	RTS

FSUB:	JSR SWAP	;It does M2-M1, we want M1-M2
FSUBX:	JSR FSUB1
	CLC
	RTS

FMUL:	JSR FMULT
	CLC
	RTS

FDIV:	JSR SWAP	;It does M2/M1, we want M1/M2.
	JSR FDIVD
	CLC
	RTS

;Floating pt. subtract. X/M1 becomes X/M2 - X/M1.
FSUB1:	JSR FCOMPL	;Complement Mant1, clears carry unless 0
SWPALN:	JSR ALNSWP	;Right shift Mant1 or swap
FADD1:	LDA NARG2
	CMP NARG1	;Compare Exp1 with Exp2
	BNE SWPALN	;If unequal, swap addends or align mantissas
	JSR ADD		;Add aligned mantissas
ADDEND:	BVC FNORM	;No overflow, normalize result
	BVS RTLOG	;(Always) Overflow - shift M1 right, carry into Sign

;Either swap mantissas (for another alignment) or do an alignment. Carry bit
;resultants determine which to do each time over.
ALNSWP:	BCC SWAP	;Swap if carry clear, else shift right arith.
RTAR:	LDA NARG1+1	;Sign of M1 into carry for
	ASL A		;right arith. shift
RTLOG:	INC NARG1	;Increment X1 to adjust for right shift
	BEQ OVFL	;Exp1 out of range
RTLOG1:	LDX #$FA	;Index for 6 byte right shift
ROR1:	ROR TEMPNH+3,X	;(M1 and E must be contiguous)
	INX		;Next byte of shift
	BNE ROR1	;Loop until done
	RTS		;Return

;Floating pt. multiply. X/M1 becomes X/M1 * X/M2.
FMULT:	JSR MD1		;Absolute value of Mant1, Mant2.
	ADC NARG1	;Add Exp1 to Exp2 for product Exp
	JSR MD2		;Check product exp. and prepare for multiply
	CLC		;Clear carry for first bit
FMUL1:	JSR RTLOG1	;M1 and E right (product and multiplier)
	BCC FMUL2	;If carry clear, skip partial product
	JSR ADD		;Add multiplicand to product
FMUL2:	DEY		;Next multiply iteration
	BPL FMUL1	;Loop until done
MDEND:	LSR ANSN	;Test Sign LSB
NORMX:	BCC FNORM	;If even, normalize product, else complement
	;falls through

;Complement the mantissa of M1.
	;falls in
FCOMPL:	SEC		;Set carry for subtract
	LDX #$03	;Index for 3-byte subtract
COMPL1:	LDA #$00	;Clear A
	SBC NARG1,X	;Subtract byte of Exp1
	STA NARG1,X	;Restore it
	DEX		;Next more significant byte
	BNE COMPL1	;Loop until done
	BEQ ADDEND	;(Always)

;Floating pt. multiply. X/M1 becomes X/M1 / X/M2.
FDIVD:	JSR MD1		;Take abs. val. of Mant1, Mant2
	SBC NARG1	;Subtract Exp1 from Exp2
	JSR MD2		;Save as quotient exp.
DIV1:	SEC		;Set carry for subtract
	LDX #$02	;Index for 3-byte subtraction
DIV2:	LDA NARG2+1,X
	SBC TEMPNH,X	;Subtract a byte of E from Mant2
	PHA		;Save on stack
	DEX		;Next more significant byte
	BPL DIV2	;Loop until done
	LDX #$FD	;Index for 3-byte conditional move
DIV3:	PLA		;Pull byte of difference off stack
	BCC DIV4	;If M2 smaller than E then don't restore M2
	STA NARG2+4,X
DIV4:	INX		;Next less significant byte
	BNE DIV3	;Loop until done
	ROL NARG1+3
	ROL NARG1+2	;Roll quotient left, carry into LSB
	ROL NARG1+1
	ASL NARG2+3
	ROL NARG2+2	;Shift dividend left
	ROL NARG2+1
	BCS OVFL	;Overflow is due to un-normalized divisor
	DEY		;Next divide iteration
	BNE DIV1	;Loop until done 23 iterations
	BEQ MDEND	;(Always) Normalize quotient and correct sign

;Prepare for multiply or divide, check result's exponent.
MD2:	STX NARG1+3
	STX NARG1+2	;Clear Mant1 (3 bytes) for MUL/DIV
	STX NARG1+1
	BCS OVCHK	;If calculation set carry, check for overflow
	BMI MD3		;If negative, then no underflow
	PLA		;Pop one return level (undeflow, answer is 0)
	PLA
	BCC NORMX	;Clear X1 and return
MD3:	EOR #$80	;Complement sign bit of exponent
	STA NARG1	;Store it.
	LDY #$17	;Count 24. (MUL) or 23. (DIV) iterations
	RTS		;Return

OVCHK:	BPL MD3		;If positive exponent, then no overflow.
	PLA
	PLA		;Pop past MD2 call

OVFL:	PLA	;Overflow, pop past first function call
	PLA
	SEC	;Indicate overflow
	RTS

;Changes the argument in (X) from Flonum to four-byte Fixnum (rounds).
RNDN2:	JSR SWAP	;Pos or neg, only NARG2
	JSR RNDN1
	JMP SWAP

RNDN1:	LDA NARG1+1	;is it positive
	BPL XINTN1	;yes
	JSR FCOMPL	;for negatives: negate --> convert --> negate
	JSR XINTN1
	LDX #NARG1
	JMP COMPL

XINTN1:	LDX #$03	;(Bashes NARG2)
SINTL:	LDA NARG2,X
	PHA		;Save NARG2
	LDA RNDUP,X	;Get 0.5 into NARG2
	STA NARG2,X
	DEX
	BPL SINTL
	JSR FADD
	JSR INTN1
FFIXD:	LDX #$FC
FFIXDL:	PLA		;Restore NARG2
	STA NARG2+4,X
	INX
	BMI FFIXDL
	RTS

;Pos or neg, only NARG1
INTN1:	LDA NARG1
	BMI FFIXP
	LDA #$00	;Negative exponent gives zero result
	STA NARG1
	STA NARG1+1
	STA NARG1+2
	STA NARG1+3
FFIXR:	RTS
FFIXP:	CMP #$9F
	BCS OVFL1	;Exponent too high, overflow
	LDA NARG1+1
	BPL FFIXP1
	JSR FCOMPL
	JSR FFIXP1
	LDX #NARG1
	JMP COMPL
FFIXP1:	LDA NARG1
	STA ANSN
	LDA #$00
	STA NARG1	;Init LSB to zero
	LDA NARG1+1
	LDY NARG1+3	;Switch LSB, MSB for fixnum format
	STY NARG1+1
	STA NARG1+3
FFIX1:	LDA ANSN
	CMP #$9E
	BEQ FFIXR	;Done when Exp=30. (4 bytes, binary point two places in)
	LSR NARG1+3
	ROR NARG1+2	;Rotate to right-justify
	ROR NARG1+1
	ROR NARG1
	INC ANSN
	BNE FFIX1	;(Always)
OVFL1:	LDA #XOFLOW
	JMP ERROR

;Complement (negate) a fixnum.
COMPL:	LDY #$03
	SEC
CMPL1:	LDA $00,X
	EOR #$FF	;Complement
	ADC #$00	;and increment.
	STA $00,X
	INX
	DEY
	BPL CMPL1
	RTS
.PAGE
;Divides NARG1 by vA.
XDVDX:	STA NARG2
	LDA #$00
	STA NARG2+1
	STA NARG2+2
	STA NARG2+3
	;falls through

;Fast and clean fixnum division routine, assumes positive numbers.
;Dividend in NARG1, divisor in NARG2.
;NARG1 becomes quotient, low byte of remainder in vA, full remainder in NARG2.
	;falls in
XDIVID:	LDX #$03
SDVLP1:	LDA NARG2,X
	BNE XDVD1
	DEX
	BPL SDVLP1
	LDA #XDBZ
	JMP ERROR
XDVD1:	LDA #$00		;Zero temp. quotient (A1L-A2H)
	LDX #$03
XDLP1:	STA A1L,X
	STA TEMPN,X
	DEX
	BPL XDLP1
	INC TEMPN		;Initialize bitholder (TEMPN,TEMPN1)
NORM:	ASL TEMPN		;Normalize the bitholder...
	ROL TEMPN+1
	ROL TEMPN1
	ROL TEMPN1+1
	ASL NARG2
	ROL NARG2+1		;and the divisor
	ROL NARG2+2
	ROL NARG2+3
	BPL NORM		;to the left side
	BMI SHFT		;(Always)
SHFTX:	PLA			;(Discard intermediate result)
SHFT:	LSR TEMPN1+1		;Back 'em off one
	ROR TEMPN1
	ROR TEMPN+1
	ROR TEMPN
	LSR NARG2+3
	ROR NARG2+2
	ROR NARG2+1
	ROR NARG2
	LDX #$03
XDLP2:	LDA TEMPN,X
	BNE DV2			;If bitholder is zero, done
	DEX
	BPL XDLP2
	BMI DONE		;(Always)
DV2:	SEC			;Subtract divisor from dividend
	LDA NARG1
	SBC NARG2
	PHA
	LDA NARG1+1
	SBC NARG2+1
	TAX
	LDA NARG1+2
	SBC NARG2+2
	TAY
	LDA NARG1+3
	SBC NARG2+3
	BCC SHFTX		;If borrow, don't save remainder
	STA NARG1+3		;or add to result
	STY NARG1+2
	STX NARG1+1
	PLA
	STA NARG1
	CLC
	LDX #$FC
XDLP3:	LDA A1L+4,X		;Add bitholder to result
	ADC TEMPN+4,X
	STA A1L+4,X
	INX
	BMI XDLP3
	BPL SHFT		;(Always)
DONE:	LDY #NARG2
	JSR XN1TOY	;Put remainder in NARG2
	LDY #A1L
	JSR XYTON1
	LDA NARG2
	RTS

IMULT:	LDA NARG1+3	;(Bashes NARG2)
	EOR NARG2+3
	STA ANSN
	LDA NARG1+3
	BPL SPRD1
	LDX #NARG1
	JSR COMPL
SPRD1:	LDA NARG2+3
	BPL SPRD2
	LDX #NARG2
	JSR COMPL
SPRD2:	LDA #$00
	LDX #$03
SPRDL1:	STA TEMPN,X
	DEX
	BPL SPRDL1
	LDY #$20	;Bit counter
MUL2:	LSR NARG2+3
	ROR NARG2+2
	ROR NARG2+1
	ROR NARG2
	BCC MUL4
	CLC
	LDX #$FC
SPRDL2:	LDA TEMPN+4,X	;Add multiplicand (NARG1) to partial product (TEMPN, TEMPN1)
	ADC NARG1+4,X
	STA TEMPN+4,X
	INX
	BMI SPRDL2
	TAX
	BMI IMULOV
MUL4:	ASL NARG1
	ROL NARG1+1
	ROL NARG1+2
	ROL NARG1+3
	BPL MUL4A
	LDX #$03	;Sig. bit dropped from NARG1, so bit counter better be 0
MUL4B:	LDA NARG2,X
	BNE IMULOV	;It isn't, error
	DEX
	BPL MUL4B
	BMI MULEND	;(Always) It is, so we're done
MUL4A:	DEY
	BNE MUL2	;Next bit
MULEND:	LDA ANSN
	BPL SPRD3
	LDX #TEMPN
	JSR COMPL
SPRD3:	CLC
	RTS
IMULOV:	SEC
	RTS

IDIVID:	LDA #$00
	STA ANSN	;SIGN
	LDA NARG1+3
	BPL SDVD2
	LDX #NARG1
	JSR COMPL
	INC ANSN
SDVD2:	LDA NARG2+3
	BPL SDVD3
	LDX #NARG2
	JSR COMPL
	LDA ANSN
	EOR #$01
	STA ANSN
SDVD3:	JSR XDIVID	;NARG2 is divisor, NARG1 is dividend, then quotient
	LDA ANSN
	BEQ SDVD4
	LDX #NARG1
	JSR COMPL
SDVD4:	RTS
;routines for both turtle graphics and trig sfuns.
GETSIN:	JSR GSETHX	;Convert NARG1 to 0-360
	LDY #NARG1
	JSR XYTON2	;Get NARG1 in NARG2
GETHS:	LDA #$00
	STA ANSN1
	STA ANSN2       
	LDY #TEMPN5	;Save NARG1 through subtract
	JSR XN1TOY
	JSR INTN1	;Make it integer... (don't round!)
	JSR FLOTN1	;then floating again, zapping fraction bits
	JSR FSUBX	;which remain after subtract
	LDY #TEMPN7
	JSR XN1TOY	;Save fraction for interpolating
	LDY #TEMPN5
	JSR XYTON1	;Get heading back for munching
	LDA NARG1
	CMP #$87
	BCC HDPOS
	BNE HDNPOS
	LDA NARG1+1
	CMP #$5A
	BCC HDPOS
	BNE HDNPOS
	LDA NARG1+2
	BNE HDNPOS
	LDA NARG1+3
	BEQ HDPOS
HDNPOS:	LDX #$03
HDNPSL:	LDA F360,X	;Subtract from 360.
	STA NARG2,X
	DEX
	BPL HDNPSL
	JSR FSUBX
	INC ANSN1	;Sign of X incr.
HDPOS:	LDA NARG1	;See if it's > 90.
	CMP #$86
	BCC HDYPOS
	BNE HDYNEG
	LDA NARG1+1
	CMP #$5A
	BCC HDYPOS
	BNE HDYNEG
	LDA NARG1+2
	BNE HDYNEG
	LDA NARG1+3
	BEQ HDYPOS
HDYNEG:	LDX #$03
HDYNL:	LDA FCIRC1,X
	STA NARG2,X
	DEX
	BPL HDYNL
	JSR FSUBX	;Subtract from 180. if > 90.
	INC ANSN2
HDYPOS:	JMP INTN1	;Make Heading integer (don't round)
.PAGE
MULCOS:	CLC		;Indexes 90-ANGLE-1 entry and following entry
	LDA #$5A
	SBC NARG1
MULSIN:	CLC
	ADC #$01	;Increment index (see below)
	ASL A		;Multiply by 2 for offset
	PHA		;Save index
	TAX
	LDA GETRM2	;Enable bank 2 ghost-memory
	LDA SINTB1,X	;Get the table's entry
	STA NARG1	;(Indexed from 1 before zero value, with
	LDA SINTB1+1,X	;an index incremented by 2, so that the
	STA NARG1+1	;value before zero gets indexed properly)
	LDA SINTB2,X
	STA NARG1+2
	LDA SINTB2+1,X
	STA NARG1+3
	LDY #TEMPN5
	JSR XN1TOY	;Save table value
	PLA		;Retrieve index
	TAX
	LDA SINTB1+2,X	;Get the next entry for interpolating
	STA NARG2
	LDA SINTB1+3,X
	STA NARG2+1
	LDA SINTB2+2,X
	STA NARG2+2
	LDA SINTB2+3,X
	STA NARG2+3
	LDY #TEMPN3
	JSR XN2TOY	;Save table value
	JSR FSUBX	;Get difference of entries in NARG1
	LDA GETRM1	;Re-enable bank 1 ghost-memory
	LDA GETRM1
	RTS

;this routine expects a flonum in NARG1, bashes it to between 0 and 360
;and puts the result in NARG1.
;cases: positive, < 360: ok.
;	positive, < 720: subtract 360.
;	negative, > -360: add 360.
;	else bash 
;bash (x) temp := (int (x/360.0)) * 360
;	  x := x - (float temp)
GSETHX:	LDY #TEMPN2
	JSR XN1TOY	;Put NARG1 in TEMPN2,3
	LDX #$03
GSETL1:	LDA F360,X
	STA NARG2,X	;Put 360. in NARG2
	DEX
	BPL GSETL1
	LDA NARG1+1
	BMI GSNEG       ;check for neg
	JSR GFSUB	;NARG1 := NARG1 - 360
	LDA NARG1+1
	BMI GSREST      ;if we got a neg result, just restore (0 < x < 360)
	JSR GFSUB
	LDA NARG1+1     ;restore adds 360 to NARG1
	BPL GSBASH
GSREST:	JMP FADD        ;add 360 back to NARG1
GSNEG:	JSR GFADD	;get NARG1 + 360. in NARG1
	LDA NARG1+1
	BMI GSBASH
	RTS
GSBASH:	LDY #TEMPN2     ;restore narg1
	JSR XYTON1
	JSR FDIV        ;we still have 360 in NARG2
	JSR INTN1       ;integerize result
	LDA #$68
	STA NARG2       ;putting a fixnum 360 in
	LDA #$01        ;NARG2
	STA NARG2+1
	LDA #$00
	STA NARG2+2
	STA NARG2+3
	JSR IMULT       ;fixnum multiply, TEMPN := NARG1*NARG2
	LDY #TEMPN
	JSR XYTON1      ;NARG1 := TEMPN
	JSR FLOTN1      ;floating-pointify NARG1
	LDY #TEMPN2
	JSR XYTON2      ;original arg in NARG2
	JSR SWAP
	JMP FSUB
.PAGE
GFADD:	LDX #$03        ;floating add of NARG2 and NARG1,
GAFAD1:	LDA NARG2,X     ;save NARG2
	PHA
	DEX
	BPL GAFAD1
	JSR FADD
	LDX #$FC
GAFAD2:	PLA
	STA NARG2+4,X
	INX
	BMI GAFAD2
	RTS

GFSUB:	LDX #$03        ;floating point sub of NARG2 and NARG1,
GAFSB1:	LDA NARG2,X     ;save NARG2
	PHA
	DEX
	BPL GAFSB1
	JSR FSUB
	LDX #$FC
GAFSB2:	PLA
	STA NARG2+4,X
	INX
	BMI GAFSB2
	RTS
.PAGE
.SBTTL	Screen Editor
;Routine to tell the editor that its buffer's been clobbered.
NOEDBF:	LDA #EDBUF&$FF	;Buffer is not retrievable
	STA ENDBUF
	LDA #EDBUF^
	STA ENDBUF+1
	RTS
;increment the point (EPOINT,EPOINT+1).

INCPNT:	INC EPOINT
	BNE INCPT2
	INC EPOINT+1
INCPT2:	RTS

;decrement the point.

DECPNT:	LDA EPOINT
	SEC
	SBC #$01
	STA EPOINT
	BCS DECPT2
	DEC EPOINT+1
DECPT2:	RTS

;set the point to the beginning of the buffer.

PNTBEG:	LDA #EDBUF&$FF
	STA EPOINT
	LDA #EDBUF^
	STA EPOINT+1
	RTS

;place cursor at top of screen

TOPSCR:	LDA #$00	;cursor at top of screen
	STA BASLIN	;baseline for top of screen
	STA CH
	STA CV
	LDA #$04
	STA BASLIN+1
	RTS

;output char in AC to EDBUF at point. Increments point. Does NOT
;increment last-char-in-buffer pointer. Returns without modifying if
;at end of buffer.

EDOUT:	TAX		;save char
	STY YSAV1
	LDA EPOINT+1
	CMP #EBFEND^
	BCC EDOUT1
	BNE EDORTS
	LDA EPOINT
	CMP #EBFEND&$FF	;Are we at end of edit buffer...
	BCS EDORTS	;if so, quit
EDOUT1:	LDY #$00
	TXA
	STA (EPOINT),Y	;if not, store char and inc pointer
	JSR INCPNT
EDORTS:	LDY YSAV1
NULOUT:	RTS

.PAGE
;top level loop in the editor; listens for characters; outputs them to
;the screen and the edit buffer; accepts commands and has them
;processed.

CHGLOP:	JSR RDKEY	;get char from kbd
	STA A2L		;save it
	LDA #CHGLOP-1^	;push return address
	PHA
	LDA #CHGLOP-1&$FF
	PHA
	LDY #$00
EDSLOP:	LDA EDSTBL,Y	;dispatch off command table
	BEQ EDSLOS	;0 signifies end of table
	CMP A2L
	BEQ EDSWIN
	INY
	INY		;go for next entry
	INY
	BNE EDSLOP	;always, unless table is too big
EDSWIN:	INY
	LDA EDSTBL,Y
	STA A2L
	INY
	LDA EDSTBL,Y
	STA A2H
	JMP (A2L)

EDSTBL:	$02
.ADDR	PRVSCR
	$03
.ADDR	EDDONE
	$04
.ADDR	DELETE
	$06
.ADDR	NXTSCR
	$07
.ADDR	EDQUIT
	$08
.ADDR	BCKCHR
	$0C
.ADDR	CENTER
	$0D
.ADDR	DINSRT
	$0E
.ADDR	NXTLIN
	$0F
.ADDR	OPLINE
	$10
.ADDR	PRVLIN
	$15
.ADDR	FORCHR
	$1B
.ADDR	RUBOUT
	$00

EDSLOS:	LDA A2L
	CMP #$20	;lowest legal character
	BCS DINSR2	;not a command, insert it.
	JMP BELL
DINSRT:	LDA #$0D	;A2L is bashed by now; so get a CR in AC.
DINSR2:	JMP INSERT

EDQUIT:	PLA
	PLA		;get CHGLOP return addr off stack
	JSR RESETT
	JMP ERDBK1

;EDDONE will read the editor-defined code back into Logo.

EDDONE:	PLA
	PLA		;get CHGLOP return addr off stack
	LDY #$00
	LDA #$0D	;Carriage return at end, just in case none there
	STA (ENDBUF),Y
	INC ENDBUF
	BNE EDDON2
	INC ENDBUF+1
EDDON2:	LDX #ERDBK1&$FF
	LDY #ERDBK1^
	JSR PUSH	;Return address from SREAD2
	JSR PNTBEG	;point to beginning
	JSR RESETT	;Clear the output device
	INC INPFLG
	LDX #WAITM&$FF
	LDY #WAITM^
	JSR PRTSTR
	JMP EVLBUF

ERDBK1:	JSR RSTIO
	JMP POPJ

;this function will display the buffer beginning at the point on the
;screen, beginning at CH, CV (should be consistent with BASLIN). It
;will stop if there is nothing more in the buffer, or when there is no
;more room on the screen. Updates SLSTCH (last-char-displayed
;pointer). EDSPBF will check as it displays for the point and will set
;CV, CH accordingly. If you would like it to turn on the cursor at a
;place other than the point, set A4L,A4H to it and call EDPBUF.

EDSPBF:	LDA EPOINT
	STA A4L
	LDA EPOINT+1
	STA A4H
EDPBUF:	LDA CV
	STA A2L
	LDA CH
	STA A2H
EDSPLP:	LDA EPOINT+1
	CMP ENDBUF+1
	BCC EDSPB1
	BNE EDPRTS
	LDA EPOINT
	CMP ENDBUF
	BCS EDPRTS	;quit if no more in buffer
EDSPB1:	LDY #$00
	LDA (EPOINT),Y	;get char
	CMP #$0D	;#$0D = CR
	BEQ EDSPCR
	LDX CH
	INX
	CPX WNDWTH	;if at end of line and next char is a
	BCC EDPCHR	;cr, then no !. otherwise yes.
	PHA
	LDA #'!
	JSR COUT	;output continuation line char
	PLA
	LDX CV		;when we output the continuation char COUT
	JMP EDPCR1	;inc'ed CV, so don't now.
EDOPCR:	LDX CV
	INX		;if we output the CR (or char on next line),
EDPCR1:	CPX WNDBTM	;will we have exceeded the screen length...
	BCS EDPRTS	;yes, quit while we're not ahead
EDPCHR:	LDX EPOINT
	CPX A4L
	BNE EDPCH2
	LDX EPOINT+1	;if we're at point then set CV, CH so we can
	CPX A4H		;display the cursor in the right place when
	BNE EDPCH2	;we come back
	LDX CV
	STX A2L
	LDX CH
	STX A2H
EDPCH2:	JSR COUT	;output char; back for more
	JSR INCPNT
	JMP EDSPLP
EDSPCR:	PHA
	JSR CLREOL
	PLA
	JMP EDOPCR
EDPRTS:	JSR CLREOP
	LDX EPOINT
	CPX A4L
	BNE EDPRS2
	LDX EPOINT+1	;if we're at point then set CV, CH so we can
	CPX A4H		;display the cursor in the right place when
	BNE EDPRS2	;we come back
	LDX CV
	STX A2L
	LDX CH
	STX A2H
EDPRS2:	LDY #$00
	LDA (EPOINT),Y
	CMP #$0D	;if it was a CR then it was displayed even if
	BNE EDPRS3	;we couldn't COUT it, so INCPNT so SLSTCH is
	JSR INCPNT	;correct.
EDPRS3:	LDA EPOINT	;point is now at location after last char on
	STA SLSTCH	;screen; store in char-after-last-char-pointer
	LDA EPOINT+1
	STA SLSTCH+1
	LDA A2H
	STA CH
	LDA A2L
	STA CV
	JSR BCALCA	;have CV in AC already
	LDA A4L
	STA EPOINT
	LDA A4H
	STA EPOINT+1
	RTS

.PAGE
SEDIT:	LDA #$00
	STA NPARTS	;tell music it doesn't have the buffer anymore.
	LDA GRPHCS
	BEQ CHGSTP
	JSR RESETT	;Nodisplay, get the text page back
CHGSTP:	LDA INPFLG
	BNE ERXETL	;Error if already editing with CHANGE
CHGST1:	LDA TOKPTR+1
	BEQ CHGNON
	LDY #$00
	LDA (TOKPTR),Y
	STA ARG1
	INY
	LDA (TOKPTR),Y
	STA ARG1+1
	LDX #ARG1
	JSR GETTYP
	CMP #SATOM
	BEQ CHGSR4
	CMP #ATOM
	BNE CHGSR5
	LDX #ARG1
	LDA #TEMPN1
	JSR GETFUN
	LDA TEMPN1+1
	BEQ CHGNEW
CHGOLD:	JSR CHGIN1
	INC OTPFLG	;Indicate print-to-buffer
	LDX #$01
	LDA #ARG1
	JSR POFUN	;store function text in EDBUF
	DEC OTPFLG
	JSR CHGIN2
	JMP CHGIN3
ERXETL:	LDY #CURTOK
	LDA #XETL
	JMP ERROR
CHGSR4:	JMP ERXUBL
CHGSR5:	JMP ERXWT1

CHGNON:	LDA ENDBUF
	CMP #EDBUF&$FF
	BNE SCHG1
	LDA ENDBUF+1
	CMP #EDBUF^
	BNE SCHG1
	JSR CHGIN1	;Unretrievable, start with empty buffer
	JSR CHGIN2
	JMP CHGIN3
SCHG1:	JSR CHGX1
CHGIN3:	JSR EDSPBF	;call edit-display-buffer
	JMP CHGLOP	;call text and command handling loop

CHGNEW:	JSR CHGIN1
	INC OTPFLG
	LDX #TOMSG&$FF
	LDY #TOMSG^
	JSR PRTSTR
	LDX #ARG1
	LDA #$01
	JSR LTYPE
CHGNLP:	LDX #TOKPTR
	JSR TFKADV
	LDA TOKPTR+1
	BEQ CHGN2
	LDY #$00
	LDA (TOKPTR),Y
	STA ARG1
	INY
	LDA (TOKPTR),Y
	STA ARG1+1
	LDA #$20
	JSR TPCHR
	LDA #$00
	LDX #ARG1
	JSR LTYPE
	JMP CHGNLP
CHGN2:	JSR BREAK1
	LDA EPOINT
	STA A4L
	LDA EPOINT+1
	STA A4H
	JSR CHGIN2
	JSR EDPBUF
	JMP CHGLOP

CHGIN2:	JSR SETVID	;make output device be screen again
	LDA EPOINT
	STA ENDBUF	;save end of buffer
	LDA EPOINT+1
	STA ENDBUF+1
CHGX1:	JSR PNTBEG
	LDA #$17	;Window bottom to allow display of
	STA WNDBTM	;"Apple Logo Editor" crock
	LDA #EDBUF^	;store location of first char displayed
	STA SFSTCH+1	;on screen (at beginning of buffer)
	LDA #EDBUF&$FF
	STA SFSTCH
	JSR TOPSCR
	JMP CHGNYM	;print editor name

CHGIN1:	LDA #EDOUT&$FF	;location of edbuf output
	STA OTPDEV
	LDA #EDOUT^	;routine (for TPCHR)
	STA OTPDEV+1
	INC INPFLG
	JMP PNTBEG	;initialize point for INSERT

CHGNYM:	LDA INVFLG
	PHA		;Save old INVFLG
	JSR SETINV	;print the "Apple Logo Screen Editor" thing on
	LDA CH		;the bottom line in reversed characters.
	PHA
	LDA CV		;save current screen location
	PHA
	LDA BASLIN	;save old baseline
	PHA
	LDA BASLIN+1
	PHA
	LDA #$00
	STA CH		;far left
	LDA #$23
	STA CV		;bottom of screen
	LDA #$D0	;slight speed bum -- we know we want
	STA BASLIN	;the bottom of the screen, so instead
	LDA #$07	;of calculating it via BCALC, we load
	STA BASLIN+1	;it up.
	LDX #CHGMSG&$FF
	LDY #CHGMSG^
	JSR PRTSTR
	PLA
	STA BASLIN+1
	PLA
	STA BASLIN
	PLA
	STA CV
	PLA
	STA CH
	PLA
	STA INVFLG	;Restore previous INVFLG
	RTS
.PAGE
;Command subroutines. It is the responsibility of a command to do its
;own redisplay, leave CH and CV indicating the position of the point
;on the screen, and the appropriate value in BASLIN before returning
;to CHGLOP. The cursor will be turned on by CHGLOP, however.
;Any command (that does anything) must update the database. The
;database consists of the edit buffer (EDBUF), whose contents must be
;updated by insertions/deletions; the point (EPOINT,EPOINT+1); the
;location in the EDBUF of the first character displayed on the screen
;(SFSTCH,SFSTCH+1); the location in the EDBUF AFTER the last character
;displayed on the screen (SLSTCH,SLSTCH+1), and the location AFTER
;the last character in the EDBUF (ENDBUF,ENDBUF+1).

INSERT:	PHA		;save char
	JSR MVDOWN	;move the buffer (starting at point) down one.
	PLA
	PHA
	JSR EDOUT	;put the char in the edit buffer
	PLA
	CMP #$0D
	BEQ INSRCR
	LDX CH
	INX
	CPX WNDWTH	;Are we at end of line...
	BCC INSRT2	;no, output straight
	PHA
	LDA #'!		;output a line continuation char.
	JSR COUT
	PLA		;recover char
	LDX CV		;if we output the line cont. char then COUT
	JMP INSRT0	;has inc'ed CV, so don't do it again.
INSRT1:	LDX CV
	INX
INSRT0:	CPX WNDBTM	;are we at end of screen...
	BNE INSRT2
	PHA		;yes, redisplay instead of EDSPBF
	JSR CENTER	;^L type redisplay
	PLA
INSRTS:	RTS
INSRT2:	JSR COUT	;output char to screen
	JMP EDSPBF	;redisplay buffer from point down
INSRCR:	PHA
	JSR CLREOL
	PLA
	JMP INSRT1

;move the contents of the edit buffer after point down one until
;reaching end of buffer contents (NOT end of buffer). Increments end
;of buffer contents pointer. Bashes AC,Y.

MVDOWN:	LDA ENDBUF
	SEC
	SBC #$01
	STA A1L
	LDA ENDBUF+1
	SBC #$00
	STA A1H
	LDY #$01
MVLOOP:	LDA A1H
	CMP EPOINT+1
	BCC MVRTS
	BNE MVCONT
	LDA A1L
	CMP EPOINT
	BCC MVRTS
MVCONT:	DEY
	LDA (A1L),Y
	INY
	STA (A1L),Y
	LDA A1L
	SEC
	SBC #$01
	STA A1L
	BCS MVLOOP
	DEC A1H
	BCC MVLOOP	;(Always)
MVRTS:	INC ENDBUF
	BNE MVRTS1
	INC ENDBUF+1
MVRTS1:	RTS

;RDSPNT repositions the text on the screen around the point. The AC
;should hold the number of lines before the point one wants redisplay
;to start from. So, for ^L it should hold 12; for M-V it should hold
;23. RDSPNT will get confused if given a buffer that contains more
;than 256*39 contiguous chars without a carriage-return in them,
;because we have a one-bite physical line counter. You change it. Sets
;first and last char on screen pointers.

RDSPNT:	STA A1H		;store the number of lines one wants before
	LDY #$00	;point on screen
	STY A1L		;zero char-counter
	STY A2L 	;zero line-counter
	LDA EPOINT+1
	STA A4H		;save for recovery by EDPBUF
	LDA EPOINT
	STA A4L
	SEC
	SBC CH		;get to beginning of screen line
	STA EPOINT
	BCS RDSPT2
	DEC EPOINT+1
RDSPT2:	JSR DECPNT
	LDA #EDBUF^
	CMP EPOINT+1
	BCC RDSPT3	;if EDBUF is less than point, you're in
	LDA #EDBUF&$FF	;buffer, otherwise at beginning or before
	CMP EPOINT	;if at beginning or before (horrors) quit
	BCC RDSPT3	;else continue
	JSR PNTBEG
	JMP COUNTM
RDSPT3:	LDA (EPOINT),Y
	CMP #$0D	;CR
	BEQ COUNTM	;if so, see if we have enough lines now
	INC A1L		;else bump char counter
	LDA A1L
	CMP #$27	;do we have a full line...
	BNE RDSPT2	;no, go back for more
COUNTM:	STY A1L		;zero char counter
	INC A2L		;bump line counter
	LDA A2L		;lines gotten
	CMP A1H		;lines wanted
	BEQ REDISP	;if same, we done won, go redisplay.
	BCS CNTDWN
	LDA EPOINT+1
	CMP #EDBUF^
	BNE RDSPT2	;if too few and at beginning of buffer,
	LDA EPOINT
	CMP #EDBUF&$FF	;redisplay anyway
	BEQ REDISP
	BNE RDSPT2	;else go for more
CNTDWN:	LDA A2L		;faster than a multiply, usually
	SEC
	SBC A1H		;# of extra lines
	STA A3L
CNTLOP:	LDA EPOINT
	CLC
	ADC #$27	;move down a screen line of chars
	BCC CNTLP2
	INC EPOINT+1
CNTLP2:	LDA A3L
	SEC
	SBC #$01	;dec line counter
	STA A3L
	BNE CNTLOP	;go for more if not zero
REDISP:	JSR TOPSCR	;physical cursor at top of screen
	LDA EPOINT
	STA SFSTCH	;make first-char-on-screen point
	LDA EPOINT+1
	STA SFSTCH+1
	JMP EDPBUF	;redisplay and restore point

;redisplay screen around point. Sets CV, CH, BASLIN,
;first-char-on-screen, char-after-last-char-on-screen.
CENTER:	LDA #$0C	;#$0C = 12.
	JMP RDSPNT	;redisplay for point on 13th line

;NXTSCR moves to the next screenful in the buffer and displays it,
;setting point to the character after the last char on the previous
;screenful (thus it will be at top of screen).

NXTSCR:	LDA SLSTCH+1
	CMP ENDBUF+1
	BNE NXTSC2
	LDA SLSTCH
	CMP ENDBUF
	BEQ RCMPLN	;complain if no next screen
NXTSC2:	LDA SLSTCH
	STA EPOINT	;point
	STA SFSTCH	;first char on screen
	LDA SLSTCH+1
	STA EPOINT+1
	STA SFSTCH+1
	JSR TOPSCR
	JMP EDSPBF	;display

;PRVSCR moves to the previous screenful in the buffer, leaves point at
;the top.

PRVSCR:	LDA SFSTCH
	STA EPOINT	;make point be beginning of screen
	LDA SFSTCH+1
	STA EPOINT+1
	LDA #$17	;redisplay 23 lines before it
	JSR RDSPNT
	LDA SFSTCH
	STA EPOINT	;make point be beginning of screen
	LDA SFSTCH+1
	STA EPOINT+1
	JMP TOPSCR	;cursor at top of screen

;RUBOUT deletes char behind cursor, redisplays.
RUBOUT:	LDA EPOINT+1
	CMP #EDBUF^
	BCC RCMPLN	;are we before or at beginning...
	BNE RUBOT2
	LDA #EDBUF&$FF	;I know the switch is unorthodox, sorry
	CMP EPOINT
	BCS RCMPLN
RUBOT2:	JSR BCKCHR
	JMP DELET2
RCMPLN:	JMP BELL	;complain if so.

;DELETE deletes char under cursor, redisplays.
DELETE:	LDA ENDBUF+1
	CMP EPOINT+1
	BCC RCMPLN	;if at buffer end, complain
	BNE DELET2
	LDA EPOINT
	CMP ENDBUF
	BCS RCMPLN
DELET2:	LDA #$01	;only moving stuff up one place
	STA A1L
	LDA #$00
	STA A1H
	LDA #A1L&$FF
	JSR MOVEUP
	JMP EDSPBF

;MOVEUP takes the location of an arg in AC,Y and moves the argth char
;after the point into the point, the arg+1th into the point+1, and so
;on until the buffer end is reached. Then it sets the end of buffer
;pointer to the point before restoring it. Better make plenty damned
;sure that MOVEUP is used carefully so that end-of-buffer-pointer
;doesn't become too small.
MOVEUP:	TAX
	LDA EPOINT	;we are saving point to restore it later
	PHA
	STA TEMPX3	;in TEMPX3 for source
	LDA EPOINT+1
	PHA
	STA TEMPX3+1
	LDA $00,X
	CLC
	ADC TEMPX3	;and add to point for source address
	STA TEMPX3
	LDA $01,X
	ADC TEMPX3+1
	STA TEMPX3+1
MVULOP:	LDA TEMPX3+1
	CMP ENDBUF+1	;are we looking at end-of-buffer...
	BCC MVULP2	;no, continue
	BNE MVURTS	;past, return
	LDA TEMPX3
	CMP ENDBUF
	BCS MVURTS	;past or end, return
MVULP2:	LDY #$00
	LDA (TEMPX3),Y	;source
	STA (EPOINT),Y	;dest
	JSR INCPNT	;inc dest
	INC TEMPX3	;inc source
	BNE MVULOP
	INC TEMPX3+1
	JMP MVULOP
MVURTS:	LDA EPOINT
	STA ENDBUF	;new end-of-buffer
	LDA EPOINT+1
	STA ENDBUF+1
	PLA
	STA EPOINT+1
	PLA
	STA EPOINT	;recover point
	RTS		;that's all, folks

;FORCHR moves forward one character, bells if at end of buffer.
FORCHR: LDA EPOINT+1
	CMP ENDBUF+1
	BCC FORCH2	;if at buffer end complain
	BNE FCMPLN
	LDA EPOINT
	CMP ENDBUF
	BCS FCMPLN
FORCH2:	LDA SLSTCH	;!!**CROCK**!! THIS CAUSES REDISPLAY WHEN
	SEC		;YOU TRY FORWARD ON NEXT TO LAST CHAR IN
	SBC #$01	;BUFFER!!! SHOULD CHECK CV,CH OR (EPOINT).
	STA A3L		;see if on last char on screen
	LDA SLSTCH+1
	SBC #$00
	STA A3H
	CMP EPOINT+1
	BNE FORCH3
	LDA A3L
	CMP EPOINT
	BNE FORCH3
	JSR INCPNT	;yes, inc point and center
	JMP CENTER
FCMPLN:	JMP BELL
FORCH3:	LDY #$00
	LDA (EPOINT),Y
	CMP #$0D
	BNE FORCH5
FORCH4:	STY CH		;if on a CR, we know we're not at end of
	INC CV		;screen by now, so zero CH, inc CV.
	JSR BCALC	;must calc new baseline
	JMP INCPNT
FORCH5:	LDA CH
	CMP #$26	;at right before "!"
	BEQ FORCH4
	INC CH
	JMP INCPNT
.PAGE
;BCKCHR backs CH and CV up, decs point. No redisplay, unless page
;boundary crossed, or previous char is a CR. Don't call it unless the
;database is consistent; i.e., CV and CH are at the point on the
;screen.
BCKCHR:	LDA #EDBUF^	;check if at beginning of buffer
	CMP EPOINT+1
	BCC BACK2	;no, win
	BNE FCMPLN	;yes, complain, quit
	LDA #EDBUF&$FF
	CMP EPOINT
	BCS FCMPLN
BACK2:	JSR DECPNT
	LDA CV		;see if we're at beginning of screen
	BNE BACK3
	LDA CH
	BNE BACK3
	JMP CENTER	;center
BACK3:	LDA CH
	BNE BACK5
	LDY #$00
	LDA (EPOINT),Y
	CMP #$0D	;#$0D = CR
	BNE BACK4
	LDA EPOINT
	STA A4L		;when we back over a cr we call
	LDA EPOINT+1	;EDPBUF so as to save space (by
	STA A4H		;not having code here to count down a
	LDA SFSTCH	;line)
	STA EPOINT
	LDA SFSTCH+1
	STA EPOINT+1
	JSR TOPSCR
	JMP EDPBUF	;don't need redisplay, space bum
BACK4:	DEC CV
	LDA #$26	;just before the "!"
	STA CH
	JSR BCALC
	RTS
BACK5:	DEC CH
	RTS
.PAGE
;algorithm for previous line: search back for a CR, counting chars. if
;you hit bob, complain. got it? save its addr, as well as offset.
;search back for another one, or bob. add last offset to this addr. gt
;than other addr? good, make other addr current. if not, make this
;addr current. redisplay point to turn on cursor, or RDSPNT if off
;screen.

PRVLIN:	LDY #$00
	STY A2L
	STY A2H		;A2 is char counter.
	LDA EPOINT
	STA A4L
	LDA EPOINT+1
	STA A4H
	JSR SRCHBK
	CMP #$0D
	BNE PCMPLN	;PCMPLN recovers point from A4 and complains
	LDA A2L
	STA NARG2	;saving offset into line in NARG2
	LDA A2H
	STA NARG2+1
	LDA EPOINT
	STA NARG2+2	;saving beginning of line in NARG2+2
	LDA EPOINT+1
	STA NARG2+3
	JSR DECPNT      ;do a DECPNT to get on previous line
	JSR SRCHBK
	LDA EPOINT
	CLC
	ADC NARG2
	STA NARG2
	LDA EPOINT+1
	ADC NARG2+1	;have beginning of prev line + offset of
	STA NARG2+1	;this'n in NARG2
	CMP NARG2+3	;compare to beginning of this line
	BCC PRVLN2	;strictly less than, use NARG2
	BNE PRVLN3	;gt or =, use NARG2+2-1
	LDA NARG2
	CMP NARG2+2
	BCC PRVLN2	;less, use NARG2
PRVLN3:	LDA NARG2+2
	SEC
	SBC #$01
	STA A4L
	LDA NARG2+3
	SBC #$00
	STA A4H		;for recovery by EDPBUF
	JMP PVRDSP
PRVLN2:	LDA NARG2
	STA A4L
	LDA NARG2+1
	STA A4H
PVRDSP:	LDA A4H
	CMP SFSTCH+1	;before first char on screen?
	BCC PRDSPT	;yo, RDSPNT
	BNE PVRDS2	;no, normal
	LDA A4L
	CMP SFSTCH
	BCC PRDSPT
PVRDS2:	JSR TOPSCR
	LDA SFSTCH
	STA EPOINT
	LDA SFSTCH+1
	STA EPOINT+1
	JMP EDPBUF
PRDSPT:	LDA A4L
	STA EPOINT
	LDA A4H
	STA EPOINT+1
	JMP CENTER
PCMPLN:	LDA A4L
	STA EPOINT
	LDA A4H
	STA EPOINT+1
	JMP BELL

;SRCHBK returns with a CR in AC if found CR; with 0 in AC if found
;bob. Incs A2L as it goes so it can be used as a counter.
;does right thing (this is a kludge) if on a CR initially - ignores
;it, but counts it.

SRCHBK:	LDY #$00
SRCBK1:	LDA EPOINT
	CMP #EDBUF&$FF
	BNE SRCBK2
	LDA EPOINT+1
	CMP #EDBUF^
	BEQ SRCBK4
SRCBK2:	JSR DECPNT
	INC A2L
	BNE SRCBK3
	INC A2H
SRCBK3:	LDA (EPOINT),Y
	CMP #$0D	;got a CR?
	BEQ SRCBK5	;y, done
	LDA EPOINT
	CMP #EDBUF&$FF	;at bob?
	BNE SRCBK2	;no, loop
	LDA EPOINT+1
	CMP #EDBUF^
	BNE SRCBK2
SRCBK4:	TYA		;y, done
	RTS
SRCBK5:	JSR INCPNT
	LDA A2L
	SEC
	SBC #$01
	STA A2L
	LDA A2H
	SBC #$00
	STA A2H		;gross shit necessary due to asymmetry
	LDA #$0D
	RTS
.PAGE
;algorithm for NXTLIN is as follows: get offset to beginning of your
;current line, and save in, say, TEMPN8. try to find a CR, if you win,
;save it in NARG2. If you run into eob, complain. If you find a CR,
;try to find another or eob. Save the address of either in TEMPN7. Add
;NARG2 + 1 to TEMPN8 and save in TEMPN8. If TEMPN8 is less than end of
;next line, i.e., TEMPN7, make point TEMPN8, otherwise make point
;TEMPN7.

NXTLIN:	LDY #$00
	STY A2L
	STY A2H         ;zero char counter
	LDA EPOINT
	STA A4L         ;for recovery in the event of disaster
	LDA EPOINT+1
	STA A4H
	JSR SRCHBK      ;get offset to beginning of this line in A2
	LDA A2L
	STA TEMPN8      ;save
	LDA A2H
	STA TEMPN8+1
	JSR SRCHFD      ;try to find a CR
	CMP #$0D
	BNE NCMPLN      ;complain if none
	LDA EPOINT
	STA NARG2
	LDA EPOINT+1
	STA NARG2+1     ;save location of end of current line
	JSR INCPNT      ;inc point to get onto beginning of next line
	JSR SRCHFD
	LDA EPOINT
	STA TEMPN7
	LDA EPOINT+1
	STA TEMPN7+1
	LDA NARG2
	CLC
	ADC #$01
	STA NARG2       ;get beginning of next line in NARG2
	LDA NARG2+1
	ADC #$00
	STA NARG2+1
	LDA NARG2
	CLC
	ADC TEMPN8      ;add offset to beginning of next line
	STA TEMPN8
	LDA NARG2+1
	ADC TEMPN8+1
	STA TEMPN8+1
	CMP TEMPN7+1    ;is beginning of next line + offset <
	BCC NXTLN2      ;end of next line? y, use first
	BNE NXTLN3      ;n, use end of next
	LDA TEMPN8
	CMP TEMPN7
	BCC NXTLN2
NXTLN3:	LDA TEMPN7
	STA A4L
	LDA TEMPN7+1
	STA A4H
	JMP NXRDSP
NXTLN2:	LDA TEMPN8
	STA A4L
	LDA TEMPN8+1
	STA A4H
NXRDSP:	LDA A4H
	CMP SLSTCH+1    ;this makes redisplay occur sometimes when it
	BCC NXRDS2      ;doesn't have to. too bad. vanilla if on
                        ;screen.
	BNE NRDSPT      ;else redisplay
	LDA A4L
	CMP SLSTCH
	BCS NRDSPT
NXRDS2:	JSR TOPSCR
	LDA SFSTCH
	STA EPOINT
	LDA SFSTCH+1
	STA EPOINT+1
	JMP EDPBUF
NRDSPT:	LDA A4L
	STA EPOINT
	LDA A4H
	STA EPOINT+1
	JMP CENTER
NCMPLN:	LDA A4L
	STA EPOINT
	LDA A4H
	STA EPOINT+1
	JMP BELL

;SRCHFD returns with a CR in AC if found CR; with 0 in AC if found
;eob.

SRCHFD:	LDY #$00
SRCHF1:	LDA EPOINT
	CMP ENDBUF
	BNE SRCHF2
	LDA EPOINT+1
	CMP ENDBUF+1
	BEQ SRCHF3
SRCHF2:	LDA (EPOINT),Y
	CMP #$0D
	BEQ SRCHF4      ;found a CR, return
	JSR INCPNT
	JMP SRCHF1
SRCHF3:	TYA
	RTS
SRCHF4:	RTS
.PAGE
;OPLINE inserts a CR at point w/o inc'ing point.
OPLINE:	LDA EPOINT+1
	CMP #EBFEND^
	BCC OPLIN1
	BNE OPLRTS
	LDA EPOINT
	CMP #EBFEND&$FF	;Are we at end of edit buffer...
	BCS OPLRTS	;if so, quit
OPLIN1:	JSR MVDOWN
	LDY #$00
	LDA #$0D
	STA (EPOINT),Y	;insert CR at point
	JMP EDSPBF	;redisplay from here down.
OPLRTS:	RTS
.PAGE
.SBTTL	File System
;DOS error routine comes here
DERROR:	TXA		;Error code is in X from DOS
	PHA		;Save DOS error code on stack
	LDA GETRM1	;Re-enable high RAM
	LDA GETRM1
	JSR RSTIO
	PLA		;Get DOS error code from stack
	AND #$0F	;Only bottom four bits matter
	TAX
	LDA DSRTBL,X	;Get error code
	JMP ERROR

;set up magic things for DOS
DOSSTP:	LDA #$40	;magic number for Applesoft
	STA DLNGFG	;store in DOS language flag
	LDA #$00
	STA DOSFL2	;store things not = to $FF
	STA DOSFL1	;or apple val for ], in these, respectively.
	LDA #$80	;this sets up error return from DOS.
	STA DOSERR
	LDA #DERROR&$FF
	STA DSERET
	LDA #DERROR^
	STA DSERET+1
	LDA #APOUT&$FF	;store APOUT in OTPDEV so DOS prints properly
	STA OTPDEV
	LDA #APOUT^
	STA OTPDEV+1
	LDA KILRAM	;Enable Monitor ROM in case DOS wants it
	JSR DOSEAT	;let DOS eat these
	LDA GETRM1	;Re-enable high RAM
	LDA GETRM1
RSTR:	RTS
.PAGE
DTPATM:	LDA ARG1
	AND #$FC
	STA ARG1
	LDX #ARG1
	LDY #TEMPN5
	JSR GETPNM
DTPTMW:	LDA TEMPN5+1
	BEQ RSTR
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPNH
	INY
	LDA (TEMPN5),Y
	STA TEMPNH+1
	INY
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	LDA TEMPNH
	BEQ RSTR
	ORA #$80
	JSR TPCHR
	LDA TEMPNH+1
	BEQ RSTR
	ORA #$80
	JSR TPCHR
	JMP DTPTMW

DPRLEN:	SEC
	LDA ENDBUF
	SBC #EDBUF&$FF
	STA TEMPN
	LDA ENDBUF+1
	SBC #EDBUF^
	STA TEMPN+1
	JSR DPR2HX
	LDA TEMPN
DPR2HX:	PHA
 	LSR A
	LSR A
	LSR A
	LSR A
	JSR DPRHXZ
	PLA
DPRHEX:	AND #$0F
DPRHXZ:	ORA #$B0
	CMP #$BA
	BCC DPRH1
	ADC #$06
DPRH1:	JMP TPCHR
.PAGE
SREAD:	LDA INPFLG
	BNE SAVSR1	;Can't do if in read-eval loop
	LDA GRPHCS
	BEQ SRDF1
	JSR RESETT
SRDF1:	LDA #$00
	STA NPARTS	;music buffer clobbered.
	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BEQ SRDF2
	CMP #SATOM
	BEQ SRDF2
	CMP #STRING
	BNE SAVSR3
SRDF2:	JSR DOSSTP
	LDX #LOADM&$FF
	LDY #LOADM^
	JSR PRTSTR
	JSR DTPATM	;Type atom DOS-style
	LDX #LOGOM&$FF
	LDY #LOGOM^
	JSR PRTSTR
	LDA KILRAM	;Enable ROM for DOS
	LDA #$8D
	JSR TPCHR
	LDA GETRM1	;Re-enable high RAM
	LDA GETRM1
	JSR RSTIO	;Detaches DOS
	CLC
	LDA FILLEN
	ADC #EDBUF&$FF
	STA ENDBUF	;recover buffer length from file length
	LDA FILLEN+1
	ADC #EDBUF^
	STA ENDBUF+1
	JSR PNTBEG	;point to beginning
	INC INPFLG	;Indicate read-eval-loop
	JMP EVLBUF
SAVSR1:	JMP ERXETL	;can't hack files from editor
SAVSR3:	JMP ERXWT1
.PAGE
SSAVE:	LDA INPFLG
	BNE SAVSR1	;Error if editing with ALEC
	LDA GRPHCS
	BEQ SAVST1
	JSR RESETT
SAVST1:	LDA #$00
	STA NPARTS	;music buffer clobbere
	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BEQ SAVST2
	CMP #SATOM
	BEQ SAVST2
	CMP #STRING
	BNE SAVSR3
SAVST2:	LDA ARG1
	PHA		;Save ARG1 for DOS-command string
	LDA ARG1+1
	PHA
	JSR CHGIN1	;output to buffer
	INC OTPFLG	;Indicate print-to-buffer
	JSR POFUNS	;get functions into buffer
	JSR PONAMS	;get variables into buffer
	LDA EPOINT
	STA ENDBUF
	LDA EPOINT+1
	STA ENDBUF+1
	DEC OTPFLG	;End print-to-buffer mode
	JSR DOSSTP	;Wake up DOS
	LDX #SAVEM&$FF
	LDY #SAVEM^
	JSR PRTSTR
	PLA		;Retrieve ARG1 (file name)
	STA ARG1+1
	PLA
	STA ARG1
	JSR DTPATM	;Type atom DOS-style
	LDX #LOGOM&$FF
	LDY #LOGOM^
	JSR PRTSTR
	LDX #SAVEM2&$FF
	LDY #SAVEM2^
	JSR PRTSTR	;write file
	JSR DPRLEN	;Give it file's length
	LDA KILRAM	;Enable ROM for DOS
	LDA #$8D
	JSR TPCHR	;let it go
	LDA GETRM1	;Re-enable high RAM
	LDA GETRM1
	JSR RSTIO	;Detaches DOS
	JSR PNTBEG
	LDA #EDBUF&$FF
	STA ENDBUF
	LDA #EDBUF^
	STA ENDBUF+1	;zero ENDBUF so RETRIEVE not possible
	JMP POPJ
.PAGE
SDELET:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #SATOM
	BEQ SDELT1
	CMP #ATOM
	BEQ SDELT1
	CMP #STRING
	BNE SDELR3
SDELT1:	JSR DOSSTP
	LDX #DELETM&$FF
	LDY #DELETM^
	JSR PRTSTR
	JSR DTPATM	;Type atom DOS-style
	LDX #LOGOM&$FF
	LDY #LOGOM^
	JSR PRTSTR
	LDA KILRAM	;Enable ROM for DOS
	LDA #$8D
	JSR TPCHR
	LDA GETRM1	;Re-enable high RAM
	LDA GETRM1
	JSR RSTIO	;Detaches DOS
	JMP POPJ
SDELR3:	JMP ERXWT1

SCATLG:	JSR DOSSTP
	LDX #CATLGM&$FF
	LDY #CATLGM^
	JSR PRTSTR
	LDA KILRAM	;Enable ROM for DOS
	LDA #$8D
	JSR TPCHR
	LDA GETRM1	;Re-enable high RAM
	LDA GETRM1
	JSR RSTIO	;Detaches DOS
	JMP POPJ
.PAGE
.SBTTL	Monitor Routines
CLRCBF:	LDA CHBUFR	;Buffer empty when next-free equals next-to-read
	STA CHBUFS
	RTS

GTBUF:	SEC
	LDA CHBUFR
	SBC CHBUFS
	AND #$3F
	BEQ GTBRTS	;Return zero if buffer empty (CHBUFR = CHBUFS)
	LDA CHBUFR
	AND #$3F
	TAX
	LDA CHBSTT,X
	INC CHBUFR	;Increment next-to-read
GTBRTS:	RTS

;Reset and clear the screen.
RESETT:	LDA #$00
	STA GRPHCS
	JSR SETTXT
	JSR SETNRM
	JMP HOME

BREAK1:	LDA #$0D
	JMP TPCHR
	;falls through

;TPCHR should always be called with an Ascii character.
;If you want it to flash or be inverted, call SETFLS or SETINV first,
;and call SETNRM when done.
	;falls in
TPCHR:	JMP (OTPDEV)	;(Output routine can't zap X or Y or even A!)
.PAGE
;Reset I/O to default drivers and mode.
RSTIO:	LDA #$00
	STA INPFLG	;Reset from read-eval mode
	STA OTPFLG	;Reset from print-to-buffer mode
	STA PRSFLG	;Do this in case resetting from READLINE state
	JSR SETVID
	;falls through

	;falls in
SETKBD:	LDA #KEYIN&$FF
	STA INPDEV
	LDA #KEYIN^
	STA INPDEV+1
	RTS

SETVID:	LDA #COUT&$FF
	STA OTPDEV
	LDA #COUT^
	STA OTPDEV+1
	RTS

SETFLS:	LDY #$40
	BNE SETIFL	;(Always)
SETINV:	LDY #$00
	BEQ SETIFL	;(Always)
SETNRM:	LDY #$80	;(Negative flag ignored)
SETIFL:	STY INVFLG
	RTS
.PAGE
BELL:	LDA #$40
	JSR WAIT
	LDY #$C0
BELL1:	LDA #$0C
	JSR WAIT
	LDA SPKR
	DEY
	BNE BELL1
BRTS:	RTS

;HOME - Home the cursor and clear the screen
HOME:	LDA WNDTOP
	STA CV
	LDY #$00
	STY CH
	BEQ CLEOP1	;(always branches)

;COUT - Output the character in A to the screen
APOUT:	AND #$7F	;eat Apple idiot char codes, type Ascii
COUT:	PHA
	STY YSAV1
	JSR COUT1
	PLA
	LDY YSAV1
	RTS

;CROUT - Output a Carriage return; suppress output if necessary
CROUT:	JSR CLREOL
	JSR TSTCHR
	BCC CR
	CMP #LSTKEY
	BNE CR
	BIT KBDCLR
	JSR RWAIT
	JMP CR

;CLREOP - Clear to end-of-page
CLREOP:	LDY CH
	LDA CV
CLEOP1:	PHA
	JSR BCALCA
	JSR CLEOL1
	LDY #$00
	PLA
	ADC #$00
	CMP WNDBTM
	BCC CLEOP1
	BCS BCALC	;(Always)
.PAGE
COUT1:	CMP #$0D
	BEQ CROUT
	CMP #$07
	BEQ BELL	;bell on output of ^G
	ORA #$80	;Assume normal first
	CMP #$E0
	BCC COUTZ	;See if it's lower case
	AND #$DF	;Make it uppercase if so
COUTZ:	LDY INVFLG	;Flash or Invert if set
	BMI COUTZ1
	AND #$3F	;Flash or invert - strip top bits
	ORA INVFLG	;and OR in flag
COUTZ1:	LDY CH
	STA (BASLIN),Y
	INC CH		;Advance Horizontally
	LDA CH
	CMP WNDWTH
	BCC BRTS
CR:	LDA #$00
	STA CH
LF:	INC CV
	LDA CV
	CMP WNDBTM
	BCC BCALCA	;Finish if scrolling unnecessary
	DEC CV
SCROLL:	LDA WNDTOP
	PHA
	JSR BCALCA
SCRL1:	LDA BASLIN
	STA BSLTMP
	LDA BASLIN+1
	STA BSLTMP+1
	LDY WNDWTH
	DEY
	PLA
	ADC #$01
	CMP WNDBTM
	BCS SCRL3
	PHA
	JSR BCALCA
SCRL2:	LDA (BASLIN),Y	;Shift a line up one, character by character
	STA (BSLTMP),Y
	DEY
	BPL SCRL2	;Next character
	BMI SCRL1	;Next line
SCRL3:	LDY #$00
	JSR CLEOL1	;Clear the bottom line, then calculate new base
	;falls through
.PAGE
	;falls in
BCALC:	LDA CV
BCALCA:	PHA
	LSR A
	AND #$03
	ORA #$04
	STA BASLIN+1
	PLA
	AND #$18
	BCC BCALC2
	ADC #$7F
BCALC2:	STA BASLIN
	ASL A
	ASL A
	ORA BASLIN
	ADC WNDLFT
	STA BASLIN
	RTS

;CLREOL - Clear to end-of-line
CLREOL:	LDY CH
CLEOL1:	LDA #$A0	;(Space, non-flashing, non-inverted)
CLEOL2:	STA (BASLIN),Y
	INY
	CPY WNDWTH
	BCC CLEOL2
	RTS

RDKEY:	JSR GTBUF	;Get character from the buffer if non-empty
	CMP #$00
	BNE KRTS
	JMP (INPDEV)

KEYIN:	LDY CH
	LDA (BASLIN),Y
	PHA
	AND #$7F
	ORA #$40
	STA (BASLIN),Y	;Make cursor position flash
	JSR RDKEY1
	STA BSLTMP
	PLA
	STA (BASLIN),Y
	LDA BSLTMP
KRTS:	RTS

RDKEY1:	INC RNDL
	BNE RDKEY2
	INC RNDH
RDKEY2:	JSR TSTCHR
	BCC RDKEY1
	BIT KBDCLR
	RTS
.PAGE
;Check for input character. Return with carry set and character in A if
;character pending, else carry clear. Supplies "[" for "M" and $FF for null
;for replacement character.
TSTCHR:	BIT KBDBYT
	BPL KNONE
	LDA KBDBYT
	AND #$7F
	BNE TRTS
	LDA #$FF       ;translation for null character so it can't be typed.
	SEC
	RTS
TRTS:	CMP #LBRAK
	BNE TRTS1
	LDA #'[
TRTS1:	SEC
	RTS
KNONE:	CLC		;Return carry clear if no character
	RTS

;SETTXT - Set text mode
SETTXT:	LDA $C054	;Primary page
	LDA $C051	;Set text mode
	LDA #$00
	STA WNDTOP
	STA WNDLFT
	LDA #$18
	STA WNDBTM
	LDA #$28
	STA WNDWTH
	LDA #$17
	STA CV
	JMP BCALCA
.PAGE
;Gets a line of input from the keyboard. Looks for Logo interrupt
;characters, and recognizes the left-bracket alias character. Returns
;number of characters (not including terminator) in X.
GETLN:	LDX #$00	;X is LINARY index
	JSR RDKEY	;Get an ascii value from keyboard
	CMP #PULCHR	;(Pull back last line), Check at first character
	BNE NPRVLN
PREVLN:	LDA LINARY,X	;get char from line-array
	BEQ GNXTX	;done if null char
	CMP #$0D
	BEQ GNXTX	;or carriage-return encountered
	JSR TPCHR	;output char to screen
	INX		;next char
	BNE PREVLN	;(Always)
NPRVLN:	TAY
	TXA		;If first character, clear line array
GTLN1L:	DEX
	STA LINARY,X
	BNE GTLN1L
	TYA
	BNE GTLN1X	;(Always)
NEXTC:	JSR RDKEY	;Get an ascii value from keyboard
GTLN1X:	CMP #$1B	;(ESC)
	BEQ GRUBOT	;do a getln rubout
	CMP #$04	;(^D)
	BEQ GDELET	;do a getln delete
	CMP #$15	;(Forward arrow)
	BNE GTLN1C
	LDA LINARY,X	;Get character under cursor
	BEQ GTLNX1
	CMP #$0D
	BNE GTLNX2
GTLNX1:	LDA #$20
GTLNX2:	STA LINARY,X
	JSR TPCHR	;Echo character
	CPX #$F8
	BCC GETLN3
	JSR BELL
GETLN3:	INX
	BNE NEXTC
	JMP CANCEL
GRUBOT:	TXA
	BEQ NEXTC
	DEX
	DEC CH
	BPL GDELET
	LDA WNDWTH
	STA CH
	DEC CH
	LDA WNDTOP
	CMP CV
	BCS GDELET
	DEC CV
	JSR BCALC
	JMP GDELET
GTLN1C:	CMP #$08	;(Back arrow)
	BEQ BCKSPC
	JMP GTLN1D
BCKSPC:	TXA
	BEQ NEXTC
	DEX
	DEC CH
	BPL NEXTC
	LDA WNDWTH
	STA CH
	DEC CH
	LDA WNDTOP
	CMP CV
	BCS NEXTC
	DEC CV
	JSR BCALC
GNXTX:	CPX #$00
	BEQ GNXTC
	LDA #$00
	STA LINARY+1,X
GNXTC:	JMP NEXTC
GDELET:	TXA
	PHA		;save location in LINARY
	LDA CH		;and location on screen
	PHA
	LDA CV
	PHA
GDLTLP:	INX		;get next char in LINARY
	LDA LINARY,X
	STA LINARY-1,X	;store in previous location
	BEQ GDLDON	;if null done
	CMP #$0D
	BEQ GDLTLP
	JSR TPCHR	;type out
	JMP GDLTLP
GDLDON:	LDA #$20	;found a null, print a space at line
	JSR TPCHR	;end
	PLA
	STA CV
	PLA
	STA CH
	JSR BCALC
	PLA
	TAX
	JMP NEXTC
CANCEL:	LDA #'\
	JSR TPCHR
	JSR BREAK1
	JMP GETLN
GTLN1D:	CMP #$18	;(Cancel line)
	BEQ CANCEL
	LDY INPFLG
	BNE GTLN2A	;or if evaluating the edit buffer
	CMP #STPKEY
	BEQ GTLNR1
	CMP #PAUSKY
	BEQ GTLNR2
	CMP #FULCHR
	BEQ GTLNR3
	CMP #MIXCHR
	BNE GTLN2A
	JSR STPMIX
	JMP NEXTC
GTLNR3:	JSR STPFUL
	JMP NEXTC
GTLN2A:	LDY LINARY,X
	STA LINARY,X
	CMP #$0D
	BEQ GCR
	JSR TPCHR
	TXA
	PHA		;save location in LINARY
	LDA CH		;and location on screen
	PHA
	LDA CV
	PHA
GINSL1:	LDA LINARY+1,X	;get next location
	PHA		;Save value
	TYA		;Get previous location
	BEQ GINSDN	;if null done
	CMP #$0D
	BEQ GINSDN
	STA LINARY+1,X	;store in next location
	JSR TPCHR	;type out
	PLA
	TAY
	CPX #$F8
	BCC GINSL2
	JSR BELL
GINSL2:	INX
	BNE GINSL1
	JMP CANCEL
GINSDN:	PLA		;Discard null
	PLA
	STA CV
	PLA
	STA CH
	PLA
	TAX
	INX
	JSR BCALC
	JMP NEXTC
GCR:	JMP BREAK1
GTLNR2:	JMP STPPKZ
.PAGE
RWAIT:	JSR RDKEY
	CMP #STPKEY
	BNE WRTS
GTLNR1:	JMP STPPK1

WAIT:	SEC
WAIT1:	PHA
WAIT2:	SBC #$01
	BNE WAIT2
	PLA
	SBC #$01
	BNE WAIT1
WRTS:	RTS

;Break to ROM Monitor
MONBRK:	STA MONACC	;Save A for monitor
	TXA
	PHA
	TYA
	PHA
	LDA KILRAM
	JSR ROMSTN	;Init monitor stuff
	JSR ROMNIT
	JSR ROMSTV	;Reset I/O Drivers
	JSR ROMSTK
	LDA #MONOBK&$FF
	STA MONBKV	;Set Monitor BRK vector
	LDA #MONOBK^
	STA MONBKV+1
	PLA
	TAY
	PLA
	TAX
	JMP ROMMON
.PAGE
.SBTTL	Argument Passing Routines:
;Gets a numerical argument. Returns with carry set if flonum.
GT1NUM:	LDX #NARG1
	JSR VPOP
GT1NMX:	JSR GTNUM1	;Alt. entry
	BCC GTERR1
	CMP #FLO	;(Sets carry if Flonum)
	RTS

;Gets two numerical arguments. Coerces one to Real if not same type.
;Returns with carry set if Flonum results.
GT2NUM:	LDX #TEMPX2
	JSR VPOP
	LDX #NARG1
	JSR VPOP
	JSR GETNUM	;GETNUM returns carry clear if argument non-numerical
	BCC GTERR1
	STA ANSN3	;Save first type
	JSR GTNUM2	;Special GETNUM for NARG2
	BCC GTERR2
	CMP ANSN3
	BNE GT2NM1
	CMP #FLO	;(Sets carry if Flonum)
	RTS
GT2NM1:	CMP #FIX	;Assume ARG1 is the integer
	BNE GT2NM2
	JSR FLOTN2	;Nope, it was NARG2, convert to flt. pt.
	SEC
	RTS
GT2NM2:	JSR FLOTN1	;Convert NARG1 to floating pt.
	SEC
	RTS
GTERR1:	LDY #$00	;ERROR wants a pointer to the
	LDA (VSP),Y	;erroneous argument, not the
	STA ARG1	;number itself, so we get it from the
	INY		;Vpdl position it was in
	LDA (VSP),Y	;(GTERR1 is for values just Vpopped)
	STA ARG1+1
	JMP ERXWT1
GTERR2:	SEC		;(GTERR2 is for values which were the second
	LDA VSP		;Vpopped)
	SBC #$02
	STA TEMPNH
	LDA VSP+1
	SBC #$00
	STA TEMPNH+1
	LDY #$00
	LDA (TEMPNH),Y
	STA ARG1
	INY
	LDA (TEMPNH),Y
	STA ARG1+1
	JMP ERXWT1

;Gets a numerical argument, changes to integer if Real.
GT1FIX:	LDX #NARG1
	JSR VPOP
	JSR GETNUM
	BCC GTERR1
	CMP #FIX
	BEQ GTFXRT
	JMP RNDN1

;Gets two numerical arguments, changes either or both to integer if Real.
GT2FIX:	LDX #TEMPX2
	JSR VPOP
	LDX #NARG1
	JSR VPOP
	JSR GETNUM
	BCC GTERR1
	CMP #FIX
	BEQ GT2FX1
	JSR RNDN1
GT2FX1:	JSR GTNUM2	;Special GETNUM for NARG2
	BCC GTERR2
	CMP #FIX
	BEQ GTFXRT
	JMP RNDN2

CHKINT:	LDA $02,X
	BNE CHKIN2
	LDA $03,X
	BNE CHKNNT
CHKIOK:	CLC
GTFXRT:	RTS
CHKIN2:	CMP #$FF
	BNE CHKNNT
	CMP $03,X
	BEQ CHKIOK
CHKNNT:	SEC
	RTS

;GETNM2 saves NARG1 before calling GETNUM with NARG2, then restores NARG1.

GTNUM2:	LDA TEMPX2
	STA NARG2
	LDA TEMPX2+1
	STA NARG2+1
GTNM2X:	LDY #A3L
	JSR XN1TOY	;Save NARG1
	LDX #NARG2
	JSR GETNUM
	PHA		;Save type
	LDY #A3L
	JSR XYTON1	;Restore NARG1
	PLA		;Get type back
	RTS

;Gets a numerical argument if possible. Returns with carry clear if successful.
;Returns with type of argument (Fix/Flo) in A.
;(Note: ATMTFX destroys previous values of NARG1 and NARG2. Call with NARG1 first,
; then save it, then call with NARG2, then restore NARG1.)

GTNUM1:	LDX #NARG1
GETNUM:	STX ANSN1	;Address of argument
	JSR GETTYP
	LDX ANSN1
	CMP #ATOM
	BEQ ATMTXX
	CMP #STRING
	BEQ ATMTXX
	CMP #FIX
	BEQ GTNM2
	CMP #FLO
	BEQ GTNM2
GTNMNO:	CLC		;Carry clear means argument not OK
	RTS
GTNM2:	PHA		;Save type
	LDA $00,X
	STA TEMPNH
	LDA $01,X
	STA TEMPNH+1
	LDY #$03
GTNML:	LDA (TEMPNH),Y
	STA $03,X
	DEX
	DEY
	BPL GTNML
	PLA		;Retrieve type
	SEC		;Carry set means argument OK
	RTS
.PAGE
;Gets two positive integers. Won't coerce.
GT2PIN:	JSR GT2FIX
	JSR CK1PIN
	LDX #NARG2
	JSR CHKINT
	BCS GT2PN2
	TAX
	BMI GT2PN2
	RTS
GT2PN1:	JMP GTERR1
GT2PN2:	JMP GTERR2

;Gets one positive integer. Won't coerce.
GT1PIN:	JSR GT1FIX
CK1PIN:	LDX #NARG1
	JSR CHKINT
	BCS GT2PN1
	TAX
	BMI GT2PN1
	RTS
.PAGE
;Convert an atom to a Fixnum or Flonum if possible. Sets the carry
;if successful. Returns type of number (Fix/Flo) in A.
;(Note: Destroys previous values of NARG1 and NARG2.)

ATMTFX:	STX ANSN1	;ANSN1 points to argument
ATMTXX:	LDY #TEMPN4	;TEMPN4 becomes PNAME (Entry point for GETNUM)
	JSR GETPNM
	LDA TEMPN4+1
	BEQ GTNMNO
	JSR CNUML0	;Initialize number to 0
	LDY #$01
	LDA (TEMPN4),Y
	STA TEMPN7+1
	DEY
	STY ANSN2	;ANSN2 is SIGN
	LDA (TEMPN4),Y
	STA TEMPN7	;(CAR) a pair of digits to TEMPN7
	CMP #'-
	BNE ATMT3
	INC ANSN2	;ANSN2 is SIGN
	BNE ATMT4A	;(Always)
ATMT3:	JSR GOBDIG
ATMT4:	LDX TEMPN4+1
	BEQ ATMT4E
ATMT4A:	LDY #$02
	LDA (TEMPN4),Y
	TAX
	INY
	LDA (TEMPN4),Y
	STA TEMPN4+1
	STX TEMPN4	;(CDR) PNAME to next two characters
	LDA TEMPN7+1
	BEQ ATMT4
	JSR GOBDIG
	LDX TEMPN4+1
	BEQ ATMT4E
	LDY #$01
	LDA (TEMPN4),Y
	STA TEMPN7+1
	DEY
	LDA (TEMPN4),Y	;(CAR) next two characters
	JSR GOBDIG
	JMP ATMT4
ATMT4E:	JSR CNUML2
	BCC NOTNM2
	PHA		;Save type
	LDX ANSN2
	BEQ ATMT5
	LDX #NARG1
	CMP #FIX	;(Type of number is in A)
	BNE ATMT41
	JSR COMPL
	JMP ATMT5
ATMT41:	JSR FCOMPL
ATMT5:	LDY ANSN1	;ANSN1 is argument pointer
	LDX #$FC
ATMT5L:	LDA NARG1+4,X	;NARG1 is NUMBER
	STA $00,Y
	INY
	INX
	BMI ATMT5L
	PLA		;Retrieve type
	SEC		;Carry set means argument is a number
	RTS

GOBDIG:	JSR CNUML1
	BCS GBDGR
NOTNM1:	PLA		;Return back past ATMTFX
	PLA
NOTNM2:	CLC		;Carry clear means argument non-numeric
GBDGR:	RTS
.PAGE
GTBOOL:	STX ANSN1
	JSR GETTYP
	LDX ANSN1
	CMP #STRING
	BNE GTBOL1
	LDY #TEMPX1
	JSR INTERN	;Intern it if it's a String, in case it's a boolean word
	LDX #TEMPX1
GTBOL1:	LDA $00,X
	LDY #$00
	CMP LTRUE
	BNE GTBL1
	LDA $01,X
	CMP LTRUE+1
	BNE GTBL1
GTRTS:	RTS
GTBL1:	INY
	LDA $00,X
	CMP LFALSE
	BNE GTBL2
	LDA $01,X
	CMP LFALSE+1
	BEQ GTRTS
GTBL2:	JSR PTRXOK
	LDA #XNTF
	JMP ERROR
.PAGE
MAKPNM:	STY ANSN2	;ANS
	STX ANSN1	;ARG
	JSR GETTYP
	LDX ANSN1
	LDY ANSN2
	CMP #ATOM
	BEQ MKPN1
	CMP #SATOM
	BEQ MKPN1
	CMP #STRING
	BNE MKPF
	JMP GTPNS
MKPF:	PHA		;Save type
	LDA $00,X	;Assume it's a fixnum or flonum
	STA TEMPN2
	LDA $01,X
	STA TEMPN2+1
	LDX #$03
	LDY #$00
MKP2L1:	LDA (TEMPN2),Y
	STA NARG1,Y
	INY
	DEX
	BPL MKP2L1
	PLA		;Retrieve type
	TAX
	LDA ANSN2
	PHA		;Save ANS pointer
	CPX #FIX
	BEQ MKPN2
	CPX #FLO
	BEQ MKPN3
ERXWTX:	JSR PTRXOK
ERXWTY:	LDY #CURTOK
	LDA #XWTA
	JMP ERROR
MKPN1:	JMP GETPNM
MKPN2:	JSR CVBFIX	;Get string on PDL
	JMP CNSPD1	;CONS string from PDL
MKPN3:	JSR CVFLO	;Get the string on PDL
	JMP CNSPD1

;CONS a string from the characters on the PDL, ANSN1 holds counter, ANS in vA.
CNSPDL:	PHA		;Save ANS ptr on stack
CNSPD1:	LDX #$00	;(JMP here if ANS already on stack)
	STX MARK1
	STX MARK1+1
	LDA ANSN1
	ROR A
	BCC CSPD1
	INC ANSN1
	LDA #$00
	BEQ CSPD2	;(Always) If odd, first char. seen will be a zero
CSPD1:	JSR POPB	;Pop two characters
CSPD2:	STA TEMPN+1
	JSR POPB
	STA TEMPN
	LDX #MARK1
	STX ANSN
	LDY #TEMPN
	LDA #STRING
	JSR CONS	;Cons a node
	DEC ANSN1
	DEC ANSN1
	BNE CSPD1	;Continue if not done
	PLA		;Retrieve ANS pointer
	TAX
	LDA MARK1
	STA $00,X
	LDA MARK1+1
	STA $01,X
	LDA #$00
	STA MARK1
	STA MARK1+1
	RTS
.PAGE
GETPNM:	STY TEMPN1+1	;TEMPN1.H is returned PNAME pointer
	STX TEMPN1	;TEMPN1.L is ATOMM pointer
	LDA $00,X
	AND #$FC
	STA $00,X
	JSR GETTYP
	LDX TEMPN1
	CMP #STRING
	BNE GTPNM1
	LDY TEMPN1+1
GTPNS:	LDA $00,X
	PHA
	AND #$FC
	STA $00,Y
	LDA $01,X
	STA $01,Y
	PLA
	AND #$01
	RTS
GTPNM1:	LDY $00,X
	STY TEMPNH	;TEMPNH becomes ATOMM
	LDY $01,X
	STY TEMPNH+1
	LDY #$02
	CMP #SATOM
	BEQ GTPN2
	LDA (TEMPNH),Y	;(Y is $02)
	TAX
	INY
	LDA (TEMPNH),Y
	STA TEMPNH+1
	STX TEMPNH
	LDX TEMPN1+1	;PNAME ptr.
	DEY
	LDA (TEMPNH),Y
	PHA
	INY
	LDA (TEMPNH),Y
	STA $01,X
	PLA
	TAY	
	AND #$FC
	STA $00,X
	TYA
	AND #$01
	RTS
GTPN2:	LDA (TEMPNH),Y	;(Y is $02)
	STA TEMPN	;TEMPN is INDEX
	INY
	LDA (TEMPNH),Y
	STA TEMPN+1
	LDA #$03
	STA TEMPN1
	LDA #$00
	STA ANSN1	;Character counter
GTPNW:	LDY TEMPN1
	LDA (TEMPN),Y	;Pname index is 3 for Sfuns
	BEQ GTPNWE
	JSR PUSHB
	INC ANSN1
	INC TEMPN1
	BNE GTPNW	;(Always)
GTPNWE:	LDA TEMPN1+1	;ANS pointer
	JSR CNSPDL
	LDA #$00	;No Funny-pname SATOMs
	RTS
.PAGE
;Converts a two-byte fixnum to  a string on the PDL
CVFIX:	LDA $00,X
	STA NARG1
	LDA $01,X
	STA NARG1+1	;NARG1 is the number to type
	LDA #$00
	STA ANSN1	;Character counter
CVFIXX:	STA NARG1+2	;(Alternate entry point)
	STA NARG1+3
	BEQ CVFX2	;(Always)

;Get 4-byte fixnum in NARG1 to string on PDL
CVBFIX:	LDA #$00
	STA ANSN1	;Character counter
	LDA NARG1+3
	BPL CVFX1
	LDX #NARG1
	JSR COMPL
	LDA #'-
	JSR PUSHB
	INC ANSN1
CVFX1:	LDA #$00
CVFX2:	STA ANSN	;ANSN is digit counter
CVBNMR:	LDA #$0A
	JSR XDVDX	;Divide NARG1 by ten and get remainder
	CLC
	ADC #'0		;Make the digit Ascii
	PHA		;Push remainder digit
	INC ANSN	;Increment digit counter
	LDX #$03
CVBL1:	LDA NARG1,X
	BNE CVBNMR
	DEX
	BPL CVBL1
CVBNMF:	PLA		;Pop a digit
	JSR PUSHB	;Push it
	INC ANSN1
	DEC ANSN
	BNE CVBNMF
	RTS
.PAGE
;Converts flonum NARG1 to characters on PDL
CVFLO:	LDA #$00
	STA ANSN1	;Counts number of characters pushed
	STA ANSN2	;ODE
	LDX #$03
TPFLL1:	LDA NARG1,X
	BNE TPFL1
	DEX
	BPL TPFLL1
	INC ANSN1
	LDA #'0		;If NARG1 = 0, push "0." and return
	JSR PUSHB
	INC ANSN1
	LDA #'.
	JMP PUSHB
TPFL1:	LDA NARG1+1
	BPL TPFL2
	JSR FCOMPL	;If NARG1 negative, invert and push "-"
	INC ANSN1
	LDA #'-
	JSR PUSHB
TPFL2:	LDA NARG1	;Now get 1 <= NARG1 < 10
	BPL TPFLS1	;Exponent too small, so multiply number
	CMP #$84
	BCS TPFLG1	;Exponent greater than 3, so too big
	CMP #$83
	BNE GINTP1	;Ok if 0,1, or 2
	LDA NARG1+1	;Else if 3,
	CMP #$50	;Make sure X < 10 (01.01 0000 Bin)
	BCC GINTP1
TPFLG1:	JSR FDVD10	;So divide by 10
	INC ANSN2	;Increment ODE
	LDA NARG1
	CMP #$83
	BCC GINTP1
	BNE TPFLG1
	LDA NARG1+1
	CMP #$50
	BCS TPFLG1
	BCC GINTP1	;(Always)
TPFLS1:	JSR MULN10	;NARG1 too small, so multiply by 10
	DEC ANSN2	;Decrement ODE
	LDA NARG1
	BPL TPFLS1
GINTP1:	LDX #$03	;Round up (add 0.000005)
GINTPL:	LDA FRNDUP,X
	STA NARG2,X
	DEX
	BPL GINTPL
	JSR FADD
	LDA NARG1
	CMP #$84
	BCS GNTPLG	;Exponent greater than 3, so too big
	CMP #$83
	BNE GINTP2	;Ok if 0,1, or 2
	LDA NARG1+1	;Else if 3,
	CMP #$50	;Make sure X < 10 (01.01 0000 Bin)
	BCC GINTP2
GNTPLG:	JSR FDVD10	;So divide by 10
	INC ANSN2
GINTP2:	JSR GETINT
	LDA ANSN2
	BPL TPFLG2
	CMP #$FF
	BCC TPFLF1	;NARG1 < 0.1, use floating pt. format (N)
TPFLR:	STA ANSN3	;Counter for Exp+1 iterations
	INC ANSN3
	BEQ TPFLR1
TPFLL5:	JSR GTDECH
	DEC ANSN3
	BNE TPFLL5
TPFLR1:	LDA #'.
	JSR PUSHB	;Push decimal pt.
	INC ANSN1
	SEC
	LDA #$05
	SBC ANSN2
	STA ANSN3	;Counter for 5-Exp iterations
	BEQ POPTZS
TPFLL6:	JSR GTDECH
	DEC ANSN3
	BNE TPFLL6
POPTZS:	JSR POPB	;Pop all trailing zeroes
	DEC ANSN1
	CMP #'0
	BEQ POPTZS
	INC ANSN1
	JMP PUSHB	;Done
TPFLG2:	CMP #$07
	BCC TPFLR	;NARG1 < 10000000, use regular format
TPFLF1:	JSR GTDECH	;Floating pt. format, call Get-Decimal-Char for digit
	LDA #'.
	JSR PUSHB	;Push a "."
	INC ANSN1
	LDA #$05	;Counter for five iterations
	STA ANSN3
TPFLL3:	JSR GTDECH	;Get another decimal digit
	DEC ANSN3
	BNE TPFLL3
	JSR POPTZS	;Pop all trailing zeros
	LDA ANSN2
	BPL TPFLEP
	EOR #$FF	;If Exp negative, invert
	STA ANSN2
	INC ANSN2	;(Complement and increment)
	LDA #'N		;and push "N"
	BNE TPFLEX	;(Always)
TPFLEP:	LDA #'E		;Exp positive, push "E"
TPFLEX:	JSR PUSHB
	INC ANSN1
	LDA ANSN2
	STA NARG1
	LDA #$00
	STA NARG1+1
	JMP CVFIXX	;Routine converts (2-byte) ARG1 into string on PDL
.PAGE
;Gets the most significant decimal digit of NARG1, then positions it for next one.
GTDECH:	CLC
	LDA TEMPN1
	ADC #'0
	JSR PUSHB
	INC ANSN1
	LDA TEMPN1
	STA NARG2
	LDA #$00
	STA NARG2+1
	STA NARG2+2
	STA NARG2+3
	JSR FLOTN2
	JSR FSUB	;Subtract the last digit we got
	JSR MULN10	;Multiply by 10 to get next digit
	;falls through

	;falls in
GETINT:	LDY #NARGX	;Gets the integer part of NARG1
	JSR XN1TOY	;Save NARG1
	JSR INTN1	;Get NARG1 as an integer (don't round)
	LDA NARG1
	STA TEMPN1
	LDY #NARGX
	JMP XYTON1	;Restore NARG1
.PAGE
;Execution diagram, flonum-to-string conversion:
;ODE := 0
;IF NUM < 1 THEN DO NUM := NUM * 10, ODE := ODE - 1, UNTIL NUM >= 1
;   ELSE IF NUM >= 10 THEN DO NUM := NUM / 10, ODE := ODE + 1, UNTIL NUM < 10
;NUM := NUM + ROUND
;IF NUM >= 10 THEN NUM := NUM / 10, ODE := ODE + 1
;INTP := INT(NUM)
;IF ODE > 6 OR ODE < -1 THEN GET-DIG, PUSH("."), (REPEAT 5 GET-DIG), POP-TZS, PR-EXP
;   ELSE (REPEAT ODE+1 GET-DIG), PUSH("."), (REPEAT 5-ODE GET-DIG), POP-TZS
;
;GET-DIG:
;	PUSH(INTP)
;	NUM := NUM - INTP, NUM := NUM * 10, NUM := NUM + ROUND
;IF NUM >= 10 THEN NUM := NUM / 10
;INTP := INT(NUM)
.PAGE
OTPFX1:	LDA #TEMPN	;Output a two-byte fixnum value (Y is ptr.)
	STA ANSN
	LDX #$00
	LDA #FIX
	JSR CONS
	LDX #TEMPN
	JSR VPUSHP
	INC OTPUTN
	JMP POPJ

OTPFIX:	LDA $03,Y
	CMP #$80
	BNE OTPFXA
	LDA $02,Y
	BNE OTPFXA
	LDA $01,Y
	BNE OTPFXA
	LDA $00,Y
	BNE OTPFXA
	LDA #$61	;Attempted to output -2^31, so change to flonum
	STA NARG1
	LDA #$80
	STA NARG1+1
	LDA #$00
	STA NARG1+2
	STA NARG1+3
OTPFL1:	LDY #NARG1
OTPFLO:	LDA #FLO
	BNE OTPNUM	;(Always)
OTPFXA:	LDA #FIX
OTPNUM:	PHA		;Save type
	LDA #TEMPN	;Entered with type (Fix/Flo) in A
	STA ANSN
	TYA
	TAX
	INX
	INX
	PLA		;Retrieve type
	JSR CONS
	LDX #TEMPN
	JSR VPUSHP
	INC OTPUTN
	JMP POPJ
.PAGE
.SBTTL	System Functions
;	Arithmetic Functions:

SUNDIF:	LDA INFDIF
	STA CURTOK	;(For possible error message in GT1NUM)
	LDA INFDIF+1
	STA CURTOK+1
	JSR GT1NUM
	BCS SNDIF2
	LDX #NARG1
	JSR COMPL
	LDY #NARG1
	JMP OTPFIX
SNDIF2:	JSR FCOMPL	;Complements flonum in NARG1.
	JMP OTPFL1

SSUM:	JSR GT2NUM
	BCS SSUMF
	LDY #A1L	;Save NARG1 and NARG2 in case of overflow
	JSR XN1TOY
	LDY #A3L
	JSR XN2TOY
	LDA NARG1+3
	STA TEMPN1
	CLC
	LDX #$FC
SSMLP1:	LDA NARG1+4,X
	ADC NARG2+4,X
	STA NARG1+4,X
	INX
	BMI SSMLP1
	LDA NARG2+3
	EOR TEMPN1
	BMI SSUMOK	;Different signs, never an overflow
	LDA NARG1+3
	EOR NARG2+3
	BPL SSUMOK	;Overflow if result not same sign as one argument
	LDY #A1L
	JSR XYTON1	;Overflow, get NARG1 and NARG2 back
	LDY #A3L
	JSR XYTON2
	JSR FLOTN2	;Convert both to floating pt.
	JSR FLOTN2
SSUMF:	JSR FADD	;Floating pt. addition
	BCS ERXOVF
	JMP OTPFL1
SSUMOK:	LDY #NARG1
	JMP OTPFIX
ERXOVF:	LDA #XOFLOW
	JMP ERROR
.PAGE
SDIF:	JSR GT2NUM
	BCS SDIFF
	LDY #A1L	;Save NARG1 and NARG2 in case of overflow
	JSR XN1TOY
	LDY #A3L
	JSR XN2TOY
	LDA NARG1+3
	STA TEMPN1
	SEC
	LDX #$FC
SDIFL1:	LDA NARG1+4,X
	SBC NARG2+4,X
	STA NARG1+4,X
	INX
	BMI SDIFL1
	LDA TEMPN1
	EOR NARG2+3
	BPL SSUMOK	;Same signs, never an overflow
	LDA NARG1+3
	EOR TEMPN1
	BPL SSUMOK	;(Always)
	LDY #A1L
	JSR XYTON1	;Overflow, get NARG1 and NARG2 back
	LDY #A3L
	JSR XYTON2
	JSR FLOTN2	;Convert both to floating pt.
	JSR FLOTN2
SDIFF:	JSR FSUB	;Floating pt. subtraction
	BCS ERXOVF
	JMP OTPFL1
.PAGE
SPROD:	JSR GT2NUM
	BCS SPRODF
	LDY #A1L	;Save NARG1 and NARG2 in case of overflow
	JSR XN1TOY
	LDY #A3L
	JSR XN2TOY
	JSR IMULT	;Returns with carry set if overflow
	BCS SPRODR
	LDY #TEMPN
	JMP OTPFIX
SPRODR:	LDY #A1L
	JSR XYTON1	;Overflow, get NARG1 and NARG2 back
	LDY #A3L
	JSR XYTON2
	JSR FLOTN1	;Convert both to floating pt.
	JSR FLOTN2
SPRODF:	JSR FMUL	;Floating pt. multiply
	BCS ERXOVF
	JMP OTPFL1
.PAGE
SDIVID:	JSR GT2NUM
	BCS SDIVF
	JSR FLOTN1
	JSR FLOTN2
SDIVF:	JSR FDIV	;Floating pt. divide
	BCS SDIVR
	JMP OTPFL1
SDIVR:	LDA #XOFLOW
	JMP ERROR

SQTENT:	JSR GT2NUM
	BCC SQTNT1
	JSR RNDN1
	JSR RNDN2
SQTNT1:	JSR IDIVID
	LDY #NARG1
	JMP OTPFIX

SRMNDR:	JSR GT2NUM
	BCC SRMND1
	JSR RNDN1
	JSR RNDN2
SRMND1:	JSR IDIVID
	LDY #NARG2
	JMP OTPFIX

SUNSUM:	LDA INFSUM
	STA CURTOK	;(For possible error message in GT1NUM)
	LDA INFSUM+1
	STA CURTOK+1
	JSR GT1NUM
	BCS SNSM1
	LDY #NARG1
	JMP OTPFIX
SNSM1:	JMP OTPFL1

SROUND:	JSR GT1NUM
	BCC SINT1
	JSR RNDN1
SINT1:	LDY #NARG1
	JMP OTPFIX
.PAGE
SSINE:	JSR GT1NUM
	BCS SSINF
	JSR FLOTN1
SSINF:	JSR GETSIN
	LDA NARG1
	JSR MULSIN
	LDY #TEMPN7
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #TEMPN5
	JSR XYTON2	;Get uncorrected table value...
	JSR FADD	;and correct it!
	LDA ANSN1	;X-Incr. sign
	BEQ SSIN2
	JSR FCOMPL
SSIN2:	JMP OTPFL1

SCOS:	JSR GT1NUM
	BCS SCOSF
	JSR FLOTN1
SCOSF:	JSR GETSIN
	LDA NARG1
	JSR MULCOS
	LDY #TEMPN7
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #TEMPN3
	JSR XYTON2	;Get uncorrected table value...
	JSR FADD	;and correct it!
	LDA ANSN2	;Y-Incr. sign
	BEQ SCOS2
	JSR FCOMPL
SCOS2:	JMP OTPFL1
.PAGE
;	Boolean Functions:

SGRTR:	JSR GT2NUM
SGRTRX:	BCS SGRTRF
SGRTR1:	LDA NARG1+3
	BMI SGRTRM
	LDA NARG2+3
	BMI JTRU	;POS > NEG
SGRTRP:	LDX #$03
SGRLP1:	LDA NARG2,X
	CMP NARG1,X
	BCC JTRU
	BNE JFLS
	DEX
	BPL SGRLP1
JFLS:	JMP VPLFLS
SGRTRM:	LDA NARG2+3
	BPL JFLS	;NEG not > POS
	AND #$7F	;Both negative, strip sign bit and compare
	STA NARG2+3
	LDA NARG1+3
	AND #$7F
	STA NARG1+3
	JMP SGRTRP
JTRU:	JMP VPLTRU
SGRTRF:	LDA NARG1+1
	BMI SGRTFM
	LDA NARG2+1
	BMI JTRU	;POS > NEG
	BPL SGRTF1
SGRTFM:	LDA NARG2+1
	BPL JFLS	;NEG not > POS
SGRTF1:	JSR FSUBX	;Both same sign - subtract NARG1 from NARG2
	LDA NARG1+1	;If NARG1 negative, then it was larger
	BMI JTRU
	BPL JFLS

SLESS:	JSR GT2NUM
	JSR SWAP	;Switch the args and call SGREATER
	JMP SGRTRX

SNOT:	LDX #ARG1
	JSR VPOP
	JSR GTBOOL
	TYA
	BNE VPLTRU
	JMP VPLFLS

STEST:	LDX #ARG1
	JSR VPOP
	JSR GTBOOL
	STY IFTEST
	JMP POPJ
.PAGE
SBOTH:	LDA NARGS
	BPL SBTH1
	EOR #$FF
	STA NARGS
SBTH1:	BEQ SBTHER	;BOTH needs more inputs
	LDA #$00
	STA ANSN4
SBTHL:	LDX #ARG1
	JSR VPOP
	JSR GTBOOL
	LDA ANSN4
	BNE SBTH2
	STY ANSN4
SBTH2:	DEC NARGS
	BNE SBTHL
	LDA ANSN4
	BEQ VPLTRU
	BNE VPLFLS
SBTHER:	LDA #XEOL
	JMP ERROR

SEITHR:	LDA NARGS
	BPL SEITH1
	EOR #$FF
	STA NARGS
SEITH1:	BEQ SBTHER	;EITHER needs more inputs
	LDA #$01
	STA ANSN4
SEITHL:	LDX #ARG1
	JSR VPOP
	JSR GTBOOL
	LDA ANSN4
	BEQ SEITH2
	STY ANSN4
SEITH2:	DEC NARGS
	BNE SEITHL
	LDA ANSN4
	BNE VPLFLS
	;falls through
.PAGE
	;falls in
VPLTRU:	LDX #LTRUE
	JSR VPUSHP
	INC OTPUTN
	JMP POPJ

STTYP:	LDA CHBUFR
	CMP CHBUFS
	BNE VPLTRU	;If CHBUFR=CHBUFS, then buffer empty
	;falls through

	;falls in
VPLFLS:	LDX #LFALSE
	JSR VPUSHP
	INC OTPUTN
	JMP POPJ

SLISTP:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BNE NTLST
YESLST:	JMP VPLTRU

SNMBRP:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #FIX
	BEQ YESLST
	CMP #FLO
	BEQ YESLST
	CMP #ATOM
	BNE NTLST
	LDX #ARG1
	JSR ATMTFX
	BCS YESLST
NTLST:	JMP VPLFLS
.PAGE
SPTHNG:	LDX #ARG2
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BEQ SPTH1
	CMP #SATOM
	BEQ SPTH1
	CMP #STRING
	BEQ SPTH4
SPTH2:	JMP VPLFLS
SPTH4:	LDY #TEMPX1
	LDX #ARG2
	JSR INTERN
	LDY #TEMPX1
	BNE SPTH1A	;(Always)
SPTH1:	LDY #ARG2
SPTH1A:	LDX #ARG1
	JSR GETVAL
	LDA ARG1+1
	BNE SPTH3
	LDA ARG1
	BNE SPTH2
SPTH3:	JMP VPLTRU

SPWRDP:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BEQ SPTH3
	CMP #SATOM
	BEQ SPTH3
	CMP #FIX
	BEQ SPTH3
	CMP #FLO
	BEQ SPTH3
	JMP VPLFLS
.PAGE
	;Word/List primitives:

SFIRST:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BEQ SFRST1
	CMP #ATOM
	BEQ SFRST2
	CMP #SATOM
	BEQ SFRST2
	CMP #FIX
	BEQ SFRST2
	CMP #FLO
	BEQ SFRST2
	CMP #STRING
	BEQ SFRST2
SDFNRR:	JMP ERXWT1
SFRST1:	LDA ARG1+1
	BEQ SDFNRR	;FIRST [] should giver error
	LDY #$00
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	STX ARG1
	JMP OTPRG1
SFRST2:	LDY #TEMPN6	;TEMPN6 is TEMP
	LDX #ARG1
	JSR MAKPNM
	LDY #$00
	LDA (TEMPN6),Y
	BEQ SDFNRR	;FIRST " will give error
	STA TEMPN5
	LDX #$00
	STX TEMPN5+1
	LDA #ARG1
	STA ANSN
	LDY #TEMPN5
	LDA #STRING
	JSR CONS
	JMP OTPRG1
.PAGE
SLAST:	LDX #ARG2
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BEQ SLST1
	CMP #ATOM
	BEQ SLST2
	CMP #SATOM
	BEQ SLST2
	CMP #FIX
	BEQ SLST2
	CMP #FLO
	BEQ SLST2
	CMP #STRING
	BEQ SLST2
SLSTR:	JMP ERXWT2
SLST1:	LDA ARG2+1
	BEQ SLSTR
	LDX #ARG2
	JSR GTLSTC
	LDY #$00
	LDA (ARG2),Y
	STA ARG1
	INY
	LDA (ARG2),Y
	STA ARG1+1
	JMP OTPRG1
SLST2:	LDY #ARG1
	LDX #ARG2
	JSR MAKPNM
	LDY #$00
	LDA (ARG1),Y
	BEQ SLSTR
	LDX #ARG1
	JSR GTLSTC
	LDY #$01
	LDA (ARG1),Y
	BEQ SLST3
	STA TEMPN
	DEY
	STY TEMPN+1
	LDA #ARG1
	STA ANSN
	LDX #$00
	LDY #TEMPN
	LDA #STRING
	JSR CONS
SLST3:	JMP OTPRG1
.PAGE
SBTFST:	LDX #ARG2
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BEQ SBFL
	CMP #SATOM
	BEQ SBFA
	CMP #ATOM
	BEQ SBFA
	CMP #FIX
	BEQ SBFA
	CMP #FLO
	BEQ SBFA
	CMP #STRING
	BEQ SBFA
SBFR:	JMP ERXWT2
SBFL:	LDA ARG2+1
	BEQ SBFR
	LDY #$02
	LDA (ARG2),Y
	STA ARG1
	INY
	LDA (ARG2),Y
	STA ARG1+1
	JMP OTPRG1
SBFA:	LDX #ARG2
	LDY #ARG1	;ARG1 is OLDPTR
	JSR MAKPNM
	LDX #ARG1
	JSR VPUSHP
	LDY #$00
	STY ANSN1
	LDA (ARG1),Y
	STA TEMPN1	;TEMPN1 is OLDCAR
	INY
	LDA (ARG1),Y
	STA TEMPN1+1
	BNE SBFA1A
	LDA TEMPN1
	BEQ SBFR
SBFA1A:	LDX #$00
	LDA TEMPN1+1
	BEQ SBFB
	STA TEMPN1
	STX TEMPN1+1
	LDY #TEMPN1
	LDA #TEMPN2
	STA ANSN
	LDA #STRING
	JSR CONS
	LDA ANSN1
	BNE SBFC
	LDX #TEMPN2
	JSR VPUSHP
	INC ANSN1	;BEG-OF-PNAME
	BNE SBFC1	;(Always)
SBFC:	LDY #$02
	LDA TEMPN2
	STA (TEMPN),Y	;TEMPN is NEWPTR
	INY
	LDA TEMPN2+1
	STA (TEMPN),Y
SBFC1:	LDA TEMPN2
	STA TEMPN
	LDA TEMPN2+1
	STA TEMPN+1
SBFB:	LDY #$02
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	STX ARG1
	BEQ SBFD
	LDX TEMPN1
	LDY #$00
	LDA (ARG1),Y
	STA TEMPN1	;OLDCAR
	INY
	LDA (ARG1),Y
	STA TEMPN1+1
	DEY
	TXA
	STA (TEMPN),Y
	INY
	LDA TEMPN1
	STA (TEMPN),Y
	JMP SBFA1A
SBFD:	LDA ANSN1
	BNE SBFDA
	LDA #ARG1
	JSR MAKMTW	;Make ARG1 the empty word
	JMP SBFD1
SBFDA:	LDX #ARG1
	JSR VPOP
SBFD1:	LDX #TEMPN	;OLDPTR, discard
	JSR VPOP
	JMP OTPRG1
.PAGE
SBTLST:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BEQ BTLSTL
	CMP #ATOM
	BEQ BTLSTA
	CMP #SATOM
	BEQ BTLSTA
	CMP #FIX
	BEQ BTLSTA
	CMP #FLO
	BEQ BTLSTA
	CMP #STRING
	BEQ BTLSTA
BTLSTR:	JMP ERXWT1
BTLSTA:	LDY #TEMPN5
	LDX #ARG1
	JSR MAKPNM
	LDA #STRING
	STA ANSN2
	LDY #$00
	LDA (TEMPN5),Y
	BEQ BTLSTR
	LDA TEMPN5
	STA ARG1
	LDA TEMPN5+1
	STA ARG1+1
	JMP BTLSTX
BTLSTL:	STA ANSN2
	LDA ARG1+1
	BEQ BTLSTR
BTLSTX:	LDA #$00
	STA ANSN1	;NEWLIST
	LDX #ARG1
	JSR VPUSHP
BTLSW:	LDY #$03
	LDA (ARG1),Y
	BEQ BTLSWE
	LDY #$00
	LDA (ARG1),Y
	STA TEMPN1	;TEMPCAR
	INY
	LDA (ARG1),Y
	STA TEMPN1+1
	LDA #TEMPN	;TEMP
	STA ANSN
	LDY #TEMPN1
	LDX #$00
	LDA ANSN2	;(List or String)
	JSR CONS
	LDA ANSN1
	BNE BTLSW2
	LDX #TEMPN
	JSR VPUSHP
	INC ANSN1
	BNE BTLSW3	;(Always)
BTLSW2:	LDY #$02
	LDA TEMPN
	STA (TEMPN2),Y
	INY
	LDA TEMPN+1
	STA (TEMPN2),Y
BTLSW3:	LDA TEMPN
	STA TEMPN2
	LDA TEMPN+1
	STA TEMPN2+1
	LDY #$02
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	STX ARG1
	JMP BTLSW
BTLSWE:	LDA ANSN2
	BNE BTLWE1
	LDA ANSN1
	BNE BTLWL1
	LDA #$00
	STA ARG1
	STA ARG1+1
	BEQ BTLWL2	;(Always)
BTLWL1:	LDX #ARG1
	JSR VPOP
BTLWL2:	LDX #TEMPN1
	JSR VPOP
	JMP OTPRG1
BTLWE1:	LDY #$00
	LDA (ARG1),Y
	STA TEMPN1
	INY
	LDA (ARG1),Y
	STA TEMPN1+1
	BEQ BTLWE2
	LDA #TEMPN
	STA ANSN
	LDX #$00
	STX TEMPN1+1
	LDA #STRING
	LDY #TEMPN1
	JSR CONS
	LDA ANSN1
	BNE BTLWE3
	LDA TEMPN
	STA ARG1
	LDA TEMPN+1
	STA ARG1+1
	JMP BTLWE5
BTLWE3:	LDY #$02
	LDA TEMPN
	STA (TEMPN2),Y
	INY
	LDA TEMPN+1
	STA (TEMPN2),Y
	JMP BTLWE4
BTLWE2:	LDA ANSN1
	BNE BTLWE4
	LDA #ARG1
	JSR MAKMTW	;Make ARG1 the empty word
	JMP BTLWE5
BTLWE4:	LDX #ARG1
	JSR VPOP
BTLWE5:	LDX #TEMPN
	JSR VPOP
	JMP OTPRG1
.PAGE
SWORD:	LDA NARGS
	BPL SWRD1
	EOR #$FF
	STA NARGS
SWRD1:	LDA #$00
	STA MARK5
	STA MARK5+1
	LDA NARGS
	ASL A
	STA ANSN4
	CLC
	LDA VSP
	ADC ANSN4
	STA TEMPN6
	LDA VSP+1
	ADC #$00
	STA TEMPN6+1
SWRDW:	LDA NARGS
	BEQ SWRD2
	LDY #$00
	LDA (TEMPN6),Y
	STA MARK3
	INY
	LDA (TEMPN6),Y
	STA MARK3+1
	SEC
	LDA TEMPN6
	SBC #$02
	STA TEMPN6
	BCS SWRDW1
	DEC TEMPN6
SWRDW1:	DEC NARGS
	LDY #MARK4
	LDX #MARK3
	JSR MAKPNM
	LDA MARK4+1
	BEQ SWRDW
	JSR CONCAT	;MARK5 := (Concatenate MARK5 MARK4)
	JMP SWRDW
SWRD2:	CLC
	LDA VSP
	ADC ANSN4
	STA VSP
	BCC SWRD3
	INC VSP+1
SWRD3:	LDA MARK5+1
	BNE SWRD4
	LDA #MARK5
	JSR MAKMTW	;Make MARK5 the empty word
SWRD4:	LDX #MARK5
	JSR VPUSHP
	INC OTPUTN
	LDA #$00
	JSR CLMK5
	JMP POPJ
.PAGE
CONCAT:	LDA MARK5+1
	BNE CNCT1
	LDA MARK4	;MARK5 is Lnil, so make
	LDX MARK4+1	;MARK5 a copy of second word and return
	LDY #MARK5
	JMP COPY
CNCT1:	LDA MARK5
	LDX MARK5+1
	LDY #TEMPN3	;Make TEMPN3 a copy of MARK5
	JSR COPY
	LDA TEMPN3
	STA TEMPN4	;Save the first word's pointer in TEMPN4
	LDA TEMPN3+1
	STA TEMPN4+1
	LDX #TEMPN3	;Get the last cell of first word (TEMPN3)
	JSR GTLSTC
	LDY #$01
	LDA (TEMPN3),Y
	BEQ CNCODD
	LDA MARK4	;Even no. chars. in first word
	LDX MARK4+1
	LDY #TEMPN5	;Make TEMPN5 a copy of second word
	JSR COPY
	LDY #$02
	LDA TEMPN5
	STA (TEMPN3),Y	;Link second word onto first
	INY
	LDA TEMPN5+1
	STA (TEMPN3),Y
CNCTWE:	LDA TEMPN4	;Restore pointer to new word
	STA MARK5
	LDA TEMPN4+1
	STA MARK5+1
	RTS
CNCODD:	LDY #$00	;Odd no. chars. in first word
	STY TEMPN1+1
	LDA (MARK4),Y	;Get first char. of second word
	INY
	STA (TEMPN3),Y	;Append it to end of first word
	LDA (MARK4),Y
	STA TEMPN1	;TEMPN1 holds second char. of second word
CNCTW:	LDA MARK4+1
	BEQ CNCTWE
	LDY #$02
	LDA (MARK4),Y
	TAX
	INY
	LDA (MARK4),Y
	STA MARK4+1	;Advance second word char-ptr
	STX MARK4
	LDA TEMPN1	;If even-numbered char. of second word nil, exit
	BEQ CNCTWE	;(already appended odd-numbered char. preceeding)
	LDA MARK4+1
	BNE CNCTW1
	STA TEMPN1+1	;Zero last character (because odd no.)
	BEQ CNCTW2	;(Always) Just add last char. if end of second word
CNCTW1:	LDY #$00
	LDA (MARK4),Y
	STA TEMPN1+1	;Get odd-numbered (3,5,...) char.
	INY
	LDA (MARK4),Y
	STA ANSN1	;Get next even-numbered (4,6,...) char.
CNCTW2:	LDA #TEMPN
	STA ANSN
	LDY #TEMPN1
	LDA #$00
	TAX
	LDA #STRING
	JSR CONS	;Cons new cell
	LDY #$02
	LDA TEMPN
	STA (TEMPN3),Y
	TAX
	INY
	LDA TEMPN+1
	STA (TEMPN3),Y	;Append to new word
	STA TEMPN3+1
	STX TEMPN3	;New new-word end pointer
	LDA ANSN1
	STA TEMPN1	;Last even char. becomes new odd char.
	JMP CNCTW
.PAGE
COPY:	STY ANSN1	;Y is STR1
	STA TEMPN1	;Make (ANSN1) point to a copy of (vXA)
	STX TEMPN1+1
	TXA
	BNE COPY1
	STA $00,Y	;If (vAX) is Lnil, make (ANSN1) Lnil
	STA $00,Y
	RTS
COPY1:	STY ANSN	;Cons up an empty cell
	LDA #$00
	TAX
	TAY
	LDA #STRING
	JSR CONS
	LDX ANSN1
	JSR VPUSHP	;Vpush forming string
COPYW:	LDX ANSN1
	LDA $00,X
	STA TEMPN2
	LDA $01,X
	STA TEMPN2+1	;TEMPN2 points to empty last cell of copy
	LDY #$00
	LDA (TEMPN1),Y
	STA (TEMPN2),Y	;Copy two characters into cell
	INY
	LDA (TEMPN1),Y
	STA (TEMPN2),Y
	INY
	LDA (TEMPN1),Y
	TAX
	INY
	LDA (TEMPN1),Y
	STA TEMPN1+1	;Advance char-ptr of original
	STX TEMPN1
	TAX
	BEQ COPYWE	;Exit if end of original
	LDA #TEMPN
	STA ANSN
	LDA #$00
	TAX
	TAY
	LDA #STRING
	JSR CONS	;Cons a new cell
	LDY #$02
	LDX ANSN1
	LDA TEMPN
	STA (TEMPN2),Y
	STA $00,X
	INY
	LDA TEMPN+1
	STA (TEMPN2),Y	;Link new cell on to end of copy
	STA $01,X	;Advance copy's last-cell ptr
	JMP COPYW
COPYWE:	LDX ANSN1	;Vpop copy's beginning pointer
	JMP VPOP
.PAGE
SFPUT:	LDX #ARG2
	JSR VPOP
	LDX #ARG1
	JSR VPOP
	LDX #ARG2
	JSR GETTYP
	CMP #LIST
	BNE ERXWT2
	LDX #ARG2
	LDY #ARG1
	STY ANSN
	JSR CONS
	JMP OTPRG1
ERXWT2:	LDX #ARG2
	LDY #CURTOK
	LDA #XWTA
	JMP ERROR
.PAGE
SLPUT:	LDX #ARG2
	JSR VPOP
	LDX #ARG1
	JSR VPOP
	LDX #ARG2
	JSR GETTYP
	CMP #LIST
	BNE ERXWT2
	LDA ARG2+1
	BNE SLPUT2
	LDY #ARG1
	STY ANSN
	LDX #$00
	TXA		;(Type LIST)
	JSR CONS
	JMP OTPRG1
SLPUT2:	LDA ARG1
	STA MARK2	;Protect the last element
	LDA ARG1+1
	STA MARK2+1
	LDA ARG2
	STA MARK3	;Protect the original list (or what's left of it)
	LDA ARG2+1
	STA MARK3+1
	LDY #$00
	LDA (MARK3),Y
	STA TEMPN1
	INY
	LDA (MARK3),Y
	STA TEMPN1+1	;(CAR) First element
	INY
	LDA (MARK3),Y
	TAX
	INY
	LDA (MARK3),Y
	STA MARK3+1
	STX MARK3
	LDA #MARK1	;Pointer to start of new list
	STA ANSN
	LDX #$00
	TXA
	LDY #TEMPN1
	JSR CONS
	LDA MARK1
	STA TEMPN2	;Pointer to newest node
	LDA MARK1+1
	STA TEMPN2+1
SLPTW:	LDA MARK3+1	;Make a new list, element by element
	BEQ SLPT2
	LDY #$00
	LDA (MARK3),Y
	STA TEMPN1	;Get an element
	INY
	LDA (MARK3),Y
	STA TEMPN1+1
	INY
	LDA (MARK3),Y
	TAX
	INY
	LDA (MARK3),Y
	STA MARK3+1
	STX MARK3	;(CDR) Advance element pointer
	LDA #TEMPN	;New pointer to newest node
	STA ANSN
	LDX #$00
	TXA		;(Type LIST)
	LDY #TEMPN1
	JSR CONS
	LDY #$02
	LDA TEMPN
	STA (TEMPN2),Y	;Pointer to last node
	TAX
	INY
	LDA TEMPN+1
	STA (TEMPN2),Y	;(CDR) Link new node onto list
	STA TEMPN2+1
	STX TEMPN2
	JMP SLPTW
SLPT2:	LDY #ARG1
	LDA #TEMPN
	STA ANSN
	LDX #$00
	TXA		;(Type LIST)
	JSR CONS	;Get a pointer to first argument
	LDY #$02
	LDA TEMPN
	STA (TEMPN2),Y
	INY
	LDA TEMPN+1
	STA (TEMPN2),Y	;Link final node on
	JMP SSN2	;MARK1 points to our new list
.PAGE
SLIST:	LDA NARGS
	BPL SLIST1
	EOR #$FF
	STA NARGS
SLIST1:	LDA #MARK1
	STA ANSN
	LDA #$00
	STA MARK1
	STA MARK1+1
	LDA NARGS
	BEQ SLSTWE
SLISTW:	LDX #MARK2
	JSR VPOP
	LDY #MARK2
	LDX #MARK1
	STX ANSN
	LDA #$00	;(Type LIST)
	JSR CONS
	DEC NARGS
	BNE SLISTW
SLSTWE:	LDA MARK1
	STA ARG1
	LDA MARK1+1
	STA ARG1+1
	LDA #$00
	JSR CLMK2
	JMP OTPRG1
.PAGE
SSNTNC:	LDA #$00
	STA MARK1
	STA MARK1+1
	LDA NARGS
	BPL SSN1
	EOR #$FF	;NARGS := - NARGS - 1
	STA NARGS
SSN1:	BNE SSNWA
SSN2:	LDA MARK1
	STA ARG1
	LDA MARK1+1
	STA ARG1+1
	LDA #$00
	JSR CLMK3
	JMP OTPRG1
SSNWA:	LDX #MARK2
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BEQ SSNW1
	LDY #MARK2
	LDX #MARK1
	STX ANSN
	LDA #LIST
	JSR CONS
	JMP SSNW2
SSNW1:	LDA #$00
	STA TEMPN2
	STA TEMPN2+1
SSNX:	LDA MARK2+1
	BEQ SSNY
	LDY #$00
	LDA (MARK2),Y
	STA MARK3
	INY
	LDA (MARK2),Y
	STA MARK3+1
	INY
	LDA (MARK2),Y
	TAX
	INY
	LDA (MARK2),Y
	STA MARK2+1
	STX MARK2
	LDX #MARK3
	JSR VPUSHP
	INC TEMPN2
	BNE SSNX
	INC TEMPN2+1
	BNE SSNX	;(Always)
SSNY:	LDA TEMPN2
	BNE SSNY1
	LDA TEMPN2+1
	BEQ SSNW2
SSNY1:	LDX #MARK3
	JSR VPOP
	LDX #MARK1
	STX ANSN
	LDY #MARK3
	LDA #LIST
	JSR CONS
	SEC
	LDA TEMPN2
	SBC #$01
	STA TEMPN2
	BCS SSNY
	DEC TEMPN2+1
	JMP SSNY1
SSNW2:	DEC NARGS
	JMP SSN1
.PAGE
;	Miscellaneous Functions:

SMAKE:	LDX #ARG2
	JSR VPOP
	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	LDY #ARG1
	CMP #ATOM
	BEQ SMAKE1
	CMP #SATOM
	BEQ SMAKE1
	CMP #STRING
	BNE ERXWT1
	LDX #ARG1
	LDY #TEMPX1
	JSR INTERN	;Intern the Name if it's a string
	LDY #TEMPX1
SMAKE1:	LDX #ARG2
	JSR PUTVAL
	JMP POPJ
ERXWT1:	LDX #ARG1
	LDY #CURTOK
	LDA #XWTA
	JMP ERROR

SOUTPT:	LDA LEVNUM
	BNE SOTPT2
	LDA LEVNUM+1
	BEQ SOTPT1
SOTPT2:	LDA #$01
	STA STPFLG
	STA OTPUTN
	JMP POPJ
SOTPT1:	LDY #CURTOK
	LDA #XNTL
	JMP ERROR
.PAGE
SSTOP:	LDA LEVNUM
	BNE SSTOP1
	LDA LEVNUM+1
	BEQ SOTPT1
SSTOP1:	LDA #$01
	STA STPFLG
	JMP POPJ

SCOMMT:	LDA #$00
	STA TOKPTR+1
	LDA EXPOUT
	BNE ERXEOL
	JMP POPJ
ERXEOL:	LDA #XEOL
	JMP ERROR

SCNTIN:	LDA #$01
	STA STPFLG
	INC COFLG	;BRKLOP will return from break-loop
	JMP POPJ
.PAGE
SIFT:	INC IFLEVL
	BNE SIFTA
	INC IFLEVL+1
	BNE SIFTA
	JMP EXCED
SIFTA:	JSR GTNXTK
	LDA NEXTOK
	CMP LTHEN
	BNE SIFT1
	LDA NEXTOK+1
	CMP LTHEN+1
	BNE SIFT1
	LDX #TOKPTR
	JSR TTKADV
SIFT1:	LDY IFTEST
	BNE SIF2
	JMP POPJ

SIFF:	INC IFLEVL
	BNE SIFFA
	INC IFLEVL+1
	BNE SIFFA
	JMP EXCED
SIFFA:	JSR GTNXTK
	LDA NEXTOK
	CMP LTHEN
	BNE SIFF1
	LDA NEXTOK+1
	CMP LTHEN+1
	BNE SIFF1
	LDX #TOKPTR
	JSR TTKADV
SIFF1:	LDY IFTEST
	BEQ SIF2
	JMP POPJ
.PAGE
SIF:	INC IFLEVL
	BNE SIFA
	INC IFLEVL+1
	BNE SIFA
	JMP EXCED
SIFA:	JSR GTNXTK
	LDA NEXTOK
	CMP LTHEN
	BNE SIF1
	LDA NEXTOK+1
	CMP LTHEN+1
	BNE SIF1
	LDX #TOKPTR
	JSR TTKADV
SIF1:	LDX #ARG1
	JSR VPOP
	JSR GTBOOL
	TYA
	BNE SIF2
SIF3A:	JMP POPJ
SIF2:	LDX #NEXTOK
	JSR EXIFSC
	LDA TOKPTR
	BNE SIF3
	LDA TOKPTR+1
	BEQ SIF3A
SIF3:	LDA NEXTOK
	CMP LELSE
	BNE SIF3A
	LDA NEXTOK+1
	CMP LELSE+1
	BNE SIF3A
	LDX #TOKPTR
	JSR TTKADV
	JMP POPJ

SELSE:	SEC
	LDA IFLEVL
	SBC #$01
	STA IFLEVL
	LDA IFLEVL+1
	SBC #$00
	STA IFLEVL+1
	BCC SELSE1
	LDA IFLEVL
	BNE SELSE2
	LDA IFLEVL+1
	BNE SELSE2
	STA TOKPTR+1
	JMP POPJ
SELSE2:	LDX #TEMPN2
	JSR EXIFSC
SELPOP:	JMP POPJ
;if we got here, else is out of place. if expout is set, return and it will
;say "else didn't output."
;else say "else is out of place." The "else didn't output" error message is
;more informative.
SELSE1:	LDA EXPOUT
	BNE SELPOP
	LDA #XELS
	JMP ERROR
.PAGE
SGO:	LDA EXPOUT
	BNE GOERR1
	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BEQ SGO1
	CMP #SATOM
	BEQ SGO1
	CMP #STRING
	BEQ SGOSTR
	CMP #FIX
	BEQ GONUM
	CMP #FLO
	BEQ GONUM
	JMP SRUN1
GONUM:	LDX #ARG1
	LDY #TEMPX1
	JSR MAKPNM	;Make a string out of the number
	LDX #TEMPX1
	LDY #ARG1
	JSR INTERN	;And Intern it
	JMP SGO1
GOERR1:	LDA #XNOP	;Explicitly signal error, "GO Didn't output"
	LDA #LGO&$FF
	STA TOKPTR
	LDA #LGO^
	STA TOKPTR+1
	LDY #TOKPTR
	JMP ERROR
SGOSTR:	LDA ARG1	;ARG1 is a String, so Intern it
	STA ARG2
	LDA ARG1+1
	STA ARG2+1
	LDX #ARG2
	LDY #ARG1
	JSR INTERN
SGO1:	LDA #LATOM
	LDX #ARG1
	JSR PUTTYP
	LDA FBODY
	STA GOPTR
	LDA FBODY+1
	STA GOPTR+1
	LDA ULNEND
	STA TEMPN3
	LDA ULNEND+1
	STA TEMPN3+1
	LDX #GOPTR
	JSR ULNADV
SGOW:	LDA GOPTR+1
	BEQ SGOR
	LDX #TEMPN1
	LDY #GOPTR
	JSR GETULN
	LDY #$00
	LDA (TEMPN1),Y
	TAX
	INY
	LDA (TEMPN1),Y
	STA TEMPN1+1
	STX TEMPN1
	LDA ARG1
	CMP TEMPN1
	BNE SGOW2
	LDA ARG1+1
	CMP TEMPN1+1
	BEQ SGOE1
SGOW2:	LDX #GOPTR
	JSR ULNADV
	JMP SGOW
SGOE1:	JMP POPJ
SGOR:	LDA TEMPN3
	STA ULNEND
	LDA TEMPN3+1
	STA ULNEND+1
	LDY #ARG1
	LDA #XLNF
	JMP ERROR
.PAGE
SRUN:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BNE SRUN1
	LDX #TOKPTR
	JSR VPUSHP
	JSR PARSEL
	LDX #TOKPTR
	JSR VPUSHP	;Save parsed list
	LDX #SRNDON&$FF
	LDY #SRNDON^
	JSR PUSH
	JMP RUNHAN
SRUN1:	JMP GTERR1

SRPEAT:	LDX #ARG2
	JSR VPOP
	LDA ARG2
	PHA		;Save second arg through GT1FIX
	LDA ARG2+1
	PHA
	JSR GT1FIX
	LDX ARG1+3
	BMI SRUN1
	LDX ARG1
	LDY ARG1+1
	PLA		;Retrieve second arg as ARG1
	STA ARG1+1
	PLA
	STA ARG1
	TXA
	PHA		;Save the number through PARSEL
	TYA
	PHA
	LDA ARG1+2
	PHA
	LDA ARG1+3
	PHA
	LDX #ARG1
	JSR GETTYP
	CMP #LIST
	BNE SRUN1
	LDX #TOKPTR
	JSR VPUSHP	;Save the rest of the command line
	JSR PARSEL
	LDX #TOKPTR
	JSR VPUSHP	;Save the parsed list on the VPDL
	PLA		;Retrieve the number
	STA ARG2+3
	PLA
	STA ARG2+2
	PLA
	STA ARG2+1
	PLA
	STA ARG2
SRPLOP:	LDA ARG2
	BNE SRPLP1
	LDA ARG2+1
	BNE SRPLP1
	LDA ARG2+2
	BNE SRPLP1
	LDA ARG2+3
	BNE SRPLP1
SRNDON:	LDX #TOKPTR
	JSR VPOP		;Get list off of the VPDL
	LDX #TOKPTR
	JSR VPOP		;Get the rest of the original line back
	JMP POPJ
SRPLP1:	SEC
	LDA ARG2
	SBC #$01
	STA ARG2
	BCS SRPLP2
	LDA ARG2+1
	SBC #$00
	STA ARG2+1
	LDA ARG2+2
	SBC #$00
	STA ARG2+2
	LDA ARG2+3
	SBC #$00
	STA ARG2+3
SRPLP2:	LDX #ARG2
	JSR PUSHP
	LDX #ARG2+2
	JSR PUSHP
	LDX #SREPT1&$FF
	LDY #SREPT1^
	JSR PUSH
	JMP RUNHAN

SREPT1:	LDX #TOKPTR
	JSR VPOP
	LDX #TOKPTR
	JSR VPUSHP
	LDX #ARG2+2
	JSR POP
	LDX #ARG2
	JSR POP
	JMP SRPLOP
.PAGE
PARSEL:	LDA #CRUNP&$FF	;Here we have to dump and reparse
	STA OTPDEV	;the ARG1 list before evaluating it.
	LDA #CRUNP^	;First make the output routine CRUNP,
	STA OTPDEV+1	;which dumps output into the Line-array.
	LDA #$00
	STA PINDEX	;char-counter for CRUNP
	LDX #ARG1
	TXA		;Don't type outer brackets!
	JSR LTYPE	;Dump line
	JSR BREAK1
	JSR RSTIO	;Reset the output routine
	LDA #TOKPTR
	STA TEMPX2	;PRDLNX wants arg. ptr. in TEMPX2
	LDX PINDEX
	DEX		;Decrement to get actual length
	STX TEMPN7	;TEMPN7 wants the input line length
	JSR PRDLNX	;Parse the line
	LDA #$00	;(??Not necessary when parser expanded)
	STA LINARY	;Zap first two chars in Line buffer so Retrieve-line nullified
	STA LINARY+1
	RTS

CRUNP:	LDX PINDEX	;Line-array index
	STA LINARY,X
	INC PINDEX
	BEQ CRUNPR
	RTS
CRUNPR:	LDA #XZAP
	LDX #XEXCED	;RUN-line too long, give "Evaluator Overflow error"
	JMP ERROR	;(??zap when parser expanded)
.PAGE
STHING:	LDX #ARG2
	JSR VPOP
	JSR GETTYP
	LDY #ARG2
	CMP #ATOM
	BEQ STH1
	CMP #SATOM
	BEQ STH1
	CMP #STRING
	BNE STH2
	LDX #ARG2
	LDY #TEMPX1
	JSR INTERN	;Intern the Name if it's a string
	LDY #TEMPX1
STH1:	LDX #ARG1
	JSR GETVAL
	LDA ARG1+1
	BNE OTPRG1
	LDA ARG1
	BEQ OTPRG1
	LDY #ARG2
	LDA #XHNV
	JMP ERROR
STH2:	LDX #ARG2
	JMP ERXWTY
OTPRG1:	INC OTPUTN
	LDX #ARG1
	JSR VPUSHP
	JMP POPJ

SNODES:	SEC
	LDA #TYPLEN&$FF
	SBC NNODES
	STA TEMPN1
	LDA #TYPLEN^
	SBC NNODES+1
	STA TEMPN1+1
	LDY #TEMPN1
	JMP OTPFX1

SREQU:	LDX #ILINE
	JSR VPUSHP	;Save ILINE
	LDX #SREQUX&$FF
	LDY #SREQUX^
	JSR PUSH
SREQUX:	LDA OTPUTN
	BNE SGCE	;If OTPUTN set, just return, else try again
	LDA #RPRMPT	;Will be re-entered here after completion or from CO
	JSR TPCHR
	LDA #$F0	;Negative PRSFLG tells READLINE to parse as a list
	STA PRSFLG	;(remember, it gets incremented once inside, too)
	LDX #ILINE
	JSR READLN
	LDA ILINE	;Restore ILINE
	STA ARG1
	LDA ILINE+1
	STA ARG1+1
	LDX #ILINE
	JSR VPOP
	JMP OTPRG1

SGCOLL:	JSR GARCOL
SGCE:	JMP POPJ
.PAGE
SDEFIN:	LDX #TEMPN5
	JSR VPOP
	LDX #TEMPN3	;TEMPN3 is ARG1
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BEQ SDEFN1
	CMP #STRING
	BNE SDFNR1
	LDY #TEMPN3
	LDX #ARG1
	JSR INTERN
	LDX #ARG1
	JSR GETTYP
	CMP #ATOM
	BNE SDFNR1
	LDA ARG1
	STA TEMPN3
	LDA ARG1+1
	STA TEMPN3+1
SDEFN1:	LDX #TEMPN5
	JSR GETTYP
	CMP #LIST
	BNE SDFNR2
	LDY #$00
	LDA (TEMPN5),Y
	STA ARG1
	INY
	LDA (TEMPN5),Y
	STA ARG1+1
	INY
	LDA (TEMPN5),Y
	STA TEMPN2	;TEMPN2 is TLIST
	INY
	LDA (TEMPN5),Y
	STA TEMPN2+1
	LDX #ARG1
	JSR GETTYP
	CMP #LIST
	BNE SDFNR2
	LDA TEMPN5+1
	BNE DEFUN1
	LDX #TEMPN3
	JSR UNFUNC
	JMP POPJ
SDFNR1:	JMP ERXWT1
SDFNR2:	JMP ERXWT2
DEFUN1:	LDX #TOKPTR
	JSR VPUSHP	;Save the rest of the line
	LDX #TEMPN5
	JSR VPUSHP
	LDA VSP
	STA TEMPN1	;TEMPN1 is PTR
	LDA VSP+1
	STA TEMPN1+1
	JSR SWAPT1
	JSR PARSEL	;Parse the arglist
	JSR SWAPT2
	LDX #TOKPTR
	JSR VPUSHP	;Vpush Arglist
DEFUNW:	LDA TEMPN2+1
	BEQ DEFNWE
	LDY #$00
	LDA (TEMPN2),Y
	STA ARG1	;ARG1 is T1
	INY
	LDA (TEMPN2),Y
	STA ARG1+1
	LDX #ARG1
	JSR GETTYP
	CMP #LIST
	BNE DEFNER
	JSR SWAPT1	;Save variables
	JSR PARSEL
	JSR SWAPT2	;Retrieve variables
	LDX #TOKPTR
	JSR VPUSHP
	LDY #$02
	LDA (TEMPN2),Y
	TAX
	INY
	LDA (TEMPN2),Y
	STA TEMPN2+1
	STX TEMPN2
	BNE DEFUNW
DEFNWE:	LDA #$00
	STA ARG2
	STA ARG2+1
DEFUNX:	LDA TEMPN1
	CMP VSP
	BNE DEFNX1
	LDA TEMPN1+1
	CMP VSP+1
	BEQ DEFNXE
DEFNX1:	LDX #TEMPN2
	JSR VPOP
	LDX #ARG2
	STX ANSN
	LDY #TEMPN2
	LDA #LIST
	JSR CONS
	JMP DEFUNX
DEFNXE:	LDA TEMPN3
	STA ARG1	;Can only give ARG1 to STUFF, won't like TEMPN3
	LDA TEMPN3+1
	STA ARG1+1
	LDX #ARG2
	LDA #ARG1
	JSR STUFF
	LDX #TEMPN
	JSR VPOP	;Vpush & discard LISTT
	LDX #TOKPTR
	JSR VPOP	;Get the rest of the line back
	JMP POPJ
DEFNER:	LDX #ARG2
	JMP ERXWTX
.PAGE
STEXT:	LDX #ARG1
	JSR VPOP
	JSR GETTYP
	CMP #ATOM
	BNE STEXTR
	LDX #ARG1
	LDA #TEMPN5	;FUN is TEMPN5
	JSR GETFUN
	LDA TEMPN5+1
	BNE STEXT1
	STA TEMPN6	;BODY is TEMPN6
	STA TEMPN6+1
	JMP STEXT3
STEXTR:	JMP ERXWT1
STEXT1:	LDY #$02
	LDA (TEMPN5),Y
	STA TEMPN6
	INY
	LDA (TEMPN5),Y
	STA TEMPN6+1
	LDX #TEMPN6
	JSR GETTYP
	CMP #LIST
	BEQ STXT1A
STXT1B:	LDY #TEMPN6
	LDX #TEMPN5
	JSR UNSTUF
	JMP STEXT3
STXT1A:	LDA TEMPN6
	STA TEMPN5
	LDA TEMPN6+1
	STA TEMPN5+1
	LDA VSP
	STA TEMPN1	;TEMPN1 is STACK
	LDA VSP+1
	STA TEMPN1+1
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPN2	;TEMPN2 is LINE
	INY
	LDA (TEMPN5),Y
	STA TEMPN2+1
	INY
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	LDX #TEMPN2
	JSR VPUSHP
STXTW:	LDA TEMPN5+1
	BEQ STXTWE
	LDY #$00
	LDA (TEMPN5),Y
	STA TEMPN2
	INY
	LDA (TEMPN5),Y
	STA TEMPN2+1
	INY
	LDA (TEMPN5),Y
	TAX
	INY
	LDA (TEMPN5),Y
	STA TEMPN5+1
	STX TEMPN5
	DEY
	LDA (TEMPN2),Y
	TAX
	INY
	LDA (TEMPN2),Y
	STA TEMPN2+1
	STX TEMPN2
	LDX #TEMPN2
	JSR VPUSHP
	JMP STXTW
STXTWE:	LDA #$00
	STA MARK1
	STA MARK1+1
STXTX:	LDA TEMPN1
	CMP VSP
	BNE STXTX1
	LDA TEMPN1+1
	CMP VSP+1
	BEQ STXTXE
STXTX1:	LDX #TEMPN2
	JSR VPOP
	LDX #MARK1
	STX ANSN
	LDY #TEMPN2
	LDA #LIST
	JSR CONS
	JMP STXTX
STXTXE:	LDA MARK1
	STA TEMPN6
	LDA MARK1+1
	STA TEMPN6+1
	LDA #$00
	STA MARK1
	STA MARK1+1
STEXT3:	LDX #TEMPN6
	JSR VPUSHP
	INC OTPUTN
	JMP POPJ
.PAGE
SEQUAL:	LDA LTRUE
	STA TEMPX2	;TEMPX2 is PRED
	LDA LTRUE+1
	STA TEMPX2+1
	LDX #ARG2
	JSR VPOP
	LDX #ARG1
	JSR VPOP
	INC OTPUTN
	LDA SP
	STA TEMPN8
	LDA SP+1
	STA TEMPN8+1
	LDX #SEQEND&$FF
	LDY #SEQEND^
	JSR PUSH
	;falls through
.PAGE
	;falls in
EQ:	LDX #ARG2
	JSR GETTYP
	STA ANSN
	LDX #ARG1
	JSR GETTYP
	STA ANSN4
	CMP #LIST
	BEQ EQL
	CMP #FIX
	BEQ EQF
	CMP #FLO
	BEQ EQF
	CMP #ATOM
	BEQ EQA
	CMP #STRING
	BNE EQO
	JMP EQSTR
EQO:	LDA ANSN4	;Loses if not same type
	CMP ANSN
	BNE EQFF
EQO1:	LDA ARG1	;Loses if not same pointer
	CMP ARG2
	BNE EQFF
	LDA ARG1+1
	CMP ARG2+1
	BEQ EQPOP
EQFF:	LDA LFALSE	;We lost
	STA TEMPX2
	LDA LFALSE+1
	STA TEMPX2+1
	JMP SEQEND
EQPOP:	JMP POPJ	;We won this round
EQL:	LDA ANSN	;ARG1 is a list
	CMP #LIST
	BNE EQFF	;Lose if ARG2 not a list
	JMP EQLIST	;Compare the lists
EQF:	LDX #ARG1	;ARG1 is a number
	JSR GTNM2	;Get arg1 into NARG1
	JSR GTNM2X	;Get arg2 into NARG2 (without bashing NARG1)
	BCC EQFF	;Not a number, lose
EQFC:	CMP ANSN4	;(Here we have two numbers) See if NARG1 same type...
	BEQ EQF1	;Yes, compare them
	CMP #FLO	;Not same type: If NARG2 is Flonum,
	BEQ EQF2	;then branch
	JSR FLOTN2	;Else NARG2 is Fixnum, convert to flt. pt.
	JMP EQF1	;and compare (NARG1 is a flonum)
EQF2:	JSR FLOTN1	;Convert NARG1 to floating pt. (NARG2 is a flonum)
EQF1:	LDX #$03	;Compares two numbers of same type
EQFLP:	LDA NARG1,X
	CMP NARG2,X
	BNE EQFF
	DEX
	BPL EQFLP
	JMP POPJ
EQA:	LDA ANSN	;ARG1 is an atom, look at ARG2
	CMP #STRING
	BNE EQA2
	JMP EQSTRX	;String, so compare with atom
EQA2:	CMP #FIX
	BEQ EQA1
	CMP #FLO
	BNE EQO		;ARG2 not a fixnum or flonum, must be the same atom then
EQA1:	STA ANSN4	;ARG1 is an atom, ARG2 is a number
	LDX #NARG2
	JSR GTNM2	;Get number arg2 into NARG2
	JSR GTNUM1	;Get arg1 into NARG1 if you can
	BCC EQFF	;Can't, so lose
	CMP ANSN4	;Have two numbers in NARG1, NARG2, do CMP for branch at EQFC
	JMP EQFC
EQLIST:	LDA ARG1+1
	BNE EQLST1
	LDA ARG2+1
	BNE EQFF
	JMP POPJ
EQLST1:	LDA ARG2+1
	BEQ EQFF
	LDX #ARG1
	JSR PUSHP
	LDX #ARG2
	JSR PUSHP
	LDY #$00
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	STX ARG1
	DEY
	LDA (ARG2),Y
	TAX
	INY
	LDA (ARG2),Y
	STA ARG2+1
	STX ARG2
	JSR TSTPOL
	LDX #EL1&$FF
	LDY #EL1^
	JSR PUSH
	JMP EQ
EL1:	LDX #ARG2
	JSR POP
	LDX #ARG1
	JSR POP
	LDY #$02
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	STX ARG1
	LDX #ARG1
	JSR GETTYP
	CMP #LIST
	BNE EL1R
	LDY #$02
	LDA (ARG2),Y
	TAX
	INY
	LDA (ARG2),Y
	STA ARG2+1
	STX ARG2
	LDX #ARG2
	JSR GETTYP
	CMP #LIST
	BNE EL1R
	JMP EQLIST
EL1R:	JSR SYSBUG
SEQEND:	LDX #TEMPX2	;PRED
	JSR VPUSHP
	LDA TEMPN8
	STA SP
	LDA TEMPN8+1
	STA SP+1
	JMP POPJ
.PAGE
EQSTRX:	LDX #ARG1	;ARG1 is an Atom, ARG2 is the String
	LDY #TEMPN6
	JSR MAKPNM
	LDA TEMPN6
	STA ARG1
	LDA TEMPN6+1
	STA ARG1+1
	JMP CMPSTR
EQSTR:	LDA ANSN	;ARG1 is a String, see what ARG2 is
	CMP #STRING
	BEQ CMPSTR	;A String, so compare them
	CMP #LIST
	BEQ EQFFJ	;A List, we lose
	LDA ARG1
	PHA		;Save ARG1 through MAKE_PNAME
	LDA ARG1+1
	PHA
	LDX #ARG2
	LDY #TEMPN6
	JSR MAKPNM	;Otherwise, get its Pname
	LDA TEMPN6
	STA ARG2
	LDA TEMPN6+1
	STA ARG2+1
	PLA		;Retrieve ARG1
	STA ARG1+1
	PLA
	STA ARG1
CMPSTR:	LDY #$00
	LDA (ARG1),Y
	CMP (ARG2),Y
	BNE EQFFJ	;Lose if first bytes not equal
	TAX
	BEQ EQPOPJ	;Win if both zero (done)
	INY
	LDA (ARG1),Y
	CMP (ARG2),Y
	BNE EQFFJ	;Lose if second bytes not equal
	TAX
	BEQ EQPOPJ	;Win if both zero (done)
	INY
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	BNE CMPS1
	LDA (ARG2),Y
	BEQ EQPOPJ	;Win if both CDRs zero (done)
EQFFJ:	JMP EQFF	;Else lose if only one is (ARG1's)
CMPS1:	STX ARG1
	LDA (ARG2),Y
	BEQ EQFFJ	;Lose if only one is (ARG2's)
	TAX
	DEY
	LDA (ARG2),Y
	STA ARG2
	STX ARG2+1
	JMP CMPSTR
EQPOPJ:	JMP EQPOP

.PAGE
STO:	LDA GRPHCS
	BEQ STO2
	JSR RESETT
STO2:	LDA INPFLG
	BNE STO1
	JMP CHGST1	;Not in EDIT-eval loop, so call screen editor
STO1:	JSR DEFSTP	;In edit-eval loop
	INC DEFFLG
	LDA #TEMPX2	;FUN is TEMPX2
	LDX #ARG1
	JSR GETFUN
	LDA TEMPX2+1
	BEQ STO1A
	LDX #ARG1
	JSR UNFUNC
STO1A:	LDA #$00
	STA NARGS
	LDA TOKPTR
	STA MARK1
	LDA TOKPTR+1
	STA MARK1+1
	BEQ STOWE
STOW:	LDA TOKPTR+1
	BEQ STOWE
	LDY #$00
	LDA (TOKPTR),Y
	STA TEMPX2	;TEMPX2 is TOKEN
	INY
	LDA (TOKPTR),Y
	STA TEMPX2+1
STOW2:	LDX #TEMPX2
	JSR GETTYP
	CMP #ATOM
	BEQ STOW3
	CMP #SATOM
	BEQ STOW3
	CMP #DATOM
	BEQ STOW3
	LDX #TEMPX2
	JMP ERXWTY
STOW3:	LDX #TOKPTR
	JSR TTKADV
	INC NARGS
	BNE STOW
	JMP EXCED
STOWE:	LDX #$00
	STX TEMPX1+1
	LDA #DEFBOD
	STA ANSN
	TXA		;(Type LIST)
	LDY #MARK1
	JSR CONS
	LDY #DEFBOD
	LDX #DEFATM
	LDA NARGS
	STA TEMPX1
	LDA #TEMPX1
	JSR PTFTXT
	JMP POPJ
.PAGE
SEND:	LDA DEFFLG
	BNE SEND1	;if edit switch off, give error
	LDA #XNED
	JMP ERROR
SEND1:	LDA #DEFATM
	LDX #DEFBOD
	JSR STUFF	;try to put the function def together
	LDA #$00
	LDX #DEFATM
	JSR LTYPE
	LDX #SENDM&$FF	;" DEFINED"
	LDY #SENDM^
	JSR PRTSTR
SEND2:	JSR EXTDEF
	JMP POPJ
.PAGE
SPO:	LDA TOKPTR+1
	BNE SPO1
	LDA PODEFL+1
	BNE SPO1A
	JMP POPJ
SPO1:	LDY #$00
	LDA (TOKPTR),Y
	STA ARG1
	INY
	LDA (TOKPTR),Y
	STA ARG1+1
	LDX #TOKPTR
	JSR TTKADV
	LDX ARG1
	LDY ARG1+1
	CPX ALL
	BNE SPO2
	CPY ALL+1
	BNE SPO2
	LDA #$01
	JSR POFUNS
SPON:	LDA #$01
	JSR PONAMS
	JMP POPJ
SPO2:	CPX NAMES
	BNE SPO3
	CPY NAMES+1
	BEQ SPON
SPO3:	CPX TITLES
	BNE SPO4
	CPY TITLES+1
	BNE SPO4
SPOTS:	LDA #$00
	JSR POFUNS
	JMP POPJ
SPO5A:	LDA ARG1
	STA PODEFL
	LDA ARG1+1
	STA PODEFL+1
SPO1A:	LDX #PODEFL
	LDA #TEMPN1
	JSR GETFUN
	LDA TEMPN1+1
	BEQ PFERR
	LDX #$01
	LDA #PODEFL
	JSR POFUN
	JMP POPJ
SPO4:	CPX PROCS
	BNE SPO5
	CPY PROCS+1
	BNE SPO5
	LDA #$01
	JSR POFUNS
	JMP POPJ
SPO5:	LDX #ARG1
	JSR GETTYP
	CMP #ATOM
	BEQ SPO5A
	CMP #SATOM
	BEQ ERXUBL
	JMP ERXWT1
ERXUBL:	LDY #ARG1
	LDA #XUBL
	JMP ERROR
PFERR:	LDY #PODEFL
	LDA #XNDF
	JMP ERROR
.PAGE
STRCBK:	LDA FRAME+1
	BNE TCBK1
	LDX #TBMSG1&$FF
	LDY #TBMSG1^
	JSR PRTSTR
	JMP TCBKWE
TCBK1:	LDX #TBMSG2&$FF
	LDY #TBMSG2^
	JSR PRTSTR
	LDA #$01
	STA ANSN1	;ANSN1 is FIRST
	LDA FRAME
	STA TEMPX1	;TEMPX1 is FR
	LDA FRAME+1
	STA TEMPX1+1
	LDA XFRAME
	STA TEMPX2	;TEMPX2 is XFR
	LDA XFRAME+1
	STA TEMPX2+1
TCBKW:	LDA TEMPX1+1
	BNE TCBKW1
	JMP TCBKWE
TCBKW1:	CLC
	LDA TEMPX1
	ADC #$0F	;Frame Bindings pointer is 15
	STA TEMPN6	;TEMPN6 is PTR
	LDA TEMPX1+1
	ADC #$00
	STA TEMPN6+1
	SEC
	LDA TEMPX2
	SBC #$02	;PTR1 (TEMPN7) points to top binding (name)
	STA TEMPN7
	LDA TEMPX2+1
	SBC #$00
	STA TEMPN7+1
TCBKX:	LDA TEMPN7+1
	CMP TEMPN6+1
	BCC TCBKXE
	BNE TCBKX1
	LDA TEMPN7
	CMP TEMPN6
	BCC TCBKXE
TCBKX1:	LDY #$00
	LDA (TEMPN7),Y
	STA TEMPNH
	INY
	LDA (TEMPN7),Y
	STA TEMPNH+1
	LDA TEMPNH
	ROR A
	BCC TCBKX2
	LDA ANSN1
	BNE TCBKX3
	LDA #',
	JSR TPCHR
	LDA #$20
	JSR TPCHR
	JMP TCBKX4
TCBKX3:	DEC ANSN1
TCBKX4:	LDY #$05
	LDA (TEMPNH),Y
	STA TEMPN8
	INY
	LDA (TEMPNH),Y
	STA TEMPN8+1
	LDA #$00
	LDX #TEMPN8
	JSR LTYPE
TCBKX2:	SEC
	LDA TEMPN7
	SBC #$04
	STA TEMPN7
	BCS TCBKX
	DEC TEMPN7+1
	JMP TCBKX
TCBKXE:	LDY #$03	;Frame Xframe pointer is 2
	LDA (TEMPX1),Y
	STA TEMPX2+1
	DEY
	LDA (TEMPX1),Y
	STA TEMPX2
	DEY		;Frame Previous-frame pointer is 0
	LDA (TEMPX1),Y
	TAX
	DEY
	LDA (TEMPX1),Y
	STA TEMPX1
	STX TEMPX1+1
	JMP TCBKW
TCBKWE:	JSR BREAK1
	JMP POPJ
.PAGE
SERASE:	LDA TOKPTR+1
	BNE SERAS1
	JMP ERXEOL
SERAS1:	LDY #$00
	LDA (TOKPTR),Y
	STA ARG1
	INY
	LDA (TOKPTR),Y
	STA ARG1+1
	LDX #TOKPTR
	JSR TTKADV
	LDX ARG1
	LDY ARG1+1
	CPX ALL
	BNE ECMP2
	CPY ALL+1
	BNE ECMP2
	JSR REINIT
	JMP TOPLOP
ECMP2:	CPX NAMES
	BNE ECMP3
	CPY NAMES+1
	BNE ECMP3
	JSR ERNAMS
	JMP POPJ
ECMP3:	CPX TITLES
	BNE ECMP4
	CPY TITLES+1
	BEQ SERPS
ECMP4:	CPX PROCS
	BNE SERAP
	CPY PROCS+1
	BNE SERAP
SERPS:	JSR ERPROS
	JMP POPJ
SERAP:	LDX #ARG1
	JSR GETTYP
	CMP #ATOM
	BNE SERAR2
	LDX #ARG1
	JSR UNFUNC
	JMP POPJ
SERAR2:	JMP ERXWT1
.PAGE
ERPROS:	LDA OBLIST
	STA TEMPN
	LDA OBLIST+1
	STA TEMPN+1
ERPRSW:	LDA TEMPN+1
	BEQ RTS30
	LDY #$00
	LDA (TEMPN),Y
	STA TEMPN1
	INY
	LDA (TEMPN),Y
	STA TEMPN1+1
	INY
	LDA (TEMPN),Y
	TAX
	INY
	LDA (TEMPN),Y
	STA TEMPN+1
	STX TEMPN
	LDX #TEMPN1
	JSR UNFUNC
	JMP ERPRSW
RTS30:	RTS
.PAGE
ERNAMS:	LDA OBLIST
	STA TEMPN
	LDA OBLIST+1
	STA TEMPN+1	;TEMPN is OBLIST pointer
	LDX #$00
	STX TEMPN1+1	;TEMPN1 is NOVALUE
	INX
	STX TEMPN1
ERNMSW:	LDA TEMPN+1
	BEQ ERNMWE
	LDY #$00
	LDA (TEMPN),Y
	STA TEMPN2	;TEMPN2 is NAME
	INY
	LDA (TEMPN),Y
	STA TEMPN2+1
	INY
	LDA (TEMPN),Y
	TAX
	INY
	LDA (TEMPN),Y
	STA TEMPN+1
	STX TEMPN
	LDX #TEMPN1
	LDY #TEMPN2
	JSR PUTVAL
	JMP ERNMSW
ERNMWE:	LDA SOBLST
	STA TEMPN
	LDA SOBLST+1
	STA TEMPN+1
ERNMX:	LDA TEMPN
	CMP SOBTOP
	BNE ERNMX1
	LDA TEMPN+1
	CMP SOBTOP+1
	BEQ RTS30
ERNMX1:	LDX #TEMPN1
	LDY #TEMPN
	JSR PUTVAL
	CLC
	LDA TEMPN
	ADC #$04
	STA TEMPN
	BCC ERNMX
	INC TEMPN+1
	JMP ERNMX
.PAGE
SDEP:	JSR GT1FIX
	LDX #NARG1
	JSR CHKINT
	BCS SRANDR
	TAX
	BMI SRANDR
	LDY #$00
	LDA (NARG1),Y
	STA NARG1
	STY NARG1+1
	STY NARG1+2
	STY NARG1+3
	LDY #NARG1
	JMP OTPFX1

SEXAM:	JSR GT2FIX	;First argument is location
	LDX #NARG1
	JSR CHKINT
	BCS SRANDR
	TAX
	BMI SRANDR
	LDX #NARG2
	JSR CHKINT
	BCS SPKERR
	TAX
	BMI SPKERR
	LDA NARG2+1
	BNE SPKERR
	LDY #$00
	LDA NARG2
	STA (NARG1),Y
	JMP POPJ
SPKERR:	JMP GTERR2	;Error, ARG2 too big
SRANDR:	JMP GTERR1
.PAGE
SRANDM:	JSR GT1FIX
	LDA NARG1+3
	BNE SRANDR	;Can't be negative or more than 16 bits
	LDA NARG1+2
	BNE SRANDR
	LDA NARG1
	STA TEMPN3	;Save Range
	LDA NARG1+1
	STA TEMPN3+1
	LDA #RANDA&$FF	;Multiply 16-bit Random number by
	STA NARG2	;transform constant "A"
	LDA #RANDA^
	STA NARG2+1
	LDA RANDOM
	STA NARG1
	LDA RANDOM+1
	STA NARG1+1
	LDA #$00
	STA NARG1+2
	STA NARG1+3
	STA NARG2+2
	STA NARG2+3
	JSR IMULT
	CLC
	LDA TEMPN
	ADC #RANDC&$FF	;Add transform constant "C"
	STA RANDOM
	STA NARG1
	LDA TEMPN+1
	ADC #RANDC^
	STA RANDOM+1
	STA NARG1+1
	LDA TEMPN3
	STA NARG2
	LDA TEMPN3+1
	STA NARG2+1
	LDA #$00
	STA NARG1+2
	STA NARG1+3
	STA NARG2+2
	STA NARG2+3
	JSR IMULT
	LDA #$00
	STA TEMPN2
	STA TEMPN2+1
	LDY #TEMPN1
	JMP OTPFIX
.PAGE
SRNDMZ:	LDA RNDL
	STA RANDOM
	LDA RNDH
	STA RANDOM+1
	JMP POPJ

SREADC:	JSR RDKEY
	STA TEMPN
	LDA #ARG1
	STA ANSN
	LDY #TEMPN
	LDX #$00
	STX TEMPN+1
	LDA #STRING	;(String typecode)
	JSR CONS	;Cons a cell with the character in it
	JMP OTPRG1	;And output it

SCURSR:	JSR GT2FIX
	LDX #NARG1
	JSR CHKINT
	BCS SCRSR1
	TAX
	BMI SCRSR1
	LDX #NARG2
	JSR CHKINT
	BCS SCRSR1
	TAX
	BMI SCRSR1
	LDA NARG1+1	;Horizontal position 0 - 39.
	BNE SCRSR1
	LDA NARG1
	CMP #$29
	BCS SCRSR1
	LDA NARG2+1	;Vertical position 0 - 23.
	BNE SCRSR1
	LDA NARG2
	CMP #$19
	BCS SCRSR1
	LDA NARG1
	STA CH
	LDA NARG2
	STA CV
	JSR BCALCA
SCALL1:	JMP POPJ
SINDXR:	LDY #CURTOK
	LDA #XUBL
	JMP ERROR
SCRSR1:	LDA #XCRSR	;"Position off of screen"
	JMP ERROR
.PAGE
SCALLR	=SCALL1-1

SCALL:	JSR GT1FIX
	LDX #NARG1
	JSR CHKINT
	BCS SCALL2
	TAX
	BMI SCALL2
	LDA #SCALLR^
	PHA		;Push return address for RTS
	LDA #SCALLR&$FF
	PHA
	JMP (NARG1)
SCALL2:	JMP GTERR1
.PAGE
SCLINP:	JSR CLRCBF	;Clear input buffer and character strobe
	JMP POPJ

SCLEAR:	JSR HOME
	JMP POPJ
.PAGE
.IFNE GRPINC	;Include Graphics if GRPINC nonzero

;	Turtle-Graphics Primitives:

SDRAW:	LDA GRPHCS
	BNE SCSA
	JSR SDRAW1
	JMP POPJ
SCSA:	JSR SCS1
	JMP POPJ

SNDSPL:	JSR RESETT	;Nodisplay, get the text page back
	LDA #$00
	STA GRPHCS
	JMP POPJ

SPENUP:	JSR GCHK
	LDA #$00	;Penup
	BEQ STPEN	;(Always)

SPENDN:	JSR GCHK
	LDA #$01	;Pendown
STPEN:	STA PEN
	JMP POPJ

SHOME:	JSR GCHK
	JSR GSHWT1	;Erase turtle if it's there
	JSR TTLHOM
	JSR GETX
	JSR GETY
	JSR GDLINE
	JMP POPJ

SXCOR:	JSR GCHK	;Xcor
	LDY #XCOR
	JMP OTPFLO

SYCOR:	JSR GCHK	;Ycor
	LDY #YCOR
	JMP OTPFLO

SHDING:	JSR GCHK	;Heading
	LDY #HEADNG
	JMP OTPFLO
.PAGE
SRT:	JSR GCHK
	JSR GT1NUM
	BCS SRT1
	JSR FLOTN1
SRT1:	LDY #HEADNG
	JSR XYTON2
	JSR FADD
	JSR GSETHX
	JSR HDNDON
	JMP STRTTL

SLT:	JSR GCHK
	JSR GT1NUM
	BCS SLT1
	JSR FLOTN1
SLT1:	LDY #HEADNG
	JSR XYTON2
	JSR FSUBX
	JSR GSETHX
	JSR HDNDON
	JMP STRTTL

STS:	JSR GCHK	;Turtlestate
	LDA #$00
	STA MARK1
	STA MARK1+1
	LDA TSHOWN
	JSR CONSTF
	LDA PEN
	JSR CONSTF
	LDA #HEADNG
	JSR CONSNM
	LDA #YCOR
	JSR CONSNM
	LDA #XCOR
	JSR CONSNM
	LDX #MARK1
	JSR VPUSHP
	INC OTPUTN
	LDA #$00
	STA MARK1
	STA MARK1+1
	JMP POPJ
.PAGE
SSETX:	JSR GCHK
	LDX #NARG1
	JSR VPOP
	JSR GSETX
	JSR XOK
	JSR GSHWT1
	JSR GETY
	JSR GDLINE
	JMP POPJ

SSETY:	JSR GCHK
	LDX #NARG1
	JSR VPOP
	JSR GSETY
	JSR YOK
	JSR GSHWT1
	JSR GETX
	JSR GDLINE
	JMP POPJ

SSETXY:	JSR GCHK
	LDX #TEMPX2
	JSR VPOP
	LDX #NARG1
	JSR VPOP
	JSR GSETX
	LDA TEMPX2
	STA NARG1
	LDA TEMPX2+1
	STA NARG1+1
	JSR GSETY
	JSR XOK
	JSR YOK
	JSR GSHWT1
	JSR GDLINE
	JMP POPJ

SSETH:	JSR GCHK
	LDX #NARG1
	JSR VPOP
	JSR GSETH
	JSR HDNDON
STRTTL:	JSR GSHWT1
	JSR HOK
	JSR GSHWT1
	JMP POPJ
.PAGE
SSETT:	JSR GCHK
	LDX #TEMPX2
	JSR VPOP	;Setturtle
	JSR GETTYP
	CMP #LIST
	BNE SSETTR
	LDA #$FB	;Index for dispatching
	STA ANSN4
SSETTL:	LDA TEMPX2+1
	BEQ SSETTD
	JSR SSTTLL
	INC ANSN4
	BNE SSETTL
SSETTD:	JSR GSHWT1
	JSR HOK
	JSR XOK
	JSR YOK
	LDA SPEN
	STA PEN
	JSR GDLINE
	JMP POPJ
SSETTR:	JMP ERXWT1	;Error XWTA,ARG1,CURTOK

SSHOWT:	JSR GCHK
	LDA TSHOWN
	BNE SSHWTR
	INC TSHOWN
	JSR DRWTTL
SSHWTR:	JMP POPJ

SHIDET:	JSR GCHK
	LDA TSHOWN
	BEQ SSHWTR
	DEC TSHOWN
	JSR DRWTTL
	JMP POPJ

SFULL:	JSR GCHK
	LDA FULLGR
	JMP POPJ

SMIX:	JSR GCHK
	LDA MIXGR
	JMP POPJ
.PAGE
SFD:	JSR GCHK
	JSR GT1NUM
	BCS SFD1
	JSR FLOTN1
SFD1:	JSR SFDX
	JSR GSHWT1
	JSR XOK
	JSR YOK
	JSR GDLINE
	JMP POPJ

SBK:	JSR GCHK
	JSR GT1NUM
	BCS SBK1
	JSR FLOTN1
SBK1:	JSR FCOMPL
	JSR SFDX
	JSR GSHWT1
	JSR XOK
	JSR YOK
	JSR GDLINE
	JMP POPJ
.PAGE
.SBTTL	Turtle-Graphics Utility Routines:
GCHK:	LDA INPFLG
	BNE GRIGN	;Ignore primitive if in eval-loop
	LDA GRPHCS	;Checks to see if Graphics mode
	BNE XRDR
SDRAW1:	LDA #$7F
	STA HCOLOR	;Color is "White1"
	JSR NOEDBF      ;buffer is not retrievable.
	LDA GPAGE
	LDA HGSW
	LDA MIXGR
	LDA GSW
	LDA #$14
	STA WNDTOP	;Set for 4 lines text
	JSR HOME
	INC GRPHCS	;Indicate Graphics mode
	LDA #$01
	STA PEN
	STA TSHOWN	;turtle shown
SCS1:	JSR TTLHOM
	JSR GETX
	JSR GETY
	JSR GPOSN	;Set initial POSN point for future GLINE's
	JSR HCLR
	JMP GSHWT1
GRIGN:	JMP POPJ

TTLHOM:	LDA #$00	;NOTE: XCOR,YCOR,HEADNG must be contiguous
	LDX #$0B
TTLL1:	STA XCOR,X
	DEX
	BPL TTLL1
XRDR:	RTS
.PAGE
CONSTF:	BNE CNSTF1
	LDY #LFALSE
	BNE CNSNM1	;(Always)
CNSTF1:	LDY #LTRUE
	BNE CNSNM1	;(Always)
CONSNM:	TAX
	TAY
	INX
	INX
	LDA #TEMPX1
	STA ANSN
	LDA #FLO
	JSR CONS	;CONS the number
	LDY #TEMPX1
CNSNM1:	LDX #MARK1
	STX ANSN
	LDA #LIST
	JMP CONS	;CONS the node

SSTTLL:	LDY #$00
	LDA (TEMPX2),Y
	STA ARG1
	INY
	LDA (TEMPX2),Y
	STA ARG1+1
	INY
	LDA (TEMPX2),Y
	TAX
	INY
	LDA (TEMPX2),Y
	STA TEMPX2+1
	STX TEMPX2
	LDX #ARG1
	LDY ANSN4
	INY
	BEQ SSTTS
	INY
	BEQ SSTTP
	INY
	BEQ GSETHJ
	INY
	BEQ GSETY
	BNE GSETX	;(Always)
GSETHJ:	JSR GSETH
	JMP HDNDON
SSTTS:	JSR GTBOOL
	INY
	TYA
	AND #$01
	STA TSHOWN
	RTS
SSTTP:	JSR GTBOOL
	INY
	TYA
	AND #$01
	STA SPEN
	RTS
.PAGE
GSETX:	JSR GT1NMX	;Set X
	BCS XCHK
	JSR FLOTN1
XCHK:	LDX #$03
XCHKL:	LDA NARG1,X
	STA SVXCOR,X
	DEX
	BPL XCHKL
	JSR RNDN1
	LDX #NARG1
	JSR CHKINT
	BCS ERXOOB
	TAX
	BMI XCHKM
	LDA NARG1+1
	BNE ERXOOB
	LDA NARG1
	CMP #$8C	;Must be <140.
	BCC STOX
	BCS ERXOOB
XCHKM:	LDA NARG1+1
	CMP #$FF
	BNE ERXOOB
	LDA NARG1
	CMP #$74	;Must be >=-140.
	BCC ERXOOB
STOX:	LDA NARG1
	STA EPOINT
	LDA NARG1+1
	STA EPOINT+1
	RTS

GSETY:	JSR GT1NMX	;Set Y
	BCS YCHK
	JSR FLOTN1
YCHK:	LDX #$03
YCHKL:	LDA NARG1,X
	STA SVYCOR,X
	LDA GRPHK1,X
	STA NARG2,X
	DEX
	BPL YCHKL
	JSR FMUL	;First multiply by 0.8
	JSR RNDN1
	LDX #NARG1
	JSR CHKINT
	BCS ERXOOB
	TAX
	BMI YCHKM
	LDA NARG1+1
	BNE ERXOOB
	LDA NARG1
	CMP #$60	;Must be <96.
	BCC STOY
ERXOOB:	LDA #XOOB	;Error "Out of Bounds"
	JMP ERROR
YCHKM:	LDA NARG1+1
	CMP #$FF
	BNE ERXOOB
	LDA NARG1
	CMP #$A0	;Must be >=-96.
	BCC ERXOOB
STOY:	LDA NARG1
	STA A5L
	RTS
.PAGE
XOK:	LDX #$03
XOKL:	LDA SVXCOR,X
	STA XCOR,X
	DEX
	BPL XOKL
	RTS

YOK:	LDX #$03
YOKL:	LDA SVYCOR,X
	STA YCOR,X
	DEX
	BPL YOKL
	RTS

HOK:	LDX #$03
HOKL:	LDA SHEDNG,X
	STA HEADNG,X
	DEX
	BPL HOKL
	RTS
.PAGE
GSETH:	JSR GT1NMX	;Setheading
	BCS GSETH1
	JSR FLOTN1
GSETH1:	JMP GSETHX	;bashes the flonum in narg1 (heading) to between 0 and 360.

	
HDNDON:	LDX #$03
HDNL:	LDA NARG1,X
	STA SHEDNG,X
	DEX
	BPL HDNL
	RTS
.PAGE
GDLINE:	LDA PEN
	BNE GDLIN1
	JSR GPOSN	;Just do a GPOSN if pen is up
        JMP GSHWT1
GDLIN1:	JSR GLINE
	;falls through

;now draw the turtle if it is being shown
	;falls in
GSHWT1:	LDA TSHOWN	;If the turtle isn't shown, exit.
	BNE DRWTTL	
GSHWTR:	RTS

	;this draws the whole turtle (both box and pointer)
DRWTTL:	LDY #HEADNG
	JSR XYTON1	;Get heading in NARG1
	LDA Y0		;Save enpoint state
	PHA
	LDA X0L
	PHA
	LDA X0H
	PHA
	LDX #$03
DRWL1:	LDA FROTK1,X	;Get shift factor (2.5) in NARG2
	STA NARG2,X
	DEX
	BPL DRWL1
	JSR FADD	;Shift turtle over 2.5 degrees
	JSR RNDN1	;Get the heading as a rounded integer
	LDA #$05
	JSR XDVDX	;Divide by 5 to get shape number
	LDX #$FF	;Quadrant counter
	LDA NARG1
	SEC
DRWL2:	INX		;indicate next quadrant
	SBC #$12	;See if it's smaller than 18. yet
	BCS DRWL2	;Nope, subtract 18.
	ADC #$12	;OK, add last subtraction back in
	ASL A		;Shift left to get table index
	TAY
	LDA GETRM2	;Enable bank 2 RAM
	LDA SHPTBL,Y
	STA SHAPE
	LDA SHPTBL+1,Y
	STA SHAPE+1
	LDA GETRM1	;Disable bank 2 RAM
	LDA GETRM1
	TXA		;Quadrant
	ASL A
	ASL A
	ASL A
	ASL A		;Multiply quadrant index by 4 to get rotation factor
	LDX #$01		;scale
	STX TEMPN
	JSR XDRAW	;called with vA = ROT, shape addr. in SHAPE, scale in TEMPN
	PLA		;(X0H)
	TAY
	PLA		;(X0L)
	TAX
	PLA		;(Y0)
	JMP HPOSN	;Re-position at endpoint
.PAGE
SFDX:	LDY #TEMPX1
	JSR XN1TOY	;Save Length in TEMPX1,2
	JSR GETHED
	LDA NARG1
	PHA		;Save table index
	JSR MULSIN
	LDY #TEMPN7
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #TEMPN5
	JSR XYTON2	;Get uncorrected table value...
	JSR FADD	;and correct it!
	LDY #TEMPX1
	JSR XYTON2	;Get length back
	JSR FMUL	;Multiply Length by fraction
	LDA ANSN1	;X-Incr. sign
	BEQ SFDP1
	JSR FCOMPL
SFDP1:	LDY #XCOR	;Get XCOR in NARG2
	JSR XYTON2
	JSR FADD
	JSR XCHK
	PLA		;Retrieve NARG1
	STA NARG1
	JSR MULCOS
	LDY #TEMPN7
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #TEMPN3
	JSR XYTON2	;Get uncorrected table value...
	JSR FSUBX	;and correct it!
	LDY #TEMPX1
	JSR XYTON2	;Get length back
	JSR FMUL	;Multiply Length by fraction
	LDA ANSN2	;Y-Incr. sign
	BEQ SFDP2
	JSR FCOMPL
SFDP2:	LDY #YCOR
	JSR XYTON2	;Get YCOR in NARG2
	JSR FADD	;Add YCOR and NARG1 (Y-incr.)
	JMP YCHK
.PAGE
GETHED:	LDY #HEADNG
	JSR XYTON2	;Get HEADING in NARG2
	LDY #HEADNG
	JSR XYTON1	;And in NARG1
	JMP GETHS

GETX:	LDY #XCOR
	JSR XYTON1
	JSR RNDN1
	JMP STOX

GETY:	LDY #YCOR
	JSR XYTON1
	LDX #$03
GTYL1:	LDA GRPHK1,X
	STA NARG2,X
	DEX
	BPL GTYL1
	JSR FMUL
	JSR RNDN1
	JMP STOY

GNORM:	SEC
	LDA #$60
	SBC A5L		;Subtract Ycoord from 96.
	STA NARG2
	CLC
	LDA EPOINT
	ADC #$8C	;Add 140. to Xcoord
	STA NARG2+2
	LDA EPOINT+1
	ADC #$00
	STA NARG2+3
	RTS
.PAGE
;Lowest-level graphics routines:

HCOLR1	=TEMPN3		;Interface labels to temporaries
COUNTH	=TEMPN3+1
DXL	=TEMPN5
DXH	=TEMPN5+1
DY	=TEMPN6
QDRNT	=TEMPN6+1
EL	=TEMPN7
EH	=TEMPN7+1
SHAPEX	=ANSN2

HCLR:	LDA #$00	;CLEAR Routine
	STA HCOLR1
	LDA #$20
	STA SHAPE+1
	LDY #$00
	STY SHAPE
BKGND1:	LDA HCOLR1
	STA (SHAPE),Y
	JSR CSHFT2
	INY
	BNE BKGND1
	INC SHAPE+1
	LDA SHAPE+1
	AND #$1F
	BNE BKGND1
	RTS

GPOSN:	JSR GNORM
	LDX NARG2+2
	LDY NARG2+3
	LDA NARG2
HPOSN:	STA Y0
	STX X0L
	STY X0H
	PHA
	AND #$C0
	STA HBASLN
	LSR A
	LSR A
	ORA HBASLN
	STA HBASLN
	PLA
	STA HBASLN+1
	ASL A
	ASL A
	ASL A
	ROL HBASLN+1
	ASL A
	ROL HBASLN+1
	ASL A
	ROR HBASLN
	LDA HBASLN+1
	AND #$1F
	ORA #$20
	STA HBASLN+1
	TXA
	CPY #$00
	BEQ HPOSN2
	LDY #$23
	ADC #$04
HPOSN1:	INY
HPOSN2:	SBC #$07
	BCS HPOSN1
	STY HNDX
	TAX
	LDA MSKTBL-249,X
	STA HMASK
	TYA
	LSR A
	LDA HCOLOR
HPOSN3:	STA HCOLR1
	BCS CSHFT2
	RTS
LFTRT:	BPL RIGHT
	LDA HMASK
	LSR A
	BCS LEFT1
	EOR #$C0
LR1:	STA HMASK
	RTS
LEFT1:	DEY
	BPL LEFT2
	LDY #$27
LEFT2:	LDA #$C0
NEWNDX:	STA HMASK
	STY HNDX
	LDA HCOLR1
CSHFT2:	ASL A
	CMP #$C0
	BPL GRTS1
	LDA HCOLR1
	EOR #$7F
	STA HCOLR1
GRTS1:	RTS
RIGHT:	LDA HMASK
	ASL A
	EOR #$80
	BMI LR1
	LDA #$81
	INY
	CPY #$28
	BCC NEWNDX
	LDY #$00
	BCS NEWNDX	;(Always taken)
.PAGE
LRUDX1:	CLC
LRUDX2:	LDA SHAPEX
	AND #$04
	BEQ LRUD4
	LDA #$7F	;XOR Mode, HMASK bit gets reversed on screen
	AND HMASK
	EOR (HBASLN),Y
	STA (HBASLN),Y
LRUD4:	LDA SHAPEX
	ADC QDRNT
EQ3:	AND #$03
	CMP #$02
	ROR A
	BCS LFTRT
UPDWN:	BMI DOWN4
	CLC
	LDA HBASLN+1
	BIT EQ1C
	BNE UP4
	ASL HBASLN
	BCS UP2
	BIT EQ3+1
	BEQ UP1
	ADC #$1F
	SEC
	BCS UP3		;(Always taken)
UP1:	ADC #$23
	PHA
	LDA HBASLN
	ADC #$B0
	BCS UP5
	ADC #$F0
UP5:	STA HBASLN
	PLA
	BCS UP3
UP2:	ADC #$1F
UP3:	ROR HBASLN
UP4:	ADC #$FC
UPDWN1:	STA HBASLN+1
	RTS
DOWN4:	LDA HBASLN+1
EQ4:	ADC #$04
	BIT EQ1C
	BNE UPDWN1
	ASL HBASLN
	BCC DOWN1
	ADC #$E0
	CLC
	BIT EQ4+1
	BEQ DOWN2
	LDA HBASLN
	ADC #$50
	EOR #$F0
	BEQ DOWN3
	EOR #$F0
DOWN3:	STA HBASLN
	LDA #$20
	BCC DOWN2
DOWN1:	ADC #$E0
DOWN2:	ROR HBASLN
	BCC UPDWN1	;(Always branches)
.PAGE
GLINE:	JSR GNORM
	LDA HNDX
	LSR A
	LDA HCOLOR
	JSR HPOSN3
	LDX NARG2+3
	LDA NARG2+2
	LDY NARG2
	PHA
	SEC
	SBC X0L
	PHA
	TXA
	SBC X0H
	STA QDRNT
	BCS HLIN2
	PLA
	EOR #$FF
	ADC #$01
	PHA
	LDA #$00
	SBC QDRNT
HLIN2:	STA DXH
	STA EH
	PLA
	STA DXL
	STA EL
	PLA
	STA X0L
	STX X0H
	TYA
	CLC
	SBC Y0
	BCC HLIN3
	EOR #$FF
	ADC #$FE
HLIN3:	STA DY
	STY Y0
	ROR QDRNT
	SEC
	SBC DXL
	TAX
	LDA #$FF
	SBC DXH
	STA COUNTH
	LDY HNDX
	BCS MOVEX2	;(Always taken)
MOVEX:	ASL A
	JSR LFTRT
	SEC
MOVEX2:	LDA EL
	ADC DY
	STA EL
	LDA EH
	SBC #$00
HCOUNT:	STA EH
	LDA HMASK
	AND #$7F
	ORA (HBASLN),Y	;Set the right bit
	STA (HBASLN),Y	;and store the new byte
	INX
	BNE HLIN4
	INC COUNTH
	BNE HLIN4
	RTS
HLIN4:	LDA QDRNT
	BCS MOVEX
	JSR UPDWN
	CLC
	LDA EL
	ADC DXL
	STA EL
	LDA EH
	ADC DXH
	BVC HCOUNT	;(Always taken)
.PAGE
MSKTBL:	$81
	$82
	$84
	$88
	$90
	$A0
	$C0

EQ1C:	$1C

COS:	$FF
	$FE
	$FA
	$F4
	$EC
	$E1
	$D4
	$C5
	$B4
	$A1
	$8D
	$78
	$61
	$49
	$31
	$18
	$FF
.PAGE
XDRAW:	TAX	;Enter with ROT in vA, shape addr. in SHAPE
	LSR A
	LSR A
	LSR A
	LSR A
	STA QDRNT
	TXA
	AND #$0F
	TAX
	LDY COS,X
	STY DXL
	EOR #$0F
	TAX
	LDY COS+1,X
	INY
	STY DY
XDRAW2:	LDY HNDX
	LDX #$00
	LDA GETRM2	;Enable bank 2 ghost-memory
	LDA (SHAPE,X)
	BNE XDRAW3
	RTS
XDRAW3:	STA SHAPEX
	LDA GETRM1	;Re-enable bank 1 ghost-memory
	LDA GETRM1
	LDX #$80
	STX EL
	STX EH
	LDX TEMPN	;SCALE
XDRAW4:	LDA EL
	SEC
	ADC DXL
	STA EL
	BCC XDRAW5
	JSR LRUDX1
	CLC
XDRAW5:	LDA EH
	ADC DY
	STA EH
	BCC XDRAW6
	JSR LRUDX2
XDRAW6:	DEX
	BNE XDRAW4
	LDA SHAPEX
	LSR A
	LSR A
	LSR A
	BNE XDRAW3
	INC SHAPE
	BNE XDRAW7
	INC SHAPE+1
XDRAW7:	LDA GETRM2	;Enable bank 2 ghost-memory
	LDA (SHAPE,X)
	BNE XDRAW3
	LDA GETRM1	;Re-enable bank 1 ghost-memory
	LDA GETRM1
	RTS
.PAGE
.ENDC		;End of conditional graphics inclusion
.IFEQ GRPINC	;If no graphics, uses dummy functions
SDRAW	=.
SNDSPL	=.
SPENUP	=.
SPENDN	=.
SHOME	=.
SXCOR	=.
SYCOR	=.
SHDING	=.
SRT	=.
SLT	=.
STS	=.
SSETX	=.
SSETY	=.
SSETXY	=.
SSETH	=.
SSETT	=.
SSHOWT	=.
SHIDET	=.
SFULL	=.
SMIX	=.
SFD	=.
SBK:	LDY #CURTOK
	LDA #XNOMUS
	JMP ERROR
.ENDC		;End of dummy graphics commands
.PAGE
.SBTTL	Music Routines

PSIZE	=TEMPN3			;length of all parameter buffers together.
MBUFLN	=TEMPN2			;length of each music buffer.
MPPRT	=TEMPX2			;needed only during the scope of PM.
COUNT	=TEMPX2+1		;used in NVOICES as a temporary.
;

;The following location should be advertised, and a .DEPOSIT done to
;reset it if the music card isn't in slot 4.
SLOT:	$4*$10			;16 times the expansion slot the ALF card is in.

;These are the codes for the commands that are stored in the music buffers.
;All have the msb set.
HINOTE	=71			;Yes, decimal.
CREST	=HINOTE+1

.PAGE
	;Logo Music initialization.

;Make the ALF card be quiet. It makes random noise on power up.
;INITLZ calls this routine.
;Reset the device by sending a "set volume 0" byte  to each stereo
;position of each channel. Then send a mode control byte of $E7
;to each stereo position. (Don't ask me what that means. I don't know.)
QUIETM:	LDA #$80
	CLC
	ADC SLOT
	STA TEMPN1
	LDA #$C0
	ADC #$00
	STA TEMPN1+1
	LDY #$00
QMPLUP:	LDA #$9F		;Starting volume setting for each stereo pos.
	CLC
QMCLUP:	JSR ALFWAT		;need to wait for the ALF
	STA (TEMPN1),Y		;TELL CHANNEL SETVOLUME 0
	ADC #$20		;next channel.
	BCC QMCLUP		;when we get past $FF, it's done.
	LDA #$E7		;mode control byte for stereo pos.
	JSR ALFWAT
	STA (TEMPN1),Y
	INY
	CPY #$03                ;stereo pos. numbers are 0,1,2.
	BNE QMPLUP		;next stereo position.
	RTS
.PAGE
;Check to see if in music mode. If not, error out to top level.
;Otherwise return.
MUSICP:	LDA NPARTS
	BEQ NOTMUS
	RTS
NOTMUS:	LDA #XNTMUS
	JMP ERROR               ;error restores the stack.

;cretinous ALF needs 18 cycle wait between frobbing it
;THE JSR and RTS use up 6 cycles each
ALFWAT: NOP
	NOP
	NOP
	RTS    

;Here are the fake music primitives.
.IFEQ MUSINC
SNVOIC	=.
SNOTE	=.
SADSR	=.
SGAP	=.
SPLAYM	=.
SVOICE	=.
SVOL	=.
SSAVEM:	LDY #CURTOK
	LDA #XNOMUS
	JMP ERROR
.ENDC				;end of fake music primitives.
.PAGE
.IFNE MUSINC
	;Music buffer configuration section
MJPOPJ:	JMP POPJ
NVERR:	JMP GTERR1		;the error was in the first arg.
SNVOIC:	JSR GT1FIX
	LDX #NARG1
	JSR CHKINT
	BCS NVERR
	TAX
	BMI NVERR
	LDA NARG1+1
	BNE NVERR
	LDA NARG1
	BEQ NVERR
	CMP #$07	;maximum 6 voices (for now)
	BCS NVERR
;A is a number 1-9, the number of parts.
	STA NPARTS
;Just exit if in the editor.
	LDA INPFLG
	BNE MJPOPJ	;ignored inside editor.
	JSR NOEDBF      ;tell editor we've clobbered the buffer.
;calculate size of parameter table by multiplying the number by
;the size of the parameter table.
	LDX NPARTS
	LDA #$00
	STA MEACTP
	STA PARPNT
	CLC
MULUP:	ADC #PARSIZ
	DEX
	BNE MULUP
	STA PSIZE	
;now A contains the length of the entire parameter area.
;Put starting address of first PARAMETER AREA into PARPNT. -- $2000. Increment is #PARSIZ
;Put starting address of first MUSIC BUFFER into PARMBS. -- $2000+PSIZE. Increment is MBUFLN.
;Put it in PARMBV also, so PLAYMUSIC can restore it.
;Note that the parameter area may not be >255 bytes.
	STA PENXT      ;pointer to place where next note should be put
	STA PSTART      ;pointer to beginning of part buffer
	LDA #$20		;this sets up the high byte of these.
	STA PENXT+1
	STA PSTART+1
	STA PARPNT+1		;initially points to beginning of
				;hi-res graphics page.
;PARPNT points to the first parameter table. PSTART points to the first
;music buffer. It shouldn't be touched in entry. PENXT is the register
;to use for pointing to the next place when entering music.

;Figure the length of the music buffers -- <$4000-(PSTART)>/(NPARTS)
	SEC
	LDA #$00
	STA NARG2+1		;this is the zero for hi-byte of (NPARTS)
	STA NARG2+2
	STA NARG2+3
	STA NARG1+2		;zero high bytes of NARG1
	STA NARG1+3
	SBC PSTART
	STA NARG1
	LDA #$40
	SBC PSTART+1
	STA NARG1+1
	LDA NPARTS		;now divide the number of bytes for all the
	STA NARG2		;music buffers by the number of buffers.
	JSR XDIVID
;Length of each music buffer is now in narg1.

	LDA NARG1
	STA MBUFLN
	CLC
	ADC PSTART		;starting address for first buffer.
	STA PEEND		;1+ending address for first buffer.
	LDA NARG1+1
	STA MBUFLN+1
	ADC PSTART+1
	STA PEEND+1
;now calculate the start and end address for each buffer and put it in the default 
;parameter table. Calculate other the defaults and install the parameter table for this buffer.
;Calculate the new SA for each buffer by adding the contents of MBUFLN, MBUFLN+1
;to PSTART, PSTART+1 and storing the result there and in PENXT,
;PENXT+1.
;To figure the new ending address, add contents of MBUFLN, MBUFLN+1
;to PEEND, PEEND+1 and store the result there.
;Figure the SA for the parameter table by adding the immediate quantity #PARSIZ
;to PARPNT, PARPNT+1 and storing the result there. Copy the table at 
;PARAMS to the locations pointed to by PARPNT, PARPNT+1. Do #PARSIZ bytes
	LDA NPARTS		;Do this for each part.
	STA COUNT
;Calculate defaults.
;Set up the channel number.
LODLUP:	LDA #$09		;nine parts
	SEC
	SBC COUNT		;now A contains 9 minus part number
;Why, you may ask, do we subtract the part number from nine? It is simple:
;Channel 2 (of 0,1,2) is the only one which has white noise. We want the
;user to be able to generate percussion sounds without either having to know
;about ordering of channels/sterso positions or having to allocate seven
;(the first one which would be in channel 2 if we didn't do this) buffers.
;The channel number is the quotient of this new number and 3, and the stereo
;position is the remainder.
	LDX #$00
	SEC
DIV3L:	SBC #$03
	BCC DIV3E		;we subtracted one too many 3's.
	INX
	BNE DIV3L
DIV3E:	ADC #$03		;add the 3 that we shouldn't have subtracted.
	CLC
;A now contains <PART#-9> mod 3, the stereo number. X is <PART#-9>/3 -- the
;channel number.
;Add the slot offset to the remainder -- the stereo position number.
	ADC SLOT		;slot offset is slot number * 16.
	STA PARCHA		;CHAN in the parameter defaults table=slot*16+P
;and now for the quotient -- the channel number. CHAN+1,X=(32*CHAN) OR #$9F.
	TXA
	JSR GETCHN
	STA PARCHA+1		;CHAN+1 in the parameter defaults table.
;And finally copy the default settings (starting address and channel number included)
;to the parameter area in the hires graphics page.
	LDY #PARSIZ-1		;number of bytes in the parameter area -1
PARLUP:	LDA PARAMS,Y
	STA (PARPNT),Y
	DEY
	BNE PARLUP
;Calculate new sa for music buffer by adding MBUFLN to PSTART.
;initialize the next place to put a note to the starting address of
;the buffer.
;new enda by adding MBUFLN to PARFE, the next eob pointer.
;new sa for parameter area by adding #PARSIZ to PARPNT. 
	CLC
	LDA PSTART
	ADC MBUFLN
	STA PSTART
	STA PENXT
	LDA PSTART+1
	ADC MBUFLN+1
	STA PSTART+1
	STA PENXT+1
	CLC
	LDA PEEND
	ADC MBUFLN
	STA PEEND
	LDA PEEND+1
	ADC MBUFLN+1
	STA PEEND+1
	CLC
	LDA PARPNT
	ADC #PARSIZ
	STA PARPNT
	BCC PAR1C
	INC PARPNT+1
PAR1C:	DEC COUNT		;decrement part count.
	BNE LODLUP		;load parameters for next part.
;do the equivalent of a VOICE 1, without error checking.
	LDX #$01
	BNE VCOK		;(always)
.PAGE
	;Music entering section

SNOTE:	JSR MUSICP
	JSR GT2FIX
	LDX #NARG1
	JSR CHKINT
	BCS MRGERR
	LDX #NARG2
	JSR CHKINT
	BCS MRGER2
	TAX
	BMI MRGER2
	LDA NARG1
	CMP #CREST+1
	BCS MRGERR
	LDX MEPRT		;parameter index for current part.
	LDY #$03		;we want to write three bytes
	JSR MCKBY		;errors out if no more bytes.
	JSR PUTBYT
	LDA NARG2
	JSR PUTBYT
	LDA NARG2+1
	JSR PUTBYT
	JMP POPJ

SVOICE:	JSR MUSICP
	JSR GT1FIX
	LDX #NARG1
	JSR CHKINT
	BCS MRGERR
	TAX
	BMI MRGERR
	LDA NARG1+1
	BNE MRGERR
	LDX NARG1
	BEQ MRGERR
	CPX NPARTS
	BEQ VCOK
	BCC VCOK
MRGERR:	JMP GTERR1
MRGER2:	JMP GTERR2
VCOK:	LDA #$00		;this is jumped to by nvoices.
	CLC
VCLUP:	DEX
	BEQ VCXIT
	ADC #PARSIZ
	BCC VCLUP
	BRK			;means #parsiz*parts>255. shouldn't happen

VCXIT:	STA MEPRT		;#PARSIZ*(PART-1)
	JMP POPJ


SAD:	JSR MUSICP
	JSR GT2PIN	;get two positive integers.
	LDA #<ATTACK-TIME>	;Attack/Decay index
	JSR MTN12A	;transfer narg1/narg2 to current part parameter indicated by A.
	JMP POPJ
	
SVS:	JSR MUSICP
	JSR GT2PIN
	LDA #<VOLUME-TIME>	;volume/sustain
	JSR MTN12A
	JMP POPJ

SRG:	JSR MUSICP
	JSR GT2PIN
	LDA #<RELEAS-TIME>	;release/gap
	JSR MTN12A
	JMP POPJ

SFZ:	JSR MUSICP		;fuzz. narg1=type, narg2=shift
	JSR GT2PIN
	LDA NARG1		;so that 0 will be in a at nofuzz.
	DEC NARG1		;Noise type is 0 or 1.
	BMI NOFUZZ		;No fuzz if type-1<0.
	LDA NARG1
	AND #$01		;keep user from screwing self.
	ASL A
	ASL A
	STA NARG1
	LDA NARG2		;Shift rate.
	AND #$03		;and protect him again. Stupid, isn't he? 
	CLC
	ADC NARG1
	ORA #$E0		;constant which means noise control.
NOFUZZ:	LDX MEPRT		;Now A=11100TSS or 0 if BMI NOFUZZ.
	STA FUZZ,X
	JMP POPJ
.PAGE
	;Music playing section

SPLAYM: JSR MUSICP
	LDA NPARTS
	STA MPPRT	;current part number
	LDA MEACTP	;number parts with notes in them.
	STA MPACTP
	LDY NPARTS
	LDX #$00	;parameter index. #parsiz*(part.number-1)
ECPYLP:	LDA #$00
	STA TIME,X
	STA TIME+1,X
	STX TEMPN1
	STY COUNT
	LDY #$07	;zero loudns, down, desire, cursus
ECPY1:	STA LOUDNS,X
	INX
	DEY
	BPL ECPY1
	LDX TEMPN1
	LDY COUNT
;MSTART -> MPNXT
;MENXT -> MPEND
;MEDEAD -> MPDEAD
	LDA MSTART,X
	STA MPNXT,X
	LDA MSTART+1,X
	STA MPNXT+1,X
	LDA MENXT,X
	STA MPEND,X
	LDA MENXT+1,X
	STA MPEND+1,X
	LDA MEDEAD,X
	STA MPDEAD,X
	TXA
	CLC
	ADC #PARSIZ	;next parameter index.
	TAX
	DEY		;number of parts left to do.
	BNE ECPYLP
	LDA MPACTP
	BNE PMLUP
	JMP FINIS

PMLUP:	LDX #$00	;start with part 0. X is parameter index.
	STA $C070	;referencing this location resets the timer
;Process the envelope for each part.
;Compare the current loudness and the desired loudness.
;If it is too soft, make it louder. If it is too loud, make it softer. If
;it is just right, the attack or decay is over and we should shoot for
;the currently desired "sustain" (i.e., sustain or release) level.
;After all this, do the next part.
ENVLUP:	LDA LOUDNS,X
	SEC
	SBC DESIRE,X	;find difference between desired and current loudness.
	STA TEMPN1
	LDA LOUDNS+1,X
	SBC DESIRE+1,X
	BCC UPLD	;should be louder.
	ORA TEMPN1
	BNE DWNLD	;should be softer.
	LDA CURSUS,X	;right loudness
	STA DESIRE,X	;now we want to shoot for the sustain level.
	LDA CURSUS+1,X
	STA DESIRE+1,X
	BCS NEXTE		;(always) do next part
;We must be in the attack phase, since no other stage gets louder.
;Increment the current loudness by the attack rate, and compare the result
;to the desired loudness. If it is currently too loud, we have overshot, so
;make the current loudness be the desired loudness
;If it is now right, start the decay and send the pitch to the device.
UPLD:	LDA LOUDNS,X		;INCREMENT current loudness by attack rate
	ADC ATTACK,X
	STA LOUDNS,X
	LDA LOUDNS+1,X
	ADC ATTACK+1,X
	STA LOUDNS+1,X
	BCS ETHERE		;OVERFLOW: we got too loud, make it exact.
	TAY
	LDA LOUDNS,X
	CMP DESIRE,X
	TYA
	SBC DESIRE+1,X
	BCC SENDE	;not loud enough yet, but keep working later.
	BCS ETHERE	;too loud -- make it exact.
;We must be in the decay phase, since no other stage gets softer.
;Decrement the current loudness by the decay rate, and compare the result
;to the desired loudness. If it is currently too soft, we have undershot, so
;make the current loudness be the desired loudness.
;If it is now right, start the release and send the pitch to the device.
DWNLD:	LDA LOUDNS,X
	SBC DOWN,X
	STA LOUDNS,X
	LDA LOUDNS+1,X
	SBC DOWN+1,X
	STA LOUDNS+1,X
	BCC ETHERE	;UNDERFLOW: too soft, make it exact.
	LDA DESIRE,X
	CMP LOUDNS,X
	LDA DESIRE+1,X
	SBC LOUDNS+1,X
	BCS SENDE	;not soft enough, but keep working later.
;too soft, make it exact.

;Make the current loudness=desired loudness.
ETHERE:	LDA DESIRE,X
	STA LOUDNS,X
	LDA DESIRE+1,X
	STA LOUDNS+1,X
;and now we want to head for the sustain level (either the sustain level or 0 in release.)
	LDA CURSUS,X
	STA DESIRE,X
	LDA CURSUS+1,X
	STA DESIRE+1,X
;send the loudness to the thing.
SENDE:	LDA LOUDNS+1,X	;we have a sixteen bit number, but we only
	LSR A		;have four bits of amplitude control,
	LSR A		;so just take the top four bits of the
	LSR A		;most significant byte.
	LSR A
	EOR CHAN+1,X	;sneaky subtraction. CHAN+1,X=(32*CHAN)or$9F.
	ORA FUZZ,X	;mask for white noise.
	LDY CHAN,X	;channel number+16*slot
	STA $C080,Y
;Falls through.
;through with this one, now for next part.
NEXTE:	TXA 
	CLC
	ADC #PARSIZ	;advance parameter index to next
	TAX		;part's parameters.
	DEC MPPRT
	BEQ CONT1	;last part?
	JMP ENVLUP	;no -- do more parts.
;We've got the volume set for each note. Now handle their durations.
CONT1:	LDX #0		;Start again with first part. X is
			;parameter index.
;Now handle durations of notes. See if anyone is through this clock cycle.
LENGTH:	LDA MPDEAD,X
	BEQ NEXTL
	LDA TIME,X
	CMP GAP,X
	BNE MDECR	;unless the gap size=time remaining, not through.
	LDA TIME+1,X
	CMP GAP+1,X
	BNE MDECR
;this note is about to finish. start the release phase.
	LDA RELEAS,X	;make the current decay rate=the release rate
	STA DOWN,X
	LDA RELEAS+1,X
	STA DOWN+1,X
	LDA #$00	;and our desired (and sustain) level is zero.
	STA DESIRE,X	
	STA DESIRE+1,X
	STA CURSUS,X
	STA CURSUS+1,X
;decrement time remaining, and get next note if this one's through.
MDECR:	LDA TIME,X
	BNE MDECR1
	LDA TIME+1,X
	BEQ ENDNTE
MDECR1:	LDA TIME,X
	SEC
	SBC #$01
	STA TIME,X
	BCS NEXTL
	DEC TIME+1,X
NEXTL:	TXA		;handle the duration for the next part.
	CLC
	ADC #PARSIZ	;point to next set of part parameters.
	TAX
	INC MPPRT
	LDA MPPRT
	CMP NPARTS
	BNE LENGTH	;more parts to do.
;no more parts to do. Wait for the clock tick.
MWAIT:	BIT $C064
	BMI MWAIT
;that's it for this clock cycle. Calculate new amplitudes and see if
;any note is through again.
	JSR POLL
	JMP PMLUP
.PAGE
;This note has finished.
;Try to get another note. If there are no more, decrement
;the number of active parts and set the volume to 0. Set the dead flag
;to indicate that there are no more notes in this part. Handle the length
;for the next part. 
;If it is the last note of all, return to Logo.

;Otherwise, get the next note from this voice and process it.

DDERR:	BRK
ENDNTE:	JSR MGBCK
	BNE PROCES	;more notes. get one and handle it.
;no more notes in this voice. set the dead flag for this voice
;and set its volume to zero. Decrement number of active parts. If it is
;then zero, there are no more notes at all, so quit. If it is not zero,
;handle the next length to wait for something to happen.
	LDA MPDEAD,X
	BEQ DDERR	;bug if already dead.
	LDA #$00
	STA DESIRE,X
	STA DESIRE+1,X
	STA MPDEAD,X
	DEC MPACTP
	BEQ FINIS
	JMP NEXTL

FINIS:	JSR QUIETM	;make sure it shuts up.
	JMP POPJ

;This is the main note-processing loop. It is called whenever a note runs out,
;and gets the next note for the current part.
;Get a byte from a buffer and figure out what to do with it.
;If there aren't any more bytes in this particular part, then go to the next part
;and get the byte there. If there simply aren't any more notes, then quit.
;If a part never had anything in it to begin with, don't count it as having
;become inactive.

PROCES:	JSR MGTBYT	;Get the next character from the buffer indicated by X
;and increment.
	CMP #CREST	;the number for rest is HINOTE+1.
	BCS NPITCH	;Byte is >=#CREST, so it is a command.
;it's a pitch -- 0-71 decimal.
;get octave number.
	LDY #$00
DIVOCT:	CMP #OCTLEN
	BCC DIVOC1
	SBC #OCTLEN
	INY
	BNE DIVOCT
DIVOC1:	STY TEMPN1	;save quotient.
	ASL A		;make remainder a word index. (2 * pitch) -- pitch is [0,11]
	TAY
	LDA OCTAB+1,Y	;Yth divisor in the table.
	STA TEMPN2	;63920/this-num is frequency.
	LDA OCTAB,Y
	LDY TEMPN1	;Y is octave number again.
;rotate the number we got from the table to make it be in the right octave.
OCTAVE:	DEY
	BMI ROUND
	LSR TEMPN2	;it is a 12 bit number.
	ROR A
	JMP OCTAVE

ROUND:	ADC #$08
	BCC SENDP
	INC TEMPN2	;a carry.
;now we have the right divisor to send to the unit.
;all we have to do is get it in the right format and then find out
;where to send it.
;a contains lower 8 bits of divisor, tempn2 the upper 4.
SENDP:	ORA #$0F	;where we write the info.
	LSR A
	ROR A
	ROR A
	ROR A
	AND CHAN+1,X
	LDY CHAN,X	;The offset from the board's memory location
	STA $C080,Y
	JSR ALFWAT
	LDA TEMPN2
	STA $C080,Y	;rest of info for board.
;now start ADSR cycle.
	LDY #$06
	STX TEMPN2	;x is the param pointer for this part.
CYCLE:	LDA DECAY,X	;we're making
	STA DOWN,X	;DOWN=DECAY,DESIRE=VOLUME,CURSUS=SUSTAN
	INX		;increment index for which bytes to move
	DEY		;decrement number of bytes to move
	BNE CYCLE
	LDX TEMPN2	;restore param index after decrementing it.
;store the duration in TIME.
STORD:	JSR MGTBYT		;get this part's next byte.
	STA TIME,X
	JSR MGTBYT
	STA TIME+1,X
;that's it for this note or rest. Do the next one.
	JMP NEXTL
.PAGE
BADCOD:	BRK
;If we got here, the thing in A must not be a pitch. If the last comparison resulted
;in EQness, then it is a rest; otherwise, it is the result of an error.
NPITCH:	BNE BADCOD	;(just compared with 72) it is a command.
	LDA RELEAS,X
	STA DOWN,X
	LDA RELEAS+1,X
	STA DOWN+1,X
	LDA #$00
	STA DESIRE,X		;a rest has amplitude 0.
	STA DESIRE+1,X
	STA CURSUS,X
	STA CURSUS+1,X
;now store the duration.
	JMP STORD
.PAGE
;Utilities
;Utility. Store the byte in A in the location pointed to by MENXT,X MENXT+1,X.
;Increment MENXT,X, MENXT+1,X. Decrement Y, in case anybody uses it to
;keep track of how many bytes it has written.
;Doesn't check for error. You should call MCKBY first.
PUTBYT:	PHA
	STY TEMPN1
	LDA MENXT,X
	STA PARPNT
	LDA MENXT+1,X
	STA PARPNT+1
	LDY #$00
	PLA
	STA (PARPNT),Y
	INC MENXT,X
	BNE PBXIT
	INC MENXT+1,X
PBXIT:	LDY TEMPN1
	DEY
	RTS
;
;This is the MCKBY routine. It takes a number of bytes in Y and a
;parameter index in X. If the part indicated by X doesn't have at
;least Y bytes left, this routine errors out and doesn't return to the
;caller. If there are enough left, it returns.
;Subtracts the beginning of the next buffer from the current pointer.
;If the difference is less than the number of bytes to write, it
;errors out. Otherwise it returns.

;Additionally, this routine keeps track of the number of parts which
;actually have any notes in them. Each time it is called, it checks
;the MEDEAD flag for that part. If it is set (0), then no notes have
;ever been put into that part's buffer -- so it increments the number
;of active parts and clears the MEDEAD flag for the part.
MCKBY:	PHA
	LDA MEDEAD,X
	BNE MCKBY1
;This is the first time.
	LDA #$01
	STA MEDEAD,X
	INC MEACTP
MCKBY1:	LDA MEEND,X
	SEC
	SBC MENXT,X
	STA TEMPN1
	LDA MEEND+1,X
	SBC MENXT+1,X
	BNE MCKOK		;We can't want more than 255 bytes.
	CPY TEMPN1
	BCC MCKOK
	BEQ MCKOK
	LDA #XTMN		;Too many notes.
	JMP ERROR		;Error resets the stack pointer.
MCKOK:	PLA
	RTS

;This routine expects a parameter index in X.
;If this part is dead, error out.
;Otherwise, return the next byte from that part buffer and increment the pointer.
MGTBYT:	LDA MPDEAD,X
	BEQ MGBERR
	STY TEMPN2
	LDY #$00
	LDA MPNXT,X
	STA PARPNT
	LDA MPNXT+1,X
	STA PARPNT+1
	LDA (PARPNT),Y
	TAY
	INC MPNXT,X
	BNE MGTBE
	INC MPNXT+1,X
MGTBE:	LDY TEMPN2
	RTS    
MGBERR:	BRK

;check this part to see if there is note left in it. return 0 in A if there
;aren't. Otherwise, return non-zero in A.
;If the current part pointer is the same as the end pointer, ther are no
;more bytes.
MGBCK:	LDA MPNXT+1,X
	CMP MPEND+1,X
	BEQ MGBCK1
	BCC MGBOK		;more bytes.
	BRK			;Way past end of buffer.
MGBCK1:	LDA MPNXT,X
	CMP MPEND,X
	BEQ MGBNOK		;no more bytes.
	BCC MGBOK		;more bytes.
	BRK			;Past end of buffer.
MGBOK:	LDA #$01		;<>0 means more bytes.
	RTS
MGBNOK:	LDA #$000		;=0 means no more bytes.
	RTS

;This routine gets the number to store in chan+1,x from the channel number,
;given in A.
GETCHN:	LSR A
	ROR A
	ROR A
	ROR A
;In one place, CHAN+1 is eor'd with the high four bits of the current
;loudness put in the low four bits. This makes the result be $9F+$20*C-V.
;So this part constant is $9F+$20*C.
	ORA #$9F
	RTS

;this routine moves narg1 and narg2 to the parameter for the current voice
;indicated by A.
MTN12A:	CLC
	ADC MEPRT
	TAY
	LDA NARG1
	STA TIME,Y
	LDA NARG1+1
	STA TIME+1,Y
	LDA NARG2
	STA TIME+2,Y
	LDA NARG2+1
	STA TIME+3,Y
	RTS

.PAGE

;Command parameters.
;Put them in the Hi-res graphics page.
TIME	=$2000		;must be first
ATTACK	=$2002		;these five must be contiguous
DECAY	=$2004
VOLUME  =$2006
SUSTAN	=$2008
RELEAS	=$200A
GAP	=$200C		;these two must be contiguous
CHAN	=$200E
LOUDNS	=$2010
DOWN	=$2012		;these 3 must be contiguous
DESIRE	=$2014
CURSUS	=$2016
FUZZ	=$2018		;note that FUZZ is a byte.
MEDEAD	=$2019		;MEDEAD is also a byte.
MPDEAD	=$201A		;DEAD flag for PM. A byte.
MSTART	=$201B		;starting address of buffer.
MENXT	=$201D		;pointer to place where next note
			;should put. initialized to start of buffer.
MEEND	=$201F		;beginning of next buffer.
MPNXT	=$2021		;next note to be played. initialized
			;to beginning of buffer.
MPEND	=$2023		;one past last note to be played.
			;initialized to MENXT.
;Here are the defaults for each part.
PARAMS:	.ADDR $0000	;TIME
	.ADDR $2000	;ATTACK
	.ADDR $0019	;DECAY
	.ADDR $D600	;VOLUME
	.ADDR $D600	;SUSTAN
	.ADDR $05DC	;RELEAS
	.ADDR $0016	;GAP
PARCHA:	.ADDR $0000	;CHAN
	.ADDR $0000	;LOUDNS
	.ADDR $0000	;DOWN
	.ADDR $0000	;DESIRE
	.ADDR $0000	;CURSUS
	.BYTE $00	;FUZZ
	.BYTE $00	;MEDEAD
	.BYTE $00	;MPDEAD
PSTART:	.ADDR $0000	;MSTART
PENXT:	.ADDR $0000	;MENXT
PEEND:	.ADDR $0000	;MEEND
	.ADDR $0000	;MPNXT
	.ADDR $0000	;MPEND
PARSIZ=.-PARAMS

.ENDC
.PAGE
.IFTF		;Unconditionally assemble from here on
ZZZZZZ=.	;(Label quickly noticeable in symbol table)
.SBTTL	Stored Interpreter Data:
;Table of divisors for octaves.
OCTAB:	.ADDR 15632		;C
	.ADDR 14752		;C#
	.ADDR 13936		;D
	.ADDR 13152		;D#
	.ADDR 12416		;E
	.ADDR 11712		;F
	.ADDR 11056		;F#
	.ADDR 10432		;G
	.ADDR 9856		;G#
	.ADDR 9296		;A
	.ADDR 8768		;A#
	.ADDR 8288		;B
OCTLEN	=<.-OCTAB>/2

;	Logo names:
PTRUE:	.ASCII "TRUE"
	$00
PFALSE:	.ASCII "FALSE"
	$00

;Evaluator type dispatch table
EVLTB1:	.ADDR XCASQ	;List
	.ADDR XCASA	;Atom
	.ADDR SYSBUG	;String
	.ADDR XCASQ	;Fix
	.ADDR XCASQ	;Flo
	.ADDR SYSBUG	;Sfun
	.ADDR SYSBUG	;Ufun
	.ADDR XCASA	;Satom
	.ADDR XCASQ	;Qatom
	.ADDR XCASD	;Datom
	.ADDR XCASL	;Latom
	.ADDR SYSBUG	;Fpack

;DOS Error number table
DSRTBL:	.BYTE XIOR	;0
	.BYTE XIOR	;1
	.BYTE XRNG	;2
	.BYTE XRNG	;3
	.BYTE XWTP	;4
	.BYTE XIOR	;5
	.BYTE XFNF	;6
	.BYTE XIOR	;7
	.BYTE XIOR	;8
	.BYTE XDKF	;9
	.BYTE XLKF	;A
	.BYTE XSYN	;B
	.BYTE XIOR	;C
	.BYTE XIOR	;D
	.BYTE XIOR	;E
	.BYTE XIOR	;F

;LTYPE type dispatch table
LTPTAB:	.ADDR LTPLS	;List
	.ADDR LTPA	;Atom
	.ADDR LTPA	;String
	.ADDR LTPF	;Fix
	.ADDR LTPF1	;Flo
	.ADDR SYSBUG	;Sfun
	.ADDR SYSBUG	;Ufun
	.ADDR LTPS	;Satom
	.ADDR LTPQ	;Qatom
	.ADDR LTPD	;Datom
	.ADDR LTPL	;Latom
	.ADDR SYSBUG	;Fpack

;Garbage collector type dispatches
GCLTAB:	.ADDR MRKCL	;List
	.ADDR MRKCL	;Atom
	.ADDR MRKCF	;String
	.ADDR MRKW3	;Fix
	.ADDR MRKW3	;Flo
	.ADDR MRKCS	;Satom
	.ADDR MRKCU	;Ufun
	.ADDR MRKCS	;Satom
	.ADDR MRKCL	;Qatom
	.ADDR MRKCL	;Datom
	.ADDR MRKCL	;Latom
	.ADDR MRKCP	;Fpack
.PAGE
;	Constants:

FLT10:	$83	;Floating-point constant, 10.0
	$50
	$00
	$00

KDECI:	$7C	;Floating-point constant, 0.1
	$66
	$66
	$66

RNDUP:	$7F	;Floating-point constant, 0.5
	$40
	$00
	$00

FRNDUP:	$6E	;Floating-point constant, 0.000005
	$53
	$E2
	$D6

FCIRC1:	$87	;Floating-point constant, 180.0
	$5A
	$00
	$00

F360:	$88     ;Floating-point constant, 360.0
	$5A
	$00
	$00

FROTK1:	$81	;Floating-point constant, 2.5
	$50
	$00
	$00

GRPHK1:	$7F	;Floating-point constant, 0.8
	$66
	$66
	$66
.PAGE
.SBTTL	Ghost-Memory Bank 2 Storage:
.=SYSTAB*$100		;Original load area

;	System Function address table:

	.ADDR	SNDSPL
	.ADDR	SPTHNG
	.ADDR	SWORD
	.ADDR	SPWRDP
	.ADDR	SUNSUM
	.ADDR	SUNDIF
	.ADDR	SMAKE
	.ADDR	SOUTPT
	.ADDR	SSTOP
	.ADDR	SPRINT
	.ADDR	STYPE
	.ADDR	SDEFIN
	.ADDR	SCLEAR
	.ADDR	SCNTIN
	.ADDR	STPPKZ
	.ADDR	SELSE
	.ADDR	SSNTNC
	.ADDR	SBOTH
	.ADDR	SEITHR
	.ADDR	XXSFR1	;Then
	.ADDR	SNOT
	.ADDR	PARLOP	;Left-parenthesis
	.ADDR	XXSFR2	;Right-parenthesis
	.ADDR	SIF
	.ADDR	SRUN
	.ADDR	SGO
	.ADDR	SBPT
	.ADDR	LOGO1	;Goodbye
	.ADDR	SGCOLL
	.ADDR	SNODES
	.ADDR	SBTFST
	.ADDR	SFIRST
	.ADDR	SBTLST
	.ADDR	SLAST
	.ADDR	STO
	.ADDR	SEDIT
	.ADDR	SEND
	.ADDR	STEXT
	.ADDR	SFD
	.ADDR	SBK
	.ADDR	SRT
	.ADDR	SLT
	.ADDR	SLIST
	.ADDR	SDRAW
	.ADDR	SHOME
	.ADDR	SPENUP
	.ADDR	SPENDN
	.ADDR	SRMNDR
	.ADDR	SSHOWT
	.ADDR	SHIDET
	.ADDR	STS
	.ADDR	SROUND
	.ADDR	SFPUT
	.ADDR	SPO
	.ADDR	XXSFR3	;All
	.ADDR	XXSFR3	;Names
	.ADDR	SERASE
	.ADDR	SREAD
	.ADDR	SSAVE
	.ADDR	SREQU
	.ADDR	STHING
	.ADDR	STTYP
	.ADDR	SSUM
	.ADDR	SDIF
	.ADDR	SPROD
	.ADDR	SDIVID
	.ADDR	SGRTR
	.ADDR	SLESS
	.ADDR	SCOMMT
	.ADDR	SEQUAL
	.ADDR	STRCBK
	.ADDR	SPOTS
	.ADDR	XXSFR3	;Titles
	.ADDR	XXSFR3	;Procedures
	.ADDR	SDEP
	.ADDR	SEXAM
	.ADDR	SSUM
	.ADDR	SDIF
	.ADDR	SPROD
	.ADDR	SDIVID
	.ADDR	SGRTR
	.ADDR	SLESS
	.ADDR	SEQUAL
	.ADDR	SLPUT
	.ADDR	SRANDM
	.ADDR	SREADC
	.ADDR	SCURSR
	.ADDR	SRNDMZ
	.ADDR	SCALL
	.ADDR	SLISTP
	.ADDR	SNMBRP
	.ADDR	SCLINP
	.ADDR	SVOICE
	.ADDR	SRPEAT
	.ADDR	SSETX
	.ADDR	SSETY
	.ADDR	SSETXY
	.ADDR	SSETH
	.ADDR	SSETT
	.ADDR	SXCOR
	.ADDR	SYCOR
	.ADDR	SHDING
	.ADDR	SFULL
	.ADDR	SMIX
	.ADDR	SDELET
	.ADDR	SCATLG
	.ADDR	SNVOIC
	.ADDR	SPLAYM
	.ADDR	SNOTE
	.ADDR	SAD
	.ADDR	SVS
	.ADDR	SRG
	.ADDR	SFZ
	.ADDR	SQTENT
	.ADDR	STEST
	.ADDR	SIFT
	.ADDR	SIFF
	.ADDR	SSINE
	.ADDR	SCOS
	.ADDR	SINDXR
.PAGE
;	Error-string address table:

ERRTBL=.-2+TDIFF

	.ADDR	XXUOP+TDIFF
	.ADDR	XXEOL+TDIFF
	.ADDR	XXUDF+TDIFF
	.ADDR	XXHNV+TDIFF
	.ADDR	XXNIP+TDIFF
	.ADDR	XXNOP+TDIFF
	.ADDR	XXRPN+TDIFF
	.ADDR	XXIFX+TDIFF
	.ADDR	XXNTMU+TDIFF
	.ADDR	XXTIP+TDIFF
	.ADDR	XXWTA+TDIFF
	.ADDR	XXUBL+TDIFF
	.ADDR	XXNTL+TDIFF
	.ADDR	XXNTF+TDIFF
	.ADDR	XXELS+TDIFF
	.ADDR	XXBRK+TDIFF
	.ADDR	XXLAB+TDIFF
	.ADDR	XXTHN+TDIFF
	.ADDR	XXLNF+TDIFF
	.ADDR	XXETL+TDIFF
	.ADDR	XXNED+TDIFF
	.ADDR	XXOPO+TDIFF
	.ADDR	XXDBZ+TDIFF
	.ADDR	XXOFL+TDIFF
	.ADDR	XXNDF+TDIFF
	.ADDR	XXCRS+TDIFF
	.ADDR	XXOOB+TDIFF
	.ADDR	XXIOR+TDIFF
	.ADDR	XXWTP+TDIFF
	.ADDR	XXFNF+TDIFF
	.ADDR	XXDKF+TDIFF
	.ADDR	XXLKF+TDIFF
	.ADDR	XXTMN+TDIFF
	.ADDR	XXSYN+TDIFF
	.ADDR	XXRNG+TDIFF
	.ADDR	XXNOMU+TDIFF
.PAGE
;	Error Messages:

;Error Message String format:
;	$FF Terminates string
;	$00 Print <Y argument to ERROR>
;	$01 Print <X argument to ERROR>
;	Anything else is printed as an Ascii character

XXUOP:	.ASCII "You don't say what to do with "
	$00
	$FF
XXEOL:	.ASCII "Unexpected end of line"
	$FF
XXUDF:	.ASCII "You haven't told me how to "
	$00
	$FF
XXHNV:	.ASCII "There's nothing named "
	$00
	$FF
XXNIP:	.ASCII "Nothing inside parentheses"
	$FF
XXNOP:	$00
	.ASCII " didn't output"
	$FF
XXRPN:	.ASCII "Unexpected closing parenthesis"
	$FF
XXIFX:	.ASCII "There's nothing before the "
	$00
	$FF
XXTIP:	.ASCII "Too much inside parentheses"
	$FF
XXWTA:	$00
	.ASCII " doesn't like "
	$01
	.ASCII " as input"
	$FF
XXUBL:	$00
	.ASCII " is a Logo primitive"
	$FF
XXNTL:	$00
	.ASCII " should only be called inside a procedure"
	$FF
XXNTF:	$01
	.ASCII " was given instead of TRUE or FALSE"
	$FF
XXELS:	.ASCII "ELSE is out of place"
	$FF
XXBRK:	.ASCII "I was told to pause"
	$FF
XXLAB:	.ASCII "The label "
	$01
	.ASCII " should be at the beginning of the line"
	$FF
XXTHN:	.ASCII "THEN is out of place"
	$FF
XXLNF:	.ASCII "There is no label "
	$00
	$FF
XXETL:	$00
	.ASCII " cannot be used inside procedures"
	$FF
XXNED:	.ASCII "END should be used only in the editor"
	$FF
XXOPO:	$00
	.ASCII " should be an input only to PRINTOUT or ERASE"
	$FF
XXDBZ:	.ASCII "I can't divide by zero"
	$FF
XXOFL:	.ASCII "Number out of range"
	$FF
XXNDF:	$00
	.ASCII " is not defined"
	$FF
XXCRS:	.ASCII "Cursor coordinates off of screen"
	$FF
XXOOB:	.ASCII "Turtle out of bounds"
	$FF
XXIOR:	.ASCII "Disk error"
	$FF
XXWTP:	.ASCII "The disk is write protected"
	$FF
XXFNF:	.ASCII "File not found"
	$FF
XXDKF:	.ASCII "The disk is full"
	$FF
XXLKF:	.ASCII "The file is locked"
	$FF
XXTMN:	.ASCII "Too many notes"
	$FF
XXNTMU: .ASCII "You haven't set NVOICES yet"
	$FF
XXSYN:	.ASCII "Syntax error in filename"
	$FF
XXRNG:	.ASCII "There's nothing to save"
	$FF
XXNOMU:	$00
	.ASCII " is not implemented"
	$FF
.PAGE
;	Miscellaneous text strings (terminated by $00):

HELSTR=.+TDIFF
	.ASCII "Apple Logo, Special Music Version"
	$0D
	.ASCII "(C) 1980 MIT"
	$0D
	.ASCII "All rights reserved"
	$0D
	.ASCII "Assembled December 18, 1980"
	$0D
	.ASCII "For MIT internal use only."
	$0D
	$00
LBUG1=.+TDIFF
	.ASCII "Logo bug; exiting..."
	$0D
	$00
RDRER2=.+TDIFF
	.ASCII "Ignoring unmatched right-bracket"
	$0D
	$00
ZPMSG1=.+TDIFF
	.ASCII "No storage left!"
	$00
ZPMSG2=.+TDIFF
	.ASCII "Stopped!"
	$00
ZPMSG3=.+TDIFF
	.ASCII "Evaluator overflow!"
	$00
WRNMSG=.+TDIFF
	.ASCII "Please ERASE something."
	$0D
	$00
ERRM1=.+TDIFF
	.ASCII ' " at level '
	$00
ERRM2=.+TDIFF
	.ASCII ' - in line "'
	$00
ERRM3=.+TDIFF
	.ASCII " of "
	$00
SENDM=.+TDIFF
	.ASCII " defined"
	$0D
	$00
PNMSG1=.+TDIFF
	.ASCII " is "
	$00
PNMSG2=.+TDIFF
	.ASCII "MAKE "
	$00
TBMSG1=.+TDIFF
	.ASCII "We're now at top-level."
	$0D
	$00
TBMSG2=.+TDIFF
	.ASCII "We're currently inside "
	$00
CHGMSG=.+TDIFF
	.ASCII "        APPLE LOGO SCREEN EDITOR        "
	$00
TOMSG=.+TDIFF
	.ASCII "TO "
	$00
ENDMSG=.+TDIFF
	.ASCII "END"
	$0D
	$00
WAITM=.+TDIFF
	.ASCII "Please wait..."
	$0D
	$00
.PAGE
SAVEM=.+TDIFF
	$84			;^D for DOS
	$C2			;B	these have their high
	$D3			;S	bits turned on because
	$C1			;A	that's the way that
	$D6			;V	Apple does it and DOS
	$C5			;E	understands it.
	$A0			;<space>
	$00
SAVEM2=.+TDIFF
	$AC			;,
	$C1			;A
	$A4			;$
	$B2			;2
	$B0			;0
	$B0			;0
	$B0			;0
	$AC			;,
	$CC			;L
	$A4			;$
	$00
LOADM=.+TDIFF
	$84		;^D for DOS
	$C2		;B
	$CC		;L
	$CF		;O
	$C1		;A
	$C4		;D
	$A0		;<space>
	$00
DELETM=.+TDIFF
	$84
	$C4		;D
	$C5		;E
	$CC		;L
	$C5		;E
	$D4		;T
	$C5		;E
	$00
CATLGM=.+TDIFF
	$84
	$C3		;C
	$C1		;A
	$D4		;T
	$C1		;A
	$CC		;L
	$CF		;O
	$C7		;G
	$00
LOGOM=.+TDIFF
	$AE		;.
	$CC		;L
	$CF		;O
	$C7		;G
	$CF		;O
	$00
.PAGE
;Start of Sine table (92 4-byte flonums, first 2 bytes only)
SINTB1=.+TDIFF
	$00	;Extra entry for interploation routine (cosine of 90.)
	$00

	$00	;0 degrees
	$00

	$7A
	$47

	$7B
	$47

	$7B
	$6B

	$7C
	$47

	$7C
	$59

	$7C
	$6B

	$7C
	$7C

	$7D
	$47

	$7D
	$50

	$7D
	$58

	$7D
	$61

	$7D
	$6A

	$7D
	$73

	$7D
	$7B

	$7E
	$42

	$7E
	$46

	$7E
	$4A

	$7E
	$4F

	$7E
	$53

	$7E
	$57

	$7E
	$5B

	$7E
	$5F

	$7E
	$64

	$7E
	$68

	$7E
	$6C

	$7E
	$70

	$7E
	$74

	$7E
	$78

	$7E
	$7C

	$7F
	$40

	$7F
	$41

	$7F
	$43

	$7F
	$45

	$7F
	$47

	$7F
	$49

	$7F
	$4B

	$7F
	$4D

	$7F
	$4E

	$7F
	$50

	$7F
	$52

	$7F
	$53

	$7F
	$55

	$7F
	$57

	$7F
	$58

	$7F	;45 degrees
	$5A

	$7F
	$5C

	$7F
	$5D

	$7F
	$5F

	$7F
	$60

	$7F
	$62

	$7F
	$63

	$7F
	$64

	$7F
	$66

	$7F
	$67

	$7F
	$68

	$7F
	$6A

	$7F
	$6B

	$7F
	$6C

	$7F
	$6D

	$7F
	$6E

	$7F
	$6F

	$7F
	$71

	$7F
	$72

	$7F
	$73

	$7F
	$74

	$7F
	$74

	$7F
	$75

	$7F
	$76

	$7F
	$77

	$7F
	$78

	$7F
	$79

	$7F
	$79

	$7F
	$7A

	$7F
	$7B

	$7F
	$7B

	$7F
	$7C

	$7F
	$7C

	$7F
	$7D

	$7F
	$7D

	$7F
	$7E

	$7F
	$7E

	$7F
	$7E

	$7F
	$7F

	$7F
	$7F

	$7F
	$7F

	$7F
	$7F

	$7F
	$7F

	$7F
	$7F

	$7F
	$7F

	$80	;90 degrees
	$40

	$80	;Extra entry for interpolation routine (sine of 90.)
	$40
.PAGE
;Start of Sine table (92 4-byte flonums, second 2 bytes only)
SINTB2=.+TDIFF
	$00
	$00

	$00	;0 degrees
	$00

	$7C
	$2D

	$79
	$63

	$2F
	$1D

	$6E
	$3E

	$3F
	$5B

	$09
	$82

	$CB
	$51

	$41
	$B2

	$18
	$2E

	$E8
	$6A

	$B1
	$B7

	$73
	$67

	$2C
	$C9

	$DD
	$30

	$41
	$F7

	$90
	$2B

	$D8
	$DF

	$1B
	$BD

	$58
	$6F

	$8E
	$A2

	$BE
	$01

	$E6
	$38

	$06
	$F5

	$1F
	$E5

	$30
	$B6

	$39
	$17

	$38
	$B9

	$2F
	$4A

	$1C
	$7C

	$00
	$00

	$EC
	$C5

	$D4
	$65

	$B6
	$BB

	$93
	$A2

	$6A
	$F4

	$3C
	$8C

	$08
	$46

	$CD
	$FF

	$8D
	$92

	$46
	$DD

	$F9
	$BE

	$A6
	$12

	$4B
	$B9

	$EA
	$91

	$82	;45 degrees
	$7A

	$13
	$54

	$9D
	$00

	$1F
	$5F

	$9A
	$53

	$0D
	$BF

	$79
	$85

	$DD
	$89

	$39
	$B0

	$8D
	$DE

	$D9
	$F9

	$1D
	$E7

	$59
	$8F

	$8C
	$D7

	$B7
	$A8

	$D9
	$EC

	$F3
	$8A

	$04
	$6D

	$0C
	$80

	$0B
	$AF

	$01
	$E5

	$EF
	$0F

	$D3
	$1A

	$AD
	$F6

	$7F
	$90

	$47
	$D9

	$06
	$C1

	$BC
	$38

	$68
	$32

	$0A
	$A0

	$A3
	$75

	$32
	$A6

	$B8
	$29

	$33
	$F1

	$A5
	$F6

	$0E
	$2E

	$6C
	$92

	$C1
	$1B

	$0B
	$C1

	$4C
	$7E

	$83
	$4F

	$B0
	$2E

	$D3
	$18

	$EC
	$0A

	$FB
	$02

	$00	;90 degrees
	$00

	$00	;Extra entry for interpolation routine
	$00
.PAGE
	;Shape-images for Logo turtles

SHPTBL=.+TDIFF		;lookup table for selecting shape images
	.ADDR TRT0
	.ADDR TRT0
	.ADDR TRT10
	.ADDR TRT10
	.ADDR TRT20
	.ADDR TRT20
	.ADDR TRT30
	.ADDR TRT30
	.ADDR TRT40
	.ADDR TRT40
	.ADDR TRT50
	.ADDR TRT50
	.ADDR TRT60
	.ADDR TRT60
	.ADDR TRT70
	.ADDR TRT70
	.ADDR TRT80
	.ADDR TRT80
.PAGE
	;Actual shape images:
.radix 8
TRT0=.+TDIFF
	77
	77
	54
	44
	45
	54
	44
	14
	56
	76
	56
	65
	77
	67
	55
	55
	66
	65
	77
	77
	0

TRT10=.+TDIFF
	74
	77
	47
	45
	45
	45
	45
	45
	65
	76
	36
	55
	45
	26
	53
	56
	66
	77
	77
	0

TRT20=.+TDIFF
	47
	73
	47
	41
	51
	14
	55
	54
	14
	66
	67
	53
	65
	66
	76
	77
	70
	0

TRT30=.+TDIFF
	74
	34
	57
	50
	14
	55
	54
	45
	26
	67
	57
	61
	57
	62
	66
	47
	77
	74
	7
	0

TRT40=.+TDIFF
	34
	77
	50
	14
	145
	55
	56
	44
	55
	264
	67
	65
	67
	66
	76
	34
	347
	7
	0

TRT50=.+TDIFF
	74
	74
	74
	14
	55
	55
	54
	56
	54
	45
	55
	76
	66
	47
	67
	257
	65
	67
	66
	67
	47
	47
	47
	7
	0

TRT60=.+TDIFF
	44
	47
	47
	55
	55
	65
	56
	44
	55
	275
	67
	365
	67
	76
	366
	74
	44
	7
	0

TRT70=.+TDIFF
	344
	344
	55
	65
	55
	56
	254
	155
	67
	77
	67
	55
	36
	36
	36
	36
	344
	344
	0

TRT80=.+TDIFF
	44
	74
	54
	55
	25
	65
	56
	44
	65
	55
	55
	27
	77
	67
	375
	76
	76
	36
	47
	74
	7
	0
.PAGE
.radix $0A

;MUSIC: Here are the defaults for each part:
	.ADDR $0000		;TIME
	.ADDR $0016		;GAP
	.ADDR $2000		;ATTACK
	.ADDR $0019		;DECAY
	.ADDR $D600		;VOLUME
	.ADDR $D600		;SUSTAN
	.ADDR $05DC		;RELEAS
	.ADDR $0000		;CHAN
	.ADDR $0000		;LOUDNS
	.ADDR $0000		;DOWN
	.ADDR $0000		;DESIRE
	.ADDR $0000		;CURSUS
	.BYTE $00		;FUZZ
	.BYTE $00               ;MEDEAD
	.BYTE $00		;MPDEAD
	.ADDR $0000		;MSTART
	.ADDR $0000		;MENXT
	.ADDR $0000		;MEEND
	.ADDR $0000		;MPNXT
	.ADDR $0000		;MPEND
.PAGE
;	Primitive table:

;Primitive-table format:
;	<Index> <Arguments> <Precedence> <Print-name (terminated by a space)>
;Note:	Abbreviations use a separate entry. For primitives with a variable
;	number of arguments, the number is given as -X-1, where X is the default
;	number of args.

PRMTAB	=.+TDIFF


	0
	0
	IALL
	.ASCII "ALL "
	-3
	1
	IBOTH
	.ASCII "AND "
	1
	0
	IBACK
	.ASCII "BACK "
	1
	5
	IBTFST
	.ASCII "BF "
	1
	0
	IBACK
	.ASCII "BK "
	1
	5
	IBTLST
	.ASCII "BL "
	1
	5
	IBTFST
	.ASCII "BUTFIRST "
	1
	5
	IBTLST
	.ASCII "BUTLAST "
	0
	0
	ICATLG
	.ASCII "CATALOG "
	0
	0
	ICLEAR
	.ASCII "CLEAR "
	0
	0
	ICLINP
	.ASCII "CLEARINPUT "
	0
	0
	ICNTIN
	.ASCII "CO "
	0
	0
	ICNTIN
	.ASCII "CONTINUE "
	1
	5
	ICOS
	.ASCII "COS "
	2
	5
	ICURSR
	.ASCII "CURSOR "
	2
	0
	IDEFIN
	.ASCII "DEFINE "
	1
	0
	IDELET
	.ASCII "DELETE "
	0
	0
	ICS
	.ASCII "DRAW "
	0
	0
	IEDIT
	.ASCII "ED "
	0
	0
	IEDIT
	.ASCII "EDIT "
	0
	1
	IELSE
	.ASCII "ELSE "
	0
	0
	IEND
	.ASCII "END "
	0
	0
	IERASE
	.ASCII "ER "
	0
	0
	IERASE
	.ASCII "ERASE "
	1
	0
	IFORWD
	.ASCII "FD "
	1
	5
	IFIRST
	.ASCII "FIRST "
	1
	0
	IFORWD
	.ASCII "FORWARD "
	2
	0
	IFPUT
	.ASCII "FPUT "
	0
	0
	IFULL
	.ASCII "FULL "
	1
	0
	IGO
	.ASCII "GO "
	0
	0
	IGDBYE
	.ASCII "GOODBYE "
	0
	0
	IHIDET
	.ASCII "HIDETURTLE "
	0
	0
	IHDING
	.ASCII "HEADING "
	0
	0
	IHOME
	.ASCII "HOME "
	0
	0
	IHIDET
	.ASCII "HT "
	1
	0
	IIF
	.ASCII "IF "
	0
	0
	IIFT
	.ASCII "IFT "
	0
	0
	IIFT
	.ASCII "IFTRUE "
	0
	0
	IIFF
	.ASCII "IFF "
	0
	0
	IIFF
	.ASCII "IFFALSE "
	1
	5
	ILAST
	.ASCII "LAST "
	1
	0
	ILEFT
	.ASCII "LEFT "
	-3
	5
	ILIST
	.ASCII "LIST "
	1
	5
	ILISTP
	.ASCII "LIST? "
	2
	0
	ILPUT
	.ASCII "LPUT "
	1
	0
	ILEFT
	.ASCII "LT "
	2
	0
	IMAKE
	.ASCII "MAKE "
	0
	0
	IMIX
	.ASCII "SPLITSCREEN "
	0
	0
	INAMES
	.ASCII "NAMES "
	0
	0
	INDSPL
	.ASCII "ND "
	0
	0
	INDSPL
	.ASCII "NODRAW "
	1
	2
	INOT
	.ASCII "NOT "
	2
	0
	INOTE
	.ASCII "NOTE "
	1
	5
	INMBRP
	.ASCII "NUMBER? "
	1
	0
	INVOIC
	.ASCII "NVOICES "
	1
	0
	IOTPUT
	.ASCII "OP "
	-3
	1
	IEITHR
	.ASCII "OR "
	1
	0
	IOTPUT
	.ASCII "OUTPUT "
	0
	0
	IPAUSE
	.ASCII "PAUSE "
	0
	0
	IPENDN
	.ASCII "PD "
	0
	0
	IPENDN
	.ASCII "PENDOWN "
	0
	0
	IPENUP
	.ASCII "PENUP "
	0
	0
	IPLAYM
	.ASCII "PLAYMUSIC "
	0
	0
	IPLAYM
	.ASCII "PM "
	0
	0
	IPO
	.ASCII "PO "
	0
	0
	IPOTS
	.ASCII "POTS "
	-2
	0
	IPRINT
	.ASCII "PR "
	-2
	0
	IPRINT
	.ASCII "PRINT "
	-2
	0
	ITYPE
	.ASCII "PRINT1 "
	0
	0
	IPO
	.ASCII "PRINTOUT "
	0
	0
	IPROCS
	.ASCII "PROCEDURES "
	0
	0
	IPENUP
	.ASCII "PU "
	2
	5
	IQTENT
	.ASCII "QUOTIENT "
	1
	0
	IRANDM
	.ASCII "RANDOM "
	0
	0
	IRNDMZ
	.ASCII "RANDOMIZE "
	0
	0
	ICTYI
	.ASCII "RC "
	1
	0
	IREAD
	.ASCII "READ "
	0
	0
	ICTYI
	.ASCII "READCHARACTER "
	2
	5
	IRMNDR
	.ASCII "REMAINDER "
	2
	0
	IRPEAT
	.ASCII "REPEAT "
	0
	0
	IREQST
	.ASCII "REQUEST "
	1
	0
	IRIGHT
	.ASCII "RIGHT "
	1
	8
	IINT
	.ASCII "ROUND "
	0
	0
	IREQST
	.ASCII "RQ "
	1
	0
	IRIGHT
	.ASCII "RT "
	1
	0
	IRUN
	.ASCII "RUN "
	1
	0
	ISAVE
	.ASCII "SAVE "
	-3
	5
	ISNTNC
	.ASCII "SE "
	-3
	5
	ISNTNC
	.ASCII "SENTENCE "
	2
	0
	IAD
	.ASCII "SETAD "
	2
	0
	IFZ
	.ASCII "SETFZ "
	2
	0
	IRG
	.ASCII "SETRG "
	2
	0
	IVS
	.ASCII "SETVS "
	1
	0
	ISETH
	.ASCII "SETH "
	1
	0
	ISETH
	.ASCII "SETHEADING "
	1
	0
	ISETT
	.ASCII "SETT "
	1
	0
	ISETT
	.ASCII "SETTURTLE "
	1
	0
	ISETX
	.ASCII "SETX "
	2
	0
	ISETXY
	.ASCII "SETXY "
	1
	0
	ISETY
	.ASCII "SETY "
	0
	0
	ISHOWT
	.ASCII "SHOWTURTLE "
	1
	5
	ISINE
	.ASCII "SIN "
	0
	0
	ISHOWT
	.ASCII "ST "
	0
	0
	ISTOP
	.ASCII "STOP "
	0
	0
	ITRCBK
	.ASCII "TB "
	1
	0
	ITEST
	.ASCII "TEST "
	1
	5
	ITEXT
	.ASCII "TEXT "
	0
	0
	ITHEN
	.ASCII "THEN "
	1
	5
	ITHING
	.ASCII "THING "
	1
	5
	ITHNGP
	.ASCII "THING? "
	0
	0
	ITITLS
	.ASCII "TITLES "
	0
	0
	ITO
	.ASCII "TO "
	0
	0
	ITRCBK
	.ASCII "TRACEBACK "
	0
	0
	ITSTAT
	.ASCII "TS "
	0
	0
	ITTYP
	.ASCII "CHAR? "
	0
	0
	ITSTAT
	.ASCII "TURTLESTATE "
	1
	0
	IVOICE
	.ASCII "VOICE "
	-3
	5
	IWORD
	.ASCII "WORD "
	1
	5
	IWORDP
	.ASCII "WORD? "
	0
	0
	IXCOR
	.ASCII "XCOR "
	0
	0
	IYCOR
	.ASCII "YCOR "
	0
	0
	ILPAR
	.ASCII "( "
	0
	0
	IRPAR
	.ASCII ") "
	2
	7
	INPROD
	.ASCII "* "
	2
	6
	INSUM
	.ASCII "+ "
	2
	6
	INDIF
	.ASCII "- "
	0
	0
	IBPT
	.ASCII ".BPT "
	1
	5
	ICALL
	.ASCII ".CALL "
	2
	0
	IPOKE
	.ASCII ".DEPOSIT "
	1
	0
	IPEEK
	.ASCII ".EXAMINE "
	0
	0
	IGCOLL
	.ASCII ".GCOLL "
	0
	0
	INODES
	.ASCII ".NODES "
	2
	7
	INQUOT
	.ASCII "/ "
	0
	0
	ICOMNT
	.ASCII "; "
	2
	4
	INLESS
	.ASCII "< "
	2
	3
	INEQUL
	.ASCII "= "
	2
	4
	INGRTR
	.ASCII "> "
.PAGE
;Graphics memory map byte table

FGRMBT:	$00
	$00
	$77
	$53
	$4C
	$48
	$20
	$00
	$00
	$77
	$50
	$47
	$53
	$20
	$00
	$00
	$77
	$4B
	$4C
	$4F
	$54
	$5A
	$20


.PAGE
;	V-Primitive table:

;V-Primitive-table format:  3 bytes/entry
;	<Index> <Pointer> <Instance>
;Note:	V-Primitives are quantifiers and other primitives whose pointer must be
;	available for comparisons. <Instance> tells which occurrence of the primitive
;	with a specific <Index> is pointed to by <Pointer>.

VPRMTB	=.+TDIFF

	INSUM
	.WORD INFSUM
	1
	INDIF
	.WORD INFDIF
	1
	ILPAR
	.WORD LPAR
	1
	IRPAR
	.WORD RPAR
	1
	IIF
	.WORD LIF
	1
	IELSE
	.WORD LELSE
	1
	ITHEN
	.WORD LTHEN
	1
	INAMES
	.WORD NAMES
	1
	IALL
	.WORD ALL
	1
	ITITLS
	.WORD TITLES
	1
	IPROCS
	.WORD PROCS
	1
	IEND
	.WORD LEND
	1
	IPO
	.WORD PO
	1
	IPO
	.WORD PRNTOT
	2
	IPOTS
	.WORD POTS
	1
	IERASE
	.WORD ER
	1
	IERASE
	.WORD ERASE
	2
	ISTOP
	.WORD LSTOP
	1
	ICOMNT
	.WORD COMMNT
	1
	IGO
	.WORD LGO
	1
VPRMTE	=.+TDIFF
.PAGE
ENDTAB=.	;End of Ghost-memory bank 2 storage

.=EDBUF-6
	JMP LOGO	;Vector for BRUN to work from DOS (Cold start)
	JMP LOGO1	;Re-entry point for crash or GOODBYE (Warm start)
.END
