;   a simple reader for (very limited) S-expressions

            include "src/mos65/objects.a65"

q_point     zds 2           ; pointer to current parse point in input buffer
q_value     zds 2           ; parsed value (if any)


; ----------------------------------------------------------------------
;   parsers
;
;   q* indicates a parser at q_point, incrementing q_point to consume
;   qY* indicates a parser at qpoint,y, incrementing y to consume
;
;   A parser attempts to parse a value starting at q_point.
;   - On success:
;     - Its input is consumed by incrementing q_point.
;     - The parsed value (if any) is stored in q_value.
;     - Z=0 (BNE) to indicate success ONLY if the parser is capable of
;       failing. Otherwise Z is not indicative of anything.
;   - On failure:
;     - No input is consumed (q_point is untouched)
;     - q_value may be destroyed
;     - Z=1 (BEQ) to indicate failure
;
;   XXX Stuff to consider:
;   - Should have some parsers assume Y=0 on entry?
;   - Should qspaces INY and then add Y to q_point when done?
;

;   ♣Z ♡AXY,q_value  Consume any character. Always successful.
qchar       inc q_point
            bne .done
            inc q_point+1
.done       rts

;   ♠Y ♣A  Advance q_point by Y characters to consume them.
;          • This does not check for end of input!
;          • This always returns with zero clear, to allow tail calls from
;            successful parsers.
;          • This always returns with A=0 and carry clear, in case that helps.
;
qYconsume   tya
            clc
            adc q_point
            sta q_point
            bcc .done
            inc q_point+1
.done       lda #0          ; clear Z to indicate success
            rts


;   ♠Y=0 ♣Z,A ♡X,q_value  Consume spaces. Always successful.
qspaces     ldy #0
            jsr qYspaces
            jmp qYconsume   ; TCO

qYspaces    lda (q_point),y
            iny
            cmp #' '
            beq qYspaces
            dey
            rts

;   ♠Z,q_value ♣AY  Parse a '()' (left-paren, right paren) as value nil.
qLR         ldy #0
            lda (q_point),y
            cmp #'('
            beq .qright
.rts        rts
.qright     iny
            jsr qYspaces
            lda (q_point),y
            cmp #')'
            beq .qsuccess
            rts
.qsuccess   lda #nil        ; intrinsic constant
            sta q_value
            sta q_value+1   ; hack: we know that `nil`'s value is 0
            iny             ; consume the ')'
            jmp qYconsume   ; TCO

;   ♠Z,q_value ♣? ♡? Consume a symbol (no more than 2 chars!)
qsym        rts




            end
----------------------------------------------------------------------

    parse: start by consuming spaces, then:
        - '(', ' '*, ')'    -> nil
        - 
        - consume spaces
        - '
        - '(' → start of list or nil (consume spaces to check
        - try smallint
        - anything else: symbol (just 2 chars for the moment)

    TOP:
        parse
        case
            object:         val := obj, goto DONE
            end of list:    ERROR "unclosed expr"
            start of list:  push(val), val → alloc(), cur = val, goto STARTING

    STARTING:   # reading value for already-alloc'd head cell of a list
                # - cur.car is waiting to be filled
                # - cur.cdr will be filled by APPENDING
        parse
        case
            object:         cur.car := obj
                            goto APPENDING
            end of list:    NOTREACHED because parser reads () as nil
            start of list:  cur.car → alloc()   # same as 2nd half SOL below
                            push(cur)
                            cur := cur.car
                            goto STARTING

    APPENDING:  # reading value for not-yet-alloc'd cell to append to cur list
                # - cur.car is filled
                # - cur.cdr is waiting to fill w/next cell ptr or end of list
        parse
        case
            end of input:   ERROR "unclosed expr"
            end of list:    cur.cdr := ∅
                            cur → pop(),
                            if cur = val: goto DONE
                                    else: goto APPENDING
            object:         cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car := obj      # ...is object
                            goto APPENDING      # continue with current list
            start of list:  cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car → alloc()   # ...points to head of new list
                            push(cur)           # we'll come back to this later
                            cur := cur.car      # start with new list
                            goto STARTING
