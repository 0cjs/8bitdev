from    testmc.mc6800.opcodes   import Instructions as I
from    testmc.mc6800.opcodes   import *
from    testmc.mc6800.opimpl    import *
from    testmc.mc6800           import Machine
from    testmc                  import tmc_tid, LSB, MSB
from    numbers                 import Number
import  pytest

#   Many functions from the opimpl module are not directly tested, but
#   instead are tested through the tests of instruction implementations.
#   This is because we want to test directly as many instruction
#   implementations as possible. The instruction implementations themselves
#   are usually very simple, and so their tests are mainly testing the
#   support functions anyway.

####################################################################
#   Address handling, reading data at the PC, reading/writing stack

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         (   0xFE,      1,     0xFF),
                         (   0xFE,      2,     0x00),
                         (   0xFE,      3,     0x01),
                         (      1,     -1,        0),
                         (      1,     -2,     0xFF),
                         (      1,     -3,     0xFE),
), ids=tmc_tid)
def test_incbyte(initial, addend, expected):
    assert expected == incbyte(initial, addend)

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         ( 0xFFFE,      1,   0xFFFF),
                         ( 0xFFFE,      2,   0x0000),
                         ( 0xFFFE,      3,   0x0001),
                         (      1,     -1,        0),
                         (      1,     -2,   0xFFFF),
                         (      1,     -3,   0xFFFE),
                         ( 0x8000, 0xFFFF,   0x7FFF),
                         ( 0x8000,-0xFFFF,   0x8001),
), ids=tmc_tid)
def test_incword(initial, addend, expected):
    assert expected == incword(initial, addend)

@pytest.mark.parametrize(' inb,   out', (
                         (0x00,     0),
                         (0x01,     1),
                         (0x7F,  0x7F),
                         (0x80, -0x80),
                         (0xFF,    -1),
), ids=tmc_tid)
def test_readsignedbyte(inb, out):
    m = Machine()
    m.pc = 0xFFFF
    m.deposit(m.pc, inb)
    assert out == readsignedbyte(m)
    assert 0x0000 == m.pc

@pytest.mark.parametrize('     x, offset, target', (
                         (0x0000,   0x00, 0x0000),
                         (0x0004,   0x03, 0x0007),
                         (0x0080,   0xFF, 0x017F),
                         (0xFFFF,   0x01, 0x0000),
                         (0xFFFF,   0xFF, 0x00FE),
))
def test_readindex(x, offset, target):
    m = Machine()
    m.setregs(R(x=x, pc=0x10))
    m.deposit(0x10, offset)
    assert target == readindex(m)

@pytest.mark.parametrize('initsp,    word,  newsp', (
                         (     0,  0x4142,      2),
                         (     1,  0x4243,      3),
                         (0xFFFD,  0xCECF, 0xFFFF),
                         (0xFFFE,  0xCF40,      0),
                         (0xFFFF,  0x4041,      1),
), ids=tmc_tid)
def test_popword(initsp, word, newsp):
    m = Machine()
    m.deposit(0x0000, b'\x40\x41\x42\x43')
    m.deposit(0xFFFC, b'\xCC\xCD\xCE\xCF')

    m.sp = initsp
    assert word == popword(m)
    assert newsp == m.sp

####################################################################
#   Opcode test framework

R = Machine.Registers

def runop(opdata, *, machine=None, memsize=0x20,
        startaddr=0x0E, initregs=R(), initmem={},
        changedregs=R(), changedmem={}):
    m = machine
    if m is None:
        m = Machine(memsize=memsize)

    #   For any register not explicitly set that has a value in changedregs,
    #   set it to some other value so we can confirm it was changed.
    unsetregs = set()
    for name, val in initregs.all().items():
        if val is None: unsetregs.add(name)
    #   But always exclude the program counter and stack pointer
    #   as they should never be randomized!
    unsetregs.discard('pc'); unsetregs.discard('sp')
    for name, val in changedregs.all().items():
        if name in unsetregs:
            setattr(m, name, not val)
    #   Also set unexpected values for any memory locations expected to change.
    for addr, value in changedmem.items():
        m.mem[addr] = not value

    #   Now that unexpected values have been placed, set any specified
    #   initial data. This is done after the unexpected value
    #   initialization so that those can be explicitly overridden.
    m.deposit(startaddr, opdata)
    for addr, value in initmem.items():
        m.deposit(addr, value)
    m.setregs(initregs)

    m.pc = startaddr
    prevregs = m.regs
    prevmem = bytes(m.mem)

    m.step(1)

    regs = m.regs
    #   If any regs in the machine are unvalued (i.e., set to `None`)
    #   the opcode implementation has done something very wrong.
    unvalued = set(regs.all().keys()) - set(regs.valued().keys())
    assert not unvalued, 'op produced unvalued register(s)'

    if changedregs.pc is None:
        changedregs = changedregs.clone(pc=startaddr + len(opdata))
    allregs = prevregs.clone(**changedregs.valued())

    #   Lining these up in columns makes it easier to see what was wrong.
   #print('    expected all:', allregs)
   #print('expected changed:', changedregs)
   #print('          actual:', regs)

    #   First assert that the registers and flags expected to change have
    #   their correct values. This makes more clear test failures where a
    #   tested value is wrong.
    assert changedregs == regs, "expected register/flag changes"
    #   Now assert that the other registers and flags, which we did not expect
    #   to change (and are not explicitly tested), are actually unchanged.
    assert allregs == regs, "unexpected register/flag changes"

    newmem = bytearray(prevmem)
    for addr, value in changedmem.items():
        newmem[addr] = value
    assert newmem == m.mem

def extend_arg(b):
    ' If `b` is an 8-bit value, extend it to 16 bits by copying LSB to MSB. '
    if b > 0xFF:
        return b
    else:
        return (b << 8) | b

####################################################################
#   Misc instructions

def test_invalid_opcodes():
    badops = (
        0x00, 0x02, 0x03, 0x04, 0x05,
        0x12, 0x13, 0x14, 0x15, 0x18, 0x1A, 0x1C, 0x1D, 0x1E, 0x1F,
        0x21,                           0x38, 0x3A, 0x3C, 0x3D,
        0x41, 0x42, 0x45, 0x4B, 0x4E,   0x51, 0x52, 0x55, 0x5B, 0x5E,
        0x61, 0x62, 0x65, 0x6B,         0x71, 0x72, 0x75, 0x7B,
        0x83, 0x87, 0x8F,               0x93, 0x9D,
        0xA3,                           0xB3,
        0xC3, 0xC7, 0xCC, 0xCD, 0xCF,   0xD3, 0xDC, 0xDD,
        0xE3, 0xEC, 0xED,               0xF3, 0xFC, 0xFD,
    )
    for i, op in enumerate(badops):
        addr = 0x00E0 + i
        with pytest.raises(InvalidOpcode) as ex:
            runop([op], memsize=0x0140, startaddr=addr)
        assert (op, addr) == (ex.value.opcode, ex.value.pc)
        assert ex.match(r'^opcode=\${:02X} pc=\${:04X}$'.format(op, addr))

def test_NOP():
    #   The test framework will ensure that nothing but the PC has changed.
    runop([I.NOP])

####################################################################
#   Branches

def test_JMP():
    runop([I.JMP, 0xAB, 0xCD], changedregs=R(pc=0xABCD))

@pytest.mark.parametrize('offset,      x,     pc', (
                         (     0, 0xFFFF, 0xFFFF),
                         (     3, 0x1234, 0x1237),
                         (  0xFF, 0xFF80, 0x007F),
), ids=tmc_tid)
def test_JMPx(offset, x, pc):
    runop([I.JMPx, offset], initregs=R(x=x), changedregs=R(pc=pc))

def test_BRA():
    runop([I.BRA,    0], startaddr=0x13, changedregs=R(pc=0x0015))
    runop([I.BRA, 0x80], startaddr=0x0E, changedregs=R(pc=0xFF90))
    runop([I.BRA, 0xFC], startaddr=0x08, changedregs=R(pc=0x0006))
    #   Additional coverage in test_readsignedbyte().

@pytest.mark.parametrize('offset, Z, newpc', (
    (0x03,    True,  0x000D),
    (0x100-4, True,  0x0006),
    (0x20,    False, 0x000A),
))
def test_BEQ(offset, Z, newpc):
    runop([I.BEQ, offset], initregs=R(Z=Z),
        startaddr=0x08, changedregs=R(pc=newpc))

@pytest.mark.parametrize('  op, initregs, taken', (
                        (I.BCC,   R(C=0),  True),
                        (I.BCC,   R(C=1), False),
                        (I.BCS,   R(C=0), False),
                        (I.BCS,   R(C=1),  True),
                        (I.BMI,   R(N=0), False),
                        (I.BMI,   R(N=1),  True),
                        (I.BNE,   R(Z=1), False),
                        (I.BNE,   R(Z=0),  True),
                        (I.BPL,   R(N=0),  True),
                        (I.BPL,   R(N=1), False),
                        (I.BVC,   R(V=0),  True),
                        (I.BVC,   R(V=1), False),
                        (I.BVS,   R(V=0), False),
                        (I.BVS,   R(V=1),  True),
))
def test_condbranch(op, initregs, taken):
    print('op {} ${:02X}, flag: {}, taken {} expected\n'
        .format(OPCODES[op][0], op, str(initregs).split()[-1], taken))
    runop([op, 0x40], initregs=initregs,
        changedregs= R(pc=0x0050) if taken else R(pc=0x0010))

############################

def test_JSR():
    runop([I.JSR, 0x56, 0x78],
        memsize=65536, startaddr=0x1234,
        initregs    = R(sp=0),                      # test stack wraparound
        changedregs = R(pc=0x5678, sp=0xFFFE),
        changedmem  = { 0x0000: 0x37, 0xFFFF: 0x12, })

def test_JSRx():
    runop([I.JSRx,                    0x16],
        initregs    = R(sp=0x1F,  x=0xFFF0, ),
        changedregs = R(sp=0x1D, pc=0x0006, ),
        startaddr   =                   0x0123,     memsize=0x140,
        changedmem  = { 0x1E: 0x01, 0x1F: 0x25, },
    )

def test_BSR():
    runop([I.BSR, 0xFE], startaddr=0x12,            # calling self
        initregs    = R(sp=0x18),
        changedregs = R(sp=0x16, pc=0x12),
        changedmem  = { 0x17: 0x00, 0x18: 0x14, },
    )

def test_RTS():
    m = Machine(memsize=0x40)
    m.sp = 0x002D; m.depword(0x002E, 0x1234)
    runop([I.RTS], machine=m, changedregs=R(pc=0x1234, sp=0x002F))

####################################################################
#   Flag Changes

@pytest.mark.parametrize('op, flag', (
    (I.CLC, R(C=0)), (I.SEC, R(C=1)),
    (I.CLV, R(V=0)), (I.SEV, R(V=1)),
    (I.CLI, R(I=0)), (I.SEI, R(I=1)),
), ids=tmc_tid)
def test_flag_change(op, flag):
    runop([op], changedregs=flag)

pccr_testdata = ('pccr, flags', (
   (0b11000000, R(H=0, I=0, N=0, Z=0, V=0, C=0)),
   (0b11000001, R(H=0, I=0, N=0, Z=0, V=0, C=1)),
   (0b11000010, R(H=0, I=0, N=0, Z=0, V=1, C=0)),
   (0b11000100, R(H=0, I=0, N=0, Z=1, V=0, C=0)),
   (0b11001000, R(H=0, I=0, N=1, Z=0, V=0, C=0)),
   (0b11010000, R(H=0, I=1, N=0, Z=0, V=0, C=0)),
   (0b11100000, R(H=1, I=0, N=0, Z=0, V=0, C=0)),
   (0b11010101, R(H=0, I=1, N=0, Z=1, V=0, C=1)),
   (0b11101010, R(H=1, I=0, N=1, Z=0, V=1, C=0)),
   (0b11111111, R(H=1, I=1, N=1, Z=1, V=1, C=1)),
))

@pytest.mark.parametrize(*pccr_testdata, ids=tmc_tid)
def test_tap(pccr, flags):
    runop([I.TAP], initregs=R(a=pccr), changedregs=flags)

@pytest.mark.parametrize(*pccr_testdata, ids=tmc_tid)
def test_tpa(pccr, flags):
    runop([I.TPA], initregs=flags, changedregs=R(a=pccr))

####################################################################
#   Data Movement

#### Stack

def test_PULA():
    runop([I.PULA],
        initregs    = R(sp=0x000C),
        initmem     = { 0x000D: 0xA1 },
        changedregs = R(sp=0x000D, a=0xA1),
        )

def test_PSHA():
    runop([I.PSHA],
        initregs    = R(a=0xEF, sp=0x000F),
        changedregs = R(sp=0x000E),
        changedmem  = { 0x000F: 0xEF },
        )

#### Loads

def loadstore_tparams(baseaddr, extras=()):
    #   Not all parameters are used by all tests.
    return {
        'argnames':     '        addr, offset,  arg, N, Z',
        'argvalues': (  ( baseaddr+0,       3, 0x01, 0, 0),
                        ( baseaddr+2,       0, 0x00, 0, 1),
                        ( baseaddr+4,    0x80, 0xEA, 1, 0),
                     ) + tuple(extras),
        'ids': tmc_tid,
    }

@pytest.mark.parametrize(**loadstore_tparams(0))
def test_LDA(addr, offset, arg, N, Z):
    runop([I.LDAA, arg], changedregs=R(a=arg, N=N, Z=Z, V=0))
    runop([I.LDAB, arg], changedregs=R(b=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**loadstore_tparams(0x44))
def test_LDAz(addr, offset, arg, N, Z):
    runop([I.LDAAz, LSB(addr)], changedregs=R(a=arg, N=N, Z=Z, V=0),
        memsize=0x50, initmem={ addr: arg })
    runop([I.LDABz, LSB(addr)], changedregs=R(b=arg, N=N, Z=Z, V=0),
        memsize=0x50, initmem={ addr: arg })

@pytest.mark.parametrize(**loadstore_tparams(0x101))
def test_LDAAm(addr, offset, arg, N, Z):
    runop([I.LDAAm, MSB(addr), LSB(addr)],
        changedregs=R(a=arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: arg })
    runop([I.LDABm, MSB(addr), LSB(addr)],
        changedregs=R(b=arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: arg })

@pytest.mark.parametrize(**loadstore_tparams(0x88))
def test_LDAx(addr, offset, arg, N, Z):
    runop([I.LDAAx, offset], memsize=0x110,
        initregs    = R(x=addr),
        initmem     = { addr+offset: LSB(arg) },
        changedregs = R(a=arg, N=N, Z=Z, V=0),)
    runop([I.LDABx, offset], memsize=0x110,
        initregs    = R(x=addr),
        initmem     = { addr+offset: LSB(arg) },
        changedregs = R(b=arg, N=N, Z=Z, V=0),)

@pytest.mark.parametrize(**loadstore_tparams(0x40,
    [(0x50, 0, 0x7FFF, 0, 0), (0x52, 0, 0x8000, 1, 0)]))
def test_LDX(addr, offset, arg, N, Z):
    arg = extend_arg(arg)
    runop([I.LDX, MSB(arg), LSB(arg)], changedregs=R(x=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**loadstore_tparams(0x22,
    [(0x50, 0, 0x7FFF, 0, 0), (0x52, 0, 0x8000, 1, 0)]))
def test_LDXz(addr, offset, arg, N, Z):
    arg = extend_arg(arg)
    runop([I.LDXz, LSB(addr)],
        changedregs=R(x=arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: MSB(arg), addr+1: LSB(arg) })

@pytest.mark.parametrize(**loadstore_tparams(0xFF,
    [(0x50, 0, 0x7FFF, 0, 0), (0x52, 0, 0x8000, 1, 0)]))
def test_LDXm(addr, offset, arg, N, Z):
    arg = extend_arg(arg)
    runop([I.LDXm, MSB(addr), LSB(addr)],
        changedregs=R(x=arg, N=N, Z=Z, V=0),
        memsize=0x110, initmem={ addr: MSB(arg), addr+1: LSB(arg) })

@pytest.mark.parametrize(**loadstore_tparams(0x59,
    [(0x50, 0, 0x7FFF, 0, 0), (0x52, 0, 0x8000, 1, 0)]))
def test_LDXx(addr, offset, arg, N, Z):
    arg = extend_arg(arg)
    runop([I.LDXx, offset], memsize=0x110,
        initregs    = R(x=addr),
        initmem     = { addr+offset: MSB(arg), addr+offset+1: LSB(arg) },
        changedregs = R(x=arg, N=N, Z=Z, V=0),
    )

#### Stores

@pytest.mark.parametrize('x, offset, addr', (
    (      0x0003,    0, 0x0003),
    (      0x0004,    2, 0x0006),
    (0x10000-0xF8, 0xFF, 0x0007),
))
def test_CLRx(x, offset, addr):
    runop([I.CLRx, offset], initregs=R(x=x),
        changedregs=R(N=0, Z=1, V=0, C=0), changedmem={ addr: 0 })

@pytest.mark.parametrize(**loadstore_tparams(0x0003))
def test_STAAm(addr, offset, arg, N, Z):
    runop([I.STAAm, MSB(addr), LSB(addr)],
        initregs    = R(a=arg),
        changedregs = R(N=N, Z=Z, V=0),
        changedmem  = { addr: arg })

@pytest.mark.parametrize(**loadstore_tparams(0x0004))
def test_STAAx(addr, offset, arg, N, Z):
    runop([I.STAAx, offset], memsize=0x90,
        initregs    = R(x=addr, a=arg),
        changedregs = R(N=N, Z=Z, V=0),
        changedmem  = { addr+offset: arg })

@pytest.mark.parametrize(**loadstore_tparams(0x40,
    [(0x50, 0, 0x7FFF, 0, 0), (0x52, 0, 0x8000, 1, 0),]))
def test_STXm(addr, offset, arg, N, Z):
    arg = extend_arg(arg)
    runop([I.STXm, MSB(addr), LSB(addr)], memsize=0x90,
        initregs    = R(x=arg),
        changedregs = R(N=N, Z=Z, V=0),
        changedmem  = { addr: MSB(arg), addr+1: LSB(arg) },
    )

def test_STXm_rollover():
    runop([I.STXm, 0xFF, 0xFF], memsize=64*1024,
        initregs= R(x=0x89AB), changedregs=R(N=1, Z=0, V=0),
        changedmem={ 0xFFFF: 0x89, 0x0000: 0xAB },
    )

@pytest.mark.parametrize(**loadstore_tparams(0xF0))
def test_STXz(addr, offset, arg, N, Z):
    arg = extend_arg(arg)
    runop([I.STXz, addr], memsize=0x100,
        initregs    = R(x=arg),
        changedregs = R(N=N, Z=Z, V=0),
        changedmem  = { addr: MSB(arg), addr+1: LSB(arg) },
    )

####################################################################
#   Flag handling for data movement and logic

def test_isneg():
    assert not isneg(0)
    assert not isneg(0x7F)
    assert     isneg(0x80)
    assert     isneg(0xFF)

def test_isneg16():
    assert not isneg(0x0000, signbit=15)
    assert not isneg(0x7FFF, signbit=15)
    assert     isneg(0x8000, signbit=15)
    assert     isneg(0xFFFF, signbit=15)

def test_iszero():
    assert     iszero(0)
    assert not iszero(1)
    assert not iszero(0xFF)

def test_logicNZV():
    ' Covered by data movement and logic opcode tests. '

####################################################################
#   Logic operations

@pytest.mark.parametrize('a,     arg,  res, N, Z', (
                         (0x00, 0x00, 0x00, 0, 1),
                         (0x00, 0xFF, 0x00, 0, 1),
                         (0xFF, 0x00, 0x00, 0, 1),
                         (0xAA, 0x3C, 0x28, 0, 0),
                         (0xAA, 0xF0, 0xA0, 1, 0),
), ids=tmc_tid)
def test_ANDA(a, arg, res, N, Z):
    runop([I.ANDA, arg], initregs=R(a=a), changedregs=R(a=res, N=N, Z=Z, V=0))

@pytest.mark.parametrize('init,  res, Z, V, C', (
                         #   XXX see comment in code re V=N⊕C
                         (0x01, 0x00, 1, 1, 1),
                         (0x02, 0x01, 0, 0, 0),
                         (0xAA, 0x55, 0, 0, 0),
                         (0xFF, 0x7F, 0, 1, 1),
), ids=tmc_tid)
def test_LSRA(init, res, Z, V, C):
    runop([I.LSRA], initregs=R(a=init),
        changedregs=R(a=res, N=0, Z=Z, V=V, C=C))

####################################################################
#   Arithmetic operations

@pytest.mark.parametrize('   n,  dec, N, Z, V', (
                         (0xFF, 0xFE, 1, 0, 0),
                         (0x81, 0x80, 1, 0, 0),
                         (0x80, 0x7F, 0, 0, 1),     # only case where V set
                         (0x7F, 0x7E, 0, 0, 0),
                         (0x01, 0x00, 0, 1, 0),
))
def test_decb(n, dec, N, Z, V):
    runop([I.DECB], initregs=R(b=n), changedregs=R(b=dec, N=N, Z=Z, V=V))

@pytest.mark.parametrize('     n, succ, Z', (
                         (0x0000, 0x0001, 0),
                         (0x00FF, 0x0100, 0),
                         (0xFFFE, 0xFFFF, 0),
                         (0xFFFF, 0x0000, 1),
))
def test_inx(n, succ, Z):
    runop([I.INX], initregs=R(x=n), changedregs=R(x=succ, Z=Z))

@pytest.mark.parametrize('     n, succ, Z', (
                         (0x0001, 0x0000, 1),
                         (0x0100, 0x00FF, 0),
                         (0xFFFF, 0xFFFE, 0),
                         (0x0000, 0xFFFF, 0),
))
def test_dex(n, succ, Z):
    runop([I.DEX], initregs=R(x=n), changedregs=R(x=succ, Z=Z))

@pytest.mark.parametrize(
    'a,     arg,  res, H, N, Z, V, C', (
    (0x00, 0x00, 0x00, 0, 0, 1, 0, 0),
    #   H: half carry determined by bits 3
    (0x0E, 0x01, 0x0F, 0, 0, 0, 0, 0),
    (0x0F, 0x01, 0x10, 1, 0, 0, 0, 0),
    (0x10, 0x01, 0x11, 0, 0, 0, 0, 0),
    #   V: overflow determined by bits 6
    (0x7E, 0x01, 0x7F, 0, 0, 0, 0, 0),
    (0x7F, 0x01, 0x80, 1, 1, 0, 1, 0),
    (0x80, 0x01, 0x81, 0, 1, 0, 0, 0),
    #   C: carry determined by bits 7
    (0xFE, 0x01, 0xFF, 0, 1, 0, 0, 0),
    (0xFF, 0x01, 0x00, 1, 0, 1, 0, 1),
    (0xF0, 0x20, 0x10, 0, 0, 0, 0, 1),  # no half carry
    #   C and V
    (0x40, 0xF0, 0x30, 0, 0, 0, 0, 1),  # 2's comp: subtract from positive
    (0xF0, 0xF0, 0xE0, 0, 1, 0, 0, 1),  # 2's comp: subtract from negative
    (0x80, 0x80, 0x00, 0, 0, 1, 1, 1),
), ids=tmc_tid)
def test_ADDA(a, arg, res, H, N, Z, V, C):
    cr = R(a=res, H=H, N=N, Z=Z, V=V, C=C)
    #   Operation should be the same whether carry set or clear.
    runop([I.ADDA, arg], initregs=R(a=a, C=0), changedregs=cr)
    runop([I.ADDA, arg], initregs=R(a=a, C=1), changedregs=cr)

@pytest.mark.parametrize('minuend, subtrahend, difference, N, Z, V, C', (
    #minu, subt, diff, N, Z, V, C
    (0x00, 0x00, 0x00, 0, 1, 0, 0),
    #   V: overflow determined by bits 6
    (0x81, 0x01, 0x80, 1, 0, 0, 0),
    (0x81, 0x02, 0x7F, 0, 0, 1, 0),
    (0x7F, 0x01, 0x7E, 0, 0, 0, 0),
    #   C: borrow determined by bits 7
    (0x01, 0x01, 0x00, 0, 1, 0, 0),
    (0x01, 0x02, 0xFF, 1, 0, 0, 1),
    (0xFF, 0x01, 0xFE, 1, 0, 0, 0),
), ids=tmc_tid)
def test_SUBA(minuend, subtrahend, difference, N, Z, V, C):
    cr = R(a=difference, N=N, Z=Z, V=V, C=C)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=0), changedregs=cr)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=1), changedregs=cr)

def test_CMPA():
    #   Confirm that A register is unchanged;
    #   test_suba() provides the rest of the coverage.
    runop([I.CMPA, 0x02], initregs=R(a=0x81), changedregs=R(N=0, Z=0, V=1, C=0))

#       Flag register value:         4  8  2
#
cpxparams = (' addr,      x,    arg, Z, N, V', (
             (0x0F1, 0x0000, 0x0000, 1, 0, 0),     # BEQ taken
             (0x0F3, 0x0001, 0x0001, 1, 0, 0),
             (0x0F5, 0x0080, 0x0080, 1, 0, 0),
             (0x0F7, 0x7FFF, 0x7FFF, 1, 0, 0),
             (0x0F9, 0x8000, 0x8000, 1, 0, 0),
             (0x0FB, 0xFFFF, 0xFFFF, 1, 0, 0),

             (0x0FD, 0x0000, 0x0001, 0, 0, 0),     # BNE taken
             (0x0FF, 0x0000, 0x00FF, 0, 0, 0),
             (0x101, 0x0000, 0x0100, 0, 1, 0),

             (0x103, 0x0000, 0x8100, 0, 0, 0),
             (0x105, 0x0000, 0x80FF, 0, 1, 1),
             (0x107, 0x0000, 0x8000, 0, 1, 1),
             (0x109, 0x0000, 0x7FFF, 0, 1, 0),

             (0x10B, 0x0000, 0xFFFF, 0, 0, 0),
             (0x10D, 0x8000, 0x0000, 0, 1, 0),
             (0x10F, 0x8000, 0x00FF, 0, 1, 0),
             (0x121, 0x8000, 0x0100, 0, 0, 1),
))

@pytest.mark.parametrize(*cpxparams, ids=tmc_tid)
def test_CPX(addr, x, arg, N, Z, V):
    runop([I.CPX, MSB(arg), LSB(arg)],
        initregs=R(x=x), changedregs=R(N=N, Z=Z, V=V))

@pytest.mark.parametrize(*cpxparams, ids=tmc_tid)
def test_CPXz(addr, x, arg, N, Z, V):
    addr -= 0x40
    runop([I.CPXz, addr], memsize=0xFF,
        initmem     = { addr: MSB(arg), addr+1: LSB(arg) },
        initregs    = R(x=x),
        changedregs = R(N=N, Z=Z, V=V))

@pytest.mark.parametrize(*cpxparams, ids=tmc_tid)
def test_CPXm(addr, x, arg, N, Z, V):
    runop([I.CPXm, MSB(addr), LSB(addr)], memsize=0x123,
        initmem     = { addr: MSB(arg), addr+1: LSB(arg) },
        initregs    = R(x=x),
        changedregs = R(N=N, Z=Z, V=V))
