import  pytest

#   Nicer assertion error display for various testmc objects.
from    testmc.pytest  import pytest_assertrepr_compare

@pytest.fixture
def m(request):
    ''' A simulated machine with the object file loaded.

        The caller must have two global variables defined in its
        module:
        - `Machine`: The class of the CPU/machine simulator to instantiate.
          Normally this is simply imported from `testmc`.
        - `object_file`: A `str` giving the path to the object file to load
          into the machine, relative to ``.build/obj/``.
    '''
    Machine = getattr(request.module, 'Machine')
    m = Machine()
    #   XXX This is probably not the best way to find this file; it makes
    #   this dependent on the CWD being the project root dir above .build/.
    m.load('.build/obj/' + getattr(request.module, 'object_file'))
    return m

#   These rely on pytest running the m() fixture only once per test, even
#   though both these fixtures and the test itself use it. I'm not sure if
#   this behaviour is documented, but it makes sense given that pytest
#   maintains careful control over the scope (test/module/etc.) in which a
#   fixture is used.

@pytest.fixture
def S(m):
    ''' The `Machine.symtab` attribute of the machine object produced by
        the `m` fixture.
    '''
    return m.symtab

@pytest.fixture
def R(m):
    ''' The `Machine.registers` attribute of the machine object produced by
        the `m` fixture.
    '''
    return m.Registers

####################################################################
#

@pytest.fixture
def loadbios(m, S):
    ''' Return a function that loads a unit test BIOS and connects input
        and output streams.

        The first parameter is the BIOS system name; the BIOS is the object
        output of ``src/SYSNAME/bioscode.a??`. This assumes that the BIOS
        will define ``charinport`` and ``charoutport`` symbols, both set to
        the same value, that define the address in the memory map to set up
        to read and write for I/O to the streams below.

        `input`, `output` and the return values all are passed to and come
        from `testmc.generic.iomem.setiostreams()`, which is used to to
        create I/O streams for the console read and write functions of the
        BIOS. See that function's documentation for full details.

        If provided, `input` is typically a `bytes` to be read, but it may
        be anything with a `read(1)` method. `output` is typically left
        unset to have the framework provide a stream from which you can
        read the output generated by the code under test. A pair of
        ``istream, ostream`` (with ``istream`` usually ignored) is returned
        for the test to query.

        Sample usage::

            _, ostream = loadbios('tmc68', b'some input\n')
            ...
            assert b'Hello, world!' == ostream.getvalue()
    '''
    def loadbios(biosname, input=None, output=None):
        bioscode = '.build/obj/src/{}/bioscode.p'.format(biosname)
        m.load(bioscode, mergestyle='prefcur', setPC=False)
        assert S['charinport'] == S['charoutport']
        return m.setiostreams(S.charinport, input, output)
    return loadbios
