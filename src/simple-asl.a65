;   Simple 6502 routines to test with Macro Assembler AS

            cpu 6502
            org $240
ident       byt "simple-asl.a65"    ; we use this to check that we've loaded
                                    ; the correct binary data and symbol table.

;       Temporary symbol demonstrations
tempsyms    nop     ; tempsyms
.foo        nop     ; tempsyms.foo
$$named     nop     ; named5
.foo        nop     ; named5.foo
-           nop     ; __back0
/           nop     ; __forw0
+           nop     ; __forw1
.foo        nop     ; __forw1.foo
            rts
tempsyms_end

;       Section demonstrations
foo         nop                 ; global    foo
    section sec1                ; level 1   :sec1:
foo         nop                 ;           :sec1:foo
bar         nop                 ;           :sec1:bar
      section sec2              ; level 2   :sec1:sec2:
foo         nop                 ;           :sec1:sec2:foo
            public bar          ;           bar         (not bar[2], bar[sec2])
bar         nop
            public baz:parent   ;           :sec1:baz   (not baz[sec2])
baz         nop
        section sec2            ; level 3   :sec1:sec2:sec2:
foo         nop                 ;           :sec1:sec2:sec2:foo
        endsection sec2
      endsection sec2
quux        nop                 ;           :sec1:quux
    endsection sec1
    section sec2                ; level 1   :sec2
foo         nop                 ;           :sec2:foo
    endsection sec2

;--------------------------------------------------------------------------
;   Macros to standardize constant definition and storage allocation.
;   • We use the intel DS/DB/DW syntax.
;   • Unfortunately, this currently uses the native duplication syntax,
;     i.e. a prefixed bracketed count `[8]$FF` on 6502.
;   • Not totally sure how good an idea this is, since it does clutter
;     up the listing with the extra (MACRO) lines.

ds          macro
            rmb ALLARGS
            endm
db          macro
            byt ALLARGS
            endm
dw          macro
            fdb ALLARGS
            endm

;   Tests of DS/DB/DW
defalloctest
dstest0     ds  3
dstest1     ds  1
dbtest      db  $00,"abc",[2]$FF
dwtest      dw  $ABCD

;--------------------------------------------------------------------------
;   Macros for "in-line" zero-page allocation.

;   We reserve the first 16 bytes of the zero page for use by "system"
;   stuff external to us, such as the BIOS, 6510 PIO registers, etc.
__ZDS_loc   set $10

            macexp_dft off      ; XXX {NOEXPAND} doesn't work
zds         macro len,{INTLABEL},{NOEXPAND}
__ZDS_save  set *
            org __ZDS_loc
__LABEL__   label *
            rmb len
            org __ZDS_save
__ZDS_loc   set __ZDS_loc+len
            endm
            macexp_dft on       ; XXX {NOEXPAND} doesn't work

;   Test of ZDS: byte at current loc, two allocs in ZP, byte at next loc
zdstest0    db  $F0
zdstest1    zds 3
zdstest2    zds 2
zdstest3    db  $F3

;--------------------------------------------------------------------------
;   Add X and Y, storing the result in xybuf and returning it in A
addxy       txa
            sty xybuf
            clc
            adc xybuf
            sta xybuf
            rts
xybuf       ds  1

;--------------------------------------------------------------------------
;           Clear an area. fillptr₁=startaddr-1, Y=length.
fill        lda #0
/           sta (fillbase),y
            dey
            bne -
            rts
fillbase    zds 2
