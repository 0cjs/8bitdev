from    mc6800sim.memory  import MemoryAccess
import  pytest

class RAM(MemoryAccess):
    def __init__(self, store):
        self.tmem = store
    def get_memory_seq(self):
        return self.tmem

@pytest.fixture(params=[
    lambda: bytearray(65536),
    lambda: [0]*65536
])
def m(request):
    return RAM(request.param())

@pytest.mark.parametrize('n', range(0, 3))   # 3 runs for each fixture.
def test_fixture_returns_fresh_memory_every_time(m, n):
    mem = m.get_memory_seq()
    #   Different types cause pytest to take a _long_ time to generate
    #   the comparison, so always convert the backing store to `bytes`.
    assert bytes(len(mem)) == bytes(mem)
    mem[3] = 0xFF

####################################################################

def test_memory_direct_access(m):
    ''' We ascertain here that direct access to the memory provided by
        the hosting class works.
    '''
    #   Here always call get_memory_seq() every time to ascertain it's
    #   working. This is actually testing our RAM class, but we should
    #   perhaps find a way to do these sorts of checks on the actual
    #   hosting classes.
    assert 0x00 == m.get_memory_seq()[0]
    m.get_memory_seq()[0] = 0xFF
    assert 0xFF == m.get_memory_seq()[0]

    mem = m.get_memory_seq()
    with pytest.raises(IndexError): mem[0x10000] = 0

def test_examine(m):
    assert 0                == m.byte(0x0005)
    assert b'\0\0\0\0'      == m.bytes(0x0004, 4)

    m.get_memory_seq()[5] = 0xCA
    assert 0xCA             == m.byte(0x0005)
    assert b'\0\xCA\0\0'    == m.bytes(0x0004, 4)
    assert bytes            is type(m.bytes(0x0004, 4))

    m.get_memory_seq()[6] = 0xFE
    assert b'\0\xCA\xFE\0'  == m.bytes(0x0004, 4)
    assert 0xCAFE           == m.word(0x0005)

    assert (0xCA, 0xFE00)   == m.words(0x0004, 2)

    with pytest.raises(IndexError): m.byte(0x10000)
    with pytest.raises(IndexError) as ex:
        m.bytes(0xFFFF, 3)
    assert ex.match('^Last address \\$10001 out of range$')

    with pytest.raises(IndexError): m.word(0xFFFF)
    with pytest.raises(IndexError): m.words(0xFFFD, 2)

def test_deposit(m):
    assert b'\x01'              == m.deposit(0x800, 1)
    assert b'\x02\x03\x04'      == m.deposit(0x802, 2, 3, 4)
    assert b'\x05\x06\x07\x08'  == m.deposit(0x806, [5, 6], 7, b'\x08')
    assert b'\x01\x00\x02\x03\x04\x00\x05\x06\x07\x08\x00' == m.bytes(0x800, 11)

def test_deposit_value(m):
    m.deposit(0, 0x0)
    m.deposit(0, 0xFF)

    with pytest.raises(ValueError) as ex:
        m.deposit(3, -1)
    assert ex.match(r'^deposit @\$0003: invalid byte value \$-1$')

    with pytest.raises(ValueError) as ex:
        m.deposit(0xF00F, 256)
    assert ex.match(r'^deposit @\$F00F: invalid byte value \$100$')

def test_deposit_index(m):
    with pytest.raises(IndexError) as ex:
        m.deposit(0xFFFF, (0, 0))
    assert ex.match('^Last address \\$10000 out of range$')

def test_depword(m):
    b = m.depword(0x0200, [0xFFFF, 0x8384], 0x8586)
    assert b'\xFF\xFF\x83\x84\x85\x86' == b
    assert bytes is type(b)

    with pytest.raises(ValueError) as ex:
        m.depword(0x0012, 2, [1, -1, 0], 0)
    assert ex.match('^deposit @\\$0012: invalid word value \\$-1$')
    with pytest.raises(ValueError): m.depword(0x0014, 0, 0x10000)

def test_depword_value(m):
    m.depword(0, 0x0)
    m.depword(0, 0xFFFF)

    with pytest.raises(ValueError) as ex:
        m.depword(0xF, -1)
    assert ex.match(r'^deposit @\$000F: invalid word value \$-1$')

    with pytest.raises(ValueError) as ex:
        m.depword(0x1234, 65536)
    assert ex.match(r'^deposit @\$1234: invalid word value \$10000$')

def test_depword_index(m):
    m.depword(0xFFFE, 0)
    with pytest.raises(IndexError) as ex:
        m.depword(0xFFFF, 0)
    assert ex.match('^Last address \\$10000 out of range$')

    m.depword(0xFFFC, 0, 0)
    with pytest.raises(IndexError) as ex:
        m.depword(0xFFFD, 0, 0)
    assert ex.match('^Last address \\$10000 out of range$')
