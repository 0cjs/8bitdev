.NLIST SEQ	;Don't print sequence numbers
.LIST CND	;Print conditional directives and unassembled code
.LIST ME	;List macro expansions
.ENABL LC	;Enable lower-case
.TITLE MIT LOGO

;	Logo Language Interpreter for the Apple-II-Plus Personal Microcomputer

;	Written and developed by Stephen L. Hain, Patrick G. Sobalvarro,
;	and Leigh L. Klotz with the M.I.T. Logo Group, at the Massachusetts
;	Institute of Technology.

;	Property of the M.I.T. Logo Laboratory,
;	545 Technology Square, Cambridge, MA 02139.
;	Copyright (C) 1980,81 Massachusetts Institute of Technology
;	All rights reserved.

;	This version of the Logo Language Interpreter runs on a 48K Apple-II-Plus
;	microcomputer equipped with a floppy disk and the Apple Language System card.

GRPINC	=1	;Nonzero means include graphics.
MUSINC	=0	;Nonzero means include music.
.PAGE
.SBTTL	Assembly Data
.SBTTL		Page Zero Variables

LNIL	= $00	;The nil node
PRECED	= $04	;Current function's precedence
NARGS	= $05	;No. of arguments for current function
EXPOUT	= $06	;Output expected if nonzero
OTPUTN	= $07	;Output given if nonzero
DEFFLG	= $08	;Defining a ufun if nonzero
RUNFLG	= $09	;Evaluating RUN or REPEAT if nonzero
STPFLG	= $0A	;Stop executing current ufun if nonzero
COFLAG	= $0B	;Return from current break-loop (CONTINUE) if nonzero
FUNTYP	= $0C	;Typecode of current function (ufun or sfun)
UFRMAT	= $0D	;Format (list or fpack) of current ufun
ERRNUM	= $0E	;Error code of last error
COLNUM	= $0F	;Graphics, current line color number
GCFLAG	= $10	;If nonzero, doing a grabage collect.
TRFLG	= $11	;Tail-recursion flag (set to value of NEST by OUTPUT)
SP	= $12	;Stack pointer
VSP	= $14	;Value-stack pointer
SIZE1	= $16	;Size of area pointed to by AREA1
SIZE2	= $18	;Size of area pointed to by AREA2
AREA1	= $1A	;Pointer to g.c.-protected area of SIZE1 contiguous nodes
AREA2	= $1C	;Pointer to g.c.-protected area of SIZE2 contiguous nodes
NNODES	= $1E	;Number of nodes allocated
;	Monitor variables:
WNDLFT	= $20	;Left column of text window (0-$37)
WNDWTH	= $21	;Width of text window (1-$28)
WNDTOP	= $22	;Top line of text window (0-$17)
WNDBTM	= $23	;Length of text window (1-$18)
CH	= $24	;Cursor column number
CV	= $25	;Cursor line number
;	DOS wants $26,$27 (RWTS)
BASLIN	= $28	;Cursor line memory pointer
;	DOS wants $2A,$2B,$2C,$2D,$2E,$2F (RWTS)
BSLTMP	= $2A	;I/O temp. var.
HMASK	= $30	;Graphics, bit mask
HNDX	= $31	;Graphics, index variable
INVFLG	= $32	;Character output mask (flash, invert, normal)
;	DOS wants $33
PALETN	= $34	;Graphics, current palette number
;	DOS wants $35 (RWTS),$36,$37,$38,$39
YSAVE	= $35	;Temp. Y reg. storage for Output routines
OTPDEV	= $36	;Output device driver address
INPDEV	= $38	;Input device driver address
TSHOWN	= $3A	;Graphics, Turtle shown if nonzero
IFTEST	= $3B	;TEST flag (TRUE if zero)
PLINE	= $3C	;Input line character pointer for parser
;	DOS wants $3C,$3D,$3E,$3F (RWTS)
;	DOS wants $40
;	DOS wnats $41 (RWTS)
;	DOS wants $42,$43
;	DOS wants $44,$45,$46,$47 (RWTS)
;	DOS wants $48,$49 (RWTS)
A1L	= $40	;Temp. var. (Editor, Infix operations, Number Parsing)
A2L	= $42	;Temp. var. (Editor, Infix operations, Number Parsing)
A3L	= $44	;Temp. var. (Editor, Infix operations)
A4L	= $46	;Temp. var. (Editor, Infix operations, Graphics)
A5L	= $48	;Temp. var. (Graphics)
;	DOS wants $4A,$4B,$4C,$4D
SHAPE	= $4A	;Graphics, shape address
RNDL	= $4C	;Random no. seed (low)
RNDH	= $4D	;Random no. seed (high)
CHBUFR	= $4E	;Character buffer next-char-to-read pointer
CHBUFS	= $4F	;Character buffer next-free-loc pointer
RANDOM	= $50	;Random number
PRSFLG	= $52	;Indicates the parser is executing, for CONS
INPFLG	= $53	;Nonzero means evaluating from the edit buffer
OTPFLG	= $54	;Nonzero means special print mode (no funny-pname quotes)
SOBLST	= $55	;Pointer to start of System Object List
SOBTOP	= $57	;Pointer to end of System Object List
SFSTCH	= $59	;pointer to first char on screen
SLSTCH	= $5B	;pointer to char after last char on screen
FRLIST	= $5D	;Pointer to start of Freelist
BRKSP	= $5F	;pointer to last break-frame
CURTOK	= $61	;Curent Token pointer
NEXTOK	= $63	;Next Token pointer
FUNCT	= $65	;Points to current Function
IFLEVL	= $67	;IF nesting level
WRPFLG	= $68	;Set indicates graphics wrapping
FRAME	= $69	;Pointer to current stack frame
XFRAME	= $6B	;Pointer to end of current stack frame
FBODY	= $6D	;Pointer to body of current Ufun
BUFOWN	= $6F	;Buffer owner (Graphics=Neg.;Music=1;Editor=2;Nobody=0)
FPTR	= $70	;Pointer to remainder of Ufun being executed
GOPTR	= $72	;Pointer to location of Ufun line to GO to
ULNEND	= $74	;Pointer to end of current line of Fpack Ufun
NEST	= $76	;EVAL nesting of current EVLINE (1 byte)
LEVNUM	= $77	;Ufun nesting level (3 bytes)
TLLEVS	= $7A	;Number of tail recursions included in LEVNUM (3 bytes)
DEFATM	= $7D	;Pointer to atom of Ufun currently being edited
;	DOS wants $7F
GCVST	=MARK1	;Start of Garbage Collecor protected variable area
MARK1	= $80	;G.C.-protected ptr.
MARK2	= $82	;G.C.-protected ptr.
MARK3	= $84	;G.C.-protected ptr.
MARK4	= $86	;G.C.-protected ptr.
DEFBOD	= $88	;Pointer to body of ufun currently being defined
UNSUM	= $8A	;Unary Sum pointer
UNDIF	= $8C	;Unary Difference pointer
ILINE	= $8E	;Current/previous toplevel command line
TOKPTR	= $90	;Token list Pointer
TRUE	= $92	;TRUE atom pointer
FALSE	= $94	;FALSE atom pointer
GCVND	=FALSE	;End of Garbage Collector protected variable area
OBLIST	= $96	;Pointer to Oblist
PODEFL	= $98	;Default ufun atom
EPOINT	= $9A	;Editor point
ENDBUF	= $9C	;Location after last character in edit buffer
;	NOTE:	The following temporary variables must be in the correct order:
ARG2	= $9E	;Primitive's second argument ptr.
NARG2	= $9E	;Fix/flonum temp.
ARG1	= $A2	;Primitive's first argument ptr.
NARG1	= $A2	;Fix/flonum temp.
TMPSTT	=TEMPNH		;Start of page-zero swapped temporaries
TEMPNH	= $A6	;Temp. var.
TEMPN	= $A8	;Temp. var.
TEMPN1	= $AA	;Temp. var.
TEMPN2	= $AC	;Temp. var.
TEMPN3	= $AE	;Temp. var.
TEMPN4	= $B0	;Temp. var.
ANSN	= $B2	;Temp. var.
ANSN1	= $B3	;Temp. var.
TMPEND	=ANSN1		;Last page-zero swapped temporary
TEMPN5	= $B4	;Temp. var.
TEMPN6	= $B6	;Temp. var.
TEMPN7	= $B8	;Temp. var.
TEMPN8	= $BA	;Temp. var.
TEMPX1	= $BC	;Temp. var.
TEMPX2	= $BE	;Temp. var.
TEMPX3	= $C0	;Temp. var.
;	End of ordered temporary variables
ANSN2	= $C2	;Temp. var.
ANSN3	= $C3	;Temp. var.
ANSN4	= $C4	;Temp. var.
PNCOLR	= $C5	;Graphics, current line color
;	XCOR,YCOR,HEADNG should be consecutive:
XCOR	= $C6	;Graphics, X-Coordinate, floating pt.
YCOR	= $CA	;Graphics, Y-Coordinate, floating pt.
HEADNG	= $CE	;Graphics, Heading, floating pt.
BKGND	= $D2	;Graphics, background color
PEN	= $D3	;Graphics, indicates pen down if nonzero
NARGX	= $D4	;Numeric temporary, 4 bytes (Number Parsing, Arctangent)
;	DOS wants $D8
X0L	= $D9	;Graphics, X loc. (low)
X0H	= $DA	;Graphics, X loc. (high)
Y0	= $DB	;Graphics, Y loc.
HBASLN	= $DC	;Graphics, screen memory line pointer
TRACE	= $DE	;Trace mode if nonzero
NPARTS	= $DF	;Music, number of voices in use
PARPNT	= $E0	;Music, current buffer pointer

DEFINP	= $E2	;Normal INPDEV routine address
DEFOUT	= $E4	;Normal OTPDEV routine address

SAVMOD	= $E6	;Nonzero means buffer contains only text
.PAGE
.SBTTL		Other Variable Storage

CHBSTT	=$300		;Start of character buffer
CHBLEN	=$40		;Length of character buffer

SCRNCH	=$340		;Graphics Y-axis scrunch factor
MSLOT	=$344		;Music card slot number times 16.

SVXCOR	=$345		;Graphics intermediary values for SETTURTLE
SVYCOR	=$349
SHEDNG	=$34D
SPEN	=$351
STSHWN	=$352
SCLNM	=$353
SPLTN	=$354

MEACTP	=$355		;Music state variables
MPACTP	=$357
MEPRT	=$359

TMPTAB	=$35B		;Start of temporary storage area

;	DOS wants $3D0-$3FF
;	DOS also uses various free bytes in the primary page screen memory ($400-$7FF)

;	Buffer information for disk-saving
DSKB1	=$4000
DSKB2	=$4001

PROGRM	=$4002		;Start of Logo code above buffer

;	Globally shared variables:
NODPTR	=ANSN		;Returned pointer address
CCOUNT	=ANSN1		;Char. count
TYPPTR	=TEMPNH		;Pointer into typecode-array
.PAGE
.SBTTL		Assembly Constants

;	Type-code constants:
LIST	=0	;List
ATOM	=1	;Atom
STRING	=2	;Alphanumeric linked-list
FIX	=3	;Fixnum (GT1NUM,GT2NUM require that FIX < FLO)
FLO	=4	;Floating point number
SFUN	=5	;System function
UFUN	=6	;User function
SATOM	=7	;Primitive
FPACK	=8	;Packed ufun
QATOM	=9	;Quoted atom (must equal 9 for PUTTYP,GETTYP)
DATOM	=10	;Dotted atom (must equal 10 for PUTTYP,GETTYP)
LATOM	=11	;Label atom (must equal 11 for PUTTYP,GETTYP)
HITYP	=11	;Highest type, for dispatch tables.
;	Parser constants:
NEWLIN	=1	;Start of input line
NEWLST	=2	;Start of sublist
REGCEL	=3	;Regular linked cell
;	General constants:
FULCHR	=$06	;Full-screen graphics character (Control-F)
STPKEY	=$07	;Stop-key character code (Control-G)
MIXCHR	=$13	;Mixed-screen graphics character (Control-S)
PULCHR	=$10	;Redisplay last line typed (Control-P)
LSTKEY	=$17	;Interrupt output listing (Control-W)
PAUSKY	=$1A	;Pause-key character code (Control-Z)
TXTCHR	=$14	;Text-screen character (Control-T)
VEWCHR	=$16	;Graphics-screen character (Control-V)
IOKEY	=$1D	;Restore KBD input device driver (Control-Shift-N)
RPRMPT	='<	;REQUEST prompt
QPRMPT	='?	;Regular prompt
LBRAK	='^	;Left-bracket replacement character
CR	=$0D	;Ascii carriage-return character
SPACE	=$20	;Ascii space character
QUOTE	=$27	;Ascii single-quote character
COMMA	=$2C	;Ascii comma character
RANDA	=5353	;Random transform constant "A"
RANDC	=43277	;Random transform constant "C"
;	Storage Parameters:
LINBUF	=$200		;Input line buffer (Page 2 for DOS compatibility)
PRSBUF	=$200		;Parse-string buffer
PRSLIM	=$2FF		;Parse-string buffer upper limit
GRPSTT	=$2000		;Start of hires graphics area
GRPEND	=$4000		;End of Hires graphics area
EDBUF	=$2000		;Start of editor buffer
EBFEND	=$3FFE		;End of edit buffer (leaving room for CR)
;	Mapped I/O locations:
GETRM1	=$C08B	;Enable high RAM (with first 4K bank)
GETRM2	=$C083	;Enable high RAM (with second 4K bank, "Ghost-memory")
KILRAM	=$C08A	;Deselect high RAM (enable Monitor/BASIC)
KBDBYT	=$C000	;Keyboard input byte
KBDCLR	=$C010	;Keyboard clear strobe
GSW	=$C050	;Graphics mode
TXTMOD	=$C051	;Display text page
FULLGR	=$C052	;Full Graphics screen
MIXGR	=$C053	;Mixed Text/Graphics switch
PRMPAG	=$C054	;Primary page
HGSW	=$C057	;High-res mode
SPKR	=$C030	;Toggle speaker
PTRIG	=$C070	;Paddle timer reset
PADDL	=$C064	;Paddle counter locations
PADBTN	=$C061	;Paddle button locations
;	Interrupt Vector areas:
RSTVEC	=$FFFC	;Location of RESET vector
IRQVEC	=$FFFE	;Location of IRQ vector
NMIVEC	=$FFFA	;Location of NMI vector (BRK command)
;	System vectors:
RESETV	=SBPT	;RESET Vector
ROMMON	=$FA4C	;ROM Monitor entry point BREAK
ROMSTN	=$FE84	;ROM Monitor SETNORM routine
ROMNIT	=$FB2F	;ROM Monitor INIT routine
ROMSTV	=$FE93	;ROM Monitor SETVID routine
ROMSTK	=$FE89	;ROM Monitor SETKBD routine
MONACC	=$45	;ROM Monitor ACC location
MONBKV	=$03F0	;ROM Monitor BRKV vector
MONOBK	=$FA59	;ROM Monitor OLDBRK routine
;	DOS locations/addresses:
DOSEAT	=$A851	;DOS subroutine to give DOS control of input
DSERET	=$9D5A	;DOS error return vector location
FILLEN	=$AA60	;DOS variable: Length of last file loaded
;???The following six addresses are all probably wrong:
DOSLEN	=$AA60	;DOS variable: Length of file to save
DOSFIL	=$AA72	;DOS variable: Start of file to save
DOSLOD	=$AA72	;DOS variable: Load addr. of file to load
DOSNAM	=$9CD3	;Address of DOS file name buffer
MAXNAM	=$1E	;Maximum no. of chars. allowed in DOS filenames
ENDNAM	=DOSNAM+MAXNAM
BLOAD	=$A35D	;BLOAD Routine address
BSAVE	=$A331	;BSAVE Routine address
DOSCAT	=$A56E	;CATALOG Routine address
DOSDEL	=$A263	;DELETE Routine address
.PAGE
;	Explicit primitive pointers:
PRMBEG	=NODBEG-$0C	;Unary Sum and Unary Difference are not on the Soblist

INFSUM	=INSUM*4+PRMBEG
INFDIF	=INDIF*4+PRMBEG
LPAR	=ILPAR*4+PRMBEG
RPAR	=IRPAR*4+PRMBEG
IF	=IIF*4+PRMBEG
ELSE	=IELSE*4+PRMBEG
THEN	=ITHEN*4+PRMBEG
NAMES	=INAMES*4+PRMBEG
ALL	=IALL*4+PRMBEG
TITLES	=ITITLS*4+PRMBEG
PROCS	=IPROCS*4+PRMBEG
END	=IEND*4+PRMBEG
STOP	=ISTOP*4+PRMBEG
COMMNT	=ICOMNT*4+PRMBEG
GO	=IGO*4+PRMBEG
TO	=ITO*4+PRMBEG
EDIT	=IEDIT*4+PRMBEG
;These primitives must be in the Soblist in the order of their indexes.

XZAP	=255	;Special case error code

;	XZAP Quantifiers:
XNSTOR	=0	;No storage left
XSTOP	=1	;Stopped!
XNSTRN	=2	;Out of nodes (Prints "No storage left" msg)
XNRGEX	=3	;Too many inputs
XPNEST	=4	;Procedure nesting too deep
XTNEST	=5	;Tail-recursion nesting too deep
PRNNST	=6	;Parenthesis nesting too deep
XIFLEX	=7	;If-level nesting too deep
XENEST	=8	;Evaluator nesting too deep
.PAGE
.SBTTL		Storage Parameters

;	Miscellaneous:	Page 0 - Variables
;			Page 1 - Processor Stack
;			Page 2 - Input line buffer (for DOS also)
;			Page 3 - Variable storage, character buffer
;			Pages 4 to 7 - Text screen page

;MISCELLANEOUS:	$0000 - $07FF: $ 800 bytes (2048 bytes)
;PDL & VPDL:	$0800 - $1BF5: $13F6 bytes (5110 bytes) 2555 words
;ENTRY POINTS:	$1BF6 - $1BFF: $   A bytes (10 bytes) Start/Restart/Reentry
;OTHER CODE:	$1C00 - $1FFF: $ 400 bytes (1024 bytes) I/O routines
;BUFFER:	$2000 - $4001: $2002 bytes (8194 bytes) Graphics/Editor
;LOGO CODE:	$4002 - $9AA5: $5AA4 bytes (23204 bytes) Main Logo code
;DOS:		$9AA6 - $BFFF: $255A bytes (9562 bytes) DOS code, buffers
;I/O:		$C000 - $CFFF: $1000 bytes (4096 bytes) Mapped I/O addresses
;NODESPACE:	$D000 - $F65F: $2660 bytes (9824 bytes) 2456 nodes
;TYPE CODES:	$F660 - $FFF7: $ 998 bytes (2456 bytes)
;UNUSED:	$FFF8 - $FFF9: $   2 bytes
;INTERRUPTS:	$FFFA - $FFFF: $   6 bytes (6 bytes) NMI, RESET, IRQ

;GHOST MEMORY:	$D000 - $DFFF: $1000 bytes (4096 bytes) Static storage

NODBEG	=$D000		;Nodespace beginning
BBASX	=NODBEG-4
NODLEN	=$2660		;Nodespace length
NODEND	=NODBEG+NODLEN	;Nodespace end
;OFSET1	=NODBEG/4 ...stupid cross assembler can't divide correctly...
OFSET1	=$3400		;Offset constant
TYPARY	=NODEND-OFSET1	;Typebase offset
TYPLEN	=NODLEN/4	;Typebase length
TYPEND	=NODEND+TYPLEN	;Typebase end
NODTST	=50		;Minimum free nodes for parser
NODLIM	=TYPLEN-NODTST	;Node allocation limit
STKLEN	=$13F6		;Combined stack length
PDLBAS	=$800		;PDL beginning (grows upwards, Push-then-incr.)
VPDLBA	=PDLBAS+STKLEN-2;VPDL beginning (grows downwards, Push-then-decr.)
STKLIM	=80		;Minimum unused stack space before panicking

GHODAT	=$3000		;Page no. of System tables (after loading)
GHOMEM	=$D000		;Page no. of Ghost-memory
TDIFF	=GHOMEM-GHODAT	;Difference between above storage areas
OCODE	=$1C00		;Location of separated code
.PAGE
.SBTTL	Macro definitions

;NOTE: These macros should return with the same values in the registers
; and flags as they do now.

;Unless otherwise specified, variables and constants are sixteen-bit, and
;registers hold addresses of sixteen-bit variables.

;VAL gets the car of NODE. VAL can't equal NODE.
.MACRO	CAR VAL,NODE
	LDY #$00
	LDA (NODE),Y
	STA VAL
	INY
	LDA (NODE),Y
	STA VAL+1
.ENDM

;X gets the car of NODE. X can't equal #NODE.
.MACRO	CARX NODE
	LDY #$00
	LDA (NODE),Y
	STA $00,X
	INY
	LDA (NODE),Y
	STA $01,X
.ENDM

;NODE gets the car of NODE.
.MACRO	CARME NODE
	LDY #$00
	LDA (NODE),Y
	TAX
	INY
	LDA (NODE),Y
	STA NODE+1
	STX NODE
.ENDM

;VAL gets the cdr of NODE. VAL can't equal NODE.
.MACRO	CDR VAL,NODE
	LDY #$02
	LDA (NODE),Y
	STA VAL
	INY
	LDA (NODE),Y
	STA VAL+1
.ENDM

;X gets the cdr of NODE. X can't equal #NODE.
.MACRO	CDRX NODE
	LDY #$02
	LDA (NODE),Y
	STA $00,X
	INY
	LDA (NODE),Y
	STA $01,X
.ENDM

;NODE gets the cdr of NODE.
.MACRO	CDRME NODE
	LDY #$02
	LDA (NODE),Y
	TAX
	INY
	LDA (NODE),Y
	STA NODE+1
	STX NODE
.ENDM

;VAL gets the car of NODE, NODE gets the cdr of NODE. VAL can't equal NODE.
.MACRO	CARNXT VAL,NODE
	LDY #$00
	LDA (NODE),Y
	STA VAL
	INY
	LDA (NODE),Y
	STA VAL+1
	INY
	LDA (NODE),Y
	TAX
	INY
	LDA (NODE),Y
	STA NODE+1
	STX NODE
.ENDM

;The car of NODE becomes VAL.
.MACRO	RPLACA NODE,VAL
	LDY #$00
	LDA VAL
	STA (NODE),Y
	INY
	LDA VAL+1
	STA (NODE),Y
.ENDM

;The car of NODE becomes X.
.MACRO	RPLCAX NODE
	LDY #$00
	LDA $00,X
	STA (NODE),Y
	INY
	LDA $01,X
	STA (NODE),Y
.ENDM

;The cdr of NODE becomes VAL.
.MACRO	RPLACD NODE,VAL
	LDY #$02
	LDA VAL
	STA (NODE),Y
	INY
	LDA VAL+1
	STA (NODE),Y
.ENDM

;The cdr of NODE becomes X.
.MACRO	RPLCDX NODE
	LDY #$02
	LDA $00,X
	STA (NODE),Y
	INY
	LDA $01,X
	STA (NODE),Y
.ENDM

;PTR (p.z. variable name) gets pushed on the PDL.
.MACRO	PUSH PTR
	LDX #PTR
	JSR PUSHP
.ENDM

;ADDR gets pushed on the PDL
.MACRO	PUSHA ADDR
	LDX #ADDR&$FF
	LDY #ADDR^
	JSR PUSH
.ENDM

;PTR (p.z. variable name) gets popped from the PDL.
.MACRO	POP PTR
	LDX #PTR
	JSR POP
.ENDM

;PTR (p.z. variable name) gets pushed on the VPDL.
.MACRO	VPUSH PTR
	LDX #PTR
	JSR VPUSHP
.ENDM

;PTR (p.z. variable name) gets popped from the VPDL.
.MACRO	VPOP PTR
	LDX #PTR
	JSR VPOP
.ENDM
.PAGE
;VAR (one byte) gets pushed on the PDL.
.MACRO	PUSHB VAR
	LDA VAR
	JSR PUSHB
.ENDM

;VAR gets the byte popped off of the PDL.
.MACRO	POPB VAR
	JSR POPB
	STA VAR
.ENDM

;PTR (p.z. variable name) points to the new node, with car CAR
; and cdr CDR (both p.z. variable names) and typecode TYPEC.
.MACRO	CONS PTR,CAR,CDR,TYPEC
	LDA #PTR
	STA NODPTR
	LDX #CDR
	LDY #CAR
	LDA #TYPEC
	JSR CONS
.ENDM

;Load four bytes into a numerical variable.
.MACRO	SETNUM NUMPTR,VALUE ?SETNM1
	LDX #$03
SETNM1:	LDA VALUE,X
	STA NUMPTR,X
	DEX
	BPL SETNM1
.ENDM

;Signal an error, first arg is error number, one or two qualifiers optional.
.MACRO	ERROR ERRN,PTR1,PTR2
.NARG NRGS
.IFGE NRGS-2
	LDY #PTR1
.ENDC
.IFGE NRGS-3
	LDX #PTR2
.ENDC
	LDA #ERRN
	JMP ERROR
.ENDM

;VALUE gets incremented by 1.
.MACRO	INC1 VALUE ?INC1A
	INC VALUE
	BNE INC1A
	INC VALUE+1
INC1A:
.ENDM

;VALUE gets incrmented by 2.
.MACRO	INC2 VALUE ?INC2A
	CLC
	LDA VALUE
	ADC #$02
	STA VALUE
	BCC INC2A
	INC VALUE+1
INC2A:
.ENDM

;X (ptr.) gets incremented by 2.
.MACRO	INC2X ?INC2XA
	CLC
	LDA $00,X
	ADC #$02
	STA $00,X
	BCC INC2XA
	INC $01,X
INC2XA:
.ENDM

;VALUE gets incrmented by 4.
.MACRO	INC4 VALUE ?INC4A
	CLC
	LDA VALUE
	ADC #$04
	STA VALUE
	BCC INC4A
	INC VALUE+1
INC4A:
.ENDM

;X (ptr.) gets incremented by 4.
.MACRO	INC4X ?INC4XA
	CLC
	LDA $00,X
	ADC #$04
	STA $00,X
	BCC INC4XA
	INC $01,X
INC4XA:
.ENDM

;VALUE gets decremented by 1.
.MACRO	DEC1 VALUE ?DEC1A
	SEC
	LDA VALUE
	SBC #$01
	STA VALUE
	BCS DEC1A
	DEC VALUE+1
DEC1A:
.ENDM

;VALUE gets decremented by 2.
.MACRO	DEC2 VALUE ?DEC2A
	SEC
	LDA VALUE
	SBC #$02
	STA VALUE
	BCS DEC2A
	DEC VALUE+1
DEC2A:
.ENDM

;Type character CHAR (one byte).
.MACRO	TPCHR CHAR
	LDA #CHAR
	JSR TPCHR
.ENDM

;Print MSG (text string address).
.MACRO	PRTSTR MSG
	LDX #MSG&$FF
	LDY #MSG^
	JSR PRTSTR
.ENDM

;Dispatch off of typecode in A from table at ADDR.
.MACRO	TYPDSP ADDR
	LDX #ADDR&$FF
	LDY #ADDR^
	JMP TYPDSP
.ENDM

;Get typecode of NODE.
.MACRO	GETTYP NODE
	LDX #NODE
	JSR GETTYP
.ENDM

;X gets VALUE.
.MACRO	PUTX VALUE
	LDA VALUE
	STA $00,X
	LDA VALUE+1
	STA $01,X
.ENDM

;VALUE gets X.
.MACRO	GETX VALUE
	LDA $00,X
	STA VALUE
	LDA $01,X
	STA VALUE+1
.ENDM

;VALUE gets Y.
.MACRO	GETY VALUE
	LDA $00,Y
	STA VALUE
	LDA $01,Y
	STA VALUE+1
.ENDM

;Sixteen-bit move:
;VAL1 gets VAL2 if two args or VAL1,VAL2 get VAL3 if three args.
.MACRO	MOV VAL1,VAL2,VAL3
.NARG NRGS
.IFEQ NRGS-3
	LDA VAL3
	STA VAL1
	STA VAL2
	LDA VAL3+1
	STA VAL1+1
	STA VAL2+1
.ENDC
.IFEQ NRGS-2
	LDA VAL2
	STA VAL1
	LDA VAL2+1
	STA VAL1+1
.ENDC
.ENDM

;Sixteen-bit immediate move:
;VAL1 gets #VAL2 if two args or VAL1,VAL2 get #VAL3 if three args.
.MACRO	SETV VAL1,VAL2,VAL3
.NARG NRGS
.IFEQ NRGS-3
	LDA #VAL3&$FF
	STA VAL1
	STA VAL2
	LDA #VAL3^
	STA VAL1+1
	STA VAL2+1
.ENDC
.IFEQ NRGS-2
	LDA #VAL2&$FF
	STA VAL1
	LDA #VAL2^
	STA VAL1+1
.ENDC
.ENDM

;Compare variable VAR1 with variable VAR2 (VAR1-VAR2).
.MACRO	COMP VAR1,VAR2 ?COMP1
	LDA VAR1+1
	CMP VAR2+1
	BNE COMP1
	LDA VAR1
	CMP VAR2
COMP1:
.ENDM

;Compare variable VAR with constant VAL (VAR-VAL).
.MACRO	CMPV VAR,VAL ?CMPV1
	LDA VAR+1
	CMP #VAL^
	BNE CMPV1
	LDA VAR
	CMP #VAL&$FF
CMPV1:
.ENDM

;Enable nodespace RAM.
.MACRO	NODRAM
	STA GETRM1
	STA GETRM1
.ENDM

;Disable nodespace RAM, enable data RAM ("ghost memory").
.MACRO	DATRAM
	STA GETRM2
.ENDM

;Make a sine table entry
SINDIF=93*2		;Length of half of sine table, in bytes
.MACRO	SINTAB HIVAL,LOVAL
	.WORD HIVAL	;Put the high value here
.=.+SINDIF-2		;Move point to next loc in low-val table
	.WORD LOVAL	;Put the low value in
.=.-SINDIF		;Move point back to next loc in high-val table
.ENDM

;Make a primitive entry
.MACRO PRIM ARGS,PREC,INDEX,PNAME
LP=LP+1			;Increment primitive number
	.BYTE ARGS
	.BYTE PREC
	.BYTE LP
	.ASCIZ PNAME
INDEX=LP
.ENDM

;Make a primitive abbreviation entry (doesn't change index or primitive number).
.MACRO PRIMA ARGS,PREC,INDEX,PNAME
	.BYTE ARGS
	.BYTE PREC
	.BYTE INDEX
	.ASCIZ PNAME
.ENDM

;Define a new error index
ERRID=0		;Initial index value
.MACRO	ERRSET ERRNAM
	ERRNAM=ERRID
	ERRID=ERRID+1
.ENDM

.PAGE
.SBTTL	Top Level

.=PROGRM
;	Local variable block:
BOTPTR	=TEMPNH		;Boot-area pointer
BOTPT1	=TEMPN		;Destination-area pointer

;Calling point for the Logo Interpreter
LOGO:	NODRAM		;Enable high RAM
	SETV RSTVEC,RESETV	;Set up the RESET key vector
;???Initialize DOS.
	LDA #GHODAT^	;Page no. of tables
	STA BOTPTR+1
	LDA #GHOMEM^	;Page no. of ghost-memory
	STA BOTPT1+1
	LDX #ENDTAB^	;Last page
	LDY #$00
	STY BOTPTR
	STY BOTPT1
	DATRAM		;Select Ghost-memory for writing
	DATRAM	
MOVLOP:	LDA (BOTPTR),Y
	STA (BOTPT1),Y
	INY
	BNE MOVLOP
	INC BOTPTR+1
	INC BOTPT1+1
	CPX BOTPTR+1	;See if last page transferred
	BCS MOVLOP

;Re-entry point for GOODBYE:
LOGO1:	CLD		;Disable decimal mode
	LDX #$FF
	TXS		;Initialize processor stack
	INX
	STX $00		;Define LNIL as $0000 at $0000 (YUK!)
	STX $01
	STX $02
	STX $03
	NODRAM		;Disable Ghost-memory
	SETV IRQVEC,NMIVEC,MONBRK	;Interrupts cause a break to Monitor
	LDA #$00
	STA BUFOWN	;Nobody owns the buffer
	SETV DEFINP,KEYIN	;Init normal drivers to KBD
	SETV DEFOUT,COUT	;and screen
.IFNE GRPINC
	JSR GRINIT	;Graphics init
.ENDC
.IFNE MUSINC
	JSR MSINIT	;Music init
.ENDC
	JSR REINIT	;Nodespace init
	PRTSTR HELSTR	;Types Hello-String
;Evaluator top loop. Prints the prompt, reads and parses a line,
; and calls EVLUAT.
TOPLOP:	LDA #QPRMPT
	JSR PGTLIN		;Print the prompt and read a line
	LDX #ILINE
	JSR PRSLIN		;Parse the line
	MOV TOKPTR,ILINE	;Set token-pointer to beginning of line
;	...
.PAGE
.SBTTL	Evaluator Routines

;	Local variable block:
TOKEN	=TEMPN		;Token ptr.
ADRESS	=TEMPNH		;Popped return address
VALUE	=TEMPN		;Binding value
NARGS1	=ANSN		;Temporary NARGS
NXLINE	=TEMPN		;Next line ptr.
NWLINE	=TEMPN1		;New consed line
PREC1	=ANSN2		;Temp. precedence
INDEX	=TEMPN		;Table index
ATMPTR	=TEMPX1		;Ptr. to interned string
TOPVAL	=TEMPX1		;Toplevel output value

;EVLUAT is the top loop evaluator. It initializes all the evaluator
; variables and stacks, and then calls EVLINE.
;	...
EVLUAT:	SETV SP,PDLBAS	;Clear the PDL
	SETV VSP,VPDLBA	;Clear the VPDL
	LDA #$00
	STA EXPOUT
	STA RUNFLG
	STA STPFLG
	STA COFLAG
	STA UFRMAT	;Top level command line is typecode LIST
	STA ERRNUM
	STA LEVNUM
	STA LEVNUM+1
	STA LEVNUM+2
	STA TLLEVS
	STA TLLEVS+1
	STA TLLEVS+2
	STA FRAME+1
	STA XFRAME+1
	STA BRKSP+1	;BRKSP = nil means break to toplevel from errors
	PUSHA TOPLOP	;Top-level Return Address

;EVLINE evaluates the ILINE.
EVLINE:	JSR TSTSTK	;Check for stack collision
	JSR POLLZ	;Check for interrupts, incl. PAUSE
	PUSHB EXPOUT
	PUSHB IFLEVL
	LDA #$00
	STA EXPOUT
	STA IFLEVL
	LDA TOKPTR+1
	BEQ EVLN1P	;EOL, return from EVLINE
EVLN1:	CAR TOKEN,TOKPTR	;Look at the next token
	GETTYP TOKEN
	CMP #LATOM	;See if it's a label
	BNE EVLN1A
	LDA LEVNUM	;It is, see if it's in the top level command line
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ EVLN2E	;It is, give an error
	LDA FBODY+1
	BEQ EVLN2E	;If Fbody is nil, we're in a break loop
	JSR TOKADV	;It's not, so skip over it

;EVLIN1 keeps calling EVLEXP until EOL or Stop-flag set.
EVLIN1:	LDA TOKPTR+1
	BNE EVLN1A
EVLN1P:	POPB IFLEVL	;If at EOL, return from EVLINE
	POPB EXPOUT

;Pops an address off of the VPDL and jumps to it.
POPJ:	POP ADRESS
	JMP (ADRESS)

EVLN2E:	ERROR XLB1	;Error - Label at toplevel

EVLN1A:	LDA STPFLG
	BNE EVLN1P	;Return from EVLINE if Stop-flag is set
	PUSHA EVLIN1	;Else push EVLIN1 return address and call EVLEXP

;EVLEXP calls EVAL with PRECED = 0. EVAL returns to EVEX1,
;which restores old PRECED.
EVLEXP:	PUSHB PRECED
	LDA #$00
	STA PRECED
	PUSHA EVEX1

;EVAL dispatches off of the typecode of the current token. All return
;eventually to EVWRAP.
EVAL:	JSR POLL	;Poll at every token to be evaluated
	PUSH CURTOK
	LDA FRAME+1
	BEQ EVAL2
	INC NEST	;Increment NEST if FRAME is nonzero
	BPL EVAL2
	LDX #XENEST
	JMP EXCED	;Evaluator nesting too deep
EVAL2:	LDA TOKPTR+1
	BEQ EVAL3	;Error if EOL
	CAR CURTOK,TOKPTR	;Get current and next tokens
	JSR TOKADV
	JSR GTNXTK
	GETTYP CURTOK	;Dispatch off typecode of current token
	TYPDSP EVLTB1

;Evaluator typecode dispatch table
EVLTB1:	.ADDR CASEQ	;List
	.ADDR CASEA	;Atom
	.ADDR CASEST	;String
	.ADDR CASEQ	;Fix
	.ADDR CASEQ	;Flo
	.ADDR SYSBG1	;Sfun
	.ADDR SYSBG1	;Ufun
	.ADDR CASEA	;Satom
	.ADDR SYSBG1	;Fpack
	.ADDR CASEQ	;Qatom
	.ADDR CASED	;Datom
	.ADDR CASEL	;Latom

EVAL3:	POP CURTOK
	ERROR XNMI,CURTOK	;CURTOK NEEDS MORE INPUTS
SYSBG1:	LDA #$01	;Bad token-typecode in command line
	JMP SYSBUG
;String dispatch. If it's not an satom, then it's an error.
CASEST:	LDX #CURTOK
	LDY #ATMPTR
	JSR INTRNP	;See if it's interned
	CMP #SATOM
	BNE CASEA1	;Error - Haven't told me how to ...
	MOV CURTOK,ATMPTR	;It's interned, update the pointer
	JMP CASEA		;and handle as a function
;Label atom dispatch
CASEL:	LDX #CURTOK
	ERROR XLAB	;Error - Can't execute a label
;Dotted atom dispatch
CASED:	LDY #CURTOK
	LDX #VALUE
	JSR GETVAL	;Get it's value (X not bashed, for CASEQ1)
	BNE CASEQ1	;Not Novalue, push it on the PDL
	LDA CURTOK	;Else strip the type-bits from the pointer
	AND #$FC
	STA CURTOK
	ERROR XHNV,CURTOK	;Error - Has no value
;Qatom, Fixnum, Flonum, List dispatch
CASEQ:	LDA CURTOK
	AND #$FC	;Strip off the pointer's type-bits
	STA CURTOK
	LDX #CURTOK	;Push the value on the VPDL
CASEQ1:	JSR VPUSHP
	LDA #$01
	STA OTPUTN	;Set Output-num
	JMP EVWRAP	;Wrap up this EVAL
;Atom, Satom dispatch
CASEA:	JSR GETCFN	;Get the function and typecode
	BEQ CASEA1	;If the function is Novalue, then error
	STY FUNTYP
	JSR INFIXP	;No, is it infix?
	BCC CASEA2	;Nope.
	CMP #INSUM	;Yes, is it "+"?
	BNE CASEA3	;Nope.
	MOV CURTOK,UNSUM	;Yes, update the curent-token
	SETV FUNCT,PRMSUM	;and the function to Unary-Sum
	JMP CASEA2
CASEA5:	ERROR XIFX,CURTOK
CASEA1:	ERROR XNDF,CURTOK
CASEA3:	CMP #INDIF	;Is the infix function "-"?
	BNE CASEA5	;Nope, error 'cause +,- are the only unary ops.
	MOV CURTOK,UNDIF	;Yes, update current-token
	SETV FUNCT,PRMDIF	;and the function to Unary-Difference
CASEA2:	PUSHB PRECED
	JSR GETPRC	;Get the new precedence
	STA PRECED
	JSR GETNGS	;Get the number of args
	AND #$7F
	STA NARGS
	PUSHA EVAL1	;Return to EVAL1 after args are gotten
	LDA NARGS
	BEQ ARGDON	;Done if no args to be gotten
	STA NARGS1	;Number of args remaining
	JSR PUSHB
	PUSH FUNCT
	PUSHB FUNTYP
	PUSHB EXPOUT
	PUSHB IFLEVL
;	...

;AL1 gets one arg.
;	...
AL1:	JSR GTNXTK
	PUSH NEXTOK
	PUSHB NARGS1
	PUSHB PRECED
	LDX #$00
	STX IFLEVL	;Reset If-level
	INX
	STX EXPOUT	;Set Expected-output
	PUSHA AL2
	JMP EVAL	;Evaluate the argument, returning to AL2.
ERXNPJ:	JMP ERXNOP

;AL2 checks to see if argument was gotten.
AL2:	POPB PRECED
	POPB NARGS1
	POP NEXTOK
	LDA OTPUTN
	BEQ ERXNPJ	;Error if no arg gotten
	DEC NARGS1
	BNE AL1		;Get another arg if not done
	POPB IFLEVL	;Else clean up and exit from arg-loop
	POPB EXPOUT
	POPB FUNTYP
	POP FUNCT
	POPB NARGS
ARGDON:	JMP POPJ

;Restores precedence from an EVAL clause.
EVEX1:	POPB PRECED
	JMP POPJ

;PARLOP is executed when an LPAR is encountered.
PARLOP:	LDX #NEXTOK
	JSR GTCFN1	;Get the next token's function and typecode
	BEQ PARLP7
	STY FUNTYP
	CPY #SFUN
	BNE PARLPA
	CMPV NEXTOK,RPAR	;It's an sfun, see if its an Rpar
	BNE PARLPA
	ERROR XNIP	;It is, error - Nothing inside parenthesis
PARLPA:	JSR GETNGS	;It's a function, get the no. of args
	STA NARGS
	TAX
	BMI PARLP3	;If high bit set, it's a variable-arg clause
PARLP7:	PUSHB EXPOUT	;Else it's just a parenthesized expression
	PUSHB IFLEVL
	LDX #$00
	STX IFLEVL	;Reset If-level
	INX
	STX EXPOUT	;Default is output expected
	PUSHA PLOP1
	JMP EVLEXP	;Evaluate the expression, returning to PLOP1
;Variable argument clause.
PARLP3:	JSR GETPRC	;Get the precedence
	STA PRECED
	MOV CURTOK,NEXTOK	;Skip the parenthesis
	JSR TOKADV
	LDA #$00
	STA NARGS	;Initialize no.-of-args
	PUSH FUNCT
	PUSHB FUNTYP
;	...

;VARGLP gets the args for a variable-arg clause.
;	...
VARGLP:	JSR GTNXTK	;Get the next token
	CMPV NEXTOK,RPAR	;See if it's an rpar
	BNE VRGLP1
	POPB FUNTYP	;It is, so no more args
	POP FUNCT
	JSR TOKADV	;Skip the rpar
	ASL NARGS	;Set high bit of NARGS
	SEC
	ROR NARGS
	JMP FNCAL1	;Execute the function
VRGLP1:	PUSHB NARGS	;Get another arg
	PUSH NEXTOK
	PUSHB EXPOUT
	PUSHB IFLEVL
	PUSHB PRECED
	LDX #$00
	STX IFLEVL	;Reset If-level
	INX
	STX EXPOUT	;Set Expected-output
	PUSHA VAL1
	JMP EVAL	;Evaluate an arg, returning to VAL1

;Checks to see if arg gotten in var-arg-loop.
VAL1:	POPB PRECED
	POPB IFLEVL
	POPB EXPOUT
	POP NEXTOK
	POPB NARGS
	LDA OTPUTN
	BEQ ERXNOP	;Error if no arg gotten
	INC NARGS	;Else increment no.-of-args
	BPL VARGLP	;Continue with loop if no overflow
EXCED:	ERROR XZAP,XNRGEX
ERXNOP:	ERROR XNOP,NEXTOK

;PLOP1 cleans up after a parenthesized expression.
PLOP1:	POPB IFLEVL
	POPB EXPOUT
	LDA TOKPTR+1	;The next token should be an rpar
	BEQ ERXMRP	;EOL, so error
	JSR GTNXTK	;Else get the next token
	CMPV NEXTOK,RPAR	;Is it an rpar?
	BNE PLOP1B	;Nope, error - Too much inside parenthesis
	JSR TOKADV	;Yes, skip it and continue
	JMP POPJ
PLOP1B:	ERROR XTIP
ERXMRP:	ERROR XMRP
.PAGE
;Cleans up after an EVAL clause.
EVWRAP:	LDA TOKPTR+1	;Just return if at EOL...
	BEQ EVRETN
	LDA OTPUTN
	BEQ EVRETN	;...or no value was gotten...
	LDA STPFLG
	BNE EVRETN	;...or stop-flag is set...
	CAR CURTOK,TOKPTR
	CMPV CURTOK,RPAR
	BEQ EVRETN	;...or an rpar is next...
	JSR GETCFN
	STY FUNTYP
	JSR INFIXP
	BCC EVRETN	;...or the next function isn't infix
	JSR GETPRC	;Infix function, get the precedence
	STA PREC1
	CMP PRECED	;Compare with previous precedence
	BCC EVRETN	;Just return if new precedence is smaller
	BEQ EVRETN	;or equal
	JSR TOKADV	;Else get the next token
	JSR GTNXTK
	PUSH NEXTOK	;Push the old infix function for EW1
	PUSH FUNCT
	PUSHB FUNTYP
	PUSHB EXPOUT
	PUSHB IFLEVL
	PUSHB PRECED
	LDA #$01
	STA EXPOUT	;Set expected-output
	LDA PREC1
	STA PRECED	;Update the precedence
	PUSHA EW1
	JMP EVAL	;Evaluate the clause, returning to EW1

;Simple return from EVAL clause.
EVRETN:	LDA FRAME+1
	BEQ EVRET1
EVRTN1:	DEC NEST	;Decrement NEST if FRAME is nonzero.
EVRET1:	LDA OTPUTN
	BEQ EVRET2	;Just return if no output gotten
	LDA EXPOUT
	ORA STPFLG
	ORA RUNFLG
	BNE EVRET2	;or Expected-output, Stop-flag, or Run-flag set
	VPOP TOPVAL	;Else get the value back
	LDA LEVNUM	;If at toplevel, print the output
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ EVRET3
	LDA FBODY+1
	BEQ EVRET3	;Also if at toplevel of a break-loop
	ERROR XUOP,VALUE	;Else give error - Don't say what to do with
EVRET3:	PRTSTR TOPMSG		;Print "Output is "
	LDX #TOPVAL
	JSR TYPE0		;Print the output
EVRET2:	POP CURTOK
	JMP POPJ

;EW1 handles a value gotten by a higher-precedence EVAL clause from EVWRAP.
EW1:	POPB PRECED	;Pop the old infix function back
	POPB IFLEVL
	POPB EXPOUT
	POPB FUNTYP
	POP FUNCT
	POP NEXTOK
	LDA OTPUTN
	BEQ EW1A	;Error if no output gotten
	LDA #$02	;Infix functions are always two args
	STA NARGS
	BNE FUNCAL	;(Always) Execute the function
EW1A:	JMP ERXNOP

;EVAL1 executes the function from EVAL after the args are gotten.
EVAL1:	POPB PRECED

;FUNCAL executes an sfun or a ufun.
FUNCAL:	PUSHA EVWRAP		;Return to EVWRAP when done.
FNCAL1:	LDA FUNTYP
	CMP #SFUN
	BNE UFUNCL
;System function
	DATRAM			;Enable ghost-memory
	LDY #PRMIDX
	LDA (FUNCT),Y
	ASL A
	STA INDEX		;Primitive table offset index
	LDA #SYSTAB^		;Page no. of dispatch addresses
	ADC #$00
	STA INDEX+1
	LDA #$00
	STA OTPUTN		;Default is no output
	CAR ADRESS,INDEX	;Get primitive address from table
	NODRAM			;Ghost-memory disable
	JMP (ADRESS)		;Execute the routine
.PAGE
;	Local variable block:
LASLIN	=ANSN3		;High byte of current ufun line
VSPPTR	=TEMPX1		;VSP pointer (shared: STPTR1)
ARGLST	=TEMPN8		;Arglist pointer for bindings (shared: GETALN)
VARNAM	=TEMPN7		;Binding name ptr.
TMPVAL	=TEMPN6		;Temporary binding value
LINPTR	=TEMPN8		;Fpacked line ptr.
ENDPTR	=TEMPX2		;Fpacked line-end ptr.
ATMNAM	=TEMPN8
BNDNGS	=ANSN3		;No. of ufun bindings
FRAMEP	=TEMPX2		;Frame pointer (for Funct/Frame pair)

;UFUNCL calls a ufun, pushing a new stack frame
; or calling UTAIL to tail-recurse.
;
;	Before pushing a stack-frame, the following information is pushed:
;ULNEND	Uline-end for current command-line
;UFRMAT	Format of current command line
;FBODY	Body of current ufun (0 if toplevel)
;FPTR	Pointer to current ufun line (0 if toplevel)
;RUNFLG	Run-flag at time of call
;
;	This is a stack frame:
;Index	Offset	Value
;
SFFBDY	=5	;Negative offset from Frame-pointer (for G.C.-Protection)
SFFRAM	=0	;FRAME: Pointer to start of last frame (0 if toplevel)
SFXFRM	=2	;XFRAME: Pointer to top of last frame (0 if toplevel)
SFFRMT	=4	;UFRMAT: Typecode of this ufun
SFTOKN	=5	;CURTOK: Pointer to this ufun atom (ie, its name)
SFNEST	=7	;NEST: Nesting level at time of ufun call
SFTEST	=8	;IFTEST: Test flag at time of ufun call
SFTKNP	=9	;TOKPTR: Pointer to rest of command line
SFNRGS	=11	;NARGS: No. of binding pairs for this ufun
SFTLVS	=12	;TLLEVS: No. of tail-recursions at time of ufun call
SFIFLV	=15	;IFLEVL: Value of IFLEVL when ufun called
;
;	Binding Pairs:
SFBNDS	=16	;BINDGS: Ptr. to start of bindings area
;VALUEn	18+2*n	Pointer to value of binding (or funct if low bit set)
;NAMEn	20+2*n	Pointer to binding atom (or frame if low bit of VALUEn set)
;
;XFRAME points directly above last binding pair.

UFUNCL:	CDR FBODY,FUNCT	;Get the text pointer
	LDY #$03	;Index for high byte of FPTR cdr
	LDA UFRMAT
	BEQ LPK1
	INY		;(Two higher for Fpack typecode than for List)
	INY
LPK1:	LDA (FPTR),Y	;Get FPTR cdr's high byte
	STA LASLIN
	JSR TSTSTK	;Check for stack collision
	PUSH ULNEND
	PUSHB UFRMAT
	PUSH FBODY
	PUSH FPTR
	PUSHB RUNFLG
	LDA #$00
	STA STPFLG
	STA RUNFLG
	STA GOPTR+1
	MOV FPTR,FBODY
	LDA TRACE	;See if Trace mode
	BEQ UFUN11
	PRTSTR TRACM1	;Yes, print "Executing "
	LDX #CURTOK
	JSR TYPE	;Print the ufun name
	TPCHR SPACE	;and a space
UFUN11:	LDA NEST	;Tail recursion:
	BEQ UFUN12	;nest must be zero unless tail-recursion-flag
	CMP TRFLG	;equals nesting level.
	BEQ UFUN12
	LDA #$00	;Reset TRFLG
	STA TRFLG
	BEQ UFUN6	;(Always)
UFUN12:	LDA LEVNUM	;Level-number must be nonzero
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ UFUN6
	LDA LASLIN	;Check for tail-recursive cases
	BNE UFUN3
	LDA TOKPTR+1	;On last line, see if on last token
	BNE UFUN5	;Nope, see if token is STOP or ELSE
	BEQ UFUN1B	;(Always) Yes, tail-recurse
UFUN3:	LDA TOKPTR+1	;Not on last line
	BEQ UFUN6	;End of line, don't tail-recurse
UFUN1:	LDY #$00	;else see if next token is STOP
	LDA (TOKPTR),Y
	TAX
	INY
	LDA (TOKPTR),Y
	JMP UFUN1A
UFUN5:	LDY #$00	;See if token is STOP or ELSE
	LDA (TOKPTR),Y
	TAX
	INY
	LDA (TOKPTR),Y
	CPX #ELSE&$FF
	BNE UFUN1A	;Not ELSE, check for STOP
	CMP #ELSE^
	BEQ UFUN1B	;It's ELSE, tail-recurse
UFUN1A:	CPX #STOP&$FF	;See if token is STOP
	BNE UFUN6	;Nope, don't tail-recurse
	CMP #STOP^
	BNE UFUN6
;Do a tail-recursive entry.
UFUN1B:	GETTYP FBODY
	STA UFRMAT
	MOV SP,XFRAME	;The frame boundary is right here
	JMP UTAIL
;Do a normal ufun entry.
UFUN6:	GETTYP FBODY
	STA UFRMAT
	LDX FRAME
	LDY FRAME+1
	MOV FRAME,SP	;FRAME points to previous frame (right here)
	JSR PUSH
	PUSH XFRAME
	PUSHB UFRMAT
	PUSH CURTOK
	PUSHB NEST
	PUSHB IFTEST
	PUSH TOKPTR
	LDX NARGS
	INX
	TXA
	JSR PUSHB	;Push NARGS plus 1 for ufun binding
	PUSH TLLEVS	;Push low two bytes of TLLEVS
	PUSHB TLLEVS+2	;Push high byte of TLLEVS
	PUSHB IFLEVL	;Push current IFLEVL
	LDY #$00
	LDA (FUNCT),Y	;Get frame number
	TAX
	INY
	LDA (FUNCT),Y
	TAY
	JSR PUSH	;Push frame number
	LDX FUNCT
	LDY FUNCT+1
	INX
	JSR PUSH	;Push FUNCT plus 1 for binding typecode distinction
	LDX #$01
	STX IFTEST	;Default is FALSE (nonzero)
	STX TLLEVS	;Tail-levels := 1
	DEX
	STX TLLEVS+1
	STX TLLEVS+2
	DEX
	STX NEST	;Nest := -1
	JSR INCLEV
	RPLACA FUNCT,FRAME	;Set the function's frame pointer
	JSR STPTR1	;VSPPTR := VSP + (NARGS * 2)
	JSR GETALN	;Get the arglist
	JSR NWBNDS	;Get the new binding values
	MOV XFRAME,SP	;XFRAME points to location after last binding pair
	JSR INCVSP
;	...
.PAGE
;UF1 does a line of the procedure.
;	...
UF1:	LDA GOPTR+1
	BEQ UF1A
	MOV FPTR,GOPTR	;GOPTR <> NIL, so FPTR := GOPTR, reset GOPTR.
	LDA #$00
	STA GOPTR+1
	BEQ UF1C	;(Always)
UF1A:	LDX #FPTR	;Advance the ufun line ptr.
	JSR ULNADV
UF1C:	LDA STPFLG
	BNE UF2A	;Exit if Stop-flag set
	LDA FPTR+1
	BEQ UF2		;or if the ufun is finished
	LDY #FPTR
	LDX #TOKPTR
	JSR GETULN	;Get the next ufun line
	PUSHA UF1	;Return to UF1 after executing it
	LDA TRACE	;Are we in Trace mode?
	BEQ UF1E	;No, evaluate the line
	CAR LINPTR,FPTR	;Yes, get the line pointer
	LDA UFRMAT
	BEQ UF1TCL
	CDR ENDPTR,FPTR	;Line-typecode Fpack, get the end pointer
	JSR TPLINF	;Type the line
	JMP UF1TC2
UF1TCL:	TPCHR SPACE	;Line-typecode List. Type a space (because TPLINF does)
	LDX #LINPTR
	JSR TYPE1	;Type the line (no outer brackets!)
UF1TC2:	JSR RDKEY	;Get a character
	JSR CKINTZ	;Check for interrupt characters (incl. PAUSE)
	BCC UF1TC2	;Get another if intercepted, else continue
	JSR BREAK1	;Print a crlf
UF1E:	JMP EVLINE	;Evaluate the line

;End of a procedure.
UF2:	LDA STPFLG	;If Stop-flag is zero, then reset Output-number
	BNE UF2A	;(OUTPUT would have set it)
	STA OTPUTN
UF2A:	SEC
	LDX #$FD	;Index for three byte subtract
UF2AL:	LDA LEVNUM+3,X
	SBC TLLEVS+3,X
	STA LEVNUM+3,X	;Level-number := Level-number - Tail-levels
	INX
	BMI UF2AL
	STX STPFLG	;Reset Stop-flag
	LDA TRACE	;Are we in Trace mode?
	BEQ UF3		;No, restore bindings and exit
	PRTSTR TRACM2	;Yes, print "Ending "
	LDY #SFTOKN	;Get the ufun name
	LDA (FRAME),Y
	STA ATMNAM
	INY
	LDA (FRAME),Y
	STA ATMNAM+1
	LDX #ATMNAM
	JSR TYPE	;Type the ufun name
	LDA OTPUTN
	BEQ UF2B
	PRTSTR TRACM3	;If outputn is set, print the output: print " with "
	VPOP ATMNAM
	VPUSH ATMNAM	;Get it but leave it
	LDX #ATMNAM
	JSR TYPE0	;Print it (with brackets)
UF2B:	JSR BREAK1	;Type a crlf
UF3:	JSR POPFRM	;Pop the ufun's stack frame, restoring bindings
	POPB RUNFLG
	POP FPTR
	POP FBODY
	POPB UFRMAT
	POP ULNEND
	JMP POPJ

INCLEV:	INC LEVNUM	;Increment Level-number
	BNE ILVRTS
	INC LEVNUM+1
	BNE ILVRTS
	INC LEVNUM+2
	BNE ILVRTS
	LDX #XPNEST
	JMP EXCED	;Error - Procedure nesting too deep
ILVRTS:	RTS
.PAGE
;Tail-recursive ufun entry routine.
UTAIL:	LDA #$FF
	STA NEST	;Nest := -1
	JSR INCLEV	;Levnum := levnum + 1
	INC TLLEVS	;Increment Tail-levels
	BNE UTAIL2
	INC TLLEVS+1
	BNE UTAIL2
	INC TLLEVS+2
	BNE UTAIL2
	LDX #XTNEST	;Error - Tail-recursion nesting too deep
	JMP EXCED
UTAIL2:	JSR STPTR1	;VSPPTR := VSP + (NARGS * 2)
	LDY #SFNRGS	;Frame index for Number-of-bindings
	LDA (FRAME),Y
	STA BNDNGS
	JSR GETALN	;Get the arglist
	LDY #SFFRMT	;Frame index for Format
	LDA UFRMAT
	STA (FRAME),Y
	LDY #SFTOKN	;Frame index for UFUN (CURTOK)
	LDA CURTOK
	STA (FRAME),Y
	INY
	LDA CURTOK+1
	STA (FRAME),Y
	LDY #SFFRAM	;Frame index for FRAME
	LDA (FUNCT),Y
	CMP FRAME	;Equal frames indicate previous tail-recursion
	BNE UTALWB	;Nope, get new bindings
	INY
	LDA (FUNCT),Y
	CMP FRAME+1
	BNE UTALWB
UTALWA:	LDA ARGLST+1		;Yup, get the new args
	BEQ UTLWAE		;Done if no args left
	CAR VARNAM,ARGLST	;Get the arg name
	LDX #ARGLST
	JSR TTKADV		;Skip to next arg
	CAR TMPVAL,VSPPTR	;Get the value from the VPDL
	JSR TRCBND		;Print it if in Trace mode
	DEC2 VSPPTR		;Skip to next value
	LDX #TMPVAL
	LDY #VARNAM		;Give the name the new value
	JSR PUTVAL
	JMP UTALWA		;Next arg
UTLWAE:	LDY #SFNRGS		;Frame index for Number-of-bindings
	LDA BNDNGS
	STA (FRAME),Y		;Set the no. of bindings
	LDA TRACE
	BEQ UTAIL4
	JSR BREAK1		;Type a crlf if in Trace mode
	JMP UTAIL4
UTALWB:	JSR NWBNDS		;Get the new bindings
UTLWBE:	CAR FRAMEP,FUNCT
	PUSH FRAMEP
	LDX FUNCT
	LDY FUNCT+1
	INX			;Set low bit to distinguish binding
	JSR PUSH
	RPLACA FUNCT,FRAME	;Set the frame pointer
	LDY #SFNRGS		;Frame index for Number-bindings
	SEC			;Carry added in (BINDINGS+NARGS+1)
	LDA BNDNGS
	ADC NARGS
	STA (FRAME),Y
	MOV XFRAME,SP		;XFRAME := SP (above last binding pair)
UTAIL4:	JSR INCVSP		;Reset VSP
	JMP UF1			;Execute the ufun
.PAGE
;Get new bindings for a ufun.
NWBNDS:	LDA ARGLST+1
	BEQ NWBNDR		;Done if no args left
	CAR VARNAM,ARGLST	;Get the arg name from the arglist
	LDX #ARGLST
	JSR TTKADV		;Skip to next name
	LDY #VARNAM
	LDX #TMPVAL
	JSR GETVAL		;Get the old value
	PUSH TMPVAL		;Push it on the stack frame
	CAR TMPVAL,VSPPTR	;Get the new value from the VSP
	JSR TRCBND		;Print it out if in Trace mode
	DEC2 VSPPTR		;Skip to next value
	LDX #TMPVAL
	LDY #VARNAM
	JSR PUTVAL		;Give the arg the new value
	PUSH VARNAM		;Push the arg name on the stack frame
	JMP NWBNDS		;Get the next arg
NWBNDR:	LDA TRACE
	BEQ NWBRTS
	JMP BREAK1		;Type a crlf if in Trace mode

;Restore the VSP after getting args.
INCVSP:	LDA NARGS
	ASL A
	ADC VSP
	STA VSP
	BCC INCVE
	INC VSP+1	;VSP := VSP + NARGS * 2
INCVE:	RTS

;Print out binding value if in TRACE mode.
TRCBND:	LDA TRACE
	BEQ INCVE
	TPCHR SPACE	;Print a space
	LDX #TMPVAL	;Get the value
	JMP TYPE0	;(Type toplevel list brackets)

;	Local variable block:
VSPPTR	=TEMPX1		;VSP Pointer (shared: UFUNCL,XTAIL,SPRNT,SWORD)

;Set VSPPTR for getting arg values.
STPTR1:	LDA NARGS
	ASL A
	ADC VSP
	STA VSPPTR
	LDA VSP+1
	ADC #$00
	STA VSPPTR+1	;VSPPTR := VSP + (NARGS * 2)
NWBRTS:	RTS
.PAGE
;Evaluates the edit buffer.
EVLBUF:	PUSHB UFRMAT	;Save typecode of superior command line
	INC INPFLG	;Indicate buffer-eval mode
EVLBF1:	LDA INPFLG	;If something reset Input-flag to default,
	BEQ EVLBF3	;exit buffer-evaluation immediately
	COMP ENDBUF,EPOINT	;See if we're at the end of the buffer
	BNE EDIN	;Nope, get the next line
;Clean up from evaluating the buffer
EVLBF2:	LDA DEFFLG	;If a procedure is being defined,
	BEQ EVBF2A
	PUSHA EVBF2A
	JMP SEND	;call END to end it, returning to EVBF2A
EVBF2A:	JSR RSTIO	;Reset flags etc. to normal I/O
EVLBF3:	LDA #$00
	STA EXPOUT	;No output was expected
	STA OTPUTN	;No output was given
	STA TOKPTR+1	;Nothing else on the command line (editor ate it)
	POPB UFRMAT	;Get superior line-typecode back
	JMP POPJ	;Return to superior

;Get a line from the edit buffer
EDIN:	LDY #EPOINT
	LDX #TOKPTR
	JSR PARSTR	;Parse a line starting at the point
	MOV EPOINT,PLINE	
	INC1 EPOINT	;Set the point to right after the carriage return
	LDA TOKPTR+1
	BEQ EVLBF1	;If the line is empty, get another
	LDA DEFFLG	;Else see if we're defining a ufun
	BEQ SRD1E	;Nope, execute the line
	LDY #$00
	LDA (TOKPTR),Y
	CMP #END&$FF	;Else see if the first token is END
	BNE ADDLIN	;Nope, add the line to the ufun definition
	INY
	LDA (TOKPTR),Y
	CMP #END^
	BNE ADDLIN
SRD1E:	LDA #$00	;Yes, evaluate the line
	STA UFRMAT	;Buffer lines are typecode List
	PUSHA EVLBF1	;Returns to get another line
	JMP EVLINE

;Add TOKPTR to procedure DEFBOD. Simple, huh?
ADDLIN:	LDX DEFBOD
	LDA DEFBOD+1
EDL1:	STX NXLINE	;NXLINE cdr's through DEFBOD
	STA NXLINE+1
	LDY #$02
	LDA (NXLINE),Y
	TAX
	INY
	LDA (NXLINE),Y
	BNE EDL1	;Keep cdring until we hit a nil
	CONS NWLINE,TOKPTR,0,LIST	;Then make a node for the new line
	RPLACD NXLINE,NWLINE	;Link it on to DEFBOD
	JMP EVLBF1	;And continue getting lines
.PAGE
.SBTTL	Parser

;	Local variable block:
LINPTR	=TEMPX2		;Addr. of ptr. to returned list
CELTYP	=TEMPX2+1	;Typecode of cell for next token
NEWCEL	=TEMPN		;Temp. ptr. to new token cell
FUNPNM	=TEMPN7+1	;Funny-pname or comment if nonzero
LSNEST	=TEMPN8		;List nesting counter
TEMP	=TEMPN1		;List ptr. discard
TOKTYP	=ANSN3		;Typecode of current token being processed
QUOTED	=TEMPN4+1	;Current token is a quoted atom if nonzero
TKNPTR	=TEMPX1		;Ptr. to final token
PTRTMP	=TEMPN2		;Temp. char. ptr. during number-parsing
STRPTR	=TEMPN6		;Token pname ptr.
LNKLST	=TEMPX1		;Pname cell link
NXTLNK	=TEMPN5		;Newest pname cell
ENDPNM	=ANSN4		;Nonzero signal end-of-pname consing
CHARS	=TEMPN		;String characters

;Entered with prompt in A, types it and reads a line into LINBUF.
PGTLIN:	JSR TPCHR
GETLIN:	JSR GETLN	;Get a line into the Line-buffer
	SETV PLINE,LINBUF	;Parse line-buffer
	RTS

PARSTR:	GETY PLINE
PRSLIN:	STX LINPTR	;Input line returned list pointer location
	LDA #$00
	STA $01,X	;Initialize parse-list to nil
	STA LSNEST	;List-nesting counter
	STA MARK1+1	;List-pointer
	STA FUNPNM	;Zero FUNPNM initially
	INC PRSFLG	;Tells CONS we're in the parser
	LDA #NEWLIN
	STA CELTYP	;Current cell type
NXTOKN:	LDA #$00
	STA TOKTYP	;No typecode yet (for SELFDL)
	STA QUOTED	;Indicates quoted atom if non-zero
	LDX FUNPNM
	BMI JNTNM1	;If funny-pname negative, rest is comment
	STA FUNPNM	;Else zero funny-pname
TGT1:	LDY #$00
	LDA (PLINE),Y
	CMP #SPACE	;Skip spaces
	BNE TGT2
	JSR INCPLN
	JMP TGT1
RDLNWE:	LDA #$00	;All done
	STA MARK1+1	;Clear MARK1
	STA PRSFLG	;Reset Parse-flag
	JMP POPLST	;Pop stacked list pointers
JNTNM1:	JSR ALLSTC	;A comment now, make a new cell, then cons a string
	LDA #STRING
	STA TOKTYP
	JMP NOTNUM
TGT2:	CMP #CR
	BEQ RDLNWE	;Done if cr
	CMP #']
	BEQ TKRBR
	PHA		;Not a right-bracket, so
	JSR ALLSTC	;allocate a token cell
	PLA
	CMP #'[
	BEQ TKLBR
	JSR SELFDL
	BCC TKNDL
	JSR INCPLN	;Self-delimiter, advance to next char.
TKDLM:	STA CHARS	;Make a pname of the self-delimiter
	LDA #$00
	STA CHARS+1
	CONS STRPTR,CHARS,0,STRING	;cons up a pname
	LDA #ATOM
	STA TOKTYP
	LDA CHARS
	CMP #$3B	;Is it a semicolon?
	BNE JADDTK
	DEC FUNPNM	;Yes, dec Funny-pname (to -1) to indicate comment
	LDY #$00
	LDA (PLINE),Y
	CMP #SPACE	;If character after semicolon
	BNE JADDTK	;is a space, skip it, because
	JSR INCPLN	;it's implied by token structure
JADDTK:	JMP ADDTOK
;Left bracket.
TKLBR:	INC LSNEST	;Start list - increment list nesting counter
	JSR INCPLN	;Skip to next character
	PUSH MARK1	;Push the list-pointer cell
	LDA #NEWLST
	STA CELTYP	;Next cell allocated will be New-list type
	JMP NXTOKN	;Continue processing line
;Right bracket.
TKRBR:	JSR INCPLN	;Skip to next character
	LDA LSNEST
	BEQ TKRBR2
	DEC LSNEST
	POP MARK1	;Pop list pointer
	LDA #REGCEL
	STA CELTYP
	JMP NXTOKN	;Continue processing line
TKRBR2:	PRTSTR RDRER2	;Print "Ignoring unmatched bracket" warning
	JMP NXTOKN
TKNDL:	CMP #'"		;Token is not a delimiter
	BNE TGT3A
	INC QUOTED	;Quoted atom
	JSR INCPLN
	LDA #QATOM
	STA TOKTYP
	JMP TGT3B1	;Check for funny-pname
TGT3A:	CMP #QUOTE	;(Single Quote)
	BNE TGT3B
	JSR INCPLN
	INC FUNPNM	;Token is a funny-pname
TKAORL:	LDA #ATOM	;Token is an Atom or Label
	STA TOKTYP
	JMP TKATOM	;Tokenize it
TGT3B:	CMP #':
	BNE TKAORL
	JSR INCPLN	;Dotted atom, skip to next character
	LDA #DATOM
	STA TOKTYP
TGT3B1:	LDY #$00	;Check for dotted or quoted funny-pname
	LDA (PLINE),Y
	CMP #QUOTE
	BNE TKATOM
	INC FUNPNM	;Token is funny-pname
	JSR INCPLN
TKATOM:	LDY #$00
	LDA (PLINE),Y
	CMP #CR		;Check for empty word at end-of-line
	BEQ EMPTWD
	LDX FUNPNM
	BNE NOTNUM	;Funny-pname, not fixnum then
TKATM1:	JSR SELFDL
	BCS EMPTWD	;Delimiter encountered immediately, so empty word
	LDA TOKTYP
	CMP #ATOM
	BNE NOTNUM	;Only atoms can be numbers now
	JSR CNUML0	;Attempt to compute numerical value, init
	MOV PTRTMP,PLINE	;Save temporary character pointer
ATM1:	LDY #$00
	LDA (PLINE),Y
	CMP #CR
	BEQ ATM2	;End of line encountered, must be numerical
	JSR SELFDL
	BCC ATM1A	;Continue if not self delimiter
	LDA TOKTYP
	CMP #LATOM
	BNE ATM2	;Self delimiter, not colon, so clean up
	BEQ NTNUMA	;(Always) It's a label, treat it as a word
EMPTWD:	LDA #STRPTR
	JSR MAKMTW	;Make STRPTR point to the empty word
	JMP ADDTOK	;and link it
ATM1A:	JSR CNUML1	;Process the next digit
	BCC NOTNMX	;Carry clear means not a number
	INC1 PLINE	;Get next digit
	JMP ATM1
ATM2:	JSR CNUML2	;Finish numerical processing (typecode in A)
	BCC NOTNMX
	LDX #TKNPTR
	STX NODPTR
	LDX #NARG1+2		;High word
	LDY #NARG1		;Low word
	JSR CONS		;Cons a numerical cell with the value in it
	RPLACA MARK1,TKNPTR	;Link the cell on to the input line
	JMP NXTOKN		;Continue processing line
NTNUMA:	LDA #ATOM
	STA TOKTYP	;Don't say it's a label yet
NOTNMX:	MOV PLINE,PTRTMP	;Not a number, reset real character pointer
NOTNUM:	LDX #LNKLST	;cons up a pname (original pointer)
	LDA #$00
	STA STRPTR+1	;Zero pointer in case it's nil
	STA ENDPNM	;Indicates end of pname if non-zero
	PHA		;First time around, push zero
	BEQ NXTCHS	;(Always)
NXTTWO:	LDA ENDPNM	;Next two characters
	BNE ADDTOK	;Link up token if end of pname
	LDA #$02
	PHA		;Not first time around, push 2
	LDX #NXTLNK	;Next pointer
NXTCHS:	STX NODPTR
	LDY #$00
	LDA (PLINE),Y
	CMP #CR
	BEQ ADDTK1	;Finish token (end of line), even no. chars.
	STA CHARS	;First character in pair
	JSR SELFDL
	BCS ADDTK1	;Finish token (delimiter hit), even no. chars.
	JSR INCPLN	;Skip to next character
	LDY #$00
	LDA (PLINE),Y
	CMP #CR
	BEQ FINTK1	;Finish token (end of line), odd no. chars.
	STA CHARS+1	;Second character in pair
	JSR SELFDL
	BCS FINTK1	;Finish token (delimiter hit), odd no. chars.
	JSR INCPLN
	JMP CNSSTR	;Cons new pair on to pname string
FINTK1:	LDA #$00
	STA CHARS+1	;Odd no. chars. in pname, zero last character
	INC ENDPNM	;Indicates end of pname
CNSSTR:	LDY #CHARS
	LDX #$00
	LDA #STRING
	JSR CONS	;Cons up the new pname pair
	PLA
	TAY		;0 first time, 2 otherwise
	BNE NTFRST
	LDA LNKLST
	STA (MARK1),Y	;(Linking garbage-collect-protects it)
	STA STRPTR	;Atom pointer
	INY
	LDA LNKLST+1
	STA (MARK1),Y
	STA STRPTR+1
	JMP NXTTWO	;Continue making the pname
NTFRST:	LDA NXTLNK	;Link cell onto pname string
	TAX
	STA (LNKLST),Y
	INY
	LDA NXTLNK+1
	STA (LNKLST),Y
	STA LNKLST+1
	STX LNKLST
	JMP NXTTWO	;Continue making the pname
ADDTK1:	PLA		;Pop chain indicator if loop exit
ADDTOK:	LDA STRPTR+1
	BNE ADTOK1
	LDA #STRPTR	;If empty pname, cons up an empty node
	JSR MAKMTW
ADTOK1:	LDA TOKTYP
	CMP #STRING
	BEQ ADDSTR	;Don't intern strings
	LDX #STRPTR
	LDY #TKNPTR
	JSR INTRNP	;See if it's interned
	CMP #STRING
	BNE ADDTK2	;Not string, so it's interned
	LDA TOKTYP
	CMP #ATOM
	BEQ ADDSTR	;Unquoted words don't need to be interned
	LDX #STRPTR	;Otherwise make a new atom
	LDA #TKNPTR
	JSR INTRNX
	LDA TOKTYP
	JMP LKATM1	;Give it typecode and link it
ADDTK2:	LDA TOKTYP	;It's interned at this point
	CMP #ATOM
	BEQ LNKATM
LKATM1:	LDX #TKNPTR
	JSR PUTTYP	;Give atom a typecode if not Atom
LNKATM:	RPLACA MARK1,TKNPTR	;Link atom onto input line
	LDA FUNPNM
	BMI NXTE
	BEQ NXTE
	LDA TKNPTR
	AND #$FC
	STA TKNPTR
	CDRME TKNPTR
	LDY #$02
	LDA (TKNPTR),Y
	ORA #$01
	STA (TKNPTR),Y
NXTE:	JMP NXTOKN	;Continue processing line
ADDSTR:	RPLACA MARK1,STRPTR	;Link up a string
	LDA FUNPNM
	BEQ NXTE
	JMP RDLNWE	;Funny-pname set -> comment -> end of line
.PAGE
;Can't touch A.
INCPLN:	INC1 PLINE
	RTS

;Unstacks any stacked list pointers.
POPLST:	LDA LSNEST
	BEQ PLRTS	;Exit if no open lists
POPLS1:	LDA INPFLG
	BNE RDL1A2	;Don't type a bracket if in read-eval loop
	TPCHR ']	;Type a "]"
RDL1A2:	POP TEMP	;Discard stacked list pointer
	DEC LSNEST	;Decrement list nesting counter
	BNE POPLS1	;Continue until none left
	LDA INPFLG
	BNE PLRTS
	JMP BREAK1	;Print crlf if not in read-eval loop

;Allocate a new list cell
ALLSTC:	CONS NEWCEL,0,0,LIST	;Cons a new node
	LDY #$00	;(Assume we want to Rplaca)
	LDA CELTYP
	CMP #NEWLIN
	BNE ALSTC1
	LDX LINPTR	;New line, LINPTR points to cell
	PUTX NEWCEL
	JMP ALSTC3
ALSTC1:	CMP #NEWLST
	BEQ ALSTC4	;For new-list, rplaca onto input line
	INY		;Regular cell, link onto input line (Rplacd)
	INY
ALSTC4:	LDA NEWCEL
	STA (MARK1),Y	;Rplaca or Rplacd for new-list or regular-cell
	INY
	LDA NEWCEL+1
	STA (MARK1),Y
ALSTC3:	MOV MARK1,NEWCEL	;New input line end-pointer
	LDA #REGCEL
	STA CELTYP	;Next cell allocated will be regular-cell
PLRTS:	RTS

;See if the character in A is a self-delimiter.
SELFDL:	LDX FUNPNM
	BMI DIGN	;If comment, nothing's a delimiter
	BNE PNMDL	;Funny pname
	LDX LSNEST
	BNE SLF2A	;Treat list elements like Qatoms
	LDX PRSFLG
	BMI SLF2A	;(Also if REQUEST set Parse-flag negative)
SLF2:	LDX QUOTED	;Check for quoted atom
	BEQ SLF1
SLF2A:	CMP #SPACE	;Quoted atoms can be terminated by a space,
	BEQ DIGY
	CMP #']		;or a closing bracket,
	BEQ DIGY
	CMP #'[		;or an opening bracket.
	BEQ DIGY
	CLC
	RTS
SLF1:	LDX TOKTYP	;Check for typecode Atom
	CPX #ATOM
	BNE SLF3
	CMP #':		;If Atom, check for colon (for Label atom)
	BNE SLF3
	JSR INCPLN	;If colon, skip over it and change typecode to Latom
	LDX #LATOM
	STX TOKTYP
DIGY:	SEC		;Carry set means true
	RTS
SLF3:	LDX #DELIMS
SLF3L:	CMP DELTAB,X	;Compare character to all delimiters
	BEQ DIGY
	DEX
	BPL SLF3L
DIGN:	CLC
	RTS
PNMDL:	CMP #QUOTE	;If funny-pname, look for quote
	BNE DIGN	;Not delimiter if no quote
	JSR INCPLN	;Skip quote always
	LDY #$00
	LDA (PLINE),Y
	CMP #QUOTE	;Look for pair of quotes
	BEQ DIGN	;If pair, not delimiter (one skipped)
	SEC		;If no pair, the quote is a delimiter (skipped)
	RTS

;Self-delimiter table.
DELIMS=13
DELTAB:	.ASCII " <>=;)(+-*/]["

;Reparse the list in ARG1.
PARSEL:	SETV OTPDEV,CRUNP	;Make the output routine CRUNP.
	SETV PLINE,PRSBUF	;Init PLINE to the Parse-buffer for CRUNP.
	LDX #ARG1
	JSR TYPE1		;Print line to buffer, (no outer brackets!)
	JSR BREAK1		;Terminate the line
	LDA #$00
	JSR RSTIO1		;Reset the output routine (don't zap INPFLG)
	SETV PLINE,PRSBUF	;Reset PLINE to beginning of buffer
	LDX #TOKPTR
	JMP PRSLIN		;Parse the line

;Output routine for PARSEL. Entered with character in A, shouldn't bash Y.
CRUNP:	LDX PLINE
	CPX #PRSLIM&$FF	;Check for buffer limit
	BNE CRUNP1
	LDX PLINE+1
	CPX #PRSLIM^
	BNE CRUNP1
	ERROR XBFX
CRUNP1:	LDY #$00
	STA (PLINE),Y	;Deposit character
	JMP INCPLN	;Increment index
.PAGE
.SBTTL	Number Parsing Utilities

;	Local variable block:
FLMODE	=TEMPN5		;Indicates mode
EXPSGN	=TEMPN5+1	;Sign of exponent, nonzero=negative
ADIGIT	=TEMPN6+1	;Indicates prescence of a digit
SAVNUM	=A1L		;Temp. number storage
EXP	=TEMPX1		;Exponent

;Process a character, number-building
CNUML1:	LDX FLMODE	;Flonum indicator
	BNE NFLDIG	;Process next flonum character
	JSR DIGITP	;Still a fixnum
	BCC NTFIX1	;Not a digit, isn't a fixnum then
	INC ADIGIT	;Indicate presence of digit
	PHA		;Save digit
	JSR NMROL1	;Multiply by 2 first
	BMI NTFIX3	;Not a fixnum if value overflow
	LDY #SAVNUM
	JSR XN1TOY	;Copy doubled number
	JSR NMROL1	;Multiplied by 4
	BMI NTFIX2
	JSR NMROL1	;Multiplied by 8
	BMI NTFIX2
	JSR ADDNUM	;Multiplied by 10.
	BMI NTFIX2
	PLA
	PHA
	JSR ADDDIG	;Add value of current digit to subtotal
	BMI NTFIX2
	PLA		;Retrieve digit
NUMOK:	SEC		;Indicate number OK
	RTS
NTFIX2:	LDY #SAVNUM
	JSR XYTON1	;Fixnum oflow, 2*number is in SAVNUM, transfer
NTFIX3:	JSR NMROR1	;Halve it
	INC FLMODE	;Indicate flonum (1)
	JSR FLOTN1	;Convert to floating pt.
	PLA		;Get the digit back
FADNML:	PHA		;Save digit
	INC ADIGIT	;Indicate presence of digit
	JSR MULN10	;Shift number before adding
	PLA		;Retrieve digit
	BCS NTNUM	;Balk if overflow
	JSR FADDIG	;Add it to the number (left of point)
	JMP NUMOK
NFLDIG:	CPX #$02	;New flonum digit
	BNE NFLDG1
	JSR DIGITP	;In decimal mode. If digit, add to number
	BCC FCKEN	;Else check for E or N
FNDIGD:	INC ADIGIT	;Indicate presence of digit
	JSR FADDGN	;Add it to the number (right of point)
	JMP NUMOK
NFLDG1:	CPX #$03	;See if exponent mode
	BEQ FXDIG
	JSR DIGITP	;Normal mode, check for digit
	BCS FADNML	;Add it if it is, else
NTFIX1:	CMP #'.		;See if digit is legal
	BEQ FMDECI
FCKEN:	CMP #'E		;Check for E or N
	BEQ FXPOS
	CMP #'N
	BNE NTNUM
	INC EXPSGN	;Indicate negative exponent
FXPOS:	LDA ADIGIT
	BEQ NTNUM	;Check that a digit was typed (so ".Ex" is illegal)
	LDX FLMODE
	LDA #$03
	STA FLMODE	;Indicate exponent mode (3)
	LDA #$00
	STA ADIGIT	;Now, indicates exponent digit presence
	BEQ MAKFLO	;(Always)
FXDIG:	JSR DIGITP	;Exponent mode, must be a digit
	BCC CNMR
	INC ADIGIT	;Indicate presence of exponent digit
	JSR INCEXP	;Exponentiate by vA
	JMP NUMOK
FMDECI:	JSR FMDC1
	LDX FLMODE
	LDA #$02
	STA FLMODE	;Indicate decimal mode (2)
MAKFLO:	TXA
	BNE NUMOK	;Exit OK if flonum, else...
	JSR FLOTN1	;make it one
	JMP NUMOK
NTNUM:	CLC		;Not a number
CNMR:	RTS

DIGITP:	CMP #':		;Checks to see if character is a digit (0-9)
	BCC DIGP1
	CLC		;Carry clear means not digit
	RTS
DIGP1:	CMP #'0		;(Sets carry correctly)
	RTS

FMDC1:	SETNUM NARGX,FLT1	;Decimal mode, set up place divisor (10.)
	RTS

;Number gobbled, finish number-building.
CNUML2:	LDX FLMODE
	BEQ CNUM2X
	LDA ADIGIT	;If floating pt., make sure that there's a digit
	BEQ NTNUM
	LDA EXP		;Check for exponent
	BEQ CNUM2R
	LDY #SAVNUM
	JSR XN1TOY	;Save number
	JSR FMDC1	;Setup divisor/multiplier (to 1.)
	LDY #NARGX
	JSR XYTON1	;and put in NARG1
CNUM2C:	JSR MULN10	;Multiply by 10 according to exponent value
	BCS NTNUM
	DEC EXP
	BNE CNUM2C
	LDY #SAVNUM	;Put number in NARG2
	JSR XYTON2
	LDA EXPSGN	;Check its sign
	BEQ CNUM2M
	JSR FDIVX	;Divide by divisor (NARG2/NARG1)
	BCS NTNUM
	BCC CNUM2R	;(Always)
CNUM2M:	JSR FMUL	;Mulyiply by multiplier
	BCS NTNUM
CNUM2R:	LDA #FLO
	SEC
	RTS
CNUM2X:	LDA #FIX
	SEC
	RTS

;Initialize number-parsing
CNUML0:	LDA #$00
	STA NARG1	;Initialize number to 0
	STA NARG1+1
	STA NARG1+2
	STA NARG1+3
	STA FLMODE	;Flonum indicator
	STA EXPSGN	;Exponent sign indicator
	STA ADIGIT	;Indicates the presence of a mant. or exp. digit
	STA EXP		;Exponent counter
	RTS

;Double number in NARG1
NMROL1:	ASL NARG1
	ROL NARG1+1
	ROL NARG1+2
	ROL NARG1+3
	RTS

;Halve number in NARG1
NMROR1:	LSR NARG1+3
	ROR NARG1+2
	ROR NARG1+1
	ROR NARG1
	RTS

;Transfer number NARG1 to addr. in Y.
XN1TOY:	LDX #$FC
XN1YL:	LDA NARG1+4,X
	STA $00,Y
	INY
	INX
	BMI XN1YL
	RTS

;Transfer number in addr. in Y to NARG1.
XYTON1:	LDX #$FC
XYN1L:	LDA $00,Y
	STA NARG1+4,X
	INY
	INX
	BMI XYN1L
	RTS

;Transfer number NARG2 to addr. in Y.
XN2TOY:	LDX #$FC
XN2YL:	LDA NARG2+4,X
	STA $00,Y
	INY
	INX
	BMI XN2YL
	RTS

;Transfer number in addr. in Y to NARG2.
XYTON2:	LDX #$FC
XYN2L:	LDA $00,Y
	STA NARG2+4,X
	INY
	INX
	BMI XYN2L
	RTS

;Add SAVNUM to NARG1
ADDNUM:	LDX #$FC
	CLC
ADDNML:	LDA SAVNUM+4,X
	ADC NARG1+4,X
	STA NARG1+4,X
	INX
	BMI ADDNML
	TAX
	RTS

;Add Ascii digit in A to NARG1 (integer).
ADDDIG:	SEC
	SBC #'0
	CLC
	LDX #$FC
	BNE ADDL1A	;(Always)
ADDLP1:	LDA #$00
ADDL1A:	ADC NARG1+4,X
	STA NARG1+4,X
	INX
	BMI ADDLP1
	TAX
	RTS

;Add Ascii digit in A to NARG1 (floating).
FADDGX:	SEC
	SBC #'0		;Get the digit's value
	JSR SETN2A	;Add A to NARG1, floating pt.
	JSR FLOTN2
	JMP FADD

;Zero NARG2.
ZERON2:	LDA #$00
;	...

;Set NARG2 to one-byte integer in A.
;	...
SETN2A:	STA NARG2
SETN20:	LDA #$00
	STA NARG2+1	;Put A in NARG2, make it floating pt., and add
	STA NARG2+2
	STA NARG2+3
	RTS

;Add Ascii digit in A to NARG1 (floating), check for overflow.
FADDIG:	JSR FADDGX
	BCS NUMOVF
	RTS

;Add decimal digit to floating pt. number
FADDGN:	PHA		;Save digit
	LDY #SAVNUM
	JSR XN1TOY	;Save NARG1
	LDY #NARGX	;Get decimal place constant
	JSR XYTON1
	JSR MULN10	;Multiply by 10 (bashes NARG2)
	LDY #NARGX
	JSR XN1TOY	;And put back
	PLA
	SEC
	SBC #'0
	JSR SETN2A	;Put digit in NARG2
	JSR FLOTN2
	JSR FDIVX	;Divide digit by decimal place (10^N)
	LDY #SAVNUM
	JSR XYTON2	;Get orig. number back
	JMP FADD	;and add new scaled digit

;Multiply NARG1 by 10., floating pt.
MULN10:	SETNUM NARG2,FLT10	;Put 10. (floating pt. constant) in NARG2
	JMP FMUL		;and multiply (calling procedure checks for overflow)

;Divide NARG1 by 10., floating pt.
FDVD10:	SETNUM NARG2,FLT10	;Put 10. (floating pt. constant) in NARG2
	JMP FDIV

;Process another exponent digit.
INCEXP:	SEC
	SBC #'0
	TAY		;Multiply exponent by ten and add new digit
	ASL EXP
	BMI NUMOVF
	LDA EXP
	ASL A
	BMI NUMOVF
	ASL A
	BMI NUMOVF
	ADC EXP
	BMI NUMOVF
	STA EXP
	TYA
	ADC EXP
	BMI NUMOVF
	STA EXP
	RTS

NUMOVF:	PLA		;Overflow, pop past subroutine
	PLA
	CLC		;Indicate not a number
	RTS

FLT1:	$80	;Floating-point constant, 1.0
	$40
	$00
	$00

FLT10:	$83	;Floating-point constant, 10.0
	$50
	$00
	$00
.PAGE
.SBTTL	Initializations

;	Local variable block:
TABIDX	=TEMPN		;Index into prim- and vprim-tables
PRMPTR	=TEMPN2		;Primitive address
NXTNOD	=TEMPN		;Used to link freelist together
NOVALU	=TEMPN1		;Temp. novalue constant
NAME	=TEMPN3		;Pname of new Logo name

;	Primitive-array offsets:
PRMNGS	=0	;No. of arguments
PRMPRC	=1	;Precedence
PRMIDX	=2	;Primitive index no.
PRMNAM	=3	;Primitive pname offset

;Reinitialize nodespace etc.
REINIT:	LDA #$00
	STA TRACE	;Not in Trace mode
	STA GCFLAG	;Not doing a garbage collect
	STA SAVMOD	;Normal buffer (not text)
	STA NNODES	;Reset node allocation counter
	STA NNODES+1
	STA FBODY+1	;Clear FBODY
	STA DEFFLG	;Reset Define-flag
	STA DEFBOD+1	;Null Define-body
	STA LEVNUM	;Reset Level-number
	STA LEVNUM+1
	STA LEVNUM+2
	STA FRAME+1	;Reset Frame (for ERROR)
	STA PODEFL+1	;Null PO-Default
	STA SIZE1	;Null Size1
	STA SIZE1+1
	STA SIZE2	;Null Size2
	STA SIZE2+1
	STA ILINE+1	;Null the Iline
	STA TRFLG	;Set tail-recursion flag to zero
	JSR CLMK4	;Clear the MARKn variables
	LDA #$01
	STA IFTEST	;Default TEST is FALSE (nonzero)
	JSR CLRCBF	;Clear the character buffer
	SETV SP,PDLBAS		;Reset the PDL
	SETV VSP,VPDLBA		;Reset the VPDL
	JSR CLRMRK	;Clear Mark bits
	JSR RSTIO	;Set I/O to default
	JSR RESETT	;Clear screen, etc.
;Make the Soblist
	SETV SOBLST,SOBTOP,NODBEG
	SETV TABIDX,PRMTAB	;Points to first byte of Primitive-table
SOBLP1:	LDY #$01
	TYA
	STA (SOBTOP),Y	;Put Novalue in car of node
	INY
	LDA TABIDX
	STA (SOBTOP),Y
	INY
	LDA TABIDX+1
	STA (SOBTOP),Y	;Pointer into ghost-memory in cdr of node
	LDA #SATOM
	LDX #SOBTOP
	JSR PUTTYP	;Give it the typecode Satom
	DATRAM		;Enable ghost-memory
	LDY #PRMNAM-1	;Primitive pname index
SOBLP:	INY
	LDA (TABIDX),Y
	BNE SOBLP	;Run through pname to get to next entry
	NODRAM		;Disable ghost-memory
	SEC
	TYA
	ADC TABIDX
	STA TABIDX	;Advance Table-index to next entry
	BCC SOBLP2
	INC TABIDX+1
SOBLP2:	INC4 SOBTOP	;Go to next node
	INC1 NNODES	;Increment Node-counter
	CMPV TABIDX,PRMTBE	;See if end of Primitive-table
	BNE SOBLP1	;Continue if not
;Link the Freelist together.
	CLC
	LDA SOBTOP
	STA FRLIST
	ADC #$04
	STA NXTNOD	;Starts after the Soblist.
	LDA SOBTOP+1
	STA FRLIST+1
	ADC #$00
	STA NXTNOD+1
	LDY #$03
	LDA #$00
	STA (SOBTOP),Y	;Terminate Soblist with nil
RINLP2:	RPLACD NXTNOD,FRLIST	;Make a pointer to the last node
	CLC
	LDA NXTNOD
	STA FRLIST
	ADC #$04
	STA NXTNOD		;Advance to next node
	LDA NXTNOD+1
	STA FRLIST+1
	ADC #$00
	STA NXTNOD+1
	CMPV NXTNOD,NODEND	;See if at end of nodespace
	BNE RINLP2		;Nope, continue
;Initialize the Oblist.
	LDX #$00
	STX OBLIST+1
	INX
	STX NOVALU+1	;Set Novalue for MKSFUN
	LDX #UNSUM
	LDA #PRMSUM&$FF
	LDY #PRMSUM^
	JSR MKSFUN	;Make the Unary sum primitive entry.
	LDX #UNDIF
	LDA #PRMDIF&$FF
	LDY #PRMDIF^
	JSR MKSFUN	;Make the Unary Difference primitive entry.
;Put "TRUE" on the Oblist.
	LDY #$00
	STY CCOUNT	;Character count
TRUEL:	LDA PTRUE,Y
	BEQ TRUELE
	JSR PUSHB	;Push a character
	INC CCOUNT
	LDY CCOUNT
	BNE TRUEL	;(Always)
TRUELE:	LDA #NAME
	JSR CNSPDL	;Make a pname
	LDX #NAME
	LDA #TRUE
	JSR INTRNX	;Intern TRUE
;Put "FALSE" on the Oblist.
	LDY #$00
	STY CCOUNT	;Character count
FALSL:	LDA PFALSE,Y
	BEQ FALSLE
	JSR PUSHB	;Push a character
	INC CCOUNT
	LDY CCOUNT
	BNE FALSL	;(Always)
FALSLE:	LDA #NAME
	JSR CNSPDL	;Make a pname
	LDX #NAME
	LDA #FALSE
	JMP INTRNX	;Intern FALSE

;Make a system function. Entry pointer is in AY, function pointer addr. in X.
MKSFUN:	STA PRMPTR
	STY PRMPTR+1
	STX NODPTR
	LDX #PRMPTR	;Entry pointer in cdr.
	LDY #NOVALU	;Initial binding of Novalue
	LDA #SATOM	;Typecode Satom
	JMP CONS

;Get Next-token from the current command line
GTNXTK:	CAR NEXTOK,TOKPTR
	RTS

;	Logo names:
PTRUE:	.ASCIZ "TRUE"
PFALSE:	.ASCIZ "FALSE"
.PAGE
.SBTTL	Miscellaneous and Evaluator Utility Routines
.SBTTL		Stack Frame Utility Routines

;(Subrs: RSTBND,POPB,POP)
;Pop one stack frame, restoring bindings.
POPFRM:	JSR RSTBND	;Restore bindings
	POPB IFLEVL
	POPB TLLEVS+2
	POP TLLEVS
	JSR POPB	;Skip NUMBER-BINDINGS
	POP TOKPTR
	POPB IFTEST
	POPB NEST
	POP CURTOK
	POPB UFRMAT
	POP XFRAME
	POP FRAME
	RTS

;	Local variable block:
VALUE	=TEMPN1		;Binding value
NAME	=TEMPN		;Binding name
ARGS	=ANSN		;No. of ufun args

;(Subrs: POP,PUTVAL)
;Restore bindings from a stack frame
RSTBND:	MOV SP,XFRAME
	LDY #SFNRGS	;Frame index for NUMBER-BINDINGS
	LDA (FRAME),Y
	BEQ RSTBWE	;Exit if no bindings to be bound
	STA ARGS
RSTBW:	POP VALUE
	POP NAME
	LDX #NAME
	LDY #VALUE
	JSR PUTVAL
	DEC ARGS
	BNE RSTBW	;Do next binding
RSTBWE:	RTS
.PAGE
.SBTTL		Stack Routines

;PUSHP is given the location of a page-zero variable in X,
;and pushes the contents of the variable onto the Logo stack.
PUSHP:	RPLCAX SP
	INC2 SP
	RTS

;PUSH pushes onto the stack the sixteen-bit value in the X and Y registers.
PUSH:	TYA
	LDY #$01
	STA (SP),Y	;High byte
	DEY
	TXA
	STA (SP),Y	;Low byte
	INC2 SP
	RTS

;PUSHB pushes onto the stack the eight-bit value in the A register.
PUSHB:	LDY #$00
	STA (SP),Y
	INC1 SP
	RTS

;VPUSH is given the address of a page-zero variable in X,
;and pushes the contents of that variable onto the Value stack.
VPUSHP:	RPLCAX VSP
	DEC2 VSP
	RTS

;POP pops a value off of the Logo stack and into the page-zero variable
;whose address is in X.
POP:	DEC2 SP
	CARX SP
	RTS

;VPOP pops a value off of the Value stack and into the page-zero variable
;whose address is in X. Doesn't destroy X.
VPOP:	INC2 VSP
	CARX VSP
	RTS

;POPB pops a one-byte value off of the Logo stack and returns with it in A.
POPB:	DEC1 SP
	LDY #$00
	LDA (SP),Y
	RTS

;TSTSTK tests to see if the Logo stack test limit has been exceeded,
; and gives an error if so. It doesn't poll for interrupts.
TSTSTK:	LDA VSP+1
	CMP SP+1
	BCC STKTZ
	BNE STKTR
	LDA VSP
	SBC SP
	CMP #STKLIM
	BCC STKTZ
STKTR:	RTS
STKTZ:	SETV SP,PDLBAS		;Reset the stack for reader/tokenizer
	SETV VSP,VPDLBA
	ERROR XZAP,XNSTOR	;Error - "No storage left" (No Stack) zapcode

;(Subrs: TSTCHR,CKINTZ,CKINTS,BELL)
;POLLZ is the special polling routine which also checks for Pause key.
POLLZ:	JSR TSTCHR	;See if char. in register
	BCC PRTS	;Return if no chars. pending
	BIT KBDCLR	;Else reset strobe
	JSR CKINTZ	;Check for interrupt characters
	JMP POLL1	;Or store the character

;TSTPOL tests to see if the Logo stack test limit has been exceeded,
; and gives an error if so. Polls for interrupts.
TSTPOL:	JSR TSTSTK

;POLL is the polling routine for user interrupts.
POLL:	JSR TSTCHR	;See if char. in register
	BCC PRTS	;Return if no kbd character pending
	CMP #PAUSKY
	BEQ PRTS	;If PAUSE, don't reset strobe, just exit
	BIT KBDCLR	;Else reset strobe
	JSR CKINTS	;Check for interrupt characters
POLL1:	BCC PRTS	;If intercepted, we're done
	TAY		;Save character
	LDA CHBUFR
	SBC CHBUFS	;Check for buffer-full (carry is set)
	AND #$3F	;Circular $40-byte buffer
	CMP #$01
	BEQ BOFL	;Oflow if next-free loc right before next-to-read
	LDA CHBUFS
	AND #$3F
	TAX
	TYA
	STA CHBSTT,X	;Store character in buffer
	INC CHBUFS	;Increment next-free-loc
PRTS:	RTS
BOFL:	JMP BELL	;Complain if buffer overflow

;(Subrs: GETCHR)
;Check for interrupt characters, incl. PAUSE
CKINTZ:	CMP #PAUSKY
	BEQ LPAUSE

;Check for interrupt characters, not incl. PAUSE
CKINTS:	CMP #STPKEY
	BEQ STPPK1
	CMP #LSTKEY	;Halt listing temporarily
	BEQ LWAIT
	CMP #FULCHR	;Full-screen graphics character
	BEQ STPFUL
	CMP #MIXCHR	;Mixed-screen graphics character
	BEQ STPMIX
	CMP #TXTCHR	;Show text screen
	BEQ STPTXT
	CMP #IOKEY	;Restore KBD driver
	BEQ RSTINP
	SEC		;Carry set means character not intercepted
	RTS

;Halt listing/Single step character handler
LWAIT:	JSR GETCHR	;Wait for a character before continuing (doesn't reset strobe)
	CMP #LSTKEY
	BEQ LWAIT1	;If it's another stop-list key, hold it until next poll
	LDA KBDCLR	;Else reset strobe
	CMP #STPKEY	;stop if the key is a stop key.
	BEQ STPPK1
LWAIT1:	CLC		;Character intercepted
	RTS

STPPK1:	ERROR XZAP,XSTOP	;Stopped!!

LPAUSE:	LDA FBODY+1		;Pause does nothing inside break loops toplevel.
	BEQ CKRTS
	ERROR XBRK


.IFEQ GRPINC
;If no graphics, these keys are not intercepted.
STPTXT:
STPMIX:
STPFUL:	SEC
	RTS
.ENDC

.IFNE GRPINC
;Full graphics screen
STPFUL:	LDA BUFOWN
	BPL CKRTS	;Ignore if not in graphics mode
	LDA GSW		;Show graphics screen (in case ^T showed text)
	LDA FULLGR	;Full screen
	CLC		;Character intercepted
	RTS

;Split graphics screen
STPMIX:	LDA BUFOWN
	BPL CKRTS	;Ignore if not in graphics mode
	LDA GSW		;Show graphics screen (in case ^T showed text)
	LDA MIXGR	;Split screen
	CLC		;Character intercepted
	RTS

;Show text screen
STPTXT:	LDA TXTMOD	;Show text screen
	CLC		;Character intercepted
	RTS
.ENDC

;Restore KBD and screen input device driver
RSTINP:	SETV DEFINP,INPDEV,KEYIN
	SETV DEFOUT,OTPDEV,CROUT
CKRTS:	CLC
	RTS
.PAGE
.SBTTL		Atomic Value Routines

;	Local variable block:
ATOMM	=TEMPNH		;Atom ptr.

;Get value into X's pointer from Y's atom
; Should return with high byte of value in A.
; Shouldn't bash X. Returns with Z bit set if value is Novalue.
GETVAL:	LDA $00,Y
	AND #$FC	;Strip off last two bits
	STA ATOMM
	LDA $01,Y
	STA ATOMM+1
	CARX ATOMM
	CMP #$01
	RTS

;	Local variable block:
ATOMM	=TEMPNH		;Atom ptr.

;Put value from X's pointer into Y's atom
PUTVAL:	LDA $00,Y
	AND #$FC
	STA ATOMM
	LDA $01,Y
	STA ATOMM+1
	RPLCAX ATOMM
	RTS
.PAGE
.SBTTL		Function Utility Routines

;	Local variable block:
OBJECT	=TEMPN		;Object ptr.
FUN	=ANSN		;Function ptr. addr.

;(Subrs: GETTYP)
;Get function from token in X to pointer in A, return function typecode in Y.
; Returns with Z set if Funct is Novalue.
GETCFN:	LDX #CURTOK	;Enter here if token is CURTOK & Funct is FUNCT
GTCFN1:	LDA #FUNCT	;Enter here to get function in Funct
GETFUN:	STA FUN
	GETX OBJECT
	JSR GETTYP
	CMP #ATOM
	BEQ GTFNA
	CMP #SATOM
	BEQ GTFNS
	LDA #$01
	LDX FUN
	STA $01,X
	CMP #$01	;Always sets Z bit
	RTS
GTFNA:	LDY #$02	;Atom (cdr then car)
	LDA (OBJECT),Y
	TAX
	INY
	LDA (OBJECT),Y
	STA OBJECT+1
	STX OBJECT
	LDX FUN
	CARX OBJECT
	LDY #UFUN
	CMP #$01	;Set Z bit if Novalue
	RTS
GTFNS:	LDX FUN		;Satom (cdr)
	CDRX OBJECT
	LDY #SFUN
	CMP #$01	;Set Z bit if Novalue
	RTS

;Get precedence of Funct in A.
GETPRC:	LDA FUNTYP
	CMP #UFUN
	BEQ GTPCU
	LDY #PRMPRC	;Sfun, Index the precedence
	BNE GTNGPC	;(Always)
GTPCU:	LDA #$05	;Ufun, precedence 5
	RTS

;Get no. of args of Funct in A.
GETNGS:	LDA FUNTYP
	CMP #SFUN
	BEQ GTNGS
GTNGU:	LDY #$04	;Ufun, second word in function block
	LDA (FUNCT),Y
	RTS
GTNGS:	LDY #PRMNGS	;Sfun, Index the no. of arguments
GTNGPC:	DATRAM	
	LDA (FUNCT),Y
	NODRAM		;Disable ghost-memory
	RTS

;Return carry set and index in A if Funct is an infix sfun.
;Entered with Fun-typecode in Y.
INFIXP:	CPY #SFUN
	BNE IFPNI	;Only sfuns can be infix
	DATRAM		;Enable ghost-memory
	LDY #PRMIDX	;Index the system function index
	LDA (FUNCT),Y
	NODRAM		;Disable ghost-memory
	CMP #INHIGH+1	;Highest infix function index
	BCS IFPNI
	CMP #INLOW	;Lowest infix function index
	RTS		;(Here Carry is set if infix, else clear)
IFPNI:	CLC		;Not infix
	RTS
.PAGE
;	Local variable block:
FNTXTP	=ANSN4		;Function text ptr. addr.
ARGS	=ANSN3		;No. of args
ATMPTR	=TEMPN7		;Atom ptr. addr.
ATOMM	=TEMPNH		;Atom ptr.
CELL	=TEMPN5		;Function cell
FUNCTP	=TEMPN6		;Function ptr.
SIZE	=TEMPN8		;Length of contiguous area to get

;(Subrs: GETTYP,GETWDS,PUTTYP)
;Creates or redefines a ufun block.
;Entered with the text pointer in Y, the no.-of-args in A,
; and the atom pointer in X.
PTFTXT:	STY FNTXTP
	STA ARGS
	STX ATMPTR
	JSR GETTYP
	CMP #ATOM
	BNE PTFTX2	;Must be an Atom
	LDX ATMPTR
	GETX ATOMM
	CDR CELL,ATOMM
	CAR FUNCTP,CELL	;Get the function ptr
	CMP #$01	;See if it's novalue
	BNE PTFTX3	;Nope, just redefine the current one
	LDX FNTXTP	;Yes, make a new one
	GETX MARK1	;Protect the text
	LDA #$04
	STA SIZE	;Function block is four words long
	LDA #$00
	STA SIZE+1
	LDY #SIZE
	LDX #FUNCTP
	JSR GETWDS	;Get four contiguous words
	LDA FUNCTP+1
	BEQ PTFER	;If no more room, give error
	RPLACA CELL,FUNCTP	;Set the function block pointer
	LDA #$00
	STA MARK1+1	;Clear the Mark variable
	LDX #FUNCTP
	LDA #UFUN
	JSR PUTTYP	;Assign the typecode
	LDY #$06
	LDX ATMPTR	;Put a back pointer to the atom in the third word
	LDA $00,X
	STA (FUNCTP),Y
	INY
	LDA $01,X
	STA (FUNCTP),Y
PTFTX3:	LDY #$01	;Define/assign the function block
	LDA #$00	;First word is Frame pointer (nil now)
	STA (FUNCTP),Y
	LDX FNTXTP
	RPLCDX FUNCTP	;Second word is body pointer
	INY
	LDA ARGS	;Third word is nargs
	STA (FUNCTP),Y
	RTS
PTFTX2:	LDY ATMPTR
	JSR PTRYOK
	ERROR XUBL	;Error - ... Is a Logo primitive
PTFER:	JMP CONSR	;Error - "No storage left" (No Nodes) zapcode

;	Local variable block:
FUN	=TEMPNH		;Function ptr.

;Delete the ufun bound to the atom in X.
UNFNC1:	LDX #ARG1	;Enter here for atom ptr. ARG1
UNFUNC:	GETX FUN
	CDRME FUN
	LDY #$01
	TYA		;Ufun <- novalue
	STA (FUN),Y
	RTS
.PAGE
.SBTTL		Nodespace Routines

;	Local variable block:
XCAR	=TEMPNH		;Addr. of car ptr.
XCDR	=TEMPNH+1	;Addr. of cdr ptr.

;(Subrs: VPUSHP,GARCOL,PUTTYP)
;CONS creates a new node from the freelist. X points to the Cdr,
;Y to the Car, NODPTR to the node's pointer, and A holds the typecode.
CONS:	PHA		;Save the typecode (for Put-type)
	CMP #LIST
	BEQ FCONS
	CMP #STRING
	BEQ SCONS
	CMP #FIX
	BEQ NCONS
	CMP #FLO
	BEQ NCONS
	CMP #ATOM
	BEQ SCONS
	CMP #SATOM
	BEQ S1CONS
	LDA #$04
	JMP SYSBUG	;System bug: Bad CONS typecode

;"F" CONS - Protect both CAR and CDR. Used for Lists.
FCONS:	JSR XCONS
	LDX XCAR
	JSR VPUSHP	;VPUSH Xcar
	LDX XCDR
	JSR VPUSHP	;VPUSH Xcdr
	JSR GARCOL
	CLC		;Reset the VPDL
	LDA VSP
	ADC #$04
	JMP SCONS2

;"N" CONS - Doesn't protect either CAR or CDR. Used for numbers.
NCONS:	JSR XCONS
	JSR GARCOL
	JMP CONSG1

;"S" CONS - Protects only CDR. Used for strings.
SCONS:	JSR XCONS
	LDX XCDR
	JSR VPUSHP	;VPUSH Xcdr
	JSR GARCOL
	JMP SCONS1	;Reset the VPDL

;"S1" CONS - Protects only CAR. Used for Satoms.
S1CONS:	JSR XCONS
	LDX XCAR
	JSR VPUSHP
	JSR GARCOL
SCONS1:	CLC		;Reset the VPDL
	LDA VSP
	ADC #$02
SCONS2:	STA VSP
	BCC CONSG1
	INC VSP+1
	BNE CONSG1	;(Always)

;Checks the situation after a garbage collect, makes the node if ok.
CONSG1:	LDA PRSFLG
	BEQ CONST2
	LDA FRLIST+1	;Parse-flag set, error only if Freelist still empty
	BNE CONS2
	BEQ CONSR	;(Always)
CONST2:	CMPV NNODES,NODLIM	;Parse-flag reset, check allocation limit.
	BCC CONS2	;Ok, make the node
CONSR:	ERROR XZAP,XNSTRN	;Error "No storage left" (No nodes)

;Initial CONS routine. If a garbage collect is necessary, returns to caller,
; otherwise zaps return address and makes the node.
XCONS:	STY XCAR
	STX XCDR
	LDA FRLIST+1
	BEQ XCONSG	;Freelist empty, return
	LDA PRSFLG
	BNE XCONS2	;Don't check limit for parser calls
	CMPV NNODES,NODLIM
	BCC XCONS2
XCONSG:	RTS
XCONS2:	PLA		;Okay to cons, zap return addr and hit CONS2
	PLA
;Makes the node
CONS2:	INC1 NNODES	;Increment node counter
	LDX XCAR
	RPLCAX FRLIST	;Put in CAR
	LDX XCDR
	LDY #$02
	LDA (FRLIST),Y	;Put in CDR, saving pointer
	PHA
	LDA $00,X
	STA (FRLIST),Y
	INY
	LDA (FRLIST),Y
	PHA
	LDA $01,X
	STA (FRLIST),Y
	LDX NODPTR
	PUTX FRLIST	;Set node pointer
	PLA
	STA FRLIST+1	;Freelist <- saved ptr from cdr of grabbed node
	PLA
	STA FRLIST
	PLA		;Retrieve node typecode
;	...
.PAGE
;(Subrs: TYPACS)
;Give node X typecode A.
;	...
PUTTYP:	CMP #LATOM+1
	BCS PUTTP2
	CMP #QATOM
	BCC PUTTP2
	AND #$03	;L,D,Qatom: modify low two bits of pointer
	ORA $00,X
	STA $00,X
	RTS
PUTTP2:	LDY $01,X
	CPY #$02
	BCC PUTTPE	;Can't give nil or novalue a type, ignore
	PHA		;Save typecode
	STY TYPPTR+1
	LDA $00,X
	STA TYPPTR
	JSR TYPACS	;Access typecode byte
	PLA		;Get typecode
	STA (TYPPTR),Y	;Deposit in type-array
PUTTPE:	RTS

;(Subrs: TYPACS)
;Give node X typecode A. Shouldn't destroy X.
GETTYP:	LDA $01,X
	BEQ GETTPE	;Pointer to 00 is empty list, typecode 0 (LIST)
	STA TYPPTR+1
	LDA $00,X
	STA TYPPTR
	JSR TYPACS	;Access typecode array
	CMP #ATOM
	BEQ GETTP4
	CMP #SATOM
	BNE GETTPE
GETTP4:	TAY		;Atom or Satom, get low two bits of pointer
	LDA $00,X	;(For Q,D,Latoms)
	AND #$03
	BEQ GETTPF	;If 0, just return with Atom or Satom code
	ORA #$08	;Else return with Qatom, Datom, or Latom
GETTPE:	RTS
GETTPF:	TYA
	RTS

;Access the typecode byte for the node in TYPPTR. Return with Y=$00.
TYPACS:	LSR TYPPTR+1	;First divide by four (four bytes/node)
	ROR TYPPTR
	LSR TYPPTR+1
	ROR TYPPTR
	CLC
	LDA TYPPTR
	ADC #TYPARY&$FF	;Add Type-array offset
	STA TYPPTR
	LDA TYPPTR+1
	ADC #TYPARY^
	STA TYPPTR+1
	LDY #$00
	LDA (TYPPTR),Y	;Access byte
	RTS

;(Subrs: GETTYP)
;Get a word arg1 from the VPDL.
GTWRD1:	VPOP ARG1
;Do a Get-type and return with Z bit set if typecode is Atom, Satom, or String.
CHKWRD:	JSR GETTYP
	CMP #ATOM
	BEQ CKWRTS
	CMP #SATOM
	BEQ CKWRTS
	CMP #STRING
CKWRTS:	RTS
.PAGE
;	Local variable block:
RETPTR	=ANSN		;Ptr. to contig. area
SIZEP	=ANSN1		;Addr. of size of area
LSTPTR	=TEMPN		;Search ptr.
LSTPT1	=TEMPN4		;Search ptr.
PTR	=TEMPN1		;Search ptr.
PTR1	=TEMPN3		;Search ptr.
SOFAR	=TEMPN2		;Size of area so far
CONTIG	=ANSN2		;Zero if contiguous so far
TMPPTR	=TEMPNH		;Temp. search ptr.

;(Subrs: GARCOL)
;Tries to find a block of (Y) contiguous free words in nodespace.
; If successful, returns the start addr. in (X). If not, returns nil.
; Trying to get 0 words gives nil, also.
GETWDS:	STX RETPTR
	STY SIZEP
	LDA #$00
	STA $01,X		;Zero result pointer
	LDA $00,Y
	ORA $01,Y
	BEQ RTS2		;If size=0, just return with 0
	JSR GW1			;try once
	LDX RETPTR
	LDA $01,X
	BNE RTS2		;if found something, exit
	JSR GARCOL		;otherwise, try again after a GC

GW1:	LDA #$00
	STA LSTPTR+1		;Zero lastptr
	STA LSTPT1+1		;and lastptr1
	MOV PTR,PTR1,FRLIST	;init ptr and ptr1 to freelist
GW1W:	LDX RETPTR
	LDA $01,X		;if ans neq nil, done
	BEQ GW1WA		;cuz found something
	INC1 SOFAR		;Adjust node counter, Nodes := (words+1)/2
	LSR SOFAR+1
	ROR SOFAR
	CLC
	LDA NNODES
	ADC SOFAR
	STA NNODES
	LDA NNODES+1
	ADC SOFAR+1
	STA NNODES+1
RTS2:	RTS
GW1WA:	LDA PTR+1		;if ptr = nil, done cuz been thru whole
	BEQ RTS2		;freelist, found nothing
GW1W1:	LDA #$00
	STA SOFAR		;sofar:= 0
	STA SOFAR+1
	STA CONTIG		;contig:= 0 (T)
GW1X:	LDX SIZEP
	LDA SOFAR+1
	CMP $01,X
	BCC GW1X2
	BNE GWIF2
	LDA SOFAR
	CMP $00,X
	BCS GWIF2		;if sofar >= size, go if2
	LDA CONTIG		;if contig = false, go else
	BNE GWELSE
	LDA PTR1
	ORA PTR1+1
	BEQ GWELSE		;if ptr1 = nil, goto else
GW1X2:	INC2 SOFAR		;sofar := sofar + 2
	CDR TMPPTR,PTR1		;temp:= (cdr ptr1)
	CLC
	LDA TMPPTR		;add 4 to temp and see if
	ADC #$04		;result is = ptr1
	TAX
	LDA TMPPTR+1
	ADC #$00
	CMP PTR1+1
	BNE NCNTIG
	CPX PTR1
	BEQ CNTIG		;if so, contig := 1 (false)
NCNTIG:	INC CONTIG
CNTIG:	MOV LSTPT1,PTR1		;lastptr1 := ptr1
	MOV PTR1,TMPPTR		;ptr1 := temp
	JMP GW1X		;round the while loop
GWIF2:	LDA LSTPTR+1		;if lastptr = nil, freelist := ptr1
	BNE GWIF3
	MOV FRLIST,PTR1		;freelist := ptr1
	JMP GWIF4
GWIF3:	RPLACD LSTPTR,PTR1	;else (rplacd lasptr ptr1)
GWIF4:	LDX RETPTR
	PUTX LSTPT1		;retptr := lastptr1
	JMP GW1W		;back to top
GWELSE:	MOV PTR,PTR1		;ptr := ptr1
	MOV LSTPTR,LSTPT1	;lastptr := lastptr1
	JMP GW1W		;back to top
.PAGE
.SBTTL		Ufun Line Utility Routines

;	Local variable block:
ARGLST	=TEMPN8		;Arglist pointer for bindings (shared: UFUNCL,XTAIL,NWBNDS)
BODY	=TEMPNH		;Body ptr.

;Get ufun line in X from body Y.
GETALN:	LDY #FBODY	;Enter here to get ARGLST from FBODY
	LDX #ARGLST
GETULN:	GETY BODY
	CARX BODY
	LDA UFRMAT
	BNE GTTFPK
	LDA $01,X	;Typecode List, check for comment if not nil
	BNE GTTCK
	RTS
GTTFPK:	CDR ULNEND,BODY	;Typecode Fpack, check for end-of-ufun
	CMP $01,X
	BNE GTTCK
	LDA ULNEND
	CMP $00,X
	BEQ GTTNIL
GTTCK:	GETX BODY	;Check for comment
	LDY #$00
	LDA (BODY),Y
	CMP #COMMNT&$FF
	BNE GTTRTS
	INY
	LDA (BODY),Y
	CMP #COMMNT^
	BNE GTTRTS
GTTNIL:	LDA #$00	;Comment, return nil
ULDV3:	STA $01,X
GTTRTS:	RTS

;	Local variable block:
BODY	=TEMPNH		;Body ptr.

GLNADV:	LDX #GOPTR
ULNADV:	GETX BODY
	LDA UFRMAT
	BNE ULDV2
ULDV1:	LDY #$02
	LDA (BODY),Y
	PHA
	INY
	LDA (BODY),Y
	STA $01,X
	PLA
	STA $00,X
	RTS
ULDV2:	LDY #$05
	LDA (BODY),Y
	BEQ ULDV3
	INC2X
	RTS

;	Local variable block:
TOKEN	=TEMPX1		;Token
LINPTR	=TEMPN8		;Fpacked line ptr. (shared: ERROR,POFUN)
ENDPTR	=TEMPX2		;Fpacked line-end ptr. (shared: ERROR,POFUN)

;(Subrs: TPCHR,TYPE0)
;Type an Fpacked line
TPLINF:	COMP LINPTR,ENDPTR
	BEQ GTTRTS
	CAR TOKEN,LINPTR
	INC2 LINPTR
	TPCHR SPACE
	LDX #TOKEN
	JSR TYPE0
	JMP TPLINF
.PAGE
.SBTTL		Token-list Routines

;	Local variable block:
TOKEN	=TEMPNH		;Token list ptr.

TOKADV:	LDX #TOKPTR
TTKADV:	JSR TFKADV
	GETX TOKEN
	LDY #$00
	LDA (TOKEN),Y
	CMP #COMMNT&$FF
	BNE TTKE
	INY
	LDA (TOKEN),Y
	CMP #COMMNT^
	BNE TTKE
	LDA #$00
	STA $01,X
TTKE:	RTS

TFKADV:	LDA UFRMAT
	CMP #FPACK
	BEQ TFK2
TFK1:	GETX TOKEN
	CDRX TOKEN
	RTS
TFK2:	INC2X
	CMP ULNEND
	BNE TFK3
	LDA $01,X
	CMP ULNEND+1
	BNE TFK3
	LDA #$00
	STA $01,X
TFK3:	RTS

;	Local variable block:
TOKEN	=TEMPN		;Token ptr.
PCOUNT	=ANSN		;Parenthesis counter

;(Subrs: TOKADV)
SKPPTH:	LDA TOKPTR+1
	BEQ RTSA2X
	CAR TOKEN,TOKPTR
	JSR TOKADV
	CMPV TOKEN,LPAR
	BNE RTSA2X
	LDA #$01
	STA PCOUNT
SKPPW:	LDA TOKPTR+1
	BEQ RTSA2X
	CAR TOKEN,TOKPTR
	JSR TOKADV
	LDX TOKEN
	LDY TOKEN+1
	CPX #LPAR&$FF
	BNE SKPPW2
	CPY #LPAR^
	BNE SKPPW2
	INC PCOUNT
	BNE SKPPW
	LDX #PRNNST
	JMP EXCED	;Parenthesis nesting too deep
SKPPW2:	CPX #RPAR&$FF
	BNE SKPPW
	CPY #RPAR^
	BNE SKPPW
	DEC PCOUNT
	BNE SKPPW
RTSA2X:	RTS

;	Local variable block:
RETTKN	=ANSN1		;Addr. of returned token ptr.
IFCNTR	=TEMPN1		;If-level counter

;(Subrs: TOKADV,SKPPTH)
EXIFSC:	STX RETTKN
	LDA IFLEVL
	STA IFCNTR
EXFW:	LDA IFCNTR
	CMP IFLEVL		;Loop while If-counter >= If-level
	BCC EXFWE
EXFWA1:	LDA TOKPTR+1
	BEQ EXFWE
	LDX RETTKN
	CARX TOKPTR
	LDY $00,X	;A is high byte, Y is low byte
	CMP #IF^
	BNE EXFW2
	CPY #IF&$FF
	BNE EXFW2
	INC IFCNTR
	JSR TOKADV
	JMP EXFW
EXFWE:	DEC IFLEVL
	RTS
EXFW2:	CMP #ELSE^
	BNE EXFW3
	CPY #ELSE&$FF
	BNE EXFW3
	DEC IFCNTR
	LDA IFCNTR
	CMP IFLEVL
	BCC EXFWE
	JSR TOKADV
	JMP EXFWA1
EXFW3:	CMP #RPAR^
	BNE EXFW4
	CPY #RPAR&$FF
	BEQ EXFWE
EXFW4:	JSR SKPPTH
	JMP EXFW
.PAGE
.SBTTL		Stuffed stuff Routines

;	Local variable block:
ATMPTR	=ANSN3		;Atom ptr. addr.
BODYP	=ANSN4		;Body ptr. addr.
BODY	=TEMPN2		;Body ptr.
LINE	=TEMPN7		;Ufun line
LENGTH	=TEMPX2		;Length of line
SIZE	=TEMPN6		;Length of fpacked space
LINE1	=TEMPN		;Line ptr. while computing size
PTR	=TEMPN5		;Ptr. to fpacked area
INDEX	=TEMPX1		;Ptr. to fpacked area
INDEX1	=TEMPN1		;Alt. index
TOKEN	=TEMPN3		;Token ptr.

;(Subrs: GETLEN,GETWDS,PTFTXT,PUTTYP)
STUFF:	STA ATMPTR		;try to associate the atom
	STX BODYP		;definition with the function body
	GETX BODY
	CAR LINE,BODY
	LDX #LENGTH
	LDY #LINE
	JSR GETLEN
	LDA #$00
	STA SIZE
	STA SIZE+1
GTSZW:	LDA BODY+1
	BEQ GTSZND
	CARNXT LINE1,BODY
GTSZX:	LDA LINE1+1
	BEQ GTSZW
GTSZX1:	INC1 SIZE
	CDRME LINE1
	BNE GTSZX1
	BEQ GTSZW	;(Always)
GTSZND:	LDX #PTR
	LDY #SIZE
	JSR GETWDS
	LDA PTR+1
	BNE STFF1
STFFA:	LDA LENGTH
	LDY BODYP
	LDX ATMPTR
	JMP PTFTXT
STFF1:	MOV AREA1,PTR
	MOV SIZE1,SIZE
	LDX #SIZE
	LDY BODYP
	JSR GETLEN
	INC2 SIZE
	LDX #INDEX
	LDY #SIZE
	JSR GETWDS
	LDA INDEX+1
	BNE STFF2
	STA SIZE1
	STA SIZE1+1
	JMP STFFA
STFF2:	MOV AREA2,INDEX1,INDEX
	CLC
	LDA SIZE
	ADC #$02
	STA SIZE2
	LDA SIZE+1
	ADC #$00
	STA SIZE2+1
	LDX BODYP
	GETX BODY
STFFW:	LDA BODY+1
	BEQ STFFWE
	RPLACA INDEX1,PTR
	INC2 INDEX1
STFFX:	LDA LINE+1
	BEQ STFFXE
	CARNXT TOKEN,LINE
	RPLACA PTR,TOKEN
	INC2 PTR
	JMP STFFX
STFFXE:	CDRME BODY
	CAR LINE,BODY
	JMP STFFW
STFFWE:	RPLACA INDEX1,PTR
	LDY #$03
	LDA #$00
	STA (INDEX1),Y
	LDX #INDEX
	LDA #FPACK
	JSR PUTTYP
	LDA LENGTH
	LDY #INDEX
	LDX ATMPTR
	JSR PTFTXT
	LDA #$00
	STA SIZE1
	STA SIZE1+1
	STA SIZE2
	STA SIZE2+1
RTS3:	RTS
.PAGE
;	Local variable block:
BODYP	=ANSN1		;Addr. of Body ptr.
FUN	=TEMPNH		;Function ptr.
INDEX	=TEMPN1		;Fpacked area index
SPPTR	=TEMPN4		;Stack ptr. temp
PTR	=TEMPN2		;Ptr. into fpack area
ENDPTR	=TEMPN3		;Fpack end-pointer
TOKEN	=TEMPN		;Token ptr.

;(Subrs: GETTYP,TSTPOL,PUSH,POP,CONS,PUTTYP,CLMK2)
UNSTUF:	STY BODYP
	GETX FUN
	CDR INDEX,FUN
	GETTYP INDEX
	CMP #FPACK
	BEQ USTF2
USTF1:	LDX BODYP
	PUTX INDEX
	RTS
USTF2:	LDA #$00
	STA MARK1+1
	MOV SPPTR,SP
USTFW2:	CAR PTR,INDEX
	CDR ENDPTR,INDEX
USTFW:	LDA ENDPTR+1
	BEQ USTFWE
	JSR TSTSTK
	PUSH PTR
	INC2 INDEX
	JMP USTFW2
USTFWE:	MOV ENDPTR,PTR
USTFX:	COMP SPPTR,SP
	BEQ USTFXE
	POP PTR
	LDA #$00
	STA MARK2+1
USTFY:	COMP ENDPTR,PTR
	BEQ USTFYE
	DEC2 ENDPTR
	CAR TOKEN,ENDPTR
	CONS MARK2,TOKEN,MARK2,LIST
	JMP USTFY
USTFYE:	LDX #MARK2
	LDA #LIST
	JSR PUTTYP
	CONS MARK1,MARK2,MARK1,LIST
	JMP USTFWE
USTFXE:	LDX BODYP
	PUTX MARK1
	LDA #$00
	JMP CLMK2	;Clear MARK1, MARK2
.PAGE
.SBTTL		Oblist Interning Routine

STRNGP	=ANSN1		;Addr. of string ptr.
RETPTR	=ANSN2		;Addr. of returned pointer
OBPTR	=TEMPN4		;Oblist pointer
PNAME	=TEMPN5		;Comparison pname
STRNG1	=TEMPNH		;Comparison string
SOBPTR	=TEMPNH		;Soblist object ptr.
SOBNAM	=TEMPN2		;Soblist object pname
CHARS	=TEMPN		;Temp. char. storage

;(Subrs: VPUSHP,ATMPNM,VPOP)
;Return a pointer to the Atom or Satom (to Y addr) with the pname of
; the string in X, or just the string ptr. if not found. Return
; typecode (in A) of returned object.
INTRNP:	STX STRNGP
	STY RETPTR
	JSR PUSH	;Save string on stack
	MOV OBPTR,OBLIST
OBFW:	LDX RETPTR
	CARX OBPTR	;Assume it's this Oblist object
	LDY #PNAME
	JSR ATMPNM	;Get atom pname
	LDX STRNGP
	LDA $00,X
	AND #$FC
	STA STRNG1
	LDA $01,X
	STA STRNG1+1
MTC2W:	LDA STRNG1+1
	BNE MTC2W1
	LDA PNAME+1
	BNE OBFNF	;If STRING is 0 and PNAME isn't, not found
MTCFND:	POP PNAME	;Pop the pushed string (we found it, both ptrs 0)
	LDA #ATOM	;Typecode is atom
	RTS
MTC2W1:	LDY #$00
	LDA (STRNG1),Y
	CMP (PNAME),Y
	BNE OBFNF
	TAX
	BEQ MTCFND	;First char both 0, so found
	INY
	LDA (STRNG1),Y
	CMP (PNAME),Y
	BNE OBFNF
	INY
	LDA (STRNG1),Y
	TAX
	INY
	LDA (STRNG1),Y
	STA STRNG1+1
	STX STRNG1
	DEY
	LDA (PNAME),Y
	TAX
	INY
	LDA (PNAME),Y
	STA PNAME+1
	STX PNAME
	JMP MTC2W	;try next two characters
OBFNF:	CDRME OBPTR	;try next Oblist object
	BNE OBFW
	LDX STRNGP	;it's not on the oblist
	JSR POP		;get string back
	LDX RETPTR	;ans becomes soblist pointer
	PUTX SOBLST
SBFW:	LDX RETPTR	;object pointer
SBFWX:	LDA $00,X
	CMP SOBTOP
	BNE SBFW1
	LDA $01,X
	CMP SOBTOP+1
	BNE SBFW1
	LDY STRNGP	;Not found anywhere, so return the string pointer
	LDA $00,Y
	STA $00,X
	LDA $01,Y
	STA $01,X
	LDA #STRING	;Typecode String
	RTS
SBFW1:	GETX SOBPTR
	LDY #$02
	LDA (SOBPTR),Y
	INY
	CLC
	ADC #PRMNAM
	STA SOBNAM
	LDA (SOBPTR),Y
	ADC #$00
	STA SOBNAM+1
	LDX STRNGP
	LDA $01,X
	BEQ SBFNF
	STA STRNG1+1
	LDA $00,X
	AND #$FC
	STA STRNG1
	LDY #$00
MTC1W1:	CAR CHARS,STRNG1
	DATRAM		;Enable ghost-memory
	LDA (SOBNAM),Y
	CMP CHARS
	BNE SBFNF
	INC1 SOBNAM
	LDA (SOBNAM),Y
	CMP CHARS+1
	BNE SBFNF
	INC1 SOBNAM
	CDRME STRNG1
	BNE MTC1W1
	LDA (SOBNAM),Y
	BEQ SBFFND
SBFNF:	NODRAM
	LDX RETPTR	;not this soblist object
	INC4X
	JMP SBFWX
SBFFND:	NODRAM
	LDA #SATOM	;Found it, it's an satom
	RTS

;	Local variable block:
NEWATM	=TEMPX1		;Ptr. returned (shared: GTBOOL,STHNGP,
			;SMAKE,SGO,STHING,SDEFIN,STEXT)

;(Subrs: GETTYP,INTRNP)
;If object in X is a string which matches an object on the ob/soblist,
; return a pointer to it in NEWATM and typecode in A, carry set. If it's a
; string not on the oblist, return a pointer to the string in NEWATM and
; String in A, carry set. If it's an atom or satom, just return with
; NEWATM = ptr. and typecode in A, carry set. If it's not an Atom, Satom,
; or String, return typecode in A and carry clear.
INTSTR:	JSR GETTYP
	CMP #ATOM
	BEQ INTST1
	CMP #SATOM
	BEQ INTST1
	CMP #STRING
	BNE INTST2
	LDY #NEWATM
	JSR INTRNP	;See if interned, returns with right stuff
	SEC		;Carry set
	RTS
INTST1:	LDY $00,X	;Atom or Satom, return ptr. to it
	STY NEWATM
	LDY $01,X
	STY NEWATM+1
	SEC		;Return carry set
	RTS
INTST2:	CLC		;Not a string, atom, or satom, so return carry clear
	RTS

;	Local variable block:
RETPTR	=ANSN2		;Addr. of returned pointer
NOVALU	=TEMPN1		;Novalue constant

;(Subrs: CONS)
;Make a new oblist entry with ptr. A and pname X.
INTRNX:	STA RETPTR
	STA NODPTR
	LDA #$01	;Not found anywhere
	STA NOVALU+1
	LDY #NOVALU
	LDA #LIST
	JSR CONS
	LDX RETPTR
	STX NODPTR
	LDY #NOVALU
	LDA #ATOM
	JSR CONS
	LDA #LIST
	LDX #OBLIST
	STX NODPTR
	LDY RETPTR
	JMP CONS
.PAGE
.SBTTL		Linked-list Utility Routines

;	Local variable block:
LSTPTR	=TEMPNH		;List ptr.

;Return length of list Y to addr. in X.
GETLEN:	GETY LSTPTR
	LDA #$00
	STA $00,X
	STA $01,X
GLENW1:	LDA LSTPTR+1
	BEQ GLENR
	LDY #$00
	LDA (LSTPTR),Y
	CMP #COMMNT&$FF
	BNE GLENW2
	INY
	LDA (LSTPTR),Y
	CMP #COMMNT^
	BEQ GLENR
GLENW2:	LDY #$02
	LDA (LSTPTR),Y
	PHA
	INY
	LDA (LSTPTR),Y
	STA LSTPTR+1
	PLA
	STA LSTPTR
	INC $00,X
	BNE GLENW1
	INC $01,X
	BNE GLENW1	;(Always)

;	Local variable block:
RETPTR	=ANSN		;Addr. of returned ptr.
LSTPTR	=TEMPNH		;List ptr.

GTLSTC:	STX RETPTR
	GETX LSTPTR
	LDY #$02
GTLC2:	LDA (LSTPTR),Y
	TAX
	INY
	LDA (LSTPTR),Y
	BEQ GTLC3
	STA LSTPTR+1
	STX LSTPTR
	DEY
	BNE GTLC2	;(Always)
GTLC3:	LDX RETPTR
	PUTX LSTPTR
GLENR:	RTS

;(Subrs: CONS)
MAKMTW:	STA NODPTR	;Make A point to the empty word
	LDA #$00
	TAX
	TAY
	LDA #STRING
	JMP CONS
.PAGE
.SBTTL		Error Routines

;	Local variable block:
ERPTR1	=TEMPX1		;X reg. error pointer
ERPTR2	=TEMPX2		;Y reg. error pointer
ERRX	=ANSN2		;X reg. error ptr. addr.
ERRY	=ANSN3		;Y reg. error ptr. addr.
ERRMSG	=TEMPN8		;Error message address
LINPTR	=TEMPN8		;Fpacked line ptr. (shared: TPLINF)
ENDPTR	=TEMPX2		;Fpacked line-end ptr. (shared: TPLINF)
ATMNAM	=TEMPN8		;Atom name
ERRNM1	=ANSN4		;Error number

;(Subrs: QUIETM,RSTIO,EXTDEF,TPCHR,BREAK1,PRTSTR,TYPE0,CLMK4,
; GETTYP,TPLINF,TYPE1,TPLEVN,TYPE)
PTRXOK:	GETX ERPTR1	;Use explicit pointers so they don't get bashed
	LDX #ERPTR1
	RTS

PTRYOK:	GETY ERPTR2
	LDY #ERPTR2
	RTS

ERROR:	STA ERRNUM
	STX ERRX
	STY ERRY
	LDA GCFLAG
	BEQ ERRNGC
	DEC GCFLAG	;If doing a garbage collect, reset flag
	LDA #$00
	STA FRLIST	;clear the freelist, and
	JSR CLRMRK	;clear the mark-array
ERRNGC:	LDA BUFOWN
	BPL ERRO1
	LDA MIXGR	;If FULL Graphics, make MIXED
	JMP ERRO2
ERRO1:	CMP #$02	;See if music owns the buffer
	BNE ERRO2
.IFNE MUSINC
	JSR QUIETM	;Shut up music if it's there
.ENDC
ERRO2:	JSR RSTIO
	LDX ERRNUM
	CPX #XBRK
	BEQ ERRO3	;Don't do EXTDEF if in a Pause-loop
	JSR EXTDEF	;(Doesn't bash X)
ERRO3:	CPX #XZAP
	BEQ ERRZ1
;Error-message string finder (Error index number in X register)
;Doesn't require an address table
;Skips message terminators (zeros) until the proper message is found
	SETV ERRMSG,ERMSGS	;Set pointer to start of messages
	DATRAM			;Enable ghost memory
	TXA			;If error number 0,
	BEQ ERRWX		;then we're there already
	LDY #$00
ERMLP:	LDA (ERRMSG),Y		;Get a character
	BEQ ERMLP1		;If zero, check index
ERMLP2:	INC1 ERRMSG		;Else go to next character
	JMP ERMLP		;and continue searching
ERMLP1:	DEX			;Decrement index when zero found
	BNE ERMLP2		;If index not yet zero, continue searching
ERRW:	INC1 ERRMSG		;Advance to next character
ERRWX:	DATRAM		;Enable Ghost-memory
	LDY #$00
	LDA (ERRMSG),Y
	NODRAM		;Ghost-memory disable
	TAX
	BEQ ERRWE
	CMP #$01
	BEQ ERRW1
	CMP #$02
	BEQ ERRW2
	JSR TPCHR
	JMP ERRW
ERRZ1:	JSR BREAK1
	LDA ERRY
	ASL A
	TAY
	DATRAM		;Enable ghost-memory
	LDX ZAPTBL,Y
	LDA ZAPTBL+1,Y
	TAY
	NODRAM		;Disable ghost-memory
	JSR PRTSTR
	LDA ERRY
	CMP #$03
	BCC ERRWE
	PRTSTR ZPMX1
	JMP ERRWE
ERRW2:	LDX ERRX
	JMP ERRW3
ERRW1:	LDX ERRY
ERRW3:	JSR TYPE0
	JMP ERRW	;Next character
ERRWE:	LDA #$00
	JSR CLMK4	;Clear all the MARK pointers
	LDA LEVNUM
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ ERR1
	LDA FBODY+1
	BEQ ERR1	;Toplevel of a break-loop if this is zero
	PRTSTR ERRM2
	CAR LINPTR,FPTR	;Get the line from the rest of the body
	LDA RUNFLG	;If RUNFLAG is zero,
	BEQ ERRWE2	;the UFRMAT is correct, else
	GETTYP FBODY	;get UFRMAT from FBODY pointer
	TAX
	BEQ TPLINE
	BNE ERRWE3	;(Always)
ERRWE2:	LDA UFRMAT
	BEQ TPLINE
ERRWE3:	CDR ENDPTR,FPTR
	JSR TPLINF
	JMP ERWE1B
TPLINE:	TPCHR SPACE
	LDX #LINPTR
	JSR TYPE1
ERWE1B:	PRTSTR ERRM1
	JSR TPLEVN
	PRTSTR ERRM3
	LDY #SFTOKN	;Frame UFUN (CURTOK) index
	LDA (FRAME),Y
	STA ATMNAM
	INY
	LDA (FRAME),Y
	STA ATMNAM+1
	LDX #ATMNAM
	JSR TYPE
ERR1:	JSR BREAK1
	LDX #$00
	STX RUNFLG	;Reset Run-flag
	LDA ERRNUM
	STA ERRNM1	;Save ERRNUM
	STX ERRNUM	;then reset it
	CMP #XZAP
	BEQ PPTTP	;XZAP is fatal, always return to toplevel
	CMP #XBRK
	BEQ ENTLOP	;A Pause, go to Break-loop handler
	LDA BRKSP+1
	BEQ PPTTP	;Non-fatal, not inside break-loop, go to toplevel
	JMP BRKENT	;Non-fatal, inside a Break-loop, so re-enter it
PPTTP:	LDA FRAME+1
	BEQ PPTT2	;No frames to pop
;Go back through all stack frames restoring bindings
PPTTP1:	JSR UNWFRM	;(Sets Z when FRAME = 0)
	BNE PPTTP1	;Continue through all frames
PPTT2:	LDA #$00
	STA LEVNUM	;Reset Level-number
	STA LEVNUM+1
	STA LEVNUM+2
	LDA ERRNM1
	CMP #XZAP
	BNE JTOP	;Return to toplevel if not XZAP
	LDA ERRY
	CMP #XNSTRN
	BNE JTOP	;or if XZAP but not XNSTRN
	SETV VSP,VPDLBA	;Error was "out-of-nodes", so reset VPDL
	JSR GARCOL	;Do a garbage collect
	CMPV NNODES,NODLIM	;See if still over the node limit
	BCC JTOP	;No, return to toplevel
NWARN:	PRTSTR WRNMSG	;Print "Please delete something"
JTOP:	JMP TOPLOP
;Enter a pause-loop.
ENTLOP:	PUSH ULNEND	;Push the state where the PAUSE occurred
	PUSH FBODY
	PUSH FPTR
	PUSHB RUNFLG
	PUSH TOKPTR
	PUSHB OTPUTN
	PUSHB IFLEVL
	PUSHB EXPOUT
	PUSHB STPFLG
	PUSHB UFRMAT	;That should be enough
	PUSH BRKSP	;Now push the Break-frame SP for the last level
	MOV BRKSP,SP	;and compute the new one

;Pause-loop error handler.
BRKLOP:	LDA COFLAG
	BEQ BRKLIN
	DEC COFLAG	;Nonzero means break out, so reset it
	POP BRKSP	;Exit this Break-loop, pop back last one
	POPB UFRMAT	;Pop back the state at which the PAUSE occurred
	POPB STPFLG
	POPB EXPOUT
	POPB IFLEVL
	POPB OTPUTN
	POP TOKPTR
	POPB RUNFLG
	POP FPTR
	POP FBODY
	POP ULNEND	;And that's the state
	JMP EVLINE	;Go back where you came from
BRKLIN:	TPCHR 'L	;Type an "L"
	JSR TPLEVN	;Type the level-number
	LDA #QPRMPT
	JSR PGTLIN	;Type the prompt and read a line
	LDX #ILINE
	JSR PRSLIN		;Parse the line
	MOV TOKPTR,ILINE	;Set token-pointer to beginning of line
	LDA #$00
	STA UFRMAT	;Command line is typecode List
	STA FBODY+1	;Indicate that we're now at toplevel of a break-loop
	PUSHA BRKLOP
	JMP EVLINE	;Evaluate the line and return to BRKLOP

;Re-enter a Break-loop from a non-fatal error. Restores successive stack frames of
;all frames above BRKSP, and resets SP to top of break-frame.
BRKENT:	COMP FRAME,BRKSP	;See if FRAME is smaller than BRKSP
	BCC BRKDN	;Yes, done
	JSR UNWFRM
	JMP BRKENT
BRKDN:	MOV SP,BRKSP	;Bindings restored, restore SP
	JMP BRKLIN	;Re-enter the break-loop

;Type the Level-number (3 bytes).
TPLEVN:	LDY #LEVNUM
	JSR XYTON1
	LDA #$00
	STA NARG1+3
	JMP TPBFIX

;Unwind a frame. Should set Z when FRAME = 0.
UNWFRM:	JSR RSTBND	;Restore bindings
	LDY #SFXFRM	;XFRAME index
	LDA (FRAME),Y
	STA XFRAME
	INY
	LDA (FRAME),Y
	STA XFRAME+1
	LDY #SFFRAM	;Previous-frame index
	LDA (FRAME),Y
	TAX
	INY
	LDA (FRAME),Y
	STA FRAME+1
	STX FRAME
	RTS

;SYSBUG prints an error message and exits to the Monitor.
; Associated error codes are:
;	1 - Bad EVAL typecode
;	2 - V-Primitive not found
;	3 - Dispatch typecode out of range
;	4 - Bad CONS typecode
;	5 - Bad TYPE typecode
;	6 - Music code bug
;	7 - Bad GCOLL typecode (Sfun)

SYSBUG:	STA $02		;Error code
	PLA
	STA $01		;Store calling point in locations $00,$01
	PLA
	STA $00
	TXA
	PHA
	TYA
	PHA
	JSR RSTIO
	PRTSTR LBUG1	;Print "LOGO BUG!"
	PLA		;we can re-enter from monitor at POPJ
	TAY
	PLA
	TAX
	LDA $02
SBPT:	BRK
	NOP
	NOP
	JSR SETUP
	JMP POPJ
.PAGE
.SBTTL	Garbage Collector

;	Local variable block:
INDEX	=TEMPN3		;Indexes oblist and soblist
NODE	=TEMPN		;Node to mark
TYPPTR	=TEMPNH		;TYPACS shares
NARGS1	=ANSN1		;No. of ufun bindings
GCPROT	=ANSN1		;G.C-protected variable pointer
FRMPTR	=TEMPN3		;Frame pointer
BINDNG	=TEMPN4		;Binding ptr.
FBDPTR	=TEMPNH		;FBODY ptr. from pre-stack-frame info.
LINE	=TEMPN1		;Line ptr. for fpacked ufuns
LINEND	=TEMPN2		;Line-end ptr. for fpacked ufuns
NXTNOD	=TEMPN3		;Oblist index
LSTNOD	=TEMPN4		;Other Oblist index

;(Subrs: SWAPT1,SWAPT2,MARK,MARKX,MARKA,CLRMRK,TYPACS,PUSH,POP,TSTSTK)
GARCOL:	INC GCFLAG		;Indicate garbage collect
	JSR SWAPT1		;Swap out p.z. vars.
;Mark the soblist objects.
	MOV INDEX,SOBLST
GCLP2:	LDX #INDEX
	JSR MARK
	INC4 INDEX
	COMP INDEX,SOBTOP
	BNE GCLP2
;Mark the VPDL objects.
	SETV INDEX,VPDLBA
GCLP3:	COMP INDEX,VSP
	BEQ GCLP3A
	CAR NODE,INDEX
	JSR MARKX
	DEC2 INDEX
	JMP GCLP3
GCLP3A:	LDA FRAME+1
	BEQ GCOL1
	STA FRMPTR+1
	LDA FRAME
	STA FRMPTR
GCLP4:	SEC
	LDA FRMPTR
	SBC #SFFBDY	;Gets the Fbody of the previous frame (Subtraction)
	STA FBDPTR
	LDA FRMPTR+1
	SBC #$00
	STA FBDPTR+1
	CAR NODE,FBDPTR	;Indexes the pre-stack-frame FBODY pointer
	JSR MARKX	;Mark the Fbody
	LDY #SFNRGS	;Frame NUMBER-BINDINGS index
	LDA (FRMPTR),Y
	BEQ GCLP5E
	STA NARGS1
	CLC
	LDA FRMPTR
	ADC #SFBNDS	;Binding pairs frame index
	STA BINDNG	;BINDNG points to a binding pair
	LDA FRMPTR+1
	ADC #$00
	STA BINDNG+1
GCLP5:	LDY #$02
	LDA (BINDNG),Y	;See if it's a fun/frame pair
	ROR A
	BCS GCLP5A
	CAR NODE,BINDNG	;Nope, get value and mark
	JSR MARKX
GCLP5A:	INC4 BINDNG
	DEC NARGS1
	BNE GCLP5
GCLP5E:	LDY #SFFRAM	;Previous-frame index
	LDA (FRMPTR),Y
	TAX
	INY
	LDA (FRMPTR),Y
	STA FRMPTR+1
	STX FRMPTR
	BNE GCLP4
GCOL1:	LDA #GCVST	;Mark all G.C.-protected variables
	STA GCPROT
GCOL1L:	LDX GCPROT
	JSR MARK
	INC GCPROT
	INC GCPROT
	LDA GCPROT
	CMP #GCVND+2
	BNE GCOL1L
	LDX #SIZE1
	LDY #AREA1
	JSR MARKA
	LDX #SIZE2
	LDY #AREA2
	JSR MARKA
;Re-link oblist around truly worthless atoms (all marking should be
; done at this point)
	MOV NXTNOD,OBLIST
GCOB1:	LDA NXTNOD+1
	BEQ GCOBD
	CARNXT LSTNOD,NXTNOD	;Mark the value, ufun, and pname of each node
	CARNXT NODE,LSTNOD	;Value
	JSR MARKX
	CAR NODE,LSTNOD		;Ufun
	JSR MARKX
	CDR NODE,LSTNOD		;Pname
	JSR MARKX
	JMP GCOB1
GCOBD:	MOV NXTNOD,OBLIST
GCOBD1:	JSR CKOBEL		;First find a marked or nonempty oblist element (and mark it)
	BCS GCOBF		;Returns carry set if NXTNOD atom marked or nonempty
	CDRME NXTNOD		;Not this one, try next
	JMP GCOBD1
GCOBF:	MOV OBLIST,LSTNOD,NXTNOD	;Just found the first worthy atom, it starts the oblist
GCOBF1:	CDR NXTNOD,LSTNOD	;Try a new node
GCOBF2:	LDA NXTNOD+1
	BEQ GCOBE		;End of Oblist, done
	JSR CKOBEL		;See if this (NXTNOD) atom is worthy
	BCC GCOBN
	MOV LSTNOD,NXTNOD	;This one's okay, so advance pointers
	JMP GCOBF1
GCOBN:	CDRME NXTNOD		;Not okay, advance to next node
	RPLACD LSTNOD,NXTNOD	;And re-link around the bad node
	JMP GCOBF2
;Sweep phase
GCOBE:	LDA #$00
	STA FRLIST+1
	STA NNODES
	STA NNODES+1
	SETV NODE,NODBEG
	SETV TYPPTR,NODEND
GCLP6:	LDY #$00
	LDA (TYPPTR),Y
	ROL A		;Get mark bit
	BCS GCLP6C
	RPLACD NODE,FRLIST
	MOV FRLIST,NODE
	BCC GCLP6F	;(Always)
GCLP6C:	INC1 NNODES
GCLP6F:	INC4 NODE
	INC1 TYPPTR
	CMPV TYPPTR,TYPEND
	BNE GCLP6
	DEC CGFLAG		;Clear garbage collect indicator
	JSR CLRMRK		;Clear the mark array
	JMP SWAPT2		;Swap back temps and exit

CLRMRK:	SETV TYPPTR,NODEND
	LDY #$00
GCLP1:	LDA (TYPPTR),Y
	AND #$7F	;Set Mark bit to 0 (reap)
	STA (TYPPTR),Y
	INC1 TYPPTR
	CMPV TYPPTR,TYPEND
	BNE GCLP1
	RTS

	;Local variable block:
FUN	=TEMPN1
VALUE	=TEMPN1

;Return carry set if NXTNOD atom is not worthless.
CKOBEL:	CAR NODE,NXTNOD
	MOV TYPPTR,NODE
	JSR TYPACS		;See if the node is marked
	ASL A
	BCS CKOBOK		;Yes
	LDX #NODE
	LDA #FUN
	JSR GETFUN		;See if it's got a ufun
	BNE CKOBKM		;Has a ufun, it's ok, mark it
	LDY #NODE
	LDX #VALUE
	JSR GETVAL		;See if it's got a value
	BNE CKOBKM		;Has a value, mark it
	CLC			;No value, waste the sucker
	RTS
CKOBKM:	MOV TYPPTR,NODE		;Mark the node itself
	JSR TYPACS
	ORA #$80
	STA (TYPPTR),Y
CKOBOK:	MOV TYPPTR,NXTNOD	;Always mark the oblist's pointer if object is ok
	JSR TYPACS
	ORA #$80
	STA (TYPPTR),Y
	SEC
CKORTS:	RTS

;	Local variable block:
SIZE	=TEMPN		;Size of contiguous area (in nodes)

MARKA:	GETX SIZE
	GETY TYPPTR
	JSR TYPACS	;Returns with Y=$00.
MRKAW:	LDA SIZE+1
	ORA SIZE
	BEQ CKORTS
	LDA (TYPPTR),Y
	ORA #$80	;Mark the node
	STA (TYPPTR),Y
	INC1 TYPPTR
	DEC2 SIZE
	JMP MRKAW
.PAGE
MARK:	GETX NODE
MARKX:	LDY #$02	;Push $02nn for delimiting toplevel
	JSR PUSH
MRKW:	LDA NODE+1	;See if we're through (node is $02nn)
	CMP #$02
	BEQ CKORTS	;Yes, all done
	LDA NODE+1	;Else see if it's nil or novalue
	CMP #$02
	BCC MRKW3
	STA TYPPTR+1
	LDA NODE
	STA TYPPTR
	JSR TYPACS	;Access typecode byte
	ASL A		;Shift mark bit into carry
	BCC MRKW2
MRKW3:	POP NODE	;Marked, pop next node off stack and continue
	JMP MRKW
MRKW2:	PHA		;Not marked, save typecode through TSTSTK
	JSR TSTSTK	;Test for stack collision
	PLA		;Retrieve typecode
	SEC
	ROR A		;Set the mark bit
	STA (TYPPTR),Y
	AND #$7F	;Get the raw typecode
	TYPDSP GCLTAB	;Dispatch to correct routine

;Garbage collector typecode dispatches
GCLTAB:	.ADDR MRKCL	;List
	.ADDR MRKCL	;Atom
	.ADDR MRKCT	;String
	.ADDR MRKW3	;Fix
	.ADDR MRKW3	;Flo
	.ADDR SYSBG7	;Sfun
	.ADDR MRKCU	;Ufun
	.ADDR MRKCS	;Satom
	.ADDR MRKCP	;Fpack
	.ADDR MRKCL	;Qatom
	.ADDR MRKCL	;Datom
	.ADDR MRKCL	;Latom

SYSBG7:	LDA #$07
	JMP SYSBUG
MRKCT:	LDA NODE
	AND #$FC	;This string might be a funny-pname
	STA NODE
MRKCF:	LDY #$02
MRKCN:	LDA (NODE),Y
	TAX
	INY
	LDA (NODE),Y
	BEQ MRKW3
	TAY
MRKCF1:	JSR PUSH
	JMP MRKW3
MRKCS:	LDY #$00
	BEQ MRKCN	;(Always)
MRKCL:	LDA NODE
	AND #$FC
	STA NODE
	LDY #$00
	LDA (NODE),Y
	TAX
	INY
	LDA (NODE),Y
	BEQ MRKCF
	TAY
MRKCL1:	JSR PUSH
	JMP MRKCF
MRKCU:	CLC		;Ufun
	LDA NODE
	ADC #$04
	STA TYPPTR
	LDA NODE+1
	ADC #$00
	STA TYPPTR+1
	JSR TYPACS	;Access typecode of next contiguous node
	ORA #$80
	STA (TYPPTR),Y	;Mark the next node
	BNE MRKCF	;(Always) Recursively mark the cdr of the ufun node
MRKCP:	CAR LINE,NODE	;LINE is line pointer
MRKCP1:	CDR LINEND,NODE	;LINEND is next-line pointer or 0
	CLC
	LDA NODE
	ADC #$02
	STA TYPPTR
	LDA NODE+1
	ADC #$00
	STA TYPPTR+1
	JSR TYPACS
	ORA #$80
	STA (TYPPTR),Y
	LDA LINEND+1
	BNE MRKPX
	JMP MRKW3
MRKPX:	COMP LINE,LINEND
	BEQ MRKPXE
	MOV TYPPTR,LINE
	JSR TYPACS
	ORA #$80
	STA (TYPPTR),Y
	LDA (LINE),Y
	TAX
	INY
	LDA (LINE),Y
	TAY
	JSR PUSH
	JSR TSTSTK
	INC2 LINE
	JMP MRKPX
MRKPXE:	INC2 NODE
	JMP MRKCP1

CLMK4:	STA MARK4+1
CLMK3:	STA MARK3+1
CLMK2:	STA MARK2+1
	STA MARK1+1
	RTS

SWAPT1:	LDY #TMPEND-TMPSTT+1
	LDX #TMPSTT
SWPLP1:	LDA $00,X
	STA TMPTAB,Y
	INX
	DEY
	BPL SWPLP1
	RTS

SWAPT2:	LDY #TMPEND-TMPSTT+1
	LDX #TMPSTT
SWPLP2:	LDA TMPTAB,Y
	STA $00,X
	INX
	DEY
	BPL SWPLP2
	RTS
.PAGE
.SBTTL	Output Routines

;	Local variable block:
TPLVLP	=TEMPN4		;Zero = print outer brackets on lists
NOSPCE	=TEMPN4+1	;Nonzero = print space before next element
THING	=TEMPN5		;Pointer to thing to print
FUNPNM	=ANSN		;Nonzero = Funny-pname atom
CHARS	=TEMPNH		;String characters

;(Subrs: PUSH,GETTYP,POP,TPCHR,TPBFIX,TYPFLO,TSTPOL,PUSHB,POPB,ATMPNM)
TYPE1:	LDA #$01
	BNE TYPE	;(Always)
TYPE0:	LDA #$00
TYPE:	STA TPLVLP
	GETX THING
	PUSHA LTRTS1
PRTHNG:	GETTYP THING
	TYPDSP LTPTAB

;TYPE typecode dispatch table
LTPTAB:	.ADDR LTPLS	;List
	.ADDR LTPA	;Atom
	.ADDR LTPSTR	;String
	.ADDR LTPF	;Fix
	.ADDR LTPF1	;Flo
	.ADDR SYSBG2	;Sfun
	.ADDR SYSBG2	;Ufun
	.ADDR LTPS	;Satom
	.ADDR SYSBG2	;Fpack
	.ADDR LTPQ	;Qatom
	.ADDR LTPD	;Datom
	.ADDR LTPL	;Latom

SYSBG2:	LDA #$05
	JMP SYSBUG

LTPFX:	LDY #$00
	LDX #$03
LTYPL1:	LDA (THING),Y
	STA NARG1,Y
	INY
	DEX
	BPL LTYPL1
	RTS

LTPSTR:	JSR TYPSTR
	JMP POPJ
LTPQ:	LDA #'"
	BNE LTPD1	;(Always)
LTPD:	LDA #':
LTPD1:	JSR TPCHR
	JSR LTPQDL
	JMP POPJ
LTPA:	JSR TYPATM
	JMP POPJ
LTPS:	JSR TPSATM
	JMP POPJ
LTPL:	JSR LTPQDL
	TPCHR ':
	JMP POPJ
LTPF:	JSR LTPFX
	JSR TPBFIX
	JMP POPJ
LTPF1:	JSR LTPFX
	JSR TYPFLO
	JMP POPJ
LTPLS:	LDA #$01
	STA NOSPCE
	LDA TPLVLP
	BNE PLSTLP
	TPCHR '[
PLSTLP:	JSR TSTPOL
	LDA THING+1
	BNE PLLP1
	LDA TPLVLP
	BNE PLLP2
	STA NOSPCE	;Print a space after Sublists
	TPCHR ']
PLLP2:	JMP POPJ
PLLP1:	LDA NOSPCE
	BNE PLLP1A
	TPCHR SPACE
PLLP1A:	PUSH THING
	PUSHB TPLVLP
	LDA #$00
	STA TPLVLP
	STA NOSPCE
	CARME THING
	PUSHA TPP1
	JMP PRTHNG
TPP1:	POPB TPLVLP
	POP THING
	CDRME THING
	JMP PLSTLP
.PAGE
TYPSTR:	LDA THING
	TAX
	AND #$FC
	STA THING
	TXA
	AND #$01
	BPL TPATM1	;(Always)

;Find out if the Q,D, or Latom is an Atom or Satom and type it.
LTPQDL:	LDA THING
	AND #$FC
	STA THING
	GETTYP THING
	CMP #SATOM
	BEQ TPSATM

TYPATM:	LDX #THING
	LDY #THING
	JSR ATMPNM	;Returns with A=1 if Funny-pname
	TAX		;Set bits for BEQ
TPATM1:	STA FUNPNM
	BEQ TPATMW
	LDA OTPFLG
	BNE TPATMW	;If OTPFLG set, don't print funny-pname quote
	TPCHR QUOTE
TPATMW:	LDA THING+1
	BEQ TPTMWE
	CARNXT CHARS,THING
	LDA CHARS
	BEQ TPTMWE
	JSR TPCHR
	LDA CHARS+1
	BEQ TPTMWE
	JSR TPCHR
	JMP TPATMW
TPTMWE:	LDA FUNPNM
	TAX
	BEQ LTRTS1
	LDA OTPFLG
	BNE LTRTS1	;Don't type funny-pname quote if OTPFLG set
	TPCHR QUOTE
LTRTS1:	RTS
.PAGE
TPSATM:	CDRME THING
	LDY #PRMNAM
TPSTMW:	DATRAM		;Enable ghost-memory
	LDA (THING),Y
	BEQ LTPRTS
	JSR TPCHR
	INY
	BNE TPSTMW	;(Always)
LTPRTS:	NODRAM		;Disable ghost-memory
LTRTS2:	RTS
.PAGE
;(Subrs: CVFIX,PRTPDL)
;Types a two-byte fixnum, always positive.
TYPFIX:	JSR CVFIX	;Get string on PDL
	JMP PRTPDL	;Type string on PDL

;(Subrs: CVBFIX,PRTPDL)
;Types a four-byte fixnum in NARG1.
TPBFIX:	JSR CVBFIX	;Get string on PDL
	JMP PRTPDL	;Type string on PDL

;(Subrs: CVFLO,PRTPDL)
;Type the flonum in NARG1.
TYPFLO:	JSR CVFLO	;Get String on PDL

;(Subrs: POPB,TPCHR)
;Type the string on the PDL, CCOUNT holds character count. Must be a small string!
PRTPDL:	LDA #$00
	PHA		;Push stop indicator
PRTPL1:	JSR POPB	;Pop chars off PDL and onto stack
	PHA
	DEC CCOUNT
	BNE PRTPL1
PRTPL2:	PLA		;Pop chars from stack and type them
	BEQ LTRTS2	;until stop indicator popped
	JSR TPCHR
	JMP PRTPL2
.PAGE
;	Local variable block:
OBPTR	=TEMPN8		;Oblist ptr.
SOBPTR	=TEMPN6		;Soblist ptr.
NAME	=TEMPN6		;Name ptr.
VALUE	=TEMPN7		;Value ptr.
BUFFLG	=ANSN3		;Print-to-buffer flag

;(Subrs: PONAME)
PONAMS:	STA BUFFLG		;Nonzero if printing to buffer
	MOV OBPTR,OBLIST	;OBPTR is OBLIST pointer
PONW1:	LDA OBPTR+1
	BEQ PONW1E	;See if done
	CARNXT NAME,OBPTR
	JSR PONAME	;Print the name and value
	JMP PONW1
PONW1E:	MOV SOBPTR,SOBLST	;SOBPTR is SOBLIST pointer
PONW2:	COMP SOBPTR,SOBTOP	;See if done
	BEQ LTRTS2
	JSR PONAME	;Print the name and value
	INC4 SOBPTR
	JMP PONW2

;(Subrs: GETVAL,TYPE,TPCHR,PRTSTR,BREAK1,CHKWRD)
PONAME:	LDX #VALUE
	LDY #NAME
	JSR GETVAL
	BEQ LTRTS2	;Skip if novalue
	LDA BUFFLG
	BNE PON1B	;Use MAKE if printing to buffer
	TPCHR '"
	LDX #NAME
	JSR TYPE
	PRTSTR PNMSG1	;"IS "
	LDX #VALUE
	JSR TYPE0
	JMP BREAK1
PON1B:	PRTSTR PNMSG2	;'MAKE "'
	LDX #NAME
	JSR TYPE
	TPCHR SPACE
	LDX #VALUE
	JSR CHKWRD	;Get typecode and check for word
	BNE PON1C
	TPCHR '"
PON1E:	LDX #VALUE
	JSR TYPE0
	JMP BREAK1
PON1C:	CMP #FIX
	BEQ PON1G
	CMP #FLO
	BNE PON1E
	LDY #$01	;A flonum, see if it's negative
	LDA (VALUE),Y
	BPL PON1E
PON1F:	TPCHR '(	;It's negative, enclose it in ()'s
	LDX #VALUE
	JSR TYPE
	TPCHR ')
	JMP BREAK1
PON1G:	LDY #$03	;A fixnum, see if it's negative
	LDA (VALUE),Y
	BPL PON1E
	BMI PON1F	;(Always)
.PAGE
;	Local variable block:
FUNPTR	=TEMPX2		;Function ptr.
ATMPTR	=ANSN1		;Function atom ptr.
FUN	=TEMPN6		;Function body
LINE	=TEMPN8		;Function line ptr.
LINPTR	=TEMPN8		;Fpacked line ptr. (shared: TPLINF)
ENDPTR	=TEMPX2		;Fpacked line-end ptr. (shared: TPLINF)
TOKEN	=TEMPX1		;Token pointer
FULL	=ANSN4		;Zero = print only title lines

;(Subrs: POFUNX)
POFUNS:	STA FULL
	MOV FUNPTR,OBLIST	;FUNPTR is OBLIST pointer
POFNSW:	LDY #$03
	LDA (FUNPTR),Y
	PHA
	DEY
	LDA (FUNPTR),Y
	PHA
	DEY
	LDA (FUNPTR),Y
	TAX
	DEY
	LDA (FUNPTR),Y
	STA FUNPTR
	STX FUNPTR+1
	LDX #FUNPTR
	JSR POFUNX
	PLA
	STA FUNPTR
	PLA
	STA FUNPTR+1
	BNE POFNSW
	RTS
.PAGE
;(Subrs: GETFUN,PRTSTR,TYPE,GETTYP,NEXLIN,TPCHR,TYPE1,BREAK1,TPLINF)
;Entered with FULL in A: 1=Title and Body; 0=Title only; Atom ptr. in X
POFUN:	STA FULL
POFUNX:	STX ATMPTR	;Save ATMPTR (Entry point for POFUNS)
	LDA #FUN
	JSR GETFUN
	BEQ PFNRTS
	PRTSTR TOMSG	;"TO "
	LDX ATMPTR	;Retrieve ATMPTR
	JSR TYPE	;Print the name
	CDRME FUN
	GETTYP FUN
	CMP #LIST
	BEQ POTXTL
	JMP POTXTF
;Ufun is List format.
POTXTL:	JSR NEXLIN	;Get arglist
	TPCHR SPACE
	LDX #LINE
	JSR TYPE1	;Type the arglist
	JSR BREAK1
	LDA FULL
	BEQ PFNRTS
;Type the body
PTXLX:	LDA FUN+1
	BEQ PTXEND
	JSR NEXLIN	;Get the next line
	TPCHR SPACE
	LDX #LINE	;Type the line
	JSR TYPE1
	JSR BREAK1
	JMP PTXLX
PTXEND:	PRTSTR ENDMSG	;Type "END"
PFNRTS:	RTS
;Ufun is packed format.
POTXTF:	CAR LINPTR,FUN	;Get arglist
	CDR ENDPTR,FUN
	INC2 FUN	;Advance ptr. to first line
	JSR TPLINF	;Type the arglist
	JSR BREAK1
	LDA FULL
	BNE PTXFX
	RTS
;Type the body.
PTXFX:	LDA ENDPTR+1
	BEQ PTXEND
	STA LINPTR+1	;New line
	LDA ENDPTR
	STA LINPTR
	CDR ENDPTR,FUN	;Get endpointer
	INC2 FUN	;Advance ptr. to next line
	LDA ENDPTR+1
	BEQ PTXEND
	JSR TPLINF	;Type the line
	JSR BREAK1
	JMP PTXFX

;Get next line from list-format ufun.
NEXLIN:	CARNXT LINE,FUN
	RTS
.PAGE
.SBTTL	Arithmetic Routines
.SBTTL		Floating Point Routines

;	Local variable block:
EXP	=ANSN		;Exponent
SIGN	=ANSN		;Mantissa sign
NARG0	=TEMPNH		;Temp. number storage

FLOTN2:	JSR SWAP
	JSR FLOTN1
	JMP SWAP

FLOTN1:	LDA NARG1+3
	BPL XFLOAT
	LDX #NARG1
	JSR COMPL
	JSR XFLOAT
	JMP FCOMPL

XFLOAT:	LDA #$9E
	STA EXP		;Shift counter (exponent)
XFLT1:	LDA NARG1+3
	CMP #$C0
	BMI XFLT2
	ASL NARG1
	ROL NARG1+1	;Rotate left to left-justify
	ROL NARG1+2
	ROL NARG1+3
	DEC EXP
	BNE XFLT1	;Stop if exponent is zero
XFLT2:	LDA NARG1+1	;Reverse LSB, MSB for floating pt. format
	LDY NARG1+3
	STY NARG1+1
	STA NARG1+3
	LDA EXP
	STA NARG1	;Put in exponent
	RTS
.PAGE
;Add M1 and M2, result in M1.
ADD:	CLC		;Clear carry
	LDX #$02	;Index for 3-byte add
ADD1:	LDA NARG1+1,X
	ADC NARG2+1,X	;Add a byte of Mant2 to Mant1
	STA NARG1+1,X
	DEX		;Index to next more signif. byte
	BPL ADD1	;Loop until done
	RTS		;Return

;Makes X/M1 and X/M2 positive. Returns with LSB of SIGN equal to XOR of
;signs of original numbers. Copies (positive) mantissa of X/M1 into E.
MD1:	ASL SIGN	;Clear LSB of Sign
	JSR ABSWAP	;Abs. val. of M1, then swap with M2
ABSWAP:	BIT NARG1+1	;Is Mant1 negative...
	BPL ABSWP1	;No, swap with Mant2 and return
	JSR FCOMPL	;Yes, complement it.
	INC SIGN	;Increment sign, complementing LSB
ABSWP1:	SEC		;Set carry for return to MUL/DIV

;Swaps X/M1 and X/M2 and leaves a copy of M1 in E.
SWAP:	LDX #$04	;Index for 4-byte swap
SWAP1:	STY NARG0-1,X
	LDA NARG1-1,X	;Swap a byte of Exp/Mant1 with
	LDY NARG2-1,X	;Exp/Mant2 and leave a copy of
	STY NARG1-1,X	;Mant1 in E (3 bytes). (E+3 is destroyed.)
	STA NARG2-1,X
	DEX		;Advance index to next byte
	BNE SWAP1	;Loop until done
	RTS		;Return

;Normalize M1 and X1 to standard format floating pt. (left-justified mantissa,
;exponent tells how much so).
NORM1:	LDA NARG1+1	;High-order Mant1 byte
	CMP #$C0	;Are Upper two bits unequal...
	BMI RTS1	;Yes, return with Mant1 normalized.
	DEC NARG1	;Decrement X1
	ASL NARG1+3
	ROL NARG1+2	;Shift Mant1 (3 bytes) left
	ROL NARG1+1
FNORM:	LDA NARG1	;Is Exp1 zero...
	BNE NORM1	;No, continue normalizing.
RTS1:	RTS		;Return

;Floating pt. add. X/M1 becomes X/M2 + X/M1.
FADD:	JSR FADD1
	CLC		;If it returns, then no overflow
	RTS

FSUB:	JSR SWAP	;It does M2-M1, we want M1-M2
FSUBX:	JSR FSUB1
	CLC
	RTS

FMUL:	JSR FMULT
	CLC
	RTS

FDIV:	JSR SWAP	;It does M2/M1, we want M1/M2.
FDIVX:	JSR FDIVD
	CLC
	RTS
.PAGE
;Floating pt. subtract. X/M1 becomes X/M2 - X/M1.
FSUB1:	JSR FCOMPL	;Complement Mant1, clears carry unless 0
SWPALN:	JSR ALNSWP	;Right shift Mant1 or swap
FADD1:	LDA NARG2
	CMP NARG1	;Compare Exp1 with Exp2
	BNE SWPALN	;If unequal, swap addends or align mantissas
	JSR ADD		;Add aligned mantissas
ADDEND:	BVC FNORM	;No overflow, normalize result
	BVS RTLOG	;(Always) Overflow - shift M1 right, carry into Sign

;Either swap mantissas (for another alignment) or do an alignment. Carry bit
;resultants determine which to do each time over.
ALNSWP:	BCC SWAP	;Swap if carry clear, else shift right arith.
RTAR:	LDA NARG1+1	;Sign of M1 into carry for
	ASL A		;right arith. shift
RTLOG:	INC NARG1	;Increment X1 to adjust for right shift
	BEQ OVFL	;Exp1 out of range
RTLOG1:	LDX #$FA	;Index for 6 byte right shift
ROR1:	ROR NARG0+3,X	;(M1 and E must be contiguous)
	INX		;Next byte of shift
	BNE ROR1	;Loop until done
	RTS		;Return

;Floating pt. multiply. X/M1 becomes X/M1 * X/M2.
FMULT:	JSR MD1		;Absolute value of Mant1, Mant2.
	ADC NARG1	;Add Exp1 to Exp2 for product Exp
	JSR MD2		;Check product exp. and prepare for multiply
	CLC		;Clear carry for first bit
FMUL1:	JSR RTLOG1	;M1 and E right (product and multiplier)
	BCC FMUL2	;If carry clear, skip partial product
	JSR ADD		;Add multiplicand to product
FMUL2:	DEY		;Next multiply iteration
	BPL FMUL1	;Loop until done
MDEND:	LSR SIGN	;Test Sign LSB
NORMX:	BCC FNORM	;If even, normalize product, else complement

;Complement the mantissa of M1.
FCOMPL:	SEC		;Set carry for subtract
	LDX #$03	;Index for 3-byte subtract
COMPL1:	LDA #$00	;Clear A
	SBC NARG1,X	;Subtract byte of Exp1
	STA NARG1,X	;Restore it
	DEX		;Next more significant byte
	BNE COMPL1	;Loop until done
	BEQ ADDEND	;(Always)

;Floating pt. multiply. X/M1 becomes X/M1 / X/M2.
FDIVD:	JSR MD1		;Take abs. val. of Mant1, Mant2
	SBC NARG1	;Subtract Exp1 from Exp2
	JSR MD2		;Save as quotient exp.
DIV1:	SEC		;Set carry for subtract
	LDX #$02	;Index for 3-byte subtraction
DIV2:	LDA NARG2+1,X
	SBC NARG0,X	;Subtract a byte of E from Mant2
	PHA		;Save on stack
	DEX		;Next more significant byte
	BPL DIV2	;Loop until done
	LDX #$FD	;Index for 3-byte conditional move
DIV3:	PLA		;Pull byte of difference off stack
	BCC DIV4	;If M2 smaller than E then don't restore M2
	STA NARG2+4,X
DIV4:	INX		;Next less significant byte
	BNE DIV3	;Loop until done
	ROL NARG1+3
	ROL NARG1+2	;Roll quotient left, carry into LSB
	ROL NARG1+1
	ASL NARG2+3
	ROL NARG2+2	;Shift dividend left
	ROL NARG2+1
	BCS OVFL	;Overflow is due to un-normalized divisor
	DEY		;Next divide iteration
	BNE DIV1	;Loop until done 23 iterations
	BEQ MDEND	;(Always) Normalize quotient and correct sign

;Prepare for multiply or divide, check result's exponent.
MD2:	STX NARG1+3
	STX NARG1+2	;Clear Mant1 (3 bytes) for MUL/DIV
	STX NARG1+1
	BCS OVCHK	;If calculation set carry, check for overflow
	BMI MD3		;If negative, then no underflow
	PLA		;Pop one return level (undeflow, answer is 0)
	PLA
	BCC NORMX	;Clear X1 and return
MD3:	EOR #$80	;Complement sign bit of exponent
	STA NARG1	;Store it.
	LDY #$17	;Count 24. (MUL) or 23. (DIV) iterations
	RTS		;Return

OVCHK:	BPL MD3		;If positive exponent, then no overflow.
	PLA
	PLA		;Pop past MD2 call

OVFL:	PLA	;Overflow, pop past first function call
	PLA
	SEC	;Indicate overflow
	RTS
.PAGE
;Changes the argument in (X) from Flonum to four-byte Fixnum (rounds).
;Error XOFL if not possible.
RNDN2:	JSR SWAP	;Pos or neg, only NARG2
	JSR RNDN1
	JMP SWAP

RNDN1:	LDA NARG1+1	;is it positive
	BPL XINTN1	;yes
	JSR FCOMPL	;for negatives: negate --> convert --> negate
	JSR XINTN1
	LDX #NARG1
	JMP COMPL

XINTN1:	LDX #$03
SINTL:	LDA NARG2,X
	PHA		;Save NARG2
	LDA RNDUP,X	;Get 0.5 into NARG2
	STA NARG2,X
	DEX
	BPL SINTL
	JSR FADD
	JSR INTN1
FFIXD:	LDX #$FC
FFIXDL:	PLA		;Restore NARG2
	STA NARG2+4,X
	INX
	BMI FFIXDL
	RTS

RNDUP:	$7F	;Floating-point constant, 0.5
	$40
	$00
	$00

;Pos or neg, only NARG1
INTN1:	LDA NARG1
	BMI FFIXP
	LDA #$00	;Negative exponent gives zero result
	STA NARG1
	STA NARG1+1
	STA NARG1+2
	STA NARG1+3
FFIXR:	RTS
FFIXP:	CMP #$9F
	BCS OVFL1	;Exponent too high, overflow
	LDA NARG1+1
	BPL FFIXP1
	JSR FCOMPL
	JSR FFIXP1
	LDX #NARG1
	JMP COMPL
FFIXP1:	LDA NARG1
	STA EXP
	LDA #$00
	STA NARG1	;Init LSB to zero
	LDA NARG1+1
	LDY NARG1+3	;Switch LSB, MSB for fixnum format
	STY NARG1+1
	STA NARG1+3
FFIX1:	LDA EXP
	CMP #$9E
	BEQ FFIXR	;Done when Exp=30. (4 bytes, binary point two places in)
	LSR NARG1+3
	ROR NARG1+2	;Rotate to right-justify
	ROR NARG1+1
	ROR NARG1
	INC EXP
	BNE FFIX1	;(Always)
OVFL1:	ERROR XOFL
.PAGE
;	Local variable block:
PRODCT	=TEMPN		;Partial product (shared: IMULT)
SAVNG1	=TEMPN2		;NARG1 save

;(Subrs: XN1TOY,XYTON1,FDIV,INTN1,FADD,IMULT,FLOTN1,XYTON2,FSUB)
;This routine expects a flonum in NARG1, bashes it to between 0 and 360
;and puts the result in NARG1.
MOD360:	LDY #SAVNG1
	JSR XN1TOY		;Save NARG1
	LDA NARG1+1
	BMI M3NEG		;check for neg
	JSR M3SUB		;NARG1 := NARG1 - 360
	LDA NARG1+1
	BMI M3ADD		;if we got a neg result, just restore (0 < x < 360)
	JSR M3SUB
	LDA NARG1+1		;restore adds 360 to NARG1
	BPL M3BASH
	BMI M3ADD		;(Always) add 360. back to NARG1
M3NEG:	JSR M3ADD		;get NARG1 + 360. in NARG1
	LDA NARG1+1
	BPL M3RTS
M3BASH:	LDY #SAVNG1		;restore NARG1
	JSR XYTON1
	JSR SET360
	JSR FDIV
	JSR INTN1		;integerize result
	LDA #$68
	STA NARG2		;putting a fixnum 360 in
	LDX #$01		;NARG2
	STX NARG2+1
	DEX
	STX NARG2+2
	STX NARG2+3
	JSR IMULT		;fixnum multiply, PRODCT := NARG1*NARG2
	LDY #PRODCT
	JSR XYTON1		;NARG1 := PRODCT
	JSR FLOTN1		;floating-pointify NARG1
	LDY #SAVNG1
	JSR XYTON2		;original arg in NARG2
	JSR FSUBX
	LDA NARG1+1		;if still negative, just add 360
	BPL M3RTS
M3ADD:	JSR SET360
	JMP FADD		;floating add of NARG2 and NARG1

M3SUB:	JSR SET360
	JMP FSUB		;floating point sub of NARG2 and NARG1

SET360:	SETNUM NARG2,F360
	RTS

;	Constants:
F180:	$87	;Floating-point constant, 180.0
	$5A
	$00
	$00

F360:	$88	;Floating-point constant, 360.0
	$5A
	$00
	$00
.PAGE
.SBTTL		Fixnum Routines

;	Local variable block:
SIGN	=ANSN		;Sign of product

;Complement (negate) a fixnum.
COMPL:	LDY #$03
	SEC
CMPL1:	LDA $00,X
	EOR #$FF	;Complement
	ADC #$00	;and increment.
	STA $00,X
	INX
	DEY
	BPL CMPL1
M3RTS:	RTS

;	Local variable block:
PRODCT	=TEMPN		;Partial product (shared: MOD360,SPROD,SRANDM)

;(Subrs: COMPL,CKN2ZR)
;PRODCT gets NARG1 * NARG2.
IMULT:	LDA NARG1+3	;(Bashes NARG2)
	EOR NARG2+3
	STA SIGN
	LDA NARG1+3
	BPL SPRD1
	LDX #NARG1
	JSR COMPL
SPRD1:	LDA NARG2+3
	BPL SPRD2
	LDX #NARG2
	JSR COMPL
SPRD2:	LDA #$00
	LDX #$03
SPRDL1:	STA PRODCT,X
	DEX
	BPL SPRDL1
	LDY #$20	;Bit counter
MUL2:	LSR NARG2+3
	ROR NARG2+2
	ROR NARG2+1
	ROR NARG2
	BCC MUL4
	CLC
	LDX #$FC
SPRDL2:	LDA PRODCT+4,X	;Add multiplicand (NARG1) to partial product
	ADC NARG1+4,X
	STA PRODCT+4,X
	INX
	BMI SPRDL2
	TAX
	BMI IMULOV
MUL4:	ASL NARG1
	ROL NARG1+1
	ROL NARG1+2
	ROL NARG1+3
	BPL MUL4A
	JSR CKN2ZR	;Sig. bit dropped from NARG1, so bit counter better be 0
	BNE IMULOV	;It isn't, error
	BEQ MULEND	;(Always) It is, so we're done
MUL4A:	DEY
	BNE MUL2	;Next bit
MULEND:	LDA SIGN
	BPL SPRD3
	LDX #PRODCT
	JSR COMPL
SPRD3:	CLC
	RTS
IMULOV:	SEC
SDVD4:	RTS
.PAGE
;(Subrs: COMPL,XDIVID)
IDIVID:	LDA #$00
	STA SIGN
	LDA NARG1+3
	BPL SDVD2
	LDX #NARG1
	JSR COMPL
	INC SIGN
SDVD2:	LDA NARG2+3
	BPL SDVD3
	LDX #NARG2
	JSR COMPL
	INC SIGN
SDVD3:	JSR XDIVID	;NARG2 is divisor, NARG1 is dividend, then quotient
	LSR SIGN
	BEQ SDVD4
	LDX #NARG1
	JMP COMPL
.PAGE
;(Subrs: CKN2ZR,XN1TOY,XYTON1)
;Divides NARG1 by vA.
XDVDX:	JSR SETN2A

;	Local variable block:
BITHLD	=TEMPN		;Bitholder
QUOTNT	=A1L		;Quotient

;Fast and clean fixnum division routine, assumes positive numbers.
;Dividend in NARG1, divisor in NARG2.
;NARG1 becomes quotient, low byte of remainder in vA, full remainder in NARG2.
XDIVID:	JSR CKN2ZR
	BNE XDVD1
	ERROR XDBZ
XDVD1:	LDA #$00		;Zero temp. quotient
	LDX #$03
XDLP1:	STA QUOTNT,X
	STA BITHLD,X
	DEX
	BPL XDLP1
	INC BITHLD		;Initialize bitholder
NORM:	ASL BITHLD		;Normalize the bitholder...
	ROL BITHLD+1
	ROL BITHLD+2
	ROL BITHLD+3
	ASL NARG2
	ROL NARG2+1		;and the divisor
	ROL NARG2+2
	ROL NARG2+3
	BPL NORM		;to the left side
	BMI SHFT		;(Always)
SHFTX:	PLA			;(Discard intermediate result)
SHFT:	LSR BITHLD+3		;Back 'em off one
	ROR BITHLD+2
	ROR BITHLD+1
	ROR BITHLD
	LSR NARG2+3
	ROR NARG2+2
	ROR NARG2+1
	ROR NARG2
	LDX #$03
XDLP2:	LDA BITHLD,X
	BNE DV2			;If bitholder is zero, done
	DEX
	BPL XDLP2
	BMI DONE		;(Always)
DV2:	SEC			;Subtract divisor from dividend
	LDA NARG1
	SBC NARG2
	PHA
	LDA NARG1+1
	SBC NARG2+1
	TAX
	LDA NARG1+2
	SBC NARG2+2
	TAY
	LDA NARG1+3
	SBC NARG2+3
	BCC SHFTX		;If borrow, don't save remainder
	STA NARG1+3		;or add to result
	STY NARG1+2
	STX NARG1+1
	PLA
	STA NARG1
	CLC
	LDX #$FC
XDLP3:	LDA QUOTNT+4,X		;Add bitholder to result
	ADC BITHLD+4,X
	STA QUOTNT+4,X
	INX
	BMI XDLP3
	BPL SHFT		;(Always)
DONE:	LDY #NARG2
	JSR XN1TOY	;Put remainder in NARG2
	LDY #QUOTNT
	JSR XYTON1
	LDA NARG2
	RTS
.PAGE
.SBTTL	Screen Editor

;	Local variable block:
FUN	=TEMPN1		;Function ptr.
CHRSAV	=A2L		;Temp. character
ADRESS	=A2L		;Dispatch address
EPNT1	=A4L		;Alt. EPOINT
CV1	=A2L		;Alt. CV
CH1	=A2L+1		;Alt. CH
ENDBF1	=A1L		;Index starting at end of buffer, going in reverse
LINCNT	=A2L		;Line counter
CHRCNT	=A2L+1		;Char. counter
CHCNT1	=A1L		;Alt. char. counter
CHCNT2	=A3L		;Alt. Alt. char. counter
LINES	=A1L+1		;No. of lines before point
LINDIF	=A3L		;Lines difference
EPNT2	=TEMPX3		;Alt. EPOINT
SLSTC1	=A3L		;Alt. SLSTCH
OFFSET	=TEMPN8		;Offset from beginning of current line
ENDLIN	=TEMPN7		;End of next line

SEDIT:	LDA EXPOUT
	BNE EDTER1
	JSR ZAPGR
	LDA INPFLG
	BNE ERXETL	;Error if already editing with screen editor
EDTST1:	LDA TOKPTR+1
	BNE EDTST2
	JMP EDTNON
EDTST2:	JSR GETRG1	;car ARG1 from TOKPTR
	GETTYP ARG1
	CMP #SATOM
	BEQ EDTST4
	CMP #ATOM
	BEQ EDTST3
	CMP #STRING
	BNE EDTER5
	TXA
	JSR INTRNX	;Make a new atom
EDTST3:	LDX #ARG1
	LDA #FUN
	JSR GETFUN
	BNE EDTOLD
	JMP EDTNEW
EDTOLD:	JSR EDTIN1
	LDA #$01
	LDX #ARG1
	JSR POFUN	;store function text in EDBUF
	JMP EDTXA1
ERXETL:	ERROR XETL,CURTOK
EDTER1:	LDA #EDIT&$FF
	LDX #EDIT^
ERXNP1:	STA TEMPX2
	STX TEMPX2+1
	ERROR XNOP,TEMPX2
EDTER5:	JMP ERXWT1
EDTST4:	LDA ARG1
	LDX ARG1+1
	CMP #ALL&$FF
	BNE EDTS4A
	CPX #ALL^
	BNE EDTS4A
	JSR EDTIN1
	JSR POFUNS
	JMP EDTX2
EDTS4A:	CMP #PROCS&$FF
	BNE EDTS4B
	CPX #PROCS^
	BNE EDTS4B
	JSR EDTIN1
	JSR POFUNS
	JMP EDTXA1
EDTS4B:	CMP #NAMES&$FF
	BNE EDTER4
	CPX #NAMES^
	BNE EDTER4
	JSR EDTIN1
EDTX2:	LDA #$01
	JSR PONAMS
EDTXA1:	JSR EDTIN2
	JMP EDTIN3
EDTER4:	ERROR XUBL,ARG1		;"Can't edit"

EDTNON:	CMPV ENDBUF,EDBUF
	BNE SEDT1
	JSR EDTIN1
	JSR EDTIN2
	JMP EDTIN3
SEDT1:	JSR EDTX1
EDTIN3:	JSR EDSPBF	;call edit-display-buffer
	JMP EDTLOP	;call text and command handling loop

EDTNEW:	JSR EDTIN1
	PRTSTR TOMSG
	LDX #ARG1
	JSR TYPE
EDTNLP:	LDX #TOKPTR
	JSR TFKADV
	LDA TOKPTR+1
	BEQ EDTN2
	JSR GETRG1	;car ARG1 from TOKPTR
	TPCHR SPACE
	LDX #ARG1
	JSR TYPE0
	JMP EDTNLP
EDTN2:	JSR BREAK1
	MOV EPNT1,EPOINT
	JSR EDTIN2
	JSR EDPBUF
	JMP EDTLOP

EDTIN2:	JSR RSTIO	;detach the print-to-buffer routine
	MOV ENDBUF,EPOINT	;save end of buffer
	JSR PNTBEG
EDTX1:	LDA #$17	;Window bottom to allow display of
	STA WNDBTM	;"MIT Logo Editor" crock
	SETV SFSTCH,EDBUF	;store location of first char displayed on screen
	JSR TOPSCR
	JSR CENTER	;redisplay about point
	JMP EDTNYM	;print editor name

EDTIN1:	SETV OTPDEV,EDOUT	;location of edbuf output routine (for TPCHR)
	JMP PNTBEG	;initialize point for INSERT

EDTNYM:	JSR SETINV	;print the "MIT Logo Screen Editor" thing on
	LDA CH		;the bottom line in reversed characters.
	PHA
	LDA CV		;save current screen location
	PHA
	LDA BASLIN	;save old baseline
	PHA
	LDA BASLIN+1
	PHA
	LDA #$00
	STA CH		;far left
	LDA #$23
	STA CV		;bottom of screen
	LDA #$D0	;slight speed bum -- we know we want
	STA BASLIN	;the bottom of the screen, so instead
	LDA #$07	;of calculating it via BCALC, we load
	STA BASLIN+1	;it up.
	PRTSTR EDTMSG
	PLA
	STA BASLIN+1
	PLA
	STA BASLIN
	PLA
	STA CV
	PLA
	STA CH
	JMP SETNRM	;No more inverted characters

ZAPGR:	LDA BUFOWN
	BPL ZPBRTS
	LDA #$01
	STA BUFOWN		;Editor owns the buffer now
	SETV ENDBUF,EDBUF	;Buffer is empty
	JMP RESETT
.PAGE
;increment the point (EPOINT,EPOINT+1).
INCPNT:	INC1 EPOINT
ZPBRTS:	RTS

;decrement the point.
DECPNT:	DEC1 EPOINT
	RTS

;set the point to the beginning of the buffer.

PNTBEG:	SETV EPOINT,EDBUF
	RTS

;place cursor at top of screen

TOPSCR:	LDA #$00	;cursor at top of screen
	STA BASLIN	;baseline for top of screen
	STA CH
	STA CV
	LDA #$04
	STA BASLIN+1
NULOUT:	RTS

;output char in AC to EDBUF at point. Increments point. Does NOT
;increment last-char-in-buffer pointer. Returns without modifying if
;at end of buffer.

EDOUT:	TAX		;save char
	CMPV EPOINT,EBFEND	;Are we at end of edit buffer...
	BCS NULOUT	;if so, quit
	LDY #$00
	TXA
	STA (EPOINT),Y	;if not, store char and inc pointer
	JMP INCPNT

.PAGE
;top level loop in the editor; listens for characters; outputs them to
;the screen and the edit buffer; accepts commands and has them
;processed.

EDTLOP:	JSR RDKEY	;get char from kbd
	STA CHRSAV	;save it
	LDA #<EDTLOP-1>^	;push return address
	PHA
	LDA #<EDTLOP-1>&$FF
	PHA
	LDY #$00
EDSLOP:	LDA EDSTBL,Y	;dispatch off command table
	BEQ EDSLOS	;0 signifies end of table
	CMP CHRSAV
	BEQ EDSWIN
	INY
	INY		;go for next entry
	INY
	BNE EDSLOP	;always, unless table is too big
EDSWIN:	INY
	LDA EDSTBL,Y
	STA ADRESS
	INY
	LDA EDSTBL,Y
	STA ADRESS+1
	JMP (ADRESS)

EDSTBL:	$01
	.ADDR BEGLIN
	$02
	.ADDR PRVSCR
	$03
	.ADDR EDDONE
	$04
	.ADDR DELETE
	$05
	.ADDR EOLLIN
	$06
	.ADDR NXTSCR
	$07
	.ADDR EDQUIT
	$08
	.ADDR BCKCHR
	$0B
	.ADDR KILLIN
	$0C
	.ADDR CENTER
	$0D
	.ADDR DINSRT
	$0E
	.ADDR NXTLIN
	$0F
	.ADDR OPLINE
	$10
	.ADDR PRVLIN
	$15
	.ADDR FORCHR
	$1B
	.ADDR RUBOUT
	$00

EDSLOS:	LDA CHRSAV
	CMP #SPACE	;lowest legal character
	BCS DINSR2	;not a command, insert it.
	JMP BELL
DINSRT:	LDA #CR		;A2L is bashed by now; so get a CR in AC.
DINSR2:	JMP INSERT

EDQUIT:	JSR RESETT
	ERROR XZAP,XSTOP

;EDDONE will read the editor-defined code back into Logo.

EDDONE:	PLA
	PLA		;get EDTLOP return addr off stack
	LDY #$00
	LDA #CR		;Carriage return at end, just in case none there
	CMP (ENDBUF),Y
	BEQ EDDNCR
	STA (ENDBUF),Y
	INC1 ENDBUF
EDDNCR:	JSR PNTBEG	;point to beginning
	JSR RESETT	;Clear the screen
	PRTSTR WAITM
	PUSHA EDDONX
	JMP EVLBUF
EDDONX:	JSR PNTBEG
	JMP POPJ

;this function will display the buffer beginning at the point on the
;screen, beginning at CH, CV (should be consistent with BASLIN). It
;will stop if there is nothing more in the buffer, or when there is no
;more room on the screen. Updates SLSTCH (last-char-displayed
;pointer). EDSPBF will check as it displays for the point and will set
;CV, CH accordingly. If you would like it to turn on the cursor at a
;place other than the point, set EPNT1 to it and call EDPBUF.

EDSPBF:	MOV EPNT1,EPOINT
EDPBUF:	LDA CV
	STA CV1
	LDA CH
	STA CH1
EDSPLP:	COMP EPOINT,ENDBUF
	BCS EDPRTS	;quit if no more in buffer
	LDY #$00
	LDA (EPOINT),Y	;get char
	CMP #CR
	BEQ EDSPCR
	LDX CH
	INX
	CPX WNDWTH	;if at end of line and next char is a
	BCC EDPCHR	;cr, then no !. otherwise yes.
	PHA
	LDA #'!
	JSR SCROUT	;output continuation line char
	PLA
	LDX CV		;when we output the continuation char SCROUT
	JMP EDPCR1	;inc'ed CV, so don't now.
EDOPCR:	LDX CV
	INX		;if we output the CR (or char on next line),
EDPCR1:	CPX WNDBTM	;will we have exceeded the screen length...
	BCS EDRTS2	;yes, quit while we're not ahead
EDPCHR:	LDX EPOINT
	CPX EPNT1
	BNE EDPCH2
	LDX EPOINT+1	;if we're at point then set CV, CH so we can
	CPX EPNT1+1	;display the cursor in the right place when
	BNE EDPCH2	;we come back
	LDX CV
	STX CV1
	LDX CH
	STX CH1
EDPCH2:	JSR SCROUT	;output char; back for more
	JSR INCPNT
	JMP EDSPLP
EDSPCR:	PHA
	JSR CLREOL
	PLA
	JMP EDOPCR
EDPRTS:	JSR CLREOP
EDRTS2:	LDX EPOINT
	CPX EPNT1
	BNE EDPRS2
	LDX EPOINT+1	;if we're at point then set CV, CH so we can
	CPX EPNT1+1	;display the cursor in the right place when
	BNE EDPRS2	;we come back
	LDX CV
	STX CV1
	LDX CH
	STX CH1
EDPRS2:	MOV SLSTCH,EPOINT	;point is now at location after last char on
	LDA CH1
	STA CH
	LDA CV1
	STA CV
	JSR BCALCA		;have CV in AC already
	MOV EPOINT,EPNT1	;screen; store in char-after-last-char-pointer
ZRTS1:	RTS

SCROUT:	CMP #CR
	BEQ SCRCR
	LDY CH
	ORA #$80
	STA (BASLIN),Y
	INC CH
	LDA CH
	CMP WNDWTH
	BCC ZRTS1
SCROT2:	LDA #$00
	STA CH
	INC CV
	JMP BCALC
SCRCR:	JSR CLREOL
	JMP SCROT2
.PAGE
;Command subroutines. It is the responsibility of a command to do its
;own redisplay, leave CH and CV indicating the position of the point
;on the screen, and the appropriate value in BASLIN before returning
;to EDTLOP. The cursor will be turned on by EDTLOP, however.
;Any command (that does anything) must update the database. The
;database consists of the edit buffer (EDBUF), whose contents must be
;updated by insertions/deletions; the point (EPOINT,EPOINT+1); the
;location in the EDBUF of the first character displayed on the screen
;(SFSTCH,SFSTCH+1); the location in the EDBUF AFTER the last character
;displayed on the screen (SLSTCH,SLSTCH+1), and the location AFTER
;the last character in the EDBUF (ENDBUF,ENDBUF+1).

INSERT:	PHA		;save char
	JSR MVDOWN	;move the buffer (starting at point) down one.
	PLA
	PHA
	JSR EDOUT	;put the char in the edit buffer
	PLA
	CMP #CR
	BEQ INSRCR
	LDX CH
	INX
	CPX WNDWTH	;Are we at end of line...
	BCC INSRT2	;no, output straight
	PHA
	LDA #'!		;output a line continuation char.
	JSR SCROUT
	PLA		;recover char
	LDX CV		;if we output the line cont. char then SCROUT
	JMP INSRT0	;has inc'ed CV, so don't do it again.
INSRT1:	LDX CV
	INX
INSRT0:	CPX WNDBTM	;are we at end of screen...
	BNE INSRT2
	JMP CENTER	;^L type redisplay
INSRT2:	JSR COUT	;output char to screen
	JMP EDSPBF	;redisplay buffer from point down
INSRCR:	PHA
	JSR CLREOL
	PLA
	JMP INSRT1

;move the contents of the edit buffer after point down one until
;reaching end of buffer contents (NOT end of buffer). Increments end
;of buffer contents pointer. Bashes AC,Y.

MVDOWN:	LDA ENDBUF
	SEC
	SBC #$01
	STA ENDBF1
	LDA ENDBUF+1
	SBC #$00
	STA ENDBF1+1
	LDY #$01
MVLOOP:	COMP ENDBF1,EPOINT
	BCC MVRTS
	DEY
	LDA (ENDBF1),Y
	INY
	STA (ENDBF1),Y
	DEC1 ENDBF1
	JMP MVLOOP
MVRTS:	INC1 ENDBUF
	RTS

;RDSPNT repositions the text on the screen around the point. The AC
;should hold the number of lines before the point one wants redisplay
;to start from. So, for ^L it should hold 12; for M-V it should hold
;23. RDSPNT will get confused if given a buffer that contains more
;than 256*39 contiguous chars without a carriage-return in them,
;because we have a one-bite physical line counter. You change it. Sets
;first and last char on screen pointers.

RDSPNT:	STA LINES	;save # lines wanted before point
	BNE RDSPT1	;do nothing if zero
RDSPT0:	RTS
RDSPT1:	LDA EPOINT
	CMP #EDBUF&$FF	;at bob?
	BNE RDSP15
	LDA EPOINT+1
	CMP #EDBUF^
	BEQ RDSPT0	;yo, quit
RDSP15:	LDY #$00
	STY LINCNT	;zero the line counter
	MOV EPNT1,EPOINT	;save the point
	LDA EPOINT
	SEC
	SBC CH		;get to beginning of this screen line
	STA EPOINT
	BCS RDSPT2
	DEC EPOINT+1
RDSPT2:	STY CHCNT2	;zero the char counter for SRCHBK
	STY CHCNT2+1
	JSR DECPNT	;Now, find out what the char at the end
	LDA (EPOINT),Y	;of the previous line is, because if it's
	PHA		;a CR, the line can be $28 long.
	JSR SRCHBK	;search back for after a CR or bob
	TAX		;save the indicator (0 -> bob; #$0D -> CR)
	PLA		;was the last char in this (previous) line a CR?
	CMP #$0D
	BEQ RDSPCR
RDSPT3:	LDA CHCNT2+1	;nope, see if it's bigger than $27
	BNE RDSPLS
	LDA CHCNT2
	CMP #$27
	BCC RDSPWN	;smaller(!), we can stop
	BEQ RDSPWN
RDSPLS:	LDA CHCNT2	;otw we have to count the screen lines in this
	SEC		;text line.
	SBC #$27
RDSPL1:	STA CHCNT2
	BCS RDSPL2
	DEC CHCNT2+1
RDSPL2:	INC LINCNT
	JMP RDSPT3
RDSPCR:	LDA CHCNT2+1
	BNE RDSPC2
	LDA CHCNT2	;this is the CR case from above
	CMP #$28
	BCC RDSPWN
	BEQ RDSPWN
RDSPC2: LDA CHCNT2
	SEC
	SBC #$28
	JMP RDSPL1
RDSPWN: INC LINCNT	;we have at least one line every time
	LDA LINCNT
	CMP LINES	;now do we have enough lines?
	BCS CNTDWN	;maybe, let's see
	TXA		;see if at beginning of buffer
	BEQ RDSPDN	;we were at bob, quit
	BNE RDSPT2	;we weren't, go fer more
CNTDWN: LDA LINCNT
	CMP LINES
	BEQ RDSPDN	;yep, done
	DEC LINCNT	;too many, count down
	LDA EPOINT
	CLC
	ADC #$27
	STA EPOINT
	BCC CNTDWN
	INC EPOINT+1
	JMP CNTDWN
RDSPDN:	JSR TOPSCR
	MOV SFSTCH, EPOINT
	JMP EDPBUF

;redisplay screen around point. Sets CV, CH, BASLIN,
;first-char-on-screen, char-after-last-char-on-screen.
CENTER:	LDA #$0C	;#$0C = 12.
	JMP RDSPNT	;redisplay for point on 13th line

;NXTSCR moves to the next screenful in the buffer and displays it,
;setting point to the character after the last char on the previous
;screenful (thus it will be at top of screen).

NXTSCR:	COMP EPOINT,ENDBUF
	BEQ ECMPLN
	COMP SLSTCH,ENDBUF
	BNE NXTSC2		;move to eob if on last screen
	MOV EPNT1,SLSTCH
	JMP EDPBUF		;EDPBUF will recover EPNT1 as point.
NXTSC2:	LDY #$00
	LDA (SLSTCH),Y
	CMP #CR
	BNE NXTSC3
	INC1 SLSTCH
NXTSC3:	MOV EPOINT,SFSTCH,SLSTCH	;point, first char on screen
	JSR TOPSCR
	JMP EDSPBF		;display

;PRVSCR moves to the previous screenful in the buffer, leaves point at
;the top.

PRVSCR:	CMPV EPOINT,EDBUF
	BNE PRVSC1
ECMPLN:	JMP BELL
PRVSC1:	CMPV SFSTCH,EDBUF
	BNE PRVSC2
	JSR PNTBEG
	JSR TOPSCR
	JMP EDSPBF
PRVSC2:	MOV EPOINT,SFSTCH	;make point be beginning of screen
	LDA #$17	;redisplay 23 lines before it
	JSR RDSPNT
	MOV EPOINT,SFSTCH	;make point be beginning of screen
	JMP TOPSCR	;cursor at top of screen

;RUBOUT deletes char behind cursor, redisplays.
RUBOUT:	CMPV EPOINT,EDBUF
	BEQ RCMPLN	;are we at beginning...
	BCC RCMPLN	;or before
	JSR BCKCHR
	JMP DELET2
RCMPLN:	JMP BELL	;complain if so.

;DELETE deletes char under cursor, redisplays.
DELETE:	COMP EPOINT,ENDBUF
	BCS RCMPLN	;if at buffer end, complain
DELET2:	LDA #$01	;only moving stuff up one place
	STA CHCNT1
	LDA #$00
	STA LINES
DELET3:	LDA #CHCNT1
	JSR MOVEUP
	JMP EDSPBF

;MOVEUP takes the location of an arg in AC,Y and moves the argth char
;after the point into the point, the arg+1th into the point+1, and so
;on until the buffer end is reached. Then it sets the end of buffer
;pointer to the point before restoring it. Better make plenty damned
;sure that MOVEUP is used carefully so that end-of-buffer-pointer
;doesn't become too small.
MOVEUP:	TAX
	LDA EPOINT	;we are saving point to restore it later
	PHA
	STA EPNT2	;in EPNT2 for source
	LDA EPOINT+1
	PHA
	STA EPNT2+1
	LDA $00,X
	CLC
	ADC EPNT2	;and add to point for source address
	STA EPNT2
	LDA $01,X
	ADC EPNT2+1
	STA EPNT2+1
MVULOP:	COMP EPNT2,ENDBUF	;are we looking at end-of-buffer...
	BCS MVURTS	;past or end, return
	LDY #$00
	LDA (EPNT2),Y	;source
	STA (EPOINT),Y	;dest
	JSR INCPNT	;inc dest
	INC EPNT2	;inc source
	BNE MVULOP
	INC EPNT2+1
	BNE MVULOP	;(Always)
MVURTS:	MOV ENDBUF,EPOINT	;new end-of-buffer
	PLA
	STA EPOINT+1
	PLA
	STA EPOINT	;recover point
	RTS		;that's all, folks

;FORCHR moves forward one character, bells if at end of buffer.
FORCHR: COMP EPOINT,ENDBUF
	BCS FCMPLN	;if at buffer end complain
	LDA SLSTCH	;!!**CROCK**!! THIS CAUSES REDISPLAY WHEN
	SEC		;YOU TRY FORWARD ON NEXT TO LAST CHAR IN
	SBC #$01	;BUFFER!!! SHOULD CHECK CV,CH OR (EPOINT).
	STA SLSTC1		;see if on last char on screen
	LDA SLSTCH+1
	SBC #$00
	STA SLSTC1+1
	COMP SLSTC1,EPOINT
	BNE FORCH3
	JSR INCPNT	;yes, inc point and center
	JMP CENTER
FCMPLN:	JMP BELL
FORCH3:	LDY #$00
	LDA (EPOINT),Y
	CMP #CR
	BNE FORCH5
FORCH4:	STY CH		;if on a CR, we know we're not at end of
	INC CV		;screen by now, so zero CH, inc CV.
	JSR BCALC	;must calc new baseline
	JMP INCPNT
FORCH5:	LDA CH
	CMP #$26	;at right before "!"
	BEQ FORCH4
	INC CH
	JMP INCPNT
.PAGE
;BCKCHR backs CH and CV up, decs point. No redisplay, unless page
;boundary crossed, or previous char is a CR. Don't call it unless the
;database is consistent; i.e., CV and CH are at the point on the
;screen.
BCKCHR:	CMPV EPOINT,EDBUF	;check if at beginning of buffer
	BEQ FCMPLN	;yes, complain, quit
	BCC FCMPLN
	JSR DECPNT
	LDA CV		;see if we're at beginning of screen
	ORA CH
	BNE BACK3
	JMP CENTER	;center
BACK3:	LDA CH
	BNE BACK5
	LDY #$00
	LDA (EPOINT),Y
	CMP #CR
	BNE BACK4
	MOV EPNT1,EPOINT	;when we back over a cr we call
	MOV EPOINT,SFSTCH	;EDPBUF so as to save space (by
	JSR TOPSCR		;not having code here to count down a line)
	JMP EDPBUF		;don't need redisplay, space bum
BACK4:	DEC CV
	LDA #$26	;just before the "!"
	STA CH
	JSR BCALC
	RTS
BACK5:	DEC CH
	RTS
.PAGE
;algorithm for previous line: search back for a CR, counting chars. if
;you hit bob, complain. got it? save its addr, as well as offset.
;search back for another one, or bob. add last offset to this addr. gt
;than other addr? good, make other addr current. if not, make this
;addr current. redisplay point to turn on cursor, or RDSPNT if off
;screen.

PRVLIN:	LDY #$00
	STY CHCNT2
	STY CHCNT2+1
	MOV EPNT1,EPOINT
	JSR SRCHBK
	CMP #CR
	BNE PCMPLN	;PCMPLN recovers point from A4 and complains
	MOV NARG2,CHCNT2	;saving offset into line in NARG2
	MOV NARG2+2,EPOINT	;saving beginning of line in NARG2+2
	JSR DECPNT	;do a DECPNT to get on previous line
	JSR SRCHBK
	LDA EPOINT
	CLC
	ADC NARG2
	STA NARG2
	LDA EPOINT+1
	ADC NARG2+1	;have beginning of prev line + offset of
	STA NARG2+1	;this'n in NARG2
	CMP NARG2+3	;compare to beginning of this line
	BCC PRVLN2	;strictly less than, use NARG2
	BNE PRVLN3	;gt or =, use NARG2+2-1
	LDA NARG2
	CMP NARG2+2
	BCC PRVLN2	;less, use NARG2
PRVLN3:	LDA NARG2+2
	SEC
	SBC #$01
	STA EPNT1
	LDA NARG2+3
	SBC #$00
	STA EPNT1+1	;for recovery by EDPBUF
	JMP PVRDSP
PRVLN2:	MOV EPNT1,NARG2
PVRDSP:	COMP EPNT1,SFSTCH	;before first char on screen?
	BCC PRDSPT	;yo, RDSPNT
	JSR TOPSCR
	MOV EPOINT,SFSTCH
	JMP EDPBUF
PRDSPT:	MOV EPOINT,EPNT1
	JMP CENTER
PCMPLN:	MOV EPOINT,EPNT1
	JMP BELL

;SRCHBK returns with a CR in AC if found CR; with 0 in AC if found
;bob. Incs CHCNT2 as it goes so it can be used as a counter.
;does right thing (this is a kludge) if on a CR initially - ignores
;it, but counts it.

SRCHBK:	LDY #$00
SRCBK1:	CMPV EPOINT,EDBUF
	BEQ SRCBK4
SRCBK2:	JSR DECPNT
	INC1 CHCNT2
SRCBK3:	LDA (EPOINT),Y
	CMP #CR		;got a CR?
	BEQ SRCBK5	;y, done
	CMPV EPOINT,EDBUF	;at bob?
	BNE SRCBK2	;no, loop
SRCBK4:	TYA		;y, done
	RTS
SRCBK5:	JSR INCPNT
	DEC1 CHCNT2
	LDA #CR
	RTS
.PAGE
;algorithm for NXTLIN is as follows: get offset to beginning of your
;current line, and save in, say, OFFSET. try to find a CR, if you win,
;save it in NARG2. If you run into eob, complain. If you find a CR,
;try to find another or eob. Save the address of either in ENDLIN. Add
;NARG2 + 1 to OFFSET and save in OFFSET. If OFFSET is less than end of
;next line, i.e., ENDLIN, make point OFFSET, otherwise make point
;ENDLIN.

NXTLIN:	LDY #$00
	STY CHCNT2
	STY CHCNT2		;zero char counter
	MOV EPNT1,EPOINT	;for recovery in the event of disaster
	JSR SRCHBK		;get offset to beginning of this line in A2
	MOV OFFSET,CHCNT2	;save
	JSR SRCHFD		;try to find a CR
	CMP #CR
	BNE NCMPLN		;complain if none
	MOV NARG2,EPOINT	;save location of end of current line
	JSR INCPNT		;inc point to get onto beginning of next line
	JSR SRCHFD
	MOV ENDLIN,EPOINT
	LDA NARG2
	CLC
	ADC #$01
	STA NARG2	;get beginning of next line in NARG2
	LDA NARG2+1
	ADC #$00
	STA NARG2+1
	LDA NARG2
	CLC
	ADC OFFSET	;add offset to beginning of next line
	STA OFFSET
	LDA NARG2+1
	ADC OFFSET+1
	STA OFFSET+1
	COMP OFFSET,ENDLIN	;is beginning of next line + offset <
	BCC NXTLN2	;end of next line? y, use first
	MOV EPNT1,ENDLIN	;n, use end of next
	JMP NXRDSP
NXTLN2:	MOV EPNT1,OFFSET
NXRDSP:	COMP EPNT1,SLSTCH	;this makes redisplay occur sometimes when it
	BCS NRDSPT	;doesn't have to. too bad. vanilla if on screen.
	JSR TOPSCR
	MOV EPOINT,SFSTCH
	JMP EDPBUF
NRDSPT:	MOV EPOINT,EPNT1
	JMP CENTER
NCMPLN:	MOV EPOINT,EPNT1
	JMP BELL

;SRCHFD returns with a CR in AC if found CR; with 0 in AC if found
;eob.

SRCHFD:	LDY #$00
SRCHF1:	COMP EPOINT,ENDBUF
	BEQ SRCHF3
	LDA (EPOINT),Y
	CMP #CR
	BEQ SRCHF4	;found a CR, return
	JSR INCPNT
	JMP SRCHF1
SRCHF3:	TYA
SRCHF4:	RTS
.PAGE
;EOLLIN moves point to end of current line, or to end of buffer.
EOLLIN:	LDY #$00
	LDA (EPOINT),Y
	CMP #$0D	;if on a cr, do nothing
	BEQ EOLRTS
	LDA EPOINT
	CMP ENDBUF
	BNE EOLLN2
	LDA EPOINT+1
	CMP ENDBUF+1	;if at end-of-buffer, do nothing.
	BEQ EOLRTS
EOLLN2:	JSR SRCHFD	;otherwise, move point forward to a CR or eob.
	MOV EPNT1, EPOINT
	JMP NXRDSP	;redisplay as from next line
EOLRTS:	RTS
.PAGE
;BEGLIN moves point to beginning of current line, or to beginning of
;buffer.
BEGLIN:	LDA EPOINT
	CMP #EDBUF&$FF
	BNE BEGLN2
	LDA EPOINT+1
	CMP EDBUF^	;if at beginning of buffer
	BEQ EOLRTS	;do nothing
BEGLN2:	MOV EPNT1,EPOINT
	LDA EPNT1
	SEC
	SBC #$01
	STA EPNT1
	LDA EPNT1+1
	SBC #$00
	STA EPNT1+1
	LDY #$00
	LDA (EPNT1),Y
	CMP #$0D	;if on a cr
	BEQ EOLRTS	;do nothing
	JSR SRCHBK	;OTW, find beginning of line or buffer
	MOV EPNT1,EPOINT	;and redisplay as from previous line.
	JMP PVRDSP
.PAGE
;KILLIN deletes all the characters from the point to the end of the
;line. If the point is already at the end of the line, it deletes the
;CR; if the point is already at the end of the buffer, it complains.
KILLIN: LDA EPOINT
	CMP ENDBUF
	BNE KILLN2
	LDA EPOINT+1
	CMP ENDBUF+1	;if at end of buffer, complain
	BEQ KCMPLN
KILLN2:	LDY #$00
	LDA (EPOINT),Y
	CMP #$0D	;if on a cr, delete it
	BNE KILLN3
	JMP DELETE
KILLN3:	MOV EPNT1,EPOINT	;save point
	JSR SRCHFD
	LDA EPOINT
	SEC
	SBC EPNT1	;figger out how many chars to delete
	STA CHCNT1
	LDA EPOINT+1
	SBC EPNT1+1
	STA LINES
	MOV EPOINT,EPNT1
	JMP DELET3	;save three bytes -- return as from delete
KCMPLN: JMP BELL
.PAGE
;OPLINE inserts a CR at point w/o inc'ing point.
OPLINE:	CMPV EPOINT,EBFEND	;Are we at end of edit buffer...
	BCS OPRTS	;if so, quit
	JSR MVDOWN
	LDY #$00
	LDA #CR
	STA (EPOINT),Y	;insert CR at point
	JMP EDSPBF	;redisplay from here down.
OPRTS:	RTS
.PAGE
.SBTTL	File System

;DOS error routine vectors here
DERROR:	TXA		;Error code is in X from DOS
	NODRAM		;Re-enable high RAM
	AND #$0F	;Only bottom four bits matter
	TAX
	LDA DSRTBL,X	;Get error code
	JMP ERROR

;DOS Error number table
DSRTBL:	.BYTE XIOR	;0 - I/O error
	.BYTE XIOR	;1 - I/O error
	.BYTE XRNG	;2 - Range error
	.BYTE XRNG	;3 - Range error
	.BYTE XWTP	;4 - Write protected disk
	.BYTE XIOR	;5 - I/O error
	.BYTE XFNF	;6 - File not found
	.BYTE XIOR	;7 - I/O error
	.BYTE XIOR	;8 - I/O error
	.BYTE XDKF	;9 - Disk full
	.BYTE XLKF	;A - File locked
	.BYTE XSYN	;B - Syntax error
	.BYTE XIOR	;C - I/O error
	.BYTE XIOR	;D - I/O error
	.BYTE XIOR	;E - I/O error
	.BYTE XIOR	;F - I/O error
.PAGE
;Save a file.
DBSAVE:	LDA #$02
	STA DOSLEN	;Give DOS the file length ($2002)
	LDA #$20
	STA DOSLEN+1
	LDA #$00
DBSAV1:	STA DOSFIL	;Give DOS the file start addr ($2000)
	LDA #$20
	STA DOSFIL+1
	JMP BSAVE	;DOS "BSAVE" Routine

;	Local variable block:
PNAME	=TEMPN5		;Atom pname ptr.
CHARS	=TEMPNH		;String characters

DTPATM:	SETV OTPDEV,DTPNAM	;Output routine puts characters in DOS
	SETV PLINE,DOSNAM	;Init name index for DOS file names
	LDX #ARG1
	LDY #PNAME
	JSR GETPNM
DTPTMW:	LDA PNAME+1
	BEQ RSTR
	CARNXT CHARS,PNAME
	LDA CHARS
	BEQ RSTR
	ORA #$80
	JSR TPCHR
	LDA CHARS+1
	BEQ RSTR
	ORA #$80
	JSR TPCHR
	JMP DTPTMW

;Put characters in DOS. Don't put too many!!
DTPNAM:	LDY #$00
	STA (PLINE),Y	;PLINE indexes DOS file name
	INC1 PLINE
	CMPV PLINE,ENDNAM	;See if too many characters
	BNE RSTR
	ERROR XSYN	;Syntax error

;	Local variable block:
LENGTH	=TEMPN		;File length (bytes)

PUTLEN:	SEC
	LDA ENDBUF
	SBC #EDBUF&$FF
	STA DOSLEN
	LDA ENDBUF+1
	SBC #EDBUF^
	STA DOSLEN+1
RSTR:	RTS
.PAGE
SREAD:	LDA INPFLG
	BNE SAVSR1	;Can't do if in read-eval loop
	JSR ZAPGR
	JSR SRDX1
	LDX #LOGOM&$FF
	LDY #LOGOM^
	JSR SRDX2
	JSR DBLOAD	;Load the file
	CLC
	LDA FILLEN
	ADC #EDBUF&$FF
	STA ENDBUF	;recover buffer length from file length
	LDA FILLEN+1
	ADC #EDBUF^
	STA ENDBUF+1
	JSR PNTBEG	;point to beginning
	LDA SAVMOD	;If reading text, don't evaluate the buffer
	BNE SRDPJ
	VPUSH TOKPTR	;Save token pointer
	PUSHA SRDF3	;Push return address
	JMP EVLBUF

SRDF3:	VPOP TOKPTR	;Get token pointer back
SRDPJ:	JMP POPJ

SRDX1:	JSR GTWRD1
	BNE SAVSR3
	JMP DTPATM	;Give DOS the name

SRDX2:	JSR PRTSTR	;Give DOS the file type
	JMP RSTIO	;Detach the DTPNAM hook

SAVSR1:	JMP ERXETL	;can't hack files from editor
SAVSR3:	JMP ERXWT1

SSAVE:	LDA INPFLG
	BNE SAVSR1	;Error if editing with ALEC
	JSR ZAPGR
	JSR GTWRD1
	BNE SAVSR3
	JSR DTPATM	;Give DOS the name
	LDX #LOGOM&$FF	;Give it the file type
	LDY #LOGOM^
	JSR SRDX2
	LDA SAVMOD	;If saving text, don't put anything else in buffer
	BNE SAVBUF	;See SREAD.
	JSR EDTIN1	;output to buffer
	JSR POFUNS	;get functions into buffer
	LDA #$01
	JSR PONAMS	;get variables into buffer
	MOV ENDBUF,EPOINT
SAVBUF:	JSR PUTLEN
	JSR DBSAV1	;Save the file
	JSR PNTBEG
	JMP POPJ

SDELET:	JSR SDELTX
	LDX #LOGOM&$FF
	LDY #LOGOM^
	JSR SRDX2
	JSR DOSDEL	;DOS "DELETE" Routine
	JMP POPJ

SCATLG:	SETV OTPDEV,APOUT	;store APOUT in OTPDEV so DOS prints properly
	JSR DOSEAT	;let DOS eat these
	JSR DOSCAT	;DOS "CATALOG" Routine
	JMP POPJ

SDELTX:	JSR GTWRD1
	BNE SDELR3
	JMP DTPATM	;Give DOS the name
SDELR3:	JMP ERXWT1

DBLOAD:	LDA #$00
	STA DOSLOD	;Give DOS load addr.
	LDA #$20
	STA DOSLOD+1
	JMP BLOAD	;DOS "BLOAD" Subroutine
.PAGE
.SBTTL	Argument Passing Routines

;	Local variable block:
TYPEC1	=ANSN3		;Typecode of first arg
ARGSAV	=TEMPX2		;Temp. storage for arg2
NUMSAV	=A3L		;Temp. storage for arg1
VSPPTR	=TEMPNH		;Ptr. to arg on VSP
ARG	=ANSN1		;Address of ptr. to argument
ARGPTR	=TEMPNH		;Ptr. to argument

;Gets a numerical argument. Returns with carry set if flonum.
GT1NUM:	VPOP NARG1
GT1NMX:	JSR GTNUM1	;Alt. entry
	BCC GTERR1
	CMP #FLO	;(Sets carry if Flonum)
GTFRTS:	RTS

GT1FLT:	VPOP NARG1
GT1FLX:	JSR GTNUM1
	BCC GTERR1
	CMP #FLO
	BEQ GTFRTS
	JMP FLOTN1

;Gets two numerical arguments. Coerces one to Real if not same type.
;Returns with carry set if Flonum results.
GT2NUM:	VPOP ARGSAV
	VPOP ARG1
	JSR GETNUM	;GETNUM returns carry clear if argument non-numerical
	BCC GTERR1
	STA TYPEC1	;Save first typecode
	JSR GTNUM2	;Special GETNUM for NARG2
	BCC GTERR2
	CMP TYPEC1
	BNE GT2NM1
	CMP #FLO	;(Sets carry if Flonum)
	RTS
GT2NM1:	CMP #FIX	;Assume ARG1 is the integer
	BNE GT2NM2
	JSR FLOTN2	;Nope, it was NARG2, convert to flt. pt.
	SEC
	RTS
GT2NM2:	JSR FLOTN1	;Convert NARG1 to floating pt.
	SEC
	RTS

;ERROR wants a pointer to the erroneous argument, not the
;number itself, so we get it from the Vpdl position it was in
;(GTERR1 is for values just Vpopped)
GTERR1:	CAR ARG1,VSP
	JMP ERXWT1

GTERR2:	SEC		;(GTERR2 is for values which were the second
	LDA VSP		;Vpopped)
	SBC #$02
	STA VSPPTR
	LDA VSP+1
	SBC #$00
	STA VSPPTR+1
	CAR ARG1,VSPPTR
	JMP ERXWT1

;Gets a numerical argument, changes to integer if Real.
GT1FIX:	VPOP ARG1
GT1FX1:	JSR GETNUM
	BCC GTERR1
	CMP #FIX
	BEQ GTFXRT
	JMP RNDN1

;Gets two numerical arguments, changes either or both to integer if Real.
GT2FIX:	VPOP ARGSAV
	VPOP ARG1
	JSR GETNUM
	BCC GTERR1
	CMP #FIX
	BEQ GT2FX1
	JSR RNDN1
GT2FX1:	JSR GTNUM2	;Special GETNUM for NARG2
	BCC GTERR2
	CMP #FIX
	BEQ GTFXRT
	JMP RNDN2

;Carry clear if 16 bit integer, set otherwise.
;Returns with sign of A equal to sign of arg.
CHKINT:	LDA $02,X
	BNE CHKIN2
	LDA $03,X
	BNE CHKNNT
CHKIOK:	CLC
GTFXRT:	RTS
CHKIN2:	CMP #$FF
	BNE CHKNNT
	CMP $03,X
	BEQ CHKIOK
CHKNNT:	SEC
	RTS

;Carry clear if positive 16 bit integer, clear otherwise.
CHKPBN:	JSR CHKINT
	BCS GTFXRT
	TAX
	BMI CHKNNT
	CLC
	RTS

;Carry clear if positive 8 bit integer, clear otherwise.
CHKPIN:	JSR CHKINT
	BCS GTFXRT
	TAY
	BMI CHKNNT
	LDA $01,X
	BNE CHKNNT
	CLC
	RTS

;Gets a positive one byte fixnum, entered with maximum value allowed in A.
SMALFX:	PHA		;Save the limit
	JSR CHKPIN
	PLA
	BCS SMLFX1
	CMP $00,X
	BCC SMLFX2
	CLC
	RTS
SMLFX2:	SEC
SMLFX1:	RTS

;Get two rounded fixnums.
GT2RND:	JSR GT2NUM
	BCC SMLFX1
	JSR RNDN1
	JMP RNDN2

;Return with Z set if NARG1 is zero.
CKN1ZR:	LDX #$04
CKN1ZL:	LDA NARG1-1,X
	BNE CKN1ZE
	DEX
	BNE CKN1ZL
CKN1ZE:	RTS

;Return with Z set if NARG2 is zero.
CKN2ZR:	LDX #$04
CKN2ZL:	LDA NARG2-1,X
	BNE CKN2ZE
	DEX
	BNE CKN2ZL
CKN2ZE:	RTS

;GTNUM2 saves NARG1 before calling GETNUM with NARG2, then restores NARG1.
GTNUM2:	MOV NARG2,ARGSAV
GTNM2X:	LDY #NUMSAV	;Entry point for EQ - the pointer is in NARG2, not ARGSAV.
	JSR XN1TOY	;Save NARG1
	LDX #NARG2
	JSR GETNUM
	PHP		;Save carry
	PHA		;Save typecode
	LDY #NUMSAV
	JSR XYTON1	;Restore NARG1
	PLA		;Get typecode back
	PLP		;Get carry back
	RTS

;Gets a numerical argument if possible. Returns with carry clear if successful.
;Returns with typecode of argument (Fix/Flo) in A.
;(Note: ATMTNM destroys previous values of NARG1 and NARG2. Call with NARG1 first,
; then save it, then call with NARG2, then restore NARG1.)

GTNUM1:	LDX #NARG1
GETNUM:	STX ARG		;Address of argument
	JSR GETTYP
	LDX ARG
	CMP #ATOM
	BEQ ATMTNX
	CMP #STRING
	BEQ ATMTNX
	CMP #FIX
	BEQ LODNUM
	CMP #FLO
	BEQ LODNUM
GTNMNO:	CLC		;Carry clear means argument not OK
	RTS

;Entry point for EQ - already know it's a number.
LODNUM:	PHA		;Save typecode
	GETX ARGPTR
	LDY #$03
GTNML:	LDA (ARGPTR),Y
	STA $03,X
	DEX
	DEY
	BPL GTNML
	PLA		;Retrieve typecode
	SEC		;Carry set means argument OK
	RTS
.PAGE
;	Local variable block:
ARG	=ANSN1		;Address of ptr. to argument
PNAME	=TEMPN4		;Pname of atom
CHARS	=TEMPN7		;String characters
SIGN	=ANSN2		;Sign of number

;Convert an atom to a Fixnum or Flonum if possible. Sets the carry
;if successful. Returns typecode of number (Fix/Flo) in A.
;(Note: Destroys previous values of NARG1 and NARG2.)

ATMTNM:	STX ARG		;Points to argument
ATMTNX:	LDY #PNAME	;(Entry point for GETNUM)
	JSR GETPNM
	LDA PNAME+1
	BEQ GTNMNO
	JSR CNUML0	;Initialize number to 0
	LDY #$01
	LDA (PNAME),Y
	STA CHARS+1
	DEY
	STY SIGN
	LDA (PNAME),Y
	STA CHARS	;(CAR) a pair of digits to CHARS
	CMP #'-
	BNE ATMT3
	INC SIGN
	BNE ATMT4A	;(Always)
ATMT3:	JSR GOBDIG
ATMT4:	LDX PNAME+1
	BEQ ATMT4E
ATMT4A:	CDRME PNAME	;next two characters
	LDA CHARS+1
	BEQ ATMT4
	JSR GOBDIG
	LDX PNAME+1
	BEQ ATMT4E
	LDY #$01
	LDA (PNAME),Y
	STA CHARS+1
	DEY
	LDA (PNAME),Y	;(CAR) next two characters
	JSR GOBDIG
	JMP ATMT4
ATMT4E:	JSR CNUML2
	BCC NOTNM2
	PHA		;Save typecode
	LDX SIGN
	BEQ ATMT5
	LDX #NARG1
	CMP #FIX	;(Typecode of number is in A)
	BNE ATMT41
	JSR COMPL
	JMP ATMT5
ATMT41:	JSR FCOMPL
ATMT5:	LDY ARG		;Argument pointer
	LDX #$FC
ATMT5L:	LDA NARG1+4,X	;NARG1 is NUMBER
	STA $00,Y
	INY
	INX
	BMI ATMT5L
	PLA		;Retrieve typecode
	SEC		;Carry set means argument is a number
	RTS

GOBDIG:	JSR CNUML1
	BCS GBDGR
NOTNM1:	PLA		;Return back past ATMTNM
	PLA
NOTNM2:	CLC		;Carry clear means argument non-numeric
GBDGR:	RTS
.PAGE
;	Local variable block:
NEWATM	=TEMPX1		;(Shared: INTSTR)
ARGPTR	=ANSN3

;Entered with arg in X.
GTBOOL:	STX ARGPTR
	JSR INTSTR	;Get pointer to atom if there is one
	BCC GTBERR
	CMP #ATOM
	BNE GTBERR
	LDY #$00	;Assume TRUE (zero)
	COMP NEWATM,TRUE
	BEQ GBDGR
	INY
	COMP NEWATM,FALSE
	BEQ GBDGR
GTBERR:	LDX ARGPTR
	JSR PTRXOK
	ERROR XNTF,CURTOK
.PAGE
;	Local variable block:
ARG	=ANSN1		;Address of ptr. to argument
PNAME	=ANSN2
ARGPTR	=TEMPNH		;Ptr. to argument

MKNUM:	PHA		;Save typecode
	GETX ARGPTR	;Assume it's a fixnum or flonum
	LDX #$03
	LDY #$00
MKP2L1:	LDA (ARGPTR),Y
	STA NARG1,Y
	INY
	DEX
	BPL MKP2L1
	PLA		;Retrieve typecode
	TAX
	LDA PNAME
	PHA		;Save pointer
	CPX #FIX
	BEQ MKPN2
	CPX #FLO
	BEQ MKPN3
	LDX ARG
ERXWTX:	JSR PTRXOK
ERXWTY:	ERROR XWTA,CURTOK
MKPN2:	JSR CVBFIX	;Get string on PDL
	JMP CNSPD1	;CONS string from PDL
MKPN3:	JSR CVFLO	;Get the string on PDL
	JMP CNSPD1

MAKPNM:	STY PNAME	;Note: X may equal Y at this point (ARG=PNAME)
	STX ARG
	JSR GETTYP
	LDY PNAME
	CMP #ATOM
	BEQ ATMPNM
	CMP #SATOM
	BEQ STMPNM
	CMP #STRING
	BEQ STRPNM
	BNE MKNUM	;(Always)
.PAGE
;	Local variable block:
PNAME	=TEMPN1+1	;Returned pname ptr.
ATMPTR	=TEMPNH		;Atom ptr.
INDEX	=TEMPN		;Prim-array index
OFFSET	=TEMPN1		;Prim-array index offest

GETPNM:	STY PNAME
	JSR GETTYP
	CMP #ATOM
	BEQ ATMPNX
	CMP #SATOM
	BEQ STMPNX

;Get pname Y from string X
STRPNM:	LDY PNAME
	LDA $00,X
	PHA
	AND #$FC
	STA $00,Y
	LDA $01,X
	STA $01,Y
	PLA		;Get low byte back (w/funny bits)
	AND #$01	;0 if reg. string, 1 if funny-pname
	RTS

;Get pname Y from atom X
ATMPNM:	STY PNAME
ATMPNX:	JSR GTPNM1
	CDRME ATMPTR
	LDX PNAME
	DEY
	LDA (ATMPTR),Y
	PHA
	INY
	LDA (ATMPTR),Y
	STA $01,X
	PLA
	TAY	
	AND #$FC
	STA $00,X
	TYA
	AND #$01
	RTS

GTPNM1:	LDA $00,X
	AND #$FC
	STA ATMPTR
	LDA $01,X
	STA ATMPTR+1
	RTS

;Get pname Y from satom X
STMPNM:	STY PNAME
STMPNX:	JSR GTPNM1
	CDR INDEX,ATMPTR
	LDA #PRMNAM
	STA OFFSET
	LDA #$00
	STA CCOUNT	;Character counter
GTPNW:	DATRAM		;Enable ghost-memory
	LDY OFFSET
	LDA (INDEX),Y	;Pname index is 3 for Sfuns
	BEQ GTPNWE
	JSR PUSHB
	INC CCOUNT
	INC OFFSET
	BNE GTPNW	;(Always)
GTPNWE:	NODRAM		;Disable ghost-memory
	LDA PNAME
;	...
.PAGE
;	Local variable block:
CHARS	=TEMPN		;String characters

;CONS a string from the characters on the PDL, CCOUNT holds counter, ANS in vA.
;Should return with $00 in A for GETPNM (the funny-pname bit).
;	...
CNSPDL:	PHA		;Save ANS ptr on stack
CNSPD1:	LDX #$00	;(JMP here if ANS already on stack)
	STX MARK1+1
	LDA CCOUNT
	ROR A
	BCC CSPD1
	INC CCOUNT
	LDA #$00
	BEQ CSPD2	;(Always) If odd, first char. seen will be a zero
CSPD1:	JSR POPB	;Pop two characters
CSPD2:	STA CHARS+1
	POPB CHARS
	CONS MARK1,CHARS,MARK1,STRING	;Cons a node
	DEC CCOUNT
	DEC CCOUNT
	BNE CSPD1	;Continue if not done
	PLA		;Retrieve pointer
	TAX
	PUTX MARK1
	LDA #$00
	STA MARK1+1
	RTS

;Converts a two-byte fixnum to a string on the PDL
CVFIX:	GETX NARG1	;NARG1 is the number to type
	LDA #$00
	STA CCOUNT	;Character counter
CVFIXX:	STA NARG1+2	;(Alternate entry point)
	STA NARG1+3
	BEQ CVFX2	;(Always)

;	Local variable block:
DCOUNT	=ANSN		;Digit counter

;Get 4-byte fixnum in NARG1 to string on PDL
CVBFIX:	LDA #$00
	STA CCOUNT	;Character counter
	LDA NARG1+3
	BPL CVFX1
	LDX #NARG1
	JSR COMPL
	LDA #'-
	JSR PUSHB
	INC CCOUNT
CVFX1:	LDA #$00
CVFX2:	STA DCOUNT	;Digit counter
CVBNMR:	LDA #$0A
	JSR XDVDX	;Divide NARG1 by ten and get remainder
	CLC
	ADC #'0		;Make the digit Ascii
	PHA		;Push remainder digit
	INC DCOUNT	;Increment digit counter
	JSR CKN1ZR
	BNE CVBNMR
CVBNMF:	PLA		;Pop a digit
	JSR PUSHB	;Push it
	INC CCOUNT
	DEC DCOUNT
	BNE CVBNMF
	RTS
.PAGE
;	Local variable block:
ODE	=ANSN2		;Running decimal pt. shift counter
ECOUNT	=ANSN3		;No. of mantissa digits to print
DIGIT	=TEMPN1		;Newest digit

;Converts flonum NARG1 to characters on PDL
CVFLO:	LDA #$00
	STA CCOUNT	;Counts number of characters pushed
	STA ODE
	JSR CKN1ZR
	BNE TPFL1
	INC CCOUNT
	LDA #'0		;If NARG1 = 0, push "0." and return
	JSR PUSHB
	INC CCOUNT
	LDA #'.
	JMP PUSHB
TPFL1:	LDA NARG1+1
	BPL TPFL2
	JSR FCOMPL	;If NARG1 negative, invert and push "-"
	LDA #'-
	JSR PUSHB
	INC CCOUNT
TPFL2:	LDA NARG1	;Now get 1 <= NARG1 < 10
	BPL TPFLS1	;Exponent too small, so multiply number
	CMP #$84
	BCS TPFLG1	;Exponent greater than 3, so too big
	CMP #$83
	BNE GINTP1	;Ok if 0,1, or 2
	LDA NARG1+1	;Else if 3,
	CMP #$50	;Make sure X < 10 (01.01 0000 Bin)
	BCC GINTP1
TPFLG1:	JSR FDVD10	;So divide by 10
	INC ODE
	LDA NARG1
	CMP #$83
	BCC GINTP1
	BNE TPFLG1
	LDA NARG1+1
	CMP #$50
	BCS TPFLG1
	BCC GINTP1	;(Always)
TPFLS1:	JSR MULN10	;NARG1 too small, so multiply by 10
	DEC ODE
	LDA NARG1
	BPL TPFLS1
GINTP1:	SETNUM NARG2,FRNDUP	;Round up (add 0.000005)
	JSR FADD
	LDA NARG1
	CMP #$84
	BCS GNTPLG	;Exponent greater than 3, so too big
	CMP #$83
	BNE GINTP2	;Ok if 0,1, or 2
	LDA NARG1+1	;Else if 3,
	CMP #$50	;Make sure X < 10 (01.01 0000 Bin)
	BCC GINTP2
GNTPLG:	JSR FDVD10	;So divide by 10
	INC ODE
GINTP2:	JSR GETINT
	LDA ODE
	BPL TPFLG2
	CMP #$FF
	BCC TPFLF1	;NARG1 < 0.1, use floating pt. format (neg exp)
TPFLR:	STA ECOUNT	;Counter for Exp+1 iterations
	INC ECOUNT
	BEQ TPFLR1
TPFLL5:	JSR GTDECH
	DEC ECOUNT
	BNE TPFLL5
TPFLR1:	LDA #'.
	JSR PUSHB	;Push decimal pt.
	INC CCOUNT
	SEC
	LDA #$05
	SBC ODE
	STA ECOUNT	;Counter for 5-Exp iterations
	BEQ POPTZS
TPFLL6:	JSR GTDECH
	DEC ECOUNT
	BNE TPFLL6
POPTZS:	JSR POPB	;Pop all trailing zeroes
	DEC CCOUNT
	CMP #'0
	BEQ POPTZS
	INC CCOUNT
	JMP PUSHB	;Done
TPFLG2:	CMP #$06
	BCC TPFLR	;NARG1 < 1000000, use regular format
TPFLF1:	JSR GTDECH	;Floating pt. format, call Get-Decimal-Char for digit
	LDA #'.
	JSR PUSHB	;Push a "."
	INC CCOUNT
	LDA #$05	;Counter for five iterations
	STA ECOUNT
TPFLL3:	JSR GTDECH	;Get another decimal digit
	DEC ECOUNT
	BNE TPFLL3
	JSR POPTZS	;Pop all trailing zeros
	LDA ODE
	BPL TPFLEP
	EOR #$FF	;If Exp negative, invert
	STA ODE
	INC ODE		;(Complement and increment)
	LDA #'N		;and push "N"
	BNE TPFLEX	;(Always)
TPFLEP:	LDA #'E		;Exp positive, push "E"
TPFLEX:	JSR PUSHB
	INC CCOUNT
	LDA ODE
	STA NARG1
	LDA #$00
	STA NARG1+1
	JMP CVFIXX	;Routine converts (2-byte) ARG1 into string on PDL

FRNDUP:	$6E	;Floating-point constant, 0.000005
	$53
	$E2
	$D6
.PAGE
;Gets the most significant decimal digit of NARG1, then positions it for next one.
GTDECH:	CLC
	LDA DIGIT
	ADC #'0
	JSR PUSHB
	INC CCOUNT
	LDA DIGIT
	JSR SETN2A
	JSR FLOTN2
	JSR FSUB	;Subtract the last digit we got
	JSR MULN10	;Multiply by 10 to get next digit
GETINT:	LDA #$00	;Gets the integer part of NARG1
	STA DIGIT	;Init DIGIT to 0
	LDA NARG1+1	;MSB in A
	LDX NARG1	;Exp in X
	BEQ GTNTR	;Done if exp 0
GTNTL:	CPX #$80	;Loop done when $80
	BEQ GTNTLE
	ASL A		;Shift bit from MSB
	ROL DIGIT	;into DIGIT
	DEX		;Dec exp
	BNE GTNTL	;(Always) Continue for 0-3 bits
GTNTLE:	ASL A		;Then do two more bits
	ROL DIGIT
	ASL A
	ROL DIGIT
GTNTR:	RTS
.PAGE
;Execution diagram, flonum-to-string conversion:
;ODE := 0
;IF NUM < 1 THEN DO NUM := NUM * 10, ODE := ODE - 1, UNTIL NUM >= 1
; ELSE IF NUM >= 10 THEN DO NUM := NUM / 10, ODE := ODE + 1, UNTIL NUM < 10
;NUM := NUM + ROUND
;IF NUM >= 10 THEN NUM := NUM / 10, ODE := ODE + 1
;INTP := INT(NUM)
;IF ODE > 6 OR ODE < -1 THEN GET-DIG, PUSH("."), (REPEAT 5 GET-DIG), POP-TZS, PR-EXP
; ELSE (REPEAT ODE+1 GET-DIG), PUSH("."), (REPEAT 5-ODE GET-DIG), POP-TZS
;
;GET-DIG:
; PUSH(INTP)
; NUM := NUM - INTP, NUM := NUM * 10, NUM := NUM + ROUND
; IF NUM >= 10 THEN NUM := NUM / 10
; INTP := INT(NUM)
.PAGE

OTFXS2:	STA NARG1
	LDA #$00
	STA NARG1+1
OTFXS1:	CONS ARG1,NARG1,0,FIX
	JMP OTPRG1

OTPFX1:	LDY #NARG1
OTPFIX:	SEC
	LDA $03,Y
	SBC #$80
	ORA $02,Y
	ORA $01,Y
	ORA $00,Y
	BNE OTPFXA
	SETNUM NARG1,FNEG0	;Attempted to output -2^31, so change to flonum
OTPFL1:	LDY #NARG1
OTPFLO:	LDA #FLO
	BNE OTPNUM	;(Always)
OTPFXA:	LDA #FIX
OTPNUM:	PHA		;Save typecode
	LDA #ARG1
	STA NODPTR
	TYA
	TAX
	INX
	INX
	PLA		;Retrieve typecode
	JSR CONS
	JMP OTPRG1

FNEG0:	$9E	;Negative zero, ie -2^31
	$80
	$00
	$00
.PAGE
.SBTTL	Primitives
.SBTTL		Arithmetic Primitives

SUNSUM:	SETV CURTOK,INFSUM	;(For possible error message in GT1NUM)
	JSR GT1NUM
	BCS SNSM1
	JMP OTPFX1

SUNDIF:	SETV CURTOK,INFDIF	;(For possible error message in GT1NUM)
	JSR GT1NUM
	BCS SNDIF2
	LDX #NARG1
	JSR COMPL
RESOK:	JMP OTPFX1
SNDIF2:	JSR FCOMPL	;Complements flonum in NARG1.
SNSM1:	JMP OTPFL1

;	Local variable block:
SIGN1	=TEMPN1		;Sign of NARG1

SSUM:	JSR GT2NUM
	BCS SSUMF
	JSR SAVNGS
	LDA NARG1+3
	STA SIGN1
	CLC
	LDX #$FC
SSMLP1:	LDA NARG1+4,X
	ADC NARG2+4,X
	STA NARG1+4,X
	INX
	BMI SSMLP1
	LDA NARG2+3
	EOR SIGN1
	BMI RESOK	;Different signs, never an overflow
	LDA NARG1+3
	EOR NARG2+3
	BPL RESOK	;Overflow if result not same sign as one argument
	JSR CONV
SSUMF:	JSR FADD	;Floating pt. addition
	BCS ERXOVF
	JMP OTPFL1
ERXOVF:	ERROR XOFL

;	Local variable block:
SIGN1	=TEMPN1		;Sign of NARG1

SDIF:	JSR GT2NUM
	BCS SDIFF
	JSR SAVNGS
	LDA NARG1+3
	STA SIGN1
	SEC
	LDX #$FC
SDIFL1:	LDA NARG1+4,X
	SBC NARG2+4,X
	STA NARG1+4,X
	INX
	BMI SDIFL1
	LDA SIGN1
	EOR NARG2+3
	BPL RESOK	;Same signs, never an overflow
	LDA NARG1+3
	EOR SIGN1
	BPL RESOK
	JSR CONV
SDIFF:	JSR FSUB	;Floating pt. subtraction
	BCS ERXOVF
	JMP OTPFL1

;	Local variable block:
SIGN1	=TEMPN1		;Sign of NARG1
PRODCT	=TEMPN		;Partial product (shared: IMULT)

SPROD:	JSR GT2NUM
	BCS SPRODF
	JSR SAVNGS
	JSR IMULT	;Returns with carry set if overflow
	BCS SPRODR
	LDY #PRODCT
	JMP OTPFIX
SPRODR:	JSR CONV
SPRODF:	JSR FMUL	;Floating pt. multiply
	BCS ERXOVF
	JMP OTPFL1

SDIVID:	JSR GT2NUM
	BCS SDIVF
	JSR FLOTN1
	JSR FLOTN2
SDIVF:	LDA NARG2
	BEQ SDIVR1
	JSR FDIV	;Floating pt. divide
	BCS SDIVR
	JMP OTPFL1
SDIVR:	ERROR XOFL
SDIVR1:	ERROR XDBZ

SQTENT:	JSR GT2RND
	JSR IDIVID
	JMP OTPFX1

SRMNDR:	JSR GT2RND
	JSR IDIVID
	LDY #NARG2
	JMP OTPFIX

SROUND:	JSR GT1NUM
	BCC SRND1
	JSR RNDN1
SRND1:	JMP OTPFX1

SINT:	JSR GT1NUM
	BCC SINT1
	JSR INTN1
SINT1:	JMP OTPFX1

;	Local variable block:
SAVNG1	=A1L		;NARG1 save
SAVNG2	=A3L		;NARG2 save

SAVNGS:	LDY #SAVNG1	;Save NARG1 and NARG2 in case of overflow
	JSR XN1TOY
	LDY #SAVNG2
	JMP XN2TOY

CONV:	LDY #SAVNG1
	JSR XYTON1	;Overflow, get NARG1 and NARG2 back
	LDY #SAVNG2
	JSR XYTON2
	JSR FLOTN1	;Convert both to floating pt.
	JMP FLOTN2
.PAGE
;	Local variable block:
SGNX	=ANSN1		;X-Incr. sign (shared: GETSIN)
FRACT	=TEMPN7		;Interpolation fraction (shared: GETSIN)
LOWENT	=TEMPN5		;Low table entry (shared: MULSIN)

SSIN:	JSR GT1FLT
	JSR GETSIN
	LDA NARG1
	JSR MULSIN
	LDY #FRACT
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #LOWENT
	JSR XYTON2	;Get uncorrected table value...
	JSR FADD	;and correct it!
	LDA SGNX	;X-Incr. sign
	BEQ SSIN2
	JSR FCOMPL
SSIN2:	JMP OTPFL1

;	Local variable block:
SGNY	=ANSN2		;Y-Incr. sign (shared: GETSIN)
FRACT	=TEMPN7		;Interpolation fraction (shared: GETSIN)
HIENT	=TEMPN3		;High table entry (shared: MULCOS)

SCOS:	JSR GT1FLT
	JSR GETSIN
	LDA NARG1
	JSR MULCOS
	LDY #FRACT
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #HIENT
	JSR XYTON2	;Get uncorrected table value...
	JSR FSUBX	;and correct it! Note that we subtract because we are
			;reading table backwards for cosine
	LDA SGNY	;Y-Incr. sign
	BEQ SCOS2
	JSR FCOMPL
SCOS2:	JMP OTPFL1
.PAGE
;	Local variable block:
SGNX	=ANSN1		;X-Incr. sign (shared: SSIN,SFDX)
SGNY	=ANSN2		;Y-Incr. sign (shared: SCOS,SFDX)
FRACT	=TEMPN7		;Interpolation fraction (shared: SSIN,SCOS,SFDX)
SAVNG1	=TEMPN5		;NARG1 save

GETSIN:	JSR MOD360	;Convert NARG1 to 0-360
	LDY #NARG1
	JSR XYTON2	;Get NARG1 in NARG2
GETSN1:	LDA #$00
	STA SGNX
	STA SGNY
	LDY #SAVNG1	;Save NARG1 through subtract
	JSR XN1TOY
	JSR INTN1	;Make it integer... (don't round!)
	JSR FLOTN1	;then floating again, zapping fraction bits
	JSR FSUBX	;which remain after subtract
	LDY #FRACT
	JSR XN1TOY	;Save fraction for interpolating
	LDY #SAVNG1
	JSR XYTON1	;Get heading back for munching
	LDA NARG1
	CMP #$87
	BCC HDPOS
	BNE HDNPOS
	LDA NARG1+1
	CMP #$5A
	BCC HDPOS
	BNE HDNPOS
	LDA NARG1+2
	ORA NARG1+3
	BEQ HDPOS
HDNPOS:	SETNUM NARG2,F360	;Subtract from 360.
	JSR FSUBX
	INC SGNX	;Sign of X incr.
HDPOS:	LDA NARG1	;See if it's > 90.
	CMP #$86
	BCC HDYPOS
	BNE HDYNEG
	LDA NARG1+1
	CMP #$5A
	BCC HDYPOS
	BNE HDYNEG
	LDA NARG1+2
	ORA NARG1+3
	BEQ HDYPOS
HDYNEG:	SETNUM NARG2,F180
	JSR FSUBX	;Subtract from 180. if > 90.
	INC SGNY
HDYPOS:	JMP INTN1	;Make Heading integer (don't round)

;	Local variable block:
LOWENT	=TEMPN5		;Low table entry (shared: SSIN,SFDX)
HIENT	=TEMPN3		;High table entry (shared: SCOS,SFDX)

MULCOS:	CLC		;Indexes 90-ANGLE-1 entry and following entry
	LDA #$5A
	SBC NARG1
MULSIN:	CLC
	ADC #$01	;Increment index (see below)
	ASL A		;Multiply by 2 for offset
	PHA		;Save index
	TAX
	DATRAM		;Enable ghost-memory
	LDA SINTB1,X	;Get the table's entry
	STA NARG1	;(Indexed from 1 before zero value, with
	LDA SINTB1+1,X	;an index incremented by 2, so that the
	STA NARG1+1	;value before zero gets indexed properly)
	LDA SINTB2,X
	STA NARG1+2
	LDA SINTB2+1,X
	STA NARG1+3
	LDY #LOWENT
	JSR XN1TOY	;Save table value
	PLA		;Retrieve index
	TAX
	LDA SINTB1+2,X	;Get the next entry for interpolating
	STA NARG2
	LDA SINTB1+3,X
	STA NARG2+1
	LDA SINTB2+2,X
	STA NARG2+2
	LDA SINTB2+3,X
	STA NARG2+3
	NODRAM		;Disable ghost-memory
	LDY #HIENT
	JSR XN2TOY	;Save table value
	JMP FSUBX	;Get difference of entries in NARG1
.PAGE
;This gets y := arctan(x):
;	x1 := a9
;	x2 := x*x
;	do for x3 := a7,a5,a3,a1
;		x1 := x2 * x1 + x3
;	y := x * x1
;Where	a1 =  .9998660
;	a3 = -.3302995
;	a5 =  .1801410
;	a7 = -.0851330
;	a9 =  .0208351

;	Local variable block:
EX2	=TEMPN3
COUNT	=ANSN2
KINDEX	=ANSN3

GATAN:	JSR ATNEXP	;Get ATNEXP (DX/DY)
	SETNUM NARG2,KRDEG	;Get 180./PI in NARG2
	JMP FMUL	;Return with ATNEXP(DX/DY)*(180./PI)

ATNEXP:	LDA NARG1	;Complete expansion.
	CMP #$80	;See if X > 1.0
	BCC ATNXP1	;X < 1.0
	BNE ATAN1	;X > 1.0
	LDA NARG1+1
	CMP #$40
	BCC ATNXP1
	BNE ATAN1
	LDA NARG1+2
	ORA NARG1+3
	BEQ ATNXP1
ATAN1:	LDA #$40	;X > 1.0
	STA NARG2+1	;Put 1.0 in NARG2
	ASL A
	STA NARG2
	ASL A
	STA NARG2+2
	STA NARG2+3
	JSR FDIVX	;Get 1./X
	JSR ATNXP1	;Get ATNEXP (1./X)
	SETNUM NARG2,KHLFPI	;Get PI/2 in NARG2
	JMP FSUBX	;Get PI/2. - ATNEXP (1./X)
ATNXP1:	SETNUM NARGX,NARG1	;The raw expansion. Save X.
	LDY #NARG2
	JSR XN1TOY		;Put in NARG2
	JSR FMUL		;and get X^2
	LDY #EX2
	JSR XN1TOY		;X2 := X*X
	SETNUM NARG1,KA9	;X1 := A9
	LDA #$04
	STA COUNT		;Four iterations
	LDA #$00
	STA KINDEX		;Constant index (A7,A5,A3,A1)
ATANL:	LDY #EX2
	JSR XYTON2
	JSR FMUL		;X1 := X2 * X1
	LDY KINDEX
	LDX #$FC
ATANL1:	LDA KATANS,Y
	STA NARG2+4,X
	INC KINDEX
	INY
	INX
	BMI ATANL1		;NARG2 := A (A7,A5,A3,A1)
	JSR FADD		;X1 := X1 + A
	DEC COUNT
	BNE ATANL		;Four expansions
	SETNUM NARG2,NARGX	;Get X back
	JMP FMUL		;Y := X1 * X

;	Local variable block:
SGNDX	=TEMPN7

SATAN:	JSR GT1FLT
	LDA NARG1+1
	STA SGNDX
	BPL SATN1
	JSR FCOMPL
SATN1:	JSR GATAN
	LDA SGNDX
	BPL SATN2
	JSR FCOMPL	;Negate
	JSR M3ADD	;And add 360
SATN2:	JMP OTPFL1

KRDEG:	$85	; 180/PI = 57.2957799
	$72
	$97
	$71

KHLFPI:	$80	; PI/2 = 1.57079632
	$64
	$87
	$ED

KA9:	$7A	; 0.0208351
	$55
	$57
	$30

KATANS	=.
KA7:	$7C	; -0.0851330
	$A8
	$D2
	$E5

KA5:	$7D	; 0.1801410
	$5C
	$3B
	$71

KA3:	$7E	; -0.3302995
	$AB
	$71
	$7E

KA1:	$7F	;0.9998660
	$7F
	$FB
	$9C
.PAGE
;	Local variable block:
ARG	=TEMPN3		;Argument copy
GUESS	=TEMPN5		;Square-root guess

SSQRT:	JSR GT1FLT	
	LDA NARG1+1
	BMI SQRTR	;We don't do negatives
	JSR CKN1ZR	;See if NARG1 is 0
	BNE SQRTAE	;Nope
SQRTO:	JMP OTPFL1	;Yup, output it
SQRTAE:	LDY #ARG
	JSR XN1TOY	;Keep a copy of the arg around
	LDA NARG1	;Halve the exponent to get the first guess...
	BMI SQRTA
	LSR A		;Positive exponent, just shift to right
	BPL SQRTB	;(Always)
SQRTA:	SEC		;Negative exponent
	ROR A		;Shift in a one
	AND #$BF	;Zap the one from before
SQRTB:	STA NARG1
	LDY #GUESS
	JSR XN1TOY	;Copy arg into Guess
SQRT1:	LDY #ARG
	JSR XYTON2	;Put orig. arg in NARG2 (Guess is in NARG1 now)
	JSR FDIVX	;Get Arg/Guess
	LDY #GUESS
	JSR XYTON2	;Get guess in NARG2
	JSR FADD	;Get Guess+Arg/Guess
	DEC NARG1	;Divide NARG1 by 2 to get (Guess+Arg/Guess)/2
	LDX #$02	;Compare new guess to old guess
SQRTL1:	LDA GUESS,X	;First three bytes must be equal
	CMP NARG1,X
	BNE SQRT2
	DEX
	BPL SQRTL1
	LDA GUESS+3	;Compare 4 most sig. bits of least sig. bytes
	EOR NARG1+3
	AND #$F0
	BEQ SQRTO	;Good enough, return with new guess
SQRT2:	LDY #GUESS
	JSR XN1TOY	;Still not good enough, make this new guess
	JMP SQRT1	;Try again
SQRTR:	ERROR XSQT
.PAGE
.SBTTL		Boolean Primitives

SGRTR:	JSR GT2NUM
SGRTRX:	BCS SGRTRF
	LDA NARG1+3
	BMI SGRTRM
	LDA NARG2+3
	BMI JTRU	;POS > NEG
SGRTRP:	LDX #$03
SGRLP1:	LDA NARG2,X
	CMP NARG1,X
	BCC JTRU
	BNE JFLS
	DEX
	BPL SGRLP1
JFLS:	JMP VPLFLS
SGRTRM:	LDA NARG2+3
	BPL JFLS	;NEG not > POS
	AND #$7F	;Both negative, strip sign bit and compare
	STA NARG2+3
	LDA NARG1+3
	AND #$7F
	STA NARG1+3
	JMP SGRTRP
JTRU:	JMP VPLTRU
SGRTRF:	LDA NARG1+1
	BMI SGRTFM
	LDA NARG2+1
	BMI JTRU	;POS > NEG
	BPL SGRTF1
SGRTFM:	LDA NARG2+1
	BPL JFLS	;NEG not > POS
SGRTF1:	JSR FSUBX	;Both same sign - subtract NARG1 from NARG2
	LDA NARG1+1	;If NARG1 negative, then it was larger
	BMI JTRU
	BPL JFLS

SLESS:	JSR GT2NUM
	JSR SWAP	;Switch the args and call SGREATER
	JMP SGRTRX
.PAGE
;	Local variable block:
ANSWER	=TEMPX2		;Equality result (TRUE or FALSE)
SPPTR	=TEMPN8		;Original SP to restore
TYPEC1	=ANSN4		;Typecode of ARG1
TYPEC2	=ANSN		;Typecode of ARG2

SEQUAL:	MOV ANSWER,TRUE
	VPOP ARG2
	VPOP ARG1
	INC OTPUTN
	MOV SPPTR,SP
	PUSHA SEQEND
EQ:	GETTYP ARG2
	STA TYPEC2
	GETTYP ARG1
	STA TYPEC1
	CMP #LIST
	BEQ EQL
	CMP #FIX
	BEQ EQF
	CMP #FLO
	BEQ EQF
	CMP #ATOM
	BEQ EQA
	CMP #STRING
	BNE EQO
	JMP EQSTR
EQO:	LDA TYPEC1	;Loses if not same typecode
	CMP TYPEC2
	BNE EQFF
EQO1:	COMP ARG1,ARG2	;Loses if not same pointer
	BEQ EQPOP
EQFF:	MOV ANSWER,FALSE	;We lost
	JMP SEQEND
EQPOP:	JMP POPJ	;We won this round
EQL:	LDA TYPEC2	;ARG1 is a list
	CMP #LIST
	BNE EQFF	;Lose if ARG2 not a list
	JMP EQLIST	;Compare the lists
EQF:	LDX #ARG1	;ARG1 is a number
	JSR LODNUM	;Get arg1 into NARG1
	JSR GTNM2X	;Get arg2 into NARG2 (without bashing NARG1)
	BCC EQFF	;Not a number, lose
EQFC:	CMP TYPEC1	;(Here we have two numbers) See if NARG1 same type...
	BEQ EQF1	;Yes, compare them
	CMP #FLO	;Not same type: If NARG2 is Flonum,
	BEQ EQF2	;then branch
	JSR FLOTN2	;Else NARG2 is Fixnum, convert to flt. pt.
	JMP EQF1	;and compare (NARG1 is a flonum)
EQF2:	JSR FLOTN1	;Convert NARG1 to floating pt. (NARG2 is a flonum)
EQF1:	LDX #$03	;Compares two numbers of same typecode
EQFLP:	LDA NARG1,X
	CMP NARG2,X
	BNE EQFF
	DEX
	BPL EQFLP
	JMP POPJ
EQA:	LDA TYPEC2	;ARG1 is an atom, look at ARG2
	CMP #STRING
	BNE EQA2
	JMP EQSTRX	;String, so compare with atom
EQA2:	CMP #FIX
	BEQ EQA1
	CMP #FLO
	BNE EQO		;ARG2 not a fixnum or flonum, must be the same atom then
EQA1:	LDA TYPEC2
	PHA
	LDA NARG2	;Save NARG2 pointer through GTNUM1
	PHA
	LDA NARG2+1
	PHA
	JSR GTNUM1	;ARG1 is an atom, ARG2 is a number: Get arg1 into NARG1 if you can
	BCC EQFF	;Can't, so lose
	STA TYPEC1
	PLA
	STA NARG2+1
	PLA
	STA NARG2
	LDX #NARG2
	JSR LODNUM	;Get number arg2 into NARG2
	PLA		;Have two numbers in NARG1, NARG2, do CMP of types for branch at EQFC
	JMP EQFC
EL1:	POP ARG2
	POP ARG1
	CDRME ARG1
	CDRME ARG2
EQLIST:	LDA ARG1+1
	BNE EQLST1
	LDA ARG2+1
	BNE EQFFJ
	JMP POPJ
EQLST1:	LDA ARG2+1
	BEQ EQFFJ
	PUSH ARG1
	PUSH ARG2
	CARME ARG1
	CARME ARG2
	JSR TSTPOL
	PUSHA EL1
	JMP EQ
SEQEND:	VPUSH ANSWER
	MOV SP,SPPTR
	JMP POPJ
EQFFJ:	JMP EQFF

;	Local variable block:
PNAME	=TEMPN6		;Pname pointer

EQSTRX:	LDX #ARG1	;ARG1 is an Atom, ARG2 is the String
	LDY #PNAME
	JSR MAKPNM
	MOV ARG1,PNAME
	JMP CMPSTR
EQSTR:	LDA TYPEC2	;ARG1 is a String, see what ARG2 is
	CMP #STRING
	BEQ CMPSTR	;A String, so compare them
	CMP #LIST
	BEQ EQFFJ	;A List, we lose
	LDA ARG1
	PHA		;Save ARG1 through MAKE_PNAME
	LDA ARG1+1
	PHA
	LDX #ARG2
	LDY #PNAME
	JSR MAKPNM	;Otherwise, get its Pname
	MOV ARG2,PNAME
	PLA		;Retrieve ARG1
	STA ARG1+1
	PLA
	STA ARG1
CMPSTR:	LDY #$00
	LDA (ARG1),Y
	CMP (ARG2),Y
	BNE EQFFJ	;Lose if first bytes not equal
	TAX
	BEQ EQPOPJ	;Win if both zero (done)
	INY
	LDA (ARG1),Y
	CMP (ARG2),Y
	BNE EQFFJ	;Lose if second bytes not equal
	TAX
	BEQ EQPOPJ	;Win if both zero (done)
	INY
	LDA (ARG1),Y
	TAX
	INY
	LDA (ARG1),Y
	STA ARG1+1
	BNE CMPS1
	LDA (ARG2),Y
	BEQ EQPOPJ	;Win if both CDRs zero (done)
	BNE EQFFJ	;(Always) Else lose if only one is (ARG1's)
CMPS1:	STX ARG1
	LDA (ARG2),Y
	BEQ EQFFJ	;Lose if only one is (ARG2's)
	TAX
	DEY
	LDA (ARG2),Y
	STA ARG2
	STX ARG2+1
	JMP CMPSTR
EQPOPJ:	JMP EQPOP
.PAGE
SNOT:	VPOP ARG1
	JSR GTBOOL
	TYA
	BNE VPLTRU
	JMP VPLFLS

;	Local variable block:
ANSWER	=ANSN4		;Boolean answer byte

SAND:	ASL NARGS
	LSR NARGS
	BEQ SBTHER	;need more inputs
	LDA #$00
	STA ANSWER
SBTHL:	VPOP ARG1
	JSR GTBOOL
	LDA ANSWER
	BNE SBTH2
	STY ANSWER
SBTH2:	DEC NARGS
	BNE SBTHL
	LDA ANSWER
	BEQ VPLTRU
	JMP VPLFLS
SBTHER:	ERROR XNMI,CURTOK

;	Local variable block:
ANSWER	=ANSN4		;Boolean answer byte

SOR:	ASL NARGS
	LSR NARGS
	BEQ SBTHER	;need more inputs
	LDA #$01
	STA ANSWER
SEITHL:	VPOP ARG1
	JSR GTBOOL
	LDA ANSWER
	BEQ SEITH2
	STY ANSWER
SEITH2:	DEC NARGS
	BNE SEITHL
	LDA ANSWER
	BNE VPLFLS
VPLTRU:	VPUSH TRUE
	INC OTPUTN
	JMP POPJ

;	Local variable block:
NEWATM	=TEMPX1		;(Shared: INTSTR)

STHNGP:	VPOP ARG1
	JSR INTSTR	;Get pointer to atom if there is one
	BCC SPTH3	;Not an atom/satom/string, so no value
	CMP #STRING
	BEQ VPLFLS	;Not there, so's got no value
	LDY #NEWATM
	LDX #ARG1
	JSR GETVAL
	BEQ VPLFLS
SPTH3:	JMP VPLTRU

SWORDP:	VPOP ARG1
	JSR GETTYP
	CMP #LIST
	BNE SPTH3
VPLFLS:	VPUSH FALSE
	INC OTPUTN
	JMP POPJ

SLISTP:	VPOP ARG1
	JSR GETTYP
	CMP #LIST
	BNE VPLFLS
	BEQ VPLTRU	;(Always)

SNMBRP:	VPOP ARG1
	JSR GETTYP
	CMP #FIX
	BEQ VPLTRU
	CMP #FLO
	BEQ VPLTRU
	CMP #LIST
	BEQ VPLFLS
	LDX #ARG1
	JSR ATMTNM
	BCS VPLTRU
	BCC VPLFLS	;(Always)

SCHARP:	LDA CHBUFR
	CMP CHBUFS
	BEQ VPLFLS	;If CHBUFR=CHBUFS, then buffer empty
	JMP VPLTRU

SPDBTN:	JSR GT1FIX
	LDX #NARG1
	JSR CHKPIN
	BCS SPDBNE
	LDX NARG1
	CPX #$03
	BCS SPDBNE
	LDA PADBTN,X
	BPL VPLFLS
	JMP VPLTRU
SPDBNE:	JMP GTERR1

.PAGE
.SBTTL		Word/List Primitives

;Primitives which give words as output:
; FIRST, LAST, BUTFIRST, BUTLAST, WORD, READCHARACTER, CHARACTER

;	Local variable block:
PNAME	=TEMPN6		;Pname ptr.
CHARS	=TEMPN5		;Characters

SFIRST:	LDX #ARG1
	JSR WRDLST
	BCC SFRST2
	LDA ARG1+1
	BEQ SDFNRR	;FIRST [] should giver error
	CARME ARG1
	JMP CHKARG	;Make sure we didn't produce a Q,D,Latom (fix it if so), output it
SDFNRR:	JMP ERXWT1
SFRST2:	LDY #PNAME
	LDX #ARG1
	JSR MAKPNM
	PHA		;Save funny-pname bit
	LDY #$00
	LDA (PNAME),Y
	BEQ SDFNRR	;FIRST " will give error
	STA CHARS
	STY CHARS+1
	CONS ARG1,CHARS,0,STRING
	PLA
	JMP FUNST1	;Put in funny-pname bit if there was one, and output

;	Local variable block:
CHARS	=TEMPN		;Characters

SLAST:	LDX #ARG2
	JSR WRDLST
	BCC SLST2
SLST1:	LDA ARG2+1
	BEQ SLSTR	;LAST [] will give error
	LDX #ARG2
	JSR GTLSTC
	CAR ARG1,ARG2
	JMP CHKARG	;Make sure we didn't produce a Q,D,Latom (fix it if so), output it
SLSTR:	JMP ERXWT2
SLST2:	LDY #ARG1
	LDX #ARG2
	JSR MAKPNM
	PHA
	LDY #$00
	LDA (ARG1),Y
	BEQ SLSTR
	LDX #ARG1
	JSR GTLSTC
	LDY #$01
	LDA (ARG1),Y
	BEQ SLST3
	STA CHARS
	LDA #$00
	STA CHARS+1
	CONS ARG1,CHARS,0,STRING
SLST3:	PLA
	JMP FUNST1	;Put in funny-pname bit if there was one, and output

;	Local variable block:
NEWCEL	=TEMPN		;New cons cell for Latom colon
CHARS	=TEMPN1		;String characters
FUNPNM	=ANSN2		;Funny-pname bit

CHKARG:	GETTYP ARG1	;If ARG1 is a Q,D, or Latom, make it a string that looks like pname
	CMP #QATOM	;(ie, add a prefix colon or quotes, or a postfix colon)
	BEQ CQATOM
	CMP #DATOM
	BEQ CDATOM
	CMP #LATOM
	BNE CKRGR
	LDX #ARG1	;It's an Latom, append a colon to it
	LDY #ARG2
	JSR GETPNM	;Get pname
	LDY #ARG1
	LDA ARG2
	LDX ARG2+1
	JSR COPY	;Get a new pname copy
	MOV ARG2,ARG1	;Save pointer, ARG1 will be final product
	LDX #ARG2
	JSR GTLSTC
	LDY #$01
	LDA (ARG2),Y	;Look at last char in cell
	BNE CLATM1	;If nonzero, have to cons new cell
	LDA #':		;Else just add colon
	BNE CLATM2	;(Always)
CLATM1:	LDA #':
	STA CHARS
	LDA #$00
	STA CHARS+1
	CONS NEWCEL,CHARS,0,STRING
	LDY #$02
	LDA NEWCEL	;Link new cell on
	STA (ARG2),Y
	INY
	LDA NEWCEL+1
CLATM2:	STA (ARG2),Y
CKRGR:	JMP OTPRG1	;Done, output it
CQATOM:	LDA #'"
	BNE CQDATM	;(Always)
CDATOM:	LDA #':
CQDATM:	PHA		;Save prefix character
	LDX #ARG1
	LDY #ARG2
	JSR GETPNM	;Get pname
	STA FUNPNM	;Save funny-pname bit
	LDY #ARG1
	LDA ARG2
	LDX ARG2+1
	JSR COPY	;Make a copy of the pname
	MOV ARG2,ARG1	;Save pointer
	PLA		;Prefix character
	STA CHARS
CQDLOP:	LDY #$01	;Loop pushes new character (in CHARS) into CAR,
	LDA (ARG2),Y
	STA CHARS+1	;Save second char.
	DEY
	LDA (ARG2),Y
	INY
	STA (ARG2),Y	;Put first char. in second char.
	LDA CHARS
	DEY
	STA (ARG2),Y	;Put new char in first char.
	LDA CHARS+1	;"new" char is last from this cell
	BEQ CKRGR1	;If zero, done!
	STA CHARS
	CDRME ARG2
	BNE CQDLOP
CQDDN1:	LDA CHARS+1	;If last cell, make a new one with last char.
	STA CHARS
	LDA #$00
	STA CHARS+1
	CONS NEWCEL,CHARS,0,STRING	;New cell with last char. in it
	RPLACD ARG2,NEWCEL	;Link it on to the string.
CKRGR1:	LDA FUNPNM
	JMP FUNST1		;Output it, with funny-pname bit
.PAGE
;	Local variable block:
OLDCAR	=TEMPN1
BEGPNM	=ANSN1		;Beginning of pname if zero
NEWNOD	=TEMPN2
NEWPTR	=TEMPN

SBTFST:	LDX #ARG2
	JSR WRDLST
	BCC SBFA
SBFL:	LDA ARG2+1
	BEQ SBFR
	CDR ARG1,ARG2
	JMP OTPRG1
SBFR:	JMP ERXWT2
;Not a list.
SBFA:	LDX #ARG2
	LDY #ARG1
	JSR MAKPNM
	PHA		;Save funny-pname bit
	VPUSH ARG1
	LDA #$00
	STA BEGPNM
	CAR OLDCAR,ARG1
	LDA OLDCAR
	BEQ SBFR	;Empty word gives error
SBFA1A:	LDX #$00
	LDA OLDCAR+1
	BEQ SBFB
	STA OLDCAR
	STX OLDCAR+1
	CONS NEWNOD,OLDCAR,0,STRING
	LDA BEGPNM
	BNE SBFC
	VPUSH NEWNOD
	INC BEGPNM
	BNE SBFC1	;(Always)
SBFC:	RPLACD NEWPTR,NEWNOD
SBFC1:	MOV NEWPTR,NEWNOD
SBFB:	CDRME ARG1
	BEQ SBFD
	LDX OLDCAR
	CAR OLDCAR,ARG1
	LDY #$00
	TXA
	STA (NEWPTR),Y
	INY
	LDA OLDCAR
	STA (NEWPTR),Y
	JMP SBFA1A
SBFD:	LDA BEGPNM
	BNE SBFDA
	LDA #ARG1
	JSR MAKMTW	;Make ARG1 the empty word
	JMP SBFD1
SBFDA:	VPOP ARG1
SBFD1:	VPOP NEWPTR
	PLA		;Retrieve funny-pname bit
	JMP FUNST1	;Output it, with a funny-pname bit if necessary

;	Local variable block:
NEWLST	=ANSN1
TMPCAR	=TEMPN1
PNAME	=TEMPN5		;Pname ptr.
ANSTYP	=ANSN2		;Result typecode
TEMP	=TEMPN
TEMP2	=TEMPN2

SBTLST:	LDX #ARG1
	JSR WRDLST
	BCS BTLSTL
BTLSTA:	LDY #PNAME
	LDX #ARG1
	JSR MAKPNM
	PHA		;Save funny-pname bit
	LDA #STRING
	STA ANSTYP
	LDY #$00
	LDA (PNAME),Y
	BEQ BTLSTR	;Empty word gives error
	MOV ARG1,PNAME
	BNE BTLSTX	;(Always)
BTLSTR:	JMP ERXWT1
BTLSTL:	STA ANSTYP
	LDA ARG1+1
	BEQ BTLSTR	;Emptry list gives error
BTLSTX:	LDA #$00
	STA NEWLST
	VPUSH ARG1
BTLSW:	LDY #$03
	LDA (ARG1),Y
	BEQ BTLSWE
	CAR TMPCAR,ARG1
	LDA #TEMP
	STA NODPTR
	LDY #TMPCAR
	LDX #$00
	LDA ANSTYP	;(List or String)
	JSR CONS
	LDA NEWLST
	BNE BTLSW2
	VPUSH TEMP
	INC NEWLST
	BNE BTLSW3	;(Always)
BTLSW2:	RPLACD TEMP2,TEMP
BTLSW3:	MOV TEMP2,TEMP
	CDRME ARG1
	JMP BTLSW
BTLSWE:	LDA ANSTYP
	BNE BTLWE1
	LDA NEWLST	;It's a list
	BNE BTLWL1
	LDA #$00
	STA ARG1+1
	BEQ BTLWL2	;(Always)
BTLWL1:	VPOP ARG1
BTLWL2:	VPOP TMPCAR
	JMP OTPRG1
BTLWE1:	CAR TMPCAR,ARG1	;It's a string
	BEQ BTLWE2
	LDA #$00
	STA TMPCAR+1
	CONS TEMP,TMPCAR,0,STRING
	LDA NEWLST
	BNE BTLWE3
	MOV ARG1,TEMP
	JMP BTLWE5
BTLWE3:	RPLACD TEMP2,TEMP
	JMP BTLWE4
BTLWE2:	LDA NEWLST
	BNE BTLWE4
	LDA #ARG1
	JSR MAKMTW	;Make ARG1 the empty word
	JMP BTLWE5
BTLWE4:	VPOP ARG1
BTLWE5:	VPOP TEMP
	PLA		;Retrieve funny-pname bit
	JMP FUNST1	;Put it on string and output it

;Initial processing for word/list primitives.
;Arg ptr. in X, returns Carry clear if Fix,Flo,Atom,Satom,String; set if List)
WRDLST:	JSR VPOP
	JSR GETTYP
	CMP #LIST
	BEQ LST		;(carry set if eq)
WRD:	CLC
LST:	RTS
.PAGE
;	Local variable block:
VSPPTR	=TEMPX1		;VSP arg. index (shared: STPTR1)
NEWARG	=TEMPX2		;Newest arg.
FUNPNM	=ANSN2		;Funny-pname flag

SWORD:	LDA #$00
	STA MARK4+1	;MARK4 is the result pointer
	STA FUNPNM	;Initially, the pname is not funny
	ASL NARGS
	LSR NARGS
	BEQ SWRD3
	JSR STPTR1	;VSPPTR := VSP + (NARGS * 2)
SWRDW:	COMP VSPPTR,VSP
	BEQ SWRD2
	CAR NEWARG,VSPPTR
	DEC2 VSPPTR
	LDY #MARK3	;MARK3 is the newest arg pname
	LDX #NEWARG
	JSR MAKPNM
	ORA FUNPNM	;If any word is a funny-pname,
	STA FUNPNM	;let it be known
	LDY #$00
	LDA (MARK3),Y
	BEQ SWRDW	;Ignore arg if empty pname
	JSR CONCAT	;MARK4 := (Concatenate MARK4 MARK3)
	JMP SWRDW
SWRD2:	JSR INCVSP	;VSP := VSP + (NARGS * 2)
SWRD3:	LDA MARK4+1
	BNE SWRD4
	LDA #MARK4
	JSR MAKMTW	;Make MARK4 the empty word
SWRD4:	LDY #$00
	LDA (MARK4),Y
	ORA FUNPNM	;Put in funny-pname bit
	STA (MARK4),Y
	VPUSH MARK4
	INC OTPUTN
	LDA #$00
	JSR CLMK4
	JMP POPJ

;	Local variable block:
COPY1	=TEMPN3		;Copy of MARK4
COPY2	=TEMPN4		;Copy of MARK3
CHARS	=TEMPN1		;String chars.
NXTCHR	=ANSN1		;Next character
NEWCEL	=TEMPN		;Newest cell ptr.

CONCAT:	LDA MARK4+1
	BNE CNCT1
	LDA MARK3	;MARK4 is Lnil, so make
	LDX MARK3+1	;MARK4 a copy of second word (MARK3) and return
	LDY #MARK4
	JMP COPY
CNCT1:	LDA MARK4	;Here, neither is empty
	LDX MARK4+1
	LDY #MARK2	;Make a copy of MARK4
	JSR COPY
	MOV COPY1,MARK2	;Save the first word's pointer
	LDX #COPY1	;Get the last cell of first word
	JSR GTLSTC
	LDY #$01
	LDA (COPY1),Y
	BEQ CNCODD
	LDA MARK3	;Even no. chars. in first word
	LDX MARK3+1
	LDY #COPY2	;Make a copy of second word
	JSR COPY
	RPLACD COPY1,COPY2	;Link second word onto first
CNCTWE:	MOV MARK4,MARK2	;Restore pointer to new word
	RTS
CNCODD:	LDY #$00	;Odd no. chars. in first word
	STY CHARS+1
	LDA (MARK3),Y	;Get first char. of second word
	INY
	STA (COPY1),Y	;Append it to end of first word
	LDA (MARK3),Y
	STA CHARS	;Second char. of second word
CNCTW:	LDA MARK3+1
	BEQ CNCTWE
	CDRME MARK3	;Advance second word char-ptr
	LDA CHARS	;If even-numbered char. of second word nil, exit
	BEQ CNCTWE	;(already appended odd-numbered char. preceeding)
	LDA MARK3+1
	BNE CNCTW1
	STA CHARS+1	;Zero last character (because odd no.)
	BEQ CNCTW2	;(Always) Just add last char. if end of second word
CNCTW1:	LDY #$00
	LDA (MARK3),Y
	STA CHARS+1	;Get odd-numbered (3,5,...) char.
	INY
	LDA (MARK3),Y
	STA NXTCHR	;Get next even-numbered (4,6,...) char.
CNCTW2:	CONS NEWCEL,CHARS,0,STRING	;Cons new cell
	LDY #$02
	LDA NEWCEL
	STA (COPY1),Y
	TAX
	INY
	LDA NEWCEL+1
	STA (COPY1),Y	;Append to new word
	STA COPY1+1
	STX COPY1	;New new-word end pointer
	LDA NXTCHR
	STA CHARS	;Last even char. becomes new odd char.
	JMP CNCTW

;	Local variable block:
NEWCPY	=ANSN1		;Returned copy ptr. addr.
STRNGP	=TEMPN1		;String ptr.
LSTCEL	=TEMPN2		;Last cell of copy
NEWCEL	=TEMPN		;New cons cell

COPY:	STY NEWCPY
	STA STRNGP	;Make NEWCPY point to a copy of STRNGP
	STX STRNGP+1
	TXA
	BNE CCOPY1
	STA $00,Y	;nil -> nil
	RTS
CCOPY1:	STY NODPTR	;Cons up an empty cell
	LDA #$00
	TAX
	TAY
	LDA #STRING
	JSR CONS
	LDX NEWCPY
	JSR VPUSHP	;Vpush forming string
COPYW:	LDX NEWCPY
	GETX LSTCEL	;LSTCEL points to empty last cell of copy
	LDY #$00
	LDA (STRNGP),Y
	STA (LSTCEL),Y	;Copy two characters into cell
	INY
	LDA (STRNGP),Y
	STA (LSTCEL),Y
	INY
	LDA (STRNGP),Y
	TAX
	INY
	LDA (STRNGP),Y
	STA STRNGP+1	;Advance char-ptr of original
	STX STRNGP
	TAX
	BEQ COPYWE	;Exit if end of original
	CONS NEWCEL,0,0,STRING	;Cons a new cell
	LDY #$02
	LDX NEWCPY
	LDA NEWCEL
	STA (LSTCEL),Y
	STA $00,X
	INY
	LDA NEWCEL+1
	STA (LSTCEL),Y	;Link new cell on to end of copy
	STA $01,X	;Advance copy's last-cell ptr
	JMP COPYW
COPYWE:	LDX NEWCPY	;Vpop copy's beginning pointer
	JMP VPOP
.PAGE
SFPUT:	VPOP ARG2
	VPOP ARG1
	GETTYP ARG2
	CMP #LIST
	BNE ERXWT2
	CONS ARG1,ARG1,ARG2,LIST
	JMP OTPRG1
ERXWT2:	ERROR XWTA,CURTOK,ARG2

;	Local variable block:
ELMENT	=TEMPN1
NEWNOD	=TEMPN2
NEWPTR	=TEMPN

SLPUT:	VPOP ARG2
	VPOP ARG1
	GETTYP ARG2
	CMP #LIST
	BNE ERXWT2
	LDA ARG2+1
	BNE SLPUT2
	CONS ARG1,ARG1,0,LIST
	JMP OTPRG1
SLPUT2:	MOV MARK2,ARG1	;Protect the last element
	MOV MARK3,ARG2	;Protect the original list (or what's left of it)
	JSR NXTLMN	;First element
	CONS MARK1,ELMENT,0,LIST	;Pointer to start of new list
	MOV NEWNOD,MARK1	;Pointer to newest node
SLPTW:	LDA MARK3+1	;Make a new list, element by element
	BEQ SLPT2
	JSR NXTLMN	;Get an element
	CONS NEWPTR,ELMENT,0,LIST	;New pointer to newest node
	LDY #$02
	LDA NEWPTR
	STA (NEWNOD),Y	;Pointer to last node
	TAX
	INY
	LDA NEWPTR+1
	STA (NEWNOD),Y	;(CDR) Link new node onto list
	STA NEWNOD+1
	STX NEWNOD
	JMP SLPTW
SLPT2:	CONS NEWPTR,ARG1,0,LIST	;Get a pointer to first argument
	RPLACD NEWNOD,NEWPTR	;Link final node on
	JMP SSN2	;MARK1 points to our new list

NXTLMN:	CARNXT ELMENT,MARK3
	RTS

SLIST:	ASL NARGS
	LSR NARGS
	LDA #$00
	STA MARK1+1
	LDA NARGS
	BEQ SLSTWE
SLISTW:	VPOP MARK2
	CONS MARK1,MARK2,MARK1,LIST
	DEC NARGS
	BNE SLISTW
SLSTWE:	MOV ARG1,MARK1
	LDA #$00
	JSR CLMK2
	JMP OTPRG1

;	Local variable block:
ELMCNT	=TEMPN2		;Element counter

SSNTNC:	LDA #$00
	STA MARK1+1
	ASL NARGS
	LSR NARGS
SSN1:	BNE SSNWA
SSN2:	MOV ARG1,MARK1
	LDA #$00
	JSR CLMK3
	JMP OTPRG1
SSNWA:	VPOP MARK2
	JSR GETTYP
	CMP #LIST
	BEQ SSNW1
	CONS MARK1,MARK2,MARK1,LIST
SSNW2:	DEC NARGS
	JMP SSN1
SSNW1:	LDA #$00
	STA ELMCNT
	STA ELMCNT+1
SSNX:	LDA MARK2+1
	BEQ SSNY
	CARNXT MARK3,MARK2
	VPUSH MARK3
	INC ELMCNT
	BNE SSNX
	INC ELMCNT+1
	BNE SSNX	;(Always)
SSNY:	LDA ELMCNT
	ORA ELMCNT+1
	BEQ SSNW2
SSNY1:	VPOP MARK3
	CONS MARK1,MARK3,MARK1,LIST
	DEC1 ELMCNT
	BCS SSNY1	;(Always)
.PAGE
.SBTTL		Miscellaneous Primitives

;	Local variable block:
NEWATM	=TEMPX1		;(Shared: INTSTR)

SMAKE:	VPOP ARG2
	VPOP ARG1
	JSR INTSTR	;Get a pointer to atom if there is one
	BCC ERXWT1	;Not a word, give error
	CMP #STRING
	BNE SMAKE2	;Not a string, then ok
	LDA #ARG1	;Pointer
	LDX #NEWATM	;Pname
	JSR INTRNX	;It's a string, make a new atom for it
	MOV NEWATM,ARG1
SMAKE2:	LDY #NEWATM	;It's ok, so give it the value
	LDX #ARG2
	JSR PUTVAL
	JMP POPJ
ERXWT1:	ERROR XWTA,CURTOK,ARG1

SOUTPT:	LDA LEVNUM
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ SOTPT1
	LDA FBODY+1
	BEQ SOTPT1	;If Fbofy is nil, we're in a break loop
	LDA EXPOUT
	BNE SOTPT3	;If output expected, give error
	INC STPFLG
	INC OTPUTN
	LDA NEST	;Set TRFLG to NEST so that UFUNCL
	STA TRFLG	;will tail-recurse with Output
	JMP POPJ
SOTPT1:	ERROR XNTL,CURTOK	;Error: Not toplevel
SOTPT3:	ERROR XOOP,CURTOK	;Error: OUTPUT out of place

SSTOP:	LDA LEVNUM
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ SOTPT1
	LDA FBODY+1
	BEQ SOTPT1	;If Fbody is nil, we're in a break loop
	INC STPFLG
STPOPJ:	JMP POPJ

SCOMMT:	LDA #$00
	STA TOKPTR+1
	JMP POPJ

SPAUSE:	LDA FBODY+1		;Ignore if toplevel of a break-loop
	BEQ CNTNDN
	ERROR XBRK		;Pause break

SCNTIN:	LDA BRKSP+1
	BEQ CNTNDN	;Ignore if not in a break-loop
	LDA #$01
	STA STPFLG
	INC COFLAG	;BRKLOP will return from break-loop
CNTNDN:	JMP POPJ
.PAGE
STEST:	VPOP ARG1
	JSR GTBOOL
	STY IFTEST
	JMP POPJ

SIFT:	JSR SIFX
	BNE SIF2
	JMP POPJ

SIFF:	JSR SIFX
	BEQ SIF2
	JMP POPJ

SIF:	JSR SIFX
	VPOP ARG1
	JSR GTBOOL
	TYA
	BNE SIF2
SIF3A:	JMP POPJ
SIF2:	LDX #NEXTOK
	JSR EXIFSC
	LDA TOKPTR+1
	BEQ SIF3A
SIF3:	CMPV NEXTOK,ELSE
	BNE SIF3A
	JSR TOKADV
	JMP POPJ

;	Local variable block:
TEMP	=TEMPN2

SELSE:	SEC
	LDA IFLEVL
	SBC #$01
	STA IFLEVL
	BCC SELSE1
	BNE SELSE2
	STA TOKPTR+1
	JMP POPJ
SELSE2:	LDX #TEMP
	JSR EXIFSC
	JMP POPJ
SELSE1:	ERROR XOOP,CURTOK

SIFX:	INC IFLEVL
	BNE SIFXA
	LDX #XIFLEX
	JMP EXCED
SIFXA:	JSR GTNXTK
	CMPV NEXTOK,THEN
	BNE SIFX1
	JSR TOKADV
SIFX1:	LDY IFTEST
	RTS
.PAGE
;	Local variable block:
ULNND1	=TEMPN3		;ULNEND save
ULINE	=TEMPN1
NEWATM	=TEMPX1		;(Shared: INTSTR)

SGO:	LDA LEVNUM
	ORA LEVNUM+1
	ORA LEVNUM+2
	BEQ SGOE
	LDA FBODY+1
	BEQ SGOE	;If Fbody is nil, we're in a break loop
	LDA EXPOUT
	BNE GOERR1
	VPOP ARG1
	CMP #FIX
	BNE GNTNUM
	CMP #FLO
	BNE GNTNUM
	LDX #ARG1
	LDY #ARG2
	JSR MAKPNM	;Make a string out of the number
	LDX #ARG2
GNTNUM:	JSR INTSTR	;Get a ptr. to the atom if there is one
	BCC SGOER2	;Not a word, so error
	CMP #STRING	;If not a string, it's ok, else can't find it
	BEQ SGOR2	;Can't find it error
SGO1:	LDA #LATOM
	LDX #NEWATM
	JSR PUTTYP
	MOV GOPTR,FBODY
	MOV ULNND1,ULNEND
	JSR GLNADV
SGOW:	LDA GOPTR+1
	BEQ SGOR
	LDX #ULINE
	LDY #GOPTR
	JSR GETULN
	CARME ULINE
	COMP NEWATM,ULINE
	BNE SGOW2
	JMP POPJ
SGOW2:	JSR GLNADV
	JMP SGOW
SGOR:	MOV ULNEND,ULNND1
SGOR2:	ERROR XLNF,ARG1		;Error: Can't find the label
SGOE:	ERROR XNTL,CURTOK	;Error: Not toplevel
SGOER2:	JMP ERXWT1	;Error: Don't like arg
GOERR1:	LDA #GO&$FF	;Explicitly signal error, "GO Didn't output"
	LDX #GO^
	JMP ERXNP1

SRUN:	VPOP ARG1
	JSR GETTYP
	CMP #LIST
	BNE SRUN2
	VPUSH TOKPTR	;Save old line
	JSR PARSEL	;Parse ARG1 into PRSBUF
	PUSHB EXPOUT
	VPUSH TOKPTR	;Save parsed list
	PUSHA SRNDON

;Executes the list in TOKPTR.
RUNHAN:	PUSHB UFRMAT
	PUSH ULNEND
	PUSHB RUNFLG
	LDX #$00
	STX UFRMAT	;Command line is of typecode List
	INX
	STX RUNFLG
	PUSHA RH1
	JMP EVLINE

RH1:	POPB RUNFLG
	POP ULNEND
	POPB UFRMAT
	JMP POPJ

SRUN1:	JMP GTERR1
SRUN2:	JMP ERXWT1

SRPEAT:	VPOP ARG2
	LDA ARG2
	PHA		;Save second arg through GT1FIX
	LDA ARG2+1
	PHA
	JSR GT1FIX
	LDX ARG1+3
	BMI SRUN1
	LDX NARG1
	LDY NARG1+1
	PLA		;Retrieve second arg as ARG1
	STA ARG1+1
	PLA
	STA ARG1
	TXA
	PHA		;Save the number through PARSEL
	TYA
	PHA
	LDA NARG1+2
	PHA
	LDA NARG1+3
	PHA
	GETTYP ARG1	;Check the second arg
	CMP #LIST
	BNE SRUN2
	VPUSH TOKPTR	;Save the rest of the command line
	PUSHB EXPOUT	;Save the Expected-output flag
	JSR PARSEL
	VPUSH TOKPTR	;Save the parsed list on the VPDL
	LDX #$03
SRPTL1:	PLA		;Retrieve the number
	STA ARG2,X
	DEX
	BPL SRPTL1
SRPLOP:	JSR CKN2ZR	;See if the repeat-counter is zero
	BNE SRPLP1	;Nonzero
SRNDON:	LDA OTPUTN	;Done repeating - If OTPUTN is 1, there's a value on the VPDL
	BEQ SRNDN1
	VPOP ARG1	;Get the value off the VPDL
SRNDN1:	VPOP TOKPTR	;Get list off of the VPDL (discarded)
	POPB EXPOUT
	VPOP TOKPTR	;Get the rest of the original line back
	LDA OTPUTN
	BEQ SRNDN2
	VPUSH ARG1	;Put the arg back if there is one
SRNDN2:	JMP POPJ

SRPLP1:	CLC		;Another repetition: Decrement the repeat-counter
	LDX #$FC
SRPL1L:	LDA ARG2+4,X
	SBC #$00
	STA ARG2+4,X
	INX
	BMI SRPL1L
SRPLP2:	PUSH ARG2	;Push the number (low word)
	PUSH ARG2+2	;(high word)
	PUSHA SREPT1	;Return to SREPT1 after executing
	JMP RUNHAN

SREPT1:	LDA OTPUTN	;See if there's an output on the VDPL
	BEQ SRPT1A
	VPOP ARG1	;Yes, get it
	LDA EXPOUT	;See if it was wanted
	BEQ RPTER1	;No, error
	DEC EXPOUT	;OK, but clear EXPOUT now
SRPT1A:	CDR TOKPTR,VSP	;Get the run-list but leave on VPDL
	LDA OTPUTN	;If there was an output on the VPDL
	BEQ SRPT1B
	VPUSH ARG1	;put it back
SRPT1B:	POP ARG2+2	;Pop the number (high bytes)
	POP ARG2	;(low bytes)
	LDA STPFLG	;If something set Stop-flag, stop repeating
	BNE SRNDON
	JMP SRPLOP	;Continue Repeating
RPTER1:	ERROR XUOP,ARG1
.PAGE
;	Local variable block:
NEWATM	=TEMPX1		;(Shared: INTSTR)

STHING:	VPOP ARG1
	JSR INTSTR
	BCC STH2	;Bad arg if not a word
	CMP #STRING
	BEQ STH1	;No value if not interned
	LDY #NEWATM
	LDX #ARG1
	JSR GETVAL
	BEQ STH1
OTPRG1:	INC OTPUTN
	VPUSH ARG1
	JMP POPJ
STH1:	ERROR XHNV,ARG2
STH2:	LDX #ARG2
	JMP ERXWTY

SREQU:	LDA OTPUTN	;Will be re-entered here after completion or from CO
	BNE SGPOPJ	;If OTPUTN set, just return, else try again
	PUSHA SREQU
	JSR GETLN
	SETV PLINE,PRSBUF
	LDA #$F0	;Negative PRSFLG tells Parser to parse as a list
	STA PRSFLG	;(Note - it gets incremented once inside)
	VPUSH TOKPTR	;Save rest of cammand line
	LDX #TOKPTR
	JSR PRSLIN	;Parse the line
	MOV ARG1,TOKPTR
	VPOP TOKPTR	;Restore command line
	JMP OTPRG1

SGCOLL:	JSR GARCOL
SGPOPJ:	JMP POPJ

SNODES:	SEC
	LDA #TYPLEN&$FF
	SBC NNODES
	STA NARG1
	LDA #TYPLEN^
	SBC NNODES+1
	STA NARG1+1
	JMP OTFXS1
.PAGE
;	Local variable block:
TLIST	=TEMPN2
NAME	=TEMPN3
VSPPTR	=TEMPN1
NEWATM	=TEMPX1		;(Shared: INTSTR)

SDEFIN:	VPOP ARG2
	VPOP ARG1
	JSR INTSTR
	BCC SDFNR1	;Bad arg if not a word
	CMP #SATOM
	BEQ SDFNR1	;Error if it's an Satom
	CMP #STRING	;Make a new atom if it's a string
	BNE SDEFN1
	LDX #NEWATM	;Name
	LDA #NAME	;Pointer
	JSR INTRNX
	JMP SDFN1A
SDEFN1:	MOV NAME,NEWATM
SDFN1A:	GETTYP ARG2
	CMP #LIST
	BNE DEFNER
	CAR ARG1,ARG2
	CDR TLIST,ARG2
	GETTYP ARG1
	CMP #LIST
	BNE DEFNER
	LDA ARG2+1
	BNE DEFUN1
	LDX #NAME
	JSR UNFUNC
	JMP POPJ
SDFNR1:	JMP ERXWT1	;Error: don't like arg1
DEFNER:	LDX #BODY
	JMP ERXWTX	;Error: don't like body
DEFUN1:	VPUSH TOKPTR	;Save the rest of the line
	VPUSH ARG2
	MOV VSPPTR,VSP
	JSR SWAPT1
	JSR PARSEL	;Parse the arglist
	JSR SWAPT2
	JSR CKTITL	;Make sure the arglist is legal
	VPUSH MARK1	;Vpush Arglist
	LDA #$00
	STA MARK1+1
DEFUNW:	LDA TLIST+1
	BEQ DEFNWE
	CAR ARG1,TLIST
	GETTYP ARG1
	CMP #LIST
	BNE DEFNER
	JSR SWAPT1	;Save variables
	JSR PARSEL
	JSR SWAPT2	;Retrieve variables
	VPUSH TOKPTR
	CDRME TLIST
	BNE DEFUNW
DEFNWE:	LDA #$00
	STA ARG2+1
DEFUNX:	COMP VSPPTR,VSP
	BEQ DEFNXE
	VPOP TLIST
	CONS ARG2,TLIST,ARG2,LIST
	JMP DEFUNX
DEFNXE:	MOV ARG1,NAME	;Can only give ARG1 to STUFF, won't like any temporaries
	LDX #ARG2
	LDA #ARG1
	JSR STUFF
	VPOP TLIST	;Vpop & discard LISTT
	VPOP TOKPTR	;Get the rest of the line back
	JMP POPJ
.PAGE
;	Local variable block:
FUN	=TEMPN5
BODY	=TEMPN6
VSPPTR	=TEMPN1
LINE	=TEMPN2
NEWATM	=TEMPX1		;(Shared: INTSTR)

STEXT:	VPOP ARG1
	JSR INTSTR	;Get the ptr. if there is one
	BCC STEXTR	;Error if not a word
	CMP #SATOM
	BEQ STEXTR	;or if Satom
	CMP #STRING
	BEQ STXT1B	;Return nil if not interned
	LDX #NEWATM
	LDA #FUN
	JSR GETFUN
	BNE STEXT1
	LDA #$00
	STA BODY+1
	BEQ STXT1A	;(Always)
STEXTR:	JMP ERXWT1	;Error: Doesn't like arg
STEXT1:	CDR BODY,FUN
	GETTYP BODY
	CMP #FPACK
	BNE STXT1A
STXT1B:	LDY #BODY
	LDX #FUN
	JSR UNSTUF
STXT1A:	VPUSH BODY
	INC OTPUTN
	JMP POPJ
.PAGE
;	Local variable block:
TOKEN	=TEMPX2		;Argument token ptr.
FUN	=TEMPX2		;Function ptr.
LENGTH	=TEMPX1		;Length of area for PTFTXT

STO:	LDA EXPOUT
	BNE STOER1	;Error if an output was expected
	JSR ZAPGR
	LDA INPFLG
	BNE DEFSTP
	JMP EDTST1	;Not in EDIT-eval loop, so call screen editor
STOER1:	LDA #TO&$FF
	LDX #TO^
	JMP ERXNP1	;Error "TO didn't output"
DEFSTP:	LDA TOKPTR+1	;In Edit-eval loop, so define a procedure
	BEQ ERELJ1
	JSR GETRG1	;car ARG1 from TOKPTR
	JSR TOKADV
	GETTYP ARG1
	CMP #SATOM
	BEQ EDTSR4
	CMP #ATOM
	BEQ DEFST1
	CMP #STRING
	BNE EDTSR5
	TXA		;Name
	JSR INTRNX	;Make a new atom
DEFST1:	MOV DEFATM,PODEFL,ARG1
	INC DEFFLG
	LDA #FUN
	LDX #ARG1
	JSR GETFUN
	BEQ STO1A
	JSR UNFNC1
STO1A:	LDA #$00
	STA NARGS
	JSR CKTITL
	CONS DEFBOD,MARK1,0,LIST
	LDA #$00
	STA LENGTH+1
	STA MARK1+1
	LDA NARGS
	STA LENGTH
	LDY #DEFBOD
	LDX #DEFATM
	LDA LENGTH
	JSR PTFTXT
	JMP POPJ
ERELJ1:	JMP ERXNMI
EDTSR4:	JMP ERXUBL
EDTSR5:	JMP ERXWT1

CKTITL:	MOV MARK1,TOKPTR
STOW:	LDA TOKPTR+1
	BEQ STOWE
	CAR TOKEN,TOKPTR
	GETTYP TOKEN
	CMP #ATOM
	BEQ STOW3
	CMP #SATOM
	BEQ STOW3
	CMP #DATOM
	BEQ STOW3
	CMP #STRING
	BNE CKTTLR
	TXA
	JSR INTRNX
	RPLACA TOKPTR,TOKEN
STOW3:	JSR TOKADV
	INC NARGS
	BPL STOW
	LDX #XNRGEX	;Error "Too many procedure inputs"
	JMP EXCED
CKTTLR:	LDX #TOKEN
	JMP ERXWTY

NXLIN1:	CARNXT LINE,FUN
STOWE:	RTS

SEND:	LDA INPFLG
	BEQ SENDR1	;Error if not in editor
	LDA DEFFLG
	BNE SEND1
	PRTSTR EXEND	;Warning if no procedure being defined
	JMP POPJ
SENDR1:	ERROR XNED
SEND1:	LDA #DEFATM
	LDX #DEFBOD
	JSR STUFF	;try to put the function def together
	LDA LEVNUM
	ORA LEVNUM+1
	ORA LEVNUM+2
	BNE SEND2	;No message if not at toplevel
	LDX #DEFATM
	JSR TYPE
	PRTSTR SENDM	;" DEFINED"
SEND2:	JSR EXTDEF
	JMP POPJ

;Can't bash X reg. (for ERROR)
EXTDEF:	LDA #$00
	STA DEFFLG
	STA DEFBOD+1
	STA DEFATM+1
	RTS
.PAGE
SPRINT:	LDA #SPACE
	JSR SPRNT
	JSR BREAK1
	JMP POPJ

SPRNT1:	LDA #$00
	JSR SPRNT
	JMP POPJ

;	Local variable block:
VSPPTR	=TEMPX1		;VSP pointer (shared: STPTR1)

SPRNT:	PHA		;Space-between-args flag
	ASL NARGS
	LSR NARGS
	BEQ SPRNT2
	JSR STPTR1	;VSPPTR := VSP + (NARGS * 2)
SPRNTW:	COMP VSPPTR,VSP
	BEQ PRNTWE
	CAR ARG1,VSPPTR
	DEC2 VSPPTR
	LDX #ARG1
	INC OTPFLG	;Tells not to print funny-pname quotes
	JSR TYPE
	DEC OTPFLG	;Reset OTPFLG
	PLA
	PHA
	BEQ SPRNTW
	JSR TPCHR
	JMP SPRNTW
PRNTWE:	JSR INCVSP	;VSP := VSP + (NARGS * 2)
SPRNT2:	PLA
	RTS
.PAGE
;	Local variable block:
FUN	=TEMPN1		;Function ptr.

SPO:	LDA TOKPTR+1
	BNE SPO1
	LDA PODEFL+1
	BNE SPO1A
	JMP POPJ
SPO1:	JSR GETRG1	;car ARG1 from TOKPTR
	JSR TOKADV
	LDX ARG1
	LDY ARG1+1
	CPX #ALL&$FF
	BNE SPO2
	CPY #ALL^
	BNE SPO2
	LDA #$01
	JSR POFUNS
SPON:	JSR PONAMS
	JMP POPJ
SPO2:	CPX #NAMES&$FF
	BNE SPO3
	CPY #NAMES^
	BEQ SPON
SPO3:	CPX #TITLES&$FF
	BNE SPO4
	CPY #TITLES^
	BNE SPO4
SPOTS:	LDA #$00
	JSR POFUNS
	JMP POPJ
SPO5A:	MOV PODEFL,ARG1
SPO1A:	LDX #PODEFL
	LDA #FUN
	JSR GETFUN
	BEQ PFERR
	LDA #$01
	LDX #PODEFL
	JSR POFUN
	JMP POPJ
SPO4:	CPX #PROCS&$FF
	BNE SPO5
	CPY #PROCS^
	BNE SPO5
	LDA #$01
	JSR POFUNS
	JMP POPJ
SPO5:	GETTYP ARG1
	CMP #ATOM
	BEQ SPO5A
	CMP #SATOM
	BEQ ERXUBL
	CMP #STRING
	BEQ PFERR
	JMP ERXWT1
ERXUBL:	ERROR XUBL,ARG1
PFERR:	ERROR XNDF,PODEFL
.PAGE
SERASE:	LDA TOKPTR+1
	BEQ ERXNMI
	JSR GETRG1	;car ARG1 from TOKPTR
	JSR TOKADV
	LDX ARG1
	LDY ARG1+1
	CPX #ALL&$FF
	BNE ECMP2
	CPY #ALL^
	BNE ECMP2
	JSR REINIT
	JMP TOPLOP
ERXNMI:	ERROR XNMI,CURTOK
ECMP2:	CPX #NAMES&$FF
	BNE ECMP3
	CPY #NAMES^
	BNE ECMP3
	JSR ERNAMS
	JMP POPJ
ECMP3:	CPX #TITLES&$FF
	BNE ECMP4
	CPY #TITLES^
	BEQ SERPS
ECMP4:	CPX #PROCS&$FF
	BNE SERAP
	CPY #PROCS^
	BNE SERAP
SERPS:	JSR ERPROS
ERPOPJ:	JMP POPJ
SERAP:	GETTYP ARG1
	CMP #ATOM
	BEQ SERAP1
	CMP #STRING
	BEQ ERPOPJ
	JMP ERXWT1
SERAP1:	JSR UNFNC1
	JMP POPJ

GETRG1:	CAR ARG1,TOKPTR
RTS30:	RTS

;	Local variable block:
OBPTR	=TEMPN		;Oblist ptr.
OBJECT	=TEMPN1		;Oblist object

ERPROS:	MOV OBPTR,OBLIST
ERPRSW:	LDA OBPTR+1
	BEQ RTS30
	CARNXT OBJECT,OBPTR
	LDX #OBJECT
	JSR UNFUNC
	JMP ERPRSW

;	Local variable block:
OBPTR	=TEMPN		;Oblist ptr.
SOBPTR	=TEMPN		;Soblist ptr.
NOVALU	=TEMPN1		;Novalue constant
NAME	=TEMPN2		;Name ptr.

ERNAMS:	MOV OBPTR,OBLIST
	LDA #$01
	STA NOVALU+1
ERNMSW:	LDA OBPTR+1
	BEQ ERNMWE
	CARNXT NAME,OBPTR
	LDX #NOVALU
	LDY #NAME
	JSR PUTVAL
	JMP ERNMSW
ERNMWE:	MOV SOBPTR,SOBLST
ERNMX:	COMP SOBPTR,SOBTOP
	BEQ RTS30
	LDX #NOVALU
	LDY #SOBPTR
	JSR PUTVAL
	INC4 SOBPTR
	JMP ERNMX

;	Local variable block:
NEWATM	=TEMPX1		;(Shared: INTSTR)
VALUE	=TEMPN1		;Name's value

SERNAM:	VPOP ARG1
	JSR INTSTR	;Get a ptr. if there is one
	BCC SERNR1	;Bad arg if not a word
	CMP #STRING
	BEQ SERNR	;Has no value if it's a string
	LDY #NEWATM
	LDX #VALUE
	JSR GETVAL
	BNE SERN3
SERNR:	ERROR XHNV,ARG1
SERNR1:	JMP ERXWT1	;Error - Don't like arg1
SERN3:	LDA #$01
	STA NOVALU+1
	LDX #NOVALU
	LDY #ARG1
	JSR PUTVAL
	JMP POPJ
.PAGE
;	Local variable block:
FR	=TEMPX1
XFR	=TEMPX2
PTR	=TEMPN6
PTR1	=TEMPN7
FIRST	=ANSN1
FUN	=TEMPNH
NAME	=TEMPN8

STRCBK:	LDA FRAME+1
	BNE TCBK1
	PRTSTR TBMSG1
	JMP POPJ
TCBK1:	PRTSTR TBMSG2
	LDA #$01
	STA FIRST
	MOV FR,FRAME
	MOV XFR,XFRAME
TCBKW:	LDA FR+1
	BNE TCBKW1
	JMP TCBKWE
TCBKW1:	CLC
	LDA FR
	ADC #SFBNDS	;Frame Bindings pointer
	STA PTR
	LDA FR+1
	ADC #$00
	STA PTR+1
	SEC
	LDA XFR
	SBC #$02	;PTR1 points to top binding (name)
	STA PTR1
	LDA XFR+1
	SBC #$00
	STA PTR1+1
TCBKX:	COMP PTR1,PTR
	BCC TCBKXE
	LDY #$01
	LDA (PTR1),Y
	STA FUN+1
	DEY
	LDA (PTR1),Y
	STA FUN
	ROR A
	BCC TCBKX2
	LDA FIRST
	BNE TCBKX3
	TPCHR COMMA
	TPCHR SPACE
	JMP TCBKX4
TCBKX3:	DEC FIRST
TCBKX4:	LDY #$05
	LDA (FUN),Y
	STA NAME
	INY
	LDA (FUN),Y
	STA NAME+1
	LDX #NAME
	JSR TYPE
TCBKX2:	SEC
	LDA PTR1
	SBC #$04
	STA PTR1
	BCS TCBKX
	DEC PTR1+1
	JMP TCBKX
TCBKXE:	LDY #SFXFRM	;Frame Xframe pointer
	LDA (FR),Y
	STA XFR
	INY
	LDA (FR),Y
	STA XFR+1
	LDY #SFFRAM	;Frame Previous-frame pointer
	LDA (FR),Y
	TAX
	INY
	LDA (FR),Y
	STA FR+1
	STX FR
	JMP TCBKW
TCBKWE:	JSR BREAK1
 	JMP POPJ

STRACE:	PRTSTR TRACEM
	LDA #$01
	STA TRACE
	TPCHR 'N
	JSR BREAK1
	JMP POPJ

SNTRAC:	PRTSTR TRACEM
	LDA #$00
	STA TRACE
	TPCHR 'F
	TPCHR 'F
	JSR BREAK1
	JMP POPJ
.PAGE
;	Local variable block:
PRODCT	=TEMPN		;Partial product (shared: IMULT)
RANGE	=TEMPN3		;Range

SRANDM:	JSR GT1FIX
	LDX #NARG1
	JSR CHKPBN
	BCS SRANDR
	MOV RANGE,NARG1
	SETV NARG2,RANDA	;Multiply 16-bit Random number by transform constant "A"
	MOV NARG1,RANDOM
	LDA #$00
	STA NARG1+2
	STA NARG1+3
	STA NARG2+2
	STA NARG2+3
	JSR IMULT
	CLC
	LDA PRODCT
	ADC #RANDC&$FF	;Add transform constant "C"
	STA RANDOM
	STA NARG1
	LDA PRODCT+1
	ADC #RANDC^
	STA RANDOM+1
	STA NARG1+1
	MOV NARG2,RANGE
	LDA #$00
	STA NARG1+2
	STA NARG1+3
	STA NARG2+2
	STA NARG2+3
	JSR IMULT
	LDA #$00
	STA PRODCT+4
	STA PRODCT+5
	LDY #PRODCT+2
	JMP OTPFIX
SRANDR:	JMP GTERR1

SRNDMZ:	MOV RANDOM,RNDL
SRPOPJ:	JMP POPJ
.PAGE
;	Local variable block:
CHARS	=TEMPN		;String characters

;Output a typed character. RDKEY looks in the buffer, if none there it
;waits for one, flashing the cursor.
SREADC:	LDA OTPUTN	;If OTPUTN is set, then we've got character, so return
	BNE SRPOPJ
	PUSHA SREADC	;Else return to SREADC again after a try in case of Pause
SRDC1:	JSR RDKEY
	JSR CKINTZ
	BCC SRDC1
OTPCHR:	STA CHARS
	LDA #$00
	STA CHARS+1
	CONS ARG1,CHARS,0,STRING	;Cons a cell with the character in it
	LDA #$01
	JMP FUNST1			;Give it a funny-pname bit, and output it

;Give string ARG1 the funny-pname bit in A (0 if none), and output it
FUNST1:	LDY #$00
	ORA (ARG1),Y
	STA (ARG1),Y
	JMP OTPRG1

;CHAR <number> returns character with ascii value <number>
SCHAR:	JSR GT1FIX	;Get integer arg
	LDX #NARG1
	JSR CHKINT	;Check 16 bits
	BCS SRANDR
	LDA NARG1+1	;Check for 8 bits
	BNE SRANDR
	LDA NARG1
	JMP OTPCHR

;	Local variable block:
PNAME	=TEMPN6

;ASCII <letter> returns ascii value of letter
SASCII:	VPOP ARG1	;Get arg
	LDX #ARG1
	LDY #PNAME
	JSR MAKPNM	;Get pname
	LDY #$01
	LDA (PNAME),Y	;Get the character
	BNE SRANDR	;we don't allow anything but 1-char strings
	DEY
	LDA (PNAME),Y
	JMP OTFXS2	;Output it as a number

SCURSR:	JSR GT2FIX
	LDX #NARG1
	LDA #$27
	JSR SMALFX
	BCS SCRSR1
	LDX #NARG2
	LDA #$17
	JSR SMALFX
	BCS SCRSR1
	LDA NARG1
	STA CH
	LDA NARG2
	STA CV
	JSR BCALCA
	JMP POPJ
SINDXR:	ERROR XUBL,CURTOK
SCRSR1:	ERROR XCSR	;"Position off of screen"

SCLINP:	JSR CLRCBF	;Clear input buffer and character strobe
	JMP POPJ

SCLEAR:	JSR HOME
	LDA BUFOWN
	BPL SCLR1
	LDA #$14	;If in GRAPHICS mode, put the
	STA CV		;cursor at the beginning of the
	JSR BCALCA	;text area
SCLR1:	JMP POPJ

SPADDL:	JSR GT1FIX
	LDX #NARG1
	JSR CHKPIN
	BCS SCALL2
	LDX NARG1
	CPX #$04
	BCS SCALL2
	JSR PREAD
	STY NARG1
	JMP OTFXS1
.PAGE
SEXAM:	JSR GT1FIX
	LDX #NARG1
	JSR CHKPBN
	BCS SCALL2
	LDY #$00
	LDA (NARG1),Y
	STA NARG1
	STY NARG1+1
	JMP OTFXS1

SDEP:	JSR GT2FIX	;First argument is location
	LDX #NARG1
	JSR CHKPBN
	BCS SCALL2
	LDX #NARG2
	JSR CHKPIN
	BCS SPKERR
	LDY #$00
	LDA NARG2
	STA (NARG1),Y
	JMP POPJ
SPKERR:	JMP GTERR2	;Error, ARG2 too big

SCALL:	JSR GT1FIX
	LDX #NARG1
	JSR CHKPBN
	BCS SCALL2
	LDA #<SCALL1-1>^
	PHA		;Push return address for RTS
	LDA #<SCALL1-1>&$FF
	PHA
	LDA KILRAM	;Enable the monitor for user routines
	JMP (NARG1)
SCALL2:	JMP GTERR1

;Make sure this is never shadowed by the monitor.
SCALL1:	NODRAM		;Return address for .CALL primitive
	JMP POPJ	;Enables default high RAM and exits

SINADR:	JSR GT1FIX
	LDX #NARG1
	JSR CHKINT
	BCS SCALL2
	LDA NARG1+1
	BNE SINAD3	;>255 means it is an address for sure.
	CMP NARG1
	BNE SINAD2
	SETV NARG1,KEYIN	;0, reset to kbd driver
	JMP SINAD3
SINAD2:	LDA NARG1
	CMP #$08	;1 to 7 means set to C#00.
	BCS SINAD3	;8-255, ok, if you really want to...
	LDA NARG1
	ORA #$C0
	STA NARG1+1
	LDA #$00
	STA NARG1
SINAD3:	MOV DEFINP,INPDEV,NARG1	;default input and inpdev get narg1
	JMP POPJ

SOTADR:	JSR GT1FIX
	LDX #NARG1
	JSR CHKINT
	BCS SCALL2
	LDA NARG1+1
	BNE SOTAD3	;>255 means it is an address for sure.
	CMP NARG1
	BNE SOTAD2
	SETV NARG1,COUT	;0, reset to screen driver
	JMP SOTAD3
SOTAD2:	LDA NARG1
	CMP #$08	;1 to 7 means set to C#00.
	BCS SOTAD3	;8-255, ok, if you really want to...
	LDA NARG1
	ORA #$C0
	STA NARG1+1
	LDA #$00
	STA NARG1
SOTAD3:	MOV DEFOUT,OTPDEV,NARG1	;default output and otpdev get narg1.
	JMP POPJ

;	Primitives which give errors if explicitly evaluated:

STHEN:	ERROR XOOP,CURTOK
SRPAR:	ERROR XRPN
SQFIER:	ERROR XOPO,CURTOK	;ALL, NAMES, TITLES, and PROCEDURES
.PAGE
.IFNE GRPINC	;Include Graphics if GRPINC nonzero
.SBTTL		Turtle-Graphics Primitives and Routines

SDRAW:	LDA BUFOWN
	BMI SDRAWA
SDRAWB:	JSR SDRAW1	;Init graphics buffer
	JMP POPJ
SDRAWA:	JSR SDRAW2	;Clear and show screen
	JMP POPJ

SCS:	LDA BUFOWN
	BPL SDRAWB
	JSR SCS1
	JMP POPJ

SNDSPL:	LDA BUFOWN
	BPL SND1	;Ignore if not graphics mode
	LDA TXTMOD	;Nodisplay, get the text page back
SND1:	JMP POPJ

SPENUP:	JSR GSTART
	LDA #$00	;Penup
	BEQ STPEN	;(Always)

SPENDN:	JSR GSTART
	LDA #$01	;Pendown
STPEN:	STA PEN
	JMP POPJ

SHOME:	JSR GSTART	;Init mode if necessary
	JSR TTLHOM	;Zero XCOR, YCOR, HEADING
	JSR GETX	;Get position params (now zero)
	JSR GETY
	JSR GDLINE	;Move turtle
	JMP POPJ

SXCOR:	JSR GSTART
	LDY #XCOR
	JMP OTPFLO

SYCOR:	JSR GSTART
	LDY #YCOR
	JMP OTPFLO

SHDING:	JSR GSTART
	LDY #HEADNG
	JMP OTPFLO
.PAGE
SRT:	JSR GSTART
	JSR GT1FLT
	LDY #HEADNG
	JSR XYTON2
	JSR FADD
	JSR MOD360
	JSR HDNDON
	JMP STRTTL

SLT:	JSR GSTART
	JSR GT1FLT
	LDY #HEADNG
	JSR XYTON2
	JSR FSUBX
	JSR MOD360
	JSR HDNDON
	JMP STRTTL

STS:	JSR GSTART	;Turtlestate
	LDA #$00
	STA MARK1+1
	LDA COLNUM
	JSR CONSN1
	LDA PALETN
	JSR CONSN1
	LDA TSHOWN
	JSR CONSTF
	LDA PEN
	JSR CONSTF
	LDA #HEADNG
	JSR CONSNM
	LDA #YCOR
	JSR CONSNM
	LDA #XCOR
	JSR CONSNM
	VPUSH MARK1
	INC OTPUTN
	LDA #$00
	STA MARK1+1
	JMP POPJ
.PAGE
SSETX:	JSR GSTART	;Init mode if necessary
	VPOP ARG1	;Get arg
	JSR GSETX	;Check and set X params
	JSR XOK		;Set new XCOR value
	JSR GETY	;Get Y params
	JSR GDLINE	;Move turtle
	JMP POPJ

SSETY:	JSR GSTART	;Init mode if necessary
	VPOP ARG1	;Get arg
	JSR GSETY	;Check and set Y params
	JSR YOK		;Set new YCOR value
	JSR GETX	;Get X params
	JSR GDLINE	;Move turtle
	JMP POPJ

;	Local variable block:
SAVRG2	=TEMPX2		;ARG2 save

SSETXY:	JSR GSTART	;Init mode if necessary
	VPOP SAVRG2	;Get Y arg
	VPOP ARG1	;Get X arg
	JSR GSETX	;Check and set X params
	MOV NARG1,SAVRG2
	JSR GSETY	;Check and set Y params
	JSR XOK		;Set new XCOR value
	JSR YOK		;Set new YCOR value
	JSR GDLINE	;Move turtle
	JMP POPJ

SSETH:	JSR GSTART
	VPOP ARG1
	JSR GSETH
STRTTL:	JSR GSHWT1
	JSR HOK
	JSR GSHWT1
	JMP POPJ
.PAGE
SSHOWT:	JSR GSTART
	LDA TSHOWN
	BNE SSHWTR
	INC TSHOWN
	JSR DRWTTL
SSHWTR:	JMP POPJ

SHIDET:	JSR GSTART
	LDA TSHOWN
	BEQ SSHWTR
	DEC TSHOWN
	JSR DRWTTL
	JMP POPJ

SFULL:	JSR GSTART
	LDA FULLGR
	JMP POPJ

SSPLIT:	JSR GSTART
	LDA MIXGR
	JMP POPJ

SWRAP:	JSR GSTART
	LDA #$01
	BNE SWRP1	;(Always)

SNOWRP:	JSR GSTART
	LDA #$00
SWRP1:	STA WRPFLG
	JMP POPJ
.PAGE
SFD:	JSR GSTART	;Init mode if necessary
	JSR GT1FLT	;Get a floating-pt. arg
SFD1:	JSR SFDX	;Check and set X,Y params
	JSR XOK		;Set new XCOR value
	JSR YOK		;Set new YCOR value
	JSR GDLINE	;Move turtle
	JMP POPJ

SBK:	JSR GSTART	;Init mode if necessary
	JSR GT1FLT	;Get a floating-pt. arg
	JSR FCOMPL	;Negate it
	JMP SFD1	;Do an FD

;	Local variable block:
LENGTH	=TEMPX1		;Line length
SGNX	=ANSN1		;X-Incr. sign (shared: GETSIN)
SGNY	=ANSN2		;Y-Incr. sign (shared: GETSIN)
FRACT	=TEMPN7		;Interpolation fraction (shared: GETSIN)
LOWENT	=TEMPN5		;Low table entry (shared: MULCOS,MULSIN)
HIENT	=TEMPN3		;High table entry (shared: MULCOS,MULSIN)

SFDX:	LDY #LENGTH	;Save arg in LENGTH
	JSR XN1TOY
	LDY #HEADNG
	JSR XYTON2	;Get HEADING in NARG2
	LDY #HEADNG
	JSR XYTON1	;And in NARG1
	JSR GETSN1	;Get the sine index and the fraction (FRACT)
	LDA NARG1	; and the signs (SGNX,Y)
	PHA		;Save table index
	JSR MULSIN	;Get sine and multiply by length
	LDY #FRACT
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #LOWENT
	JSR XYTON2	;Get uncorrected table value...
	JSR FADD	;and correct it!
	LDY #LENGTH
	JSR XYTON2	;Get length back
	JSR FMUL	;Multiply Length by fraction
	LDA SGNX	;Correct X-Incr. sign
	BEQ SFDP1
	JSR FCOMPL
SFDP1:	LDY #XCOR	;Get XCOR in NARG2
	JSR XYTON2
	JSR FADD	;Add X-Incr.
	JSR GSETXF	;Check for out-of-bounds
	PLA		;Retrieve sine table index
	STA NARG1
	JSR MULCOS	;Get cosine and multiply by length
	LDY #FRACT
	JSR XYTON2	;Restore interpolation fraction
	JSR FMUL	;Get interpolation correction
	LDY #HIENT
	JSR XYTON2	;Get uncorrected table value...
	JSR FSUBX	;and correct it!
	LDY #LENGTH
	JSR XYTON2	;Get length back
	JSR FMUL	;Multiply Length by fraction
	LDA SGNY	;Correct Y-Incr. sign
	BEQ SFDP2
	JSR FCOMPL
SFDP2:	LDY #YCOR
	JSR XYTON2	;Get YCOR in NARG2
	JSR FADD	;Add Y-Incr.
	JMP GSETYF	;Check for out-of-bounds
.PAGE
SPALET:	JSR GSTART
	JSR GT1FIX
	JSR CKCOLR
	LDX NARG1
	STX PALETN
	LDA CLTAB1,X	;Lookup the background color
	STA BKGND
	JSR SDRAW2
	LDX #$01	;Default is PC 1
	STX COLNUM
	LDA CLTAB1+1
	STA PNCOLR
	JMP POPJ

CKCOLR:	LDX #NARG1
	LDA #$06	;Highest palette no.
	JSR SMALFX	;Check the argument
	BCC CKCLR
	JMP GTERR1

SSPENC:	JSR GSTART
	JSR GT1FIX
	JSR CKCOLR
	LDX NARG1
	STX COLNUM
	LDA CLTAB1,X
	STA PNCOLR
	JMP POPJ

SSBKGD:	JSR GSTART
	JSR GT1FIX
	JSR CKCOLR
	LDX NARG1
	JSR BKGNDX
	JMP POPJ

BKGNDX:	CPX PALETN
	BEQ CKCLR
	LDA CLTAB1,X
	STX PALETN
	EOR BKGND
	JSR CBKGND
	LDX PALETN
	LDA CLTAB1,X
	STA BKGND
CKCLR:	RTS

SPENC:	LDA PNCOLR
	JMP OTFXS2

SBKGND:	LDA BKGND
	JMP OTFXS2

SSCNCH:	JSR GT1FLT
	SETNUM SCRNCH,NARG1
	JMP POPJ

;		  0	  1	  2	  3	  4	  5	  6
;Colors:	BLACK	WHITE	GREEN	VIOLET	BLUE	ORANGE	XOR
;Palettes:	BLACK	WHITE	GREEN	VIOLET	BLUE	ORANGE	SINGLE

;Color table.
CLTAB1:	$00
	$FF
	$2A
	$55
	$AA
	$D5
	$00
.PAGE
;	Local variable block:
SAVN2	=TEMPN5
SGNDX	=TEMPN7
SGNDY	=TEMPN7+1

STWRDS:	JSR GSTART
	JSR GT2NUM	;Get A and B
	BCS STWRD1
	JSR FLOTN1
	JSR FLOTN2
STWRD1:	LDY #EX2
	JSR XN1TOY	;Save NARG1
	LDY #YCOR
	JSR XYTON1	;Get YCOR in NARG1
	JSR FSUBX	;Get B-YCOR
	LDA NARG1+1
	STA SGNDY
	BPL STWRD2
	JSR FCOMPL
STWRD2:	LDY #SAVN2
	JSR XN1TOY	;Save B-YCOR
	LDY #EX2
	JSR XYTON1	;Get A back
	LDY #XCOR
	JSR XYTON2	;Get XCOR in NARG2
	JSR FSUB	;Get A-XCOR
	LDA NARG1+1
	STA SGNDX
	BPL STWRD3
	JSR FCOMPL
STWRD3:	LDY #SAVN2
	JSR XYTON2	;Get B-YCOR back
	JSR TWRD1
	LDA SGNDY
	BPL STWRD4
	SETNUM NARG2,F180
	JSR FSUBX	;Get 180-ANG
STWRD4:	LDA SGNDX
	BPL STWRD5
	SETNUM NARG2,F360
	JSR FSUBX	;Get 360-ANG
STWRD5:	JMP OTPFL1

TWRD1:	JSR CKN1ZR	;See if DX is 0 (DX is NARG1)
	BEQ TWRD2
	JSR CKN2ZR	;See if DY is 0 (DY is NARG2)
	BNE TWRD3
	SETNUM NARG1,F90	;DY = 0, output 90.
TWRD2:	RTS		;DX = 0, return with 0
TWRD3:	JSR FDIV	;Get DX/DY
	JMP GATAN

F90:	$86	; 90.0
	$5A
	$00
	$00
.PAGE
SRDPCT:	JSR GSTART
	JSR SRDX1
	LDX #SCRNM&$FF
	LDY #SCRNM^
	JSR SRDX2
	JSR DBLOAD	;Load the file
	LDX DSKB1
	STX PALETN
	LDA CLTAB1,X
	STA BKGND
	LDX DSKB2
	STX COLNUM
	LDA CLTAB1,X
	STA PNCOLR
	JSR GSHWT1	;Re-show turtle if shown
SRDPC1:	JMP POPJ

SSVPCT:	JSR GSTART
	JSR GTWRD1
	BNE SSVSR3
	JSR DTPATM	;Give DOS the name
	LDX #SCRNM&$FF
	LDY #SCRNM^
	JSR SRDX2
	LDA TSHOWN	;Hide turtle if shown
	PHA		;Save TSHOWN
	BEQ SSVST3
	DEC TSHOWN
	JSR DRWTTL
SSVST3:	LDA PALETN
	STA DSKB1
	LDA COLNUM
	STA DSKB2
	JSR DBSAVE	;Save the file
	PLA
	STA TSHOWN
	JSR GSHWT1
SSVPC1:	JMP POPJ
SSVSR3:	JMP ERXWT1

SERPCT:	JSR SDELTX
	LDX #SCRNM&$FF
	LDY #SCRNM^
	JSR SRDX2
	JSR DOSDEL	;DOS "DELETE" Routine
GRPOPJ:	JMP POPJ
.PAGE
;Graphics init routine: set up scrunch factor to GRPHK1.
GRINIT:	SETNUM SCRNCH,GRPHK1
	RTS

;Starts up graphics if not started
GSTART:	LDA INPFLG
	BNE GRPOPJ	;Ignore primitive if in eval-loop
	LDA BUFOWN	;Checks to see if Graphics mode
	BMI SDRAW3
SDRAW1:	LDX #$00	;Set up default palette and pencolor
	STX PALETN	;(Double width white on black)
	INX
	STX COLNUM
	LDA CLTAB1
	STA BKGND
	LDA CLTAB1+1	;Default is pencolor 1
	STA PNCOLR
	LDA PRMPAG	;Primary page
	LDA HGSW	;Hi-res style
	LDA MIXGR
	LDA #$00
	STA CH
	LDA #$14
	STA CV
	JSR BCALCA	;Put cursor at line 20.
	JSR CLREOP	;Clear to end of page
	LDA #$FF
	STA BUFOWN	;Indicate Graphics mode
SDRAW2:	LDA #$01	;Init the turtle
	STA PEN
	STA TSHOWN	;turtle shown
	JSR TTLHOM	;Zero XCOR, YCOR, HEADNG
SCS1:	JSR GETX
	JSR GETY
	JSR GPOSN	;Set initial POSN point for future GLINE's
	LDA BKGND
	JSR HBKGND
	JSR GSHWT1
SDRAW3:	LDA GSW		;Show the screen
	RTS

TTLHOM:	LDA #$00	;NOTE: XCOR,YCOR,HEADNG must be contiguous
	LDX #$0B
TTLL1:	STA XCOR,X
	DEX
	BPL TTLL1
XRDR:	RTS
.PAGE
;	Local variable block:
NUMPTR	=TEMPX1
XNUM	=TEMPN

CONSTF:	BNE CNSTF1
	LDY #FALSE
	BNE CNSNM1	;(Always)
CNSTF1:	LDY #TRUE
	BNE CNSNM1	;(Always)
CONSN1:	STA XNUM
	LDA #$00
	STA XNUM+1
	CONS NUMPTR,XNUM,0,FIX
	JMP CNSNM2
CONSNM:	TAX
	TAY
	INX
	INX
	LDA #NUMPTR
	STA NODPTR
	LDA #FLO
	JSR CONS	;CONS the number
CNSNM2:	LDY #NUMPTR
CNSNM1:	LDX #MARK1
	STX NODPTR
	LDA #LIST
	JMP CONS	;CONS the node

;	Local variable block:
LSTPTR	=TEMPX2		;Running arglist pointer
DSPTCH	=ANSN4		;Element disptach no.

SSETT:	JSR GSTART
	VPOP LSTPTR	;Setturtle
	JSR GETTYP
	CMP #LIST
	BNE SSETTR
	LDA #$F9	;Index for dispatching
	STA DSPTCH
SSETTL:	LDA LSTPTR+1
	BEQ SSETTD
	JSR SSTTLL
	INC DSPTCH
	BNE SSETTL
SSETTD:	JSR HOK
	JSR XOK
	JSR YOK
	JSR GDLINE
	LDA SPEN
	STA PEN
	LDA STSHWN
	STA TSHOWN
	LDX SPLTN
	JSR BKGNDX
	LDX SCLNM
	STX COLNUM
	LDA CLTAB1,X
	STA PNCOLR
	JMP POPJ
SSETTR:	JMP ERXWT1

SSTTPL:	JSR GT1FX1
	JSR CKCOLR
	LDA NARG1
	STA SPLTN
	RTS
SSTTPC:	JSR GT1FX1
	JSR CKCOLR
	LDA NARG1
	STA SCLNM
	RTS

SSTTLL:	CARNXT ARG1,LSTPTR
	LDX #ARG1
	LDY DSPTCH
	INY
	BEQ SSTTPC
	INY
	BEQ SSTTPL
	INY
	BEQ SSTTS
	INY
	BEQ SSTTP
	INY
	BEQ GSETH
	INY
	BNE GSETX
	JMP GSETY
SSTTS:	JSR GTBOOL
	INY
	TYA
	AND #$01
	STA STSHWN
	RTS
SSTTP:	JSR GTBOOL
	INY
	TYA
	AND #$01
	STA SPEN
	RTS
.PAGE
GSETH:	JSR GT1FLX	;Setheading
	JSR MOD360
HDNDON:	SETNUM SHEDNG,NARG1
	RTS

;	Local variable block:
XSCR	=A4L		;Screen X-coordinate
YSCR	=A5L		;Screen Y-coordinate
XCORD	=NARG2		;Mapped X coordinate
YCORD	=NARG2+2	;Mapped Y coordinate
QDRNT	=TEMPN6+1
HMASK1	=TEMPNH		;HMASK with MSB=0
HMASK2	=TEMPNH+1	;HMASK shifted left one bit

;Check and set the screen X parameter and XCOR value.
GSETX:	JSR GT1NUM		;Get numeric arg
	BCS GSETXF		;Separate handler for floating pt.
	JSR XCHK		;Check limits and position legality
	BCC STOX		;On screen if carry clear, else wraps off screen
	MOV XSCR,NARG1		;(Off screen) Set X param.
	;T1 := arg / width (int., +/-)
	;arg := arg - T1 * width (int.)
	JMP STOX1		;Set XCOR value and exit
STOX:	MOV XSCR,NARG1		;Set X param.
STOX1:	JSR FLOTN1		;Float for XCOR value
	SETNUM SVXCOR,NARG1	;Set XCOR value
	RTS
GSETXF:	SETNUM SVXCOR,NARG1	;Set XCOR value
	JSR RNDN1		;Round up to integer (Oflow error if can't)
	JSR XCHK		;Check limits and position legality
	BCC STOX1		;On screen if carry clear, else wraps off screen
	MOV XSCR,NARG1		;(Off screen) Set X param.
	;T1 := arg / width (int., +/-)
	;SVX/YCOR := SVX/YCOR - Float(T1 * width) (flt.)
	RTS

;Check integer parameter. Error if more'n 16 bits -
;if off screen, set carry if wrapping else error OOB.
XCHK:	LDX #NARG1
	JSR CHKINT		;Sixteen bits maximum.
	BCS ERXOFL		;Else overflow error
	TAX
	BMI XCHKM		;Separate check for negatives
	LDA NARG1+1		;Check positive range
	BNE XOFSCR		;Off screen
	LDA NARG1
	CMP #$8C		;Must be <140.
	BCS XOFSCR		;Off screen
XCHRTS:	RTS
XCHKM:	LDA NARG1+1		;Check negative range
	CMP #$FF
	BNE XOFSCR		;Off screen
	LDA #$74		;Must be >=-140.
	CMP NARG1
	BCC XCHRTS		;OK
XOFSCR:	LDA WRPFLG		;Coord. off screen (carry set)
	BNE XCHRTS		;OK if wrapping
	ERROR XOOB		;Error (OOB) if not wrapping
ERXOFL:	ERROR XOFL

;Check and set the screen Y parameter and YCOR value.
GSETY:	JSR GT1NUM		;Get numeric arg
	BCS GSETYF		;Separate handler for floating pt.
	JSR YCHK		;Check limits and position legality
	BCC STOY		;On screen if carry clear, else wraps off screen
	MOV YSCR,NARG1		;(Off screen) Set Y param.
	;T1 := arg / width (int., +/-)
	;arg := arg - T1 * width (int.)
	JMP STOY1		;Set YCOR value and exit
STOY:	MOV YSCR,NARG1		;Set Y param.
STOY1:	JSR FLOTN1		;Float for YCOR value
	SETNUM SVYCOR,NARG1	;Set YCOR value
	RTS
GSETYF:	SETNUM SVYCOR,NARG1	;Set YCOR value
	JSR RNDN1		;Round up to integer (Oflow error if can't)
	JSR YCHK		;Check limits and position legality
	BCC STOY1		;On screen if carry clear, else wraps off screen
	MOV YSCR,NARG1		;(Off screen) Set Y param.
	;T1 := arg / width (int., +/-)
	;SVY/YCOR := SVY/YCOR - Float(T1 * width) (flt.)
	RTS

;Check integer parameter. Error if more'n 16 bits -
;if off screen, set carry if wrapping else error OOB.
YCHK:	LDX #NARG1
	JSR CHKINT		;Sixteen bits maximum.
	BCS ERXOFL		;Else overflow error
	TAX
	BMI YCHKM		;Separate check for negatives
	LDA NARG1+1		;Check positive range
	BNE YOFSCR		;Off screen
	LDA NARG1
	CMP #$8C		;Must be <140.
	BCS YOFSCR		;Off screen
YCHRTS:	RTS
YCHKM:	LDA NARG1+1		;Check negative range
	CMP #$FF
	BNE YOFSCR		;Off screen
	LDA #$74		;Must be >=-140.
	CMP NARG1
	BCC YCHRTS		;OK
YOFSCR:	LDA WRPFLG		;Coord. off screen (carry set)
	BNE YCHRTS		;OK if wrapping
	ERROR XOOB		;Error (OOB) if not wrapping

;Set XCOR value to OK new one.
XOK:	SETNUM XCOR,SVXCOR
	RTS

;Set YCOR value to OK new one.
YOK:	SETNUM YCOR,SVYCOR
	RTS

;Set HEADING value to OK new one.
HOK:	SETNUM HEADNG,SHEDNG
	RTS
.PAGE
GDLINE:	JSR GSHWT1	;Hide the turtle if it is shown
	LDA PEN
	BNE GDLIN1
	JSR GPOSN	;Just do a GPOSN if pen is up
	JMP GSHWT1
GDLIN1:	JSR GLINE	;Draw the line

;Show/Hide the turtle if it is being shown
GSHWT1:	LDA TSHOWN	;If the turtle isn't shown, exit.
	BNE DRWTTL	
GSHWTR:	RTS

;Draw the turtle
DRWTTL:	LDY #HEADNG
	JSR XYTON1	;Get heading in NARG1
	LDA Y0		;Save enpoint state
	PHA
	LDA X0L
	PHA
	LDA X0H
	PHA
	SETNUM NARG2,FROTK1	;Get shift factor (2.5) in NARG2
	JSR FADD	;Shift turtle over 2.5 degrees
	JSR RNDN1	;Get the heading as a rounded integer
	LDA #$05
	JSR XDVDX	;Divide by 5 to get shape number
	LDX #$FF	;Quadrant counter
	LDA NARG1
	SEC
DRWL2:	INX		;indicate next quadrant
	SBC #$12	;See if it's smaller than 18. yet
	BCS DRWL2	;Nope, subtract 18.
	ADC #$12	;OK, add last subtraction back in
	ASL A		;Shift left to get table index
	TAY
	DATRAM		;Enable Ghost-memory
	LDA SHPTBL,Y
	STA SHAPE
	LDA SHPTBL+1,Y
	STA SHAPE+1
	NODRAM		;Disable Ghost-memory
	TXA		;Quadrant
	ASL A
	ASL A
	ASL A
	ASL A		;Multiply quadrant index by 4 to get rotation factor
	JSR XDRAW	;called with A = ROT, shape addr. in SHAPE
	PLA		;(X0H)
	TAY
	PLA		;(X0L)
	TAX
	PLA		;(Y0)
	JMP HPOSN	;Re-position at endpoint
.PAGE
;Get previous X param. from XCOR.
GETX:	LDY #XCOR
	JSR XYTON1
	JSR RNDN1	;Round up
	JMP STOX

;Get previous Y param. from YCOR.
GETY:	LDY #YCOR
	JSR XYTON1
	SETNUM NARG2,SCRNCH
	JSR FMUL	;Multiply by scrunch factor
	JSR RNDN1	;Round up
	JMP STOY
.PAGE
;Lowest-level graphics routines:

HCOLR1	=TEMPN3		;Interface labels to temporaries
COUNTH	=TEMPN3+1
DXL	=TEMPN5
DXH	=TEMPN5+1
DYL	=TEMPN6
DYH	=TEMPN6+1
EL	=TEMPN7
EH	=TEMPN7+1
DOTCNT	=TEMPN8
QDRNT	=ANSN2
SHAPEX	=ANSN3

HBKGND:	STA HCOLR1
	LDA #$20
	STA SHAPE+1	;SHAPE is byte address
	LDY #$00
	STY SHAPE
BKGND1:	LDA HCOLR1
	STA (SHAPE),Y
	JSR CSHFT2	;Shift mask over every byte (XABABABA -> XBABABAB)
	INY
	BNE BKGND1
	INC SHAPE+1	;Next page
	LDA SHAPE+1
	CMP #$40
	BNE BKGND1
	RTS

;XORs HCOLR1 with every screen byte.
CBKGND:	STA HCOLR1
	LDA #$20
	STA SHAPE+1	;SHAPE is byte address
	LDY #$00
	STY SHAPE
CBKGN1:	LDA (SHAPE),Y
	EOR HCOLR1
	STA (SHAPE),Y
	JSR CSHFT1	;Shift mask over
	INY
	BNE CBKGN1
	INC SHAPE+1	;Next page
	LDA SHAPE+1
	CMP #$40
	BNE CBKGN1
	RTS

;Map X,Y params. into screen coordinates
GNORM:	SEC
	LDA #$60
	SBC YSCR	;Subtract YSCR from 96.
	STA YCORD
	LDA #$00
	SBC YSCR+1
	STA YCORD+1
	CLC
	LDA XSCR
	ADC #$8C	;Add 140. to XSCR
	STA XCORD
	LDA XSCR+1
	ADC #$00
	STA XCORD+1
	RTS

GPOSN:	JSR GNORM
	LDX XCORD
	LDY XCORD+1
	LDA YCORD
HPOSN:	STA Y0		;Calculates HBASLN and HNDX from dot coordinates
	STX X0L		;Just trust it, don't ask any questions...
	STY X0H
	PHA
	AND #$C0
	STA HBASLN	;Y coord. is ABCDEFGH
	LSR A
	LSR A
	ORA HBASLN
	STA HBASLN	;HBASLN now ABAB0000
	PLA
	STA HBASLN+1	;HBASLN+1 now ABCDEFGH
	ASL A
	ASL A
	ASL A		;A now DEFGH000
	ROL HBASLN+1	;HBASLN+1 now BCDEFGHC
	ASL A		;A now EFGH0000
	ROL HBASLN+1	;HBASLN+1 now CDEFGHCD
	ASL A		;A now FGH00000
	ROR HBASLN	;HBASLN now EABAB000
	LDA HBASLN+1
	AND #$1F
	ORA #$20
	STA HBASLN+1	;HBASLN,+1 now 001FGHCD EABAB000 (of course)
	TXA		;(X coord. low in A, high in Y)
	CPY #$00	;High byte either 0 or 1
	BEQ HPOSN2	;It's 0, start byte count (Y) at 0
	LDY #$23	;It's 1, start byte count at $23 and add four to X coord.
	ADC #$04	;(because $23 * 7 + 4 = $FF, that's why)
HPOSN1:	INY
HPOSN2:	SBC #$07	;Subtract sevens until borrow set
	BCS HPOSN1
	STY HNDX	;Byte count is offset index (for memory accesses from HBASLN)
	TAX		;Remainder specifies bit position, get the byte mask
	LDA MSKTBL-249,X
	STA HMASK
	TYA
	LSR A		;Sets carry if on odd byte
	LDA PNCOLR
HPOSN3:	STA HCOLR1	;Deposits the color mask, shifts it
	BCS CSHFT2	;if we are on an odd byte
	RTS

LFTRT:	BPL RIGHT	;Sign of A determines left/right direction
	LDA HMASK	;Going left: rotate bits right (Apple's shift register is
	LSR A		;in backwards, no doubt...)
	BCS LEFT1	;Whoops, into next byte
	EOR #$C0	;Change the top bits (ie bit 6 off, bit seven on)
LR1:	STA HMASK
	RTS

LEFT1:	DEY		;Mask bit was bumped into MSB of the byte to the left
	BPL LEFT2	;If we're at the left edge,
	LDY #$27	;then wrap around
LEFT2:	LDA #$C0
NEWNDX:	STA HMASK	;New HMASK along with
	STY HNDX	;new horiz. index, let's see
CSHFT1:	LDA HCOLR1	;if the color mask should be shifted...
CSHFT2:	ASL A		;Reverses color mask if necessary.
	CMP #$C0	;CMP gives Minus if top two bits different
	BPL GRTS1	;i.e., reverse mask only if mask isn't solid
	LDA HCOLR1
	EOR #$7F	;XABABABA -> XBABABAB
	STA HCOLR1
GRTS1:	RTS

RIGHT:	LDA HMASK	;Going right: shift mask to the left (backwards shift register,
	ASL A		;again...)
	EOR #$80	;Reverse top bit
	BMI LR1		;Mask OK if bit 7 on (ie bit 6 was off)
	LDA #$81	;The new mask (bit 0 on)
	INY		;Incr. horiz. index
	CPY #$28	;If at edge, wrap around. Store new mask.
	BCC NEWNDX
	LDY #$00
	BCS NEWNDX	;(Always taken)
.PAGE
LRUDX1:	CLC
LRUDX2:	LDA SHAPEX
	AND #$04
	BEQ LRUD4
	LDA #$7F
	AND HMASK
	EOR (HBASLN),Y
	STA (HBASLN),Y
LRUD4:	LDA SHAPEX
	ADC QDRNT
EQ3:	AND #$03
	CMP #$02
	ROR A
	BCS LFTRT
UPDWN:	BMI DOWN4	;Dispatch off sign in A
	CLC		;We're going up
	LDA HBASLN+1	;No need to extrapolate the details...
	BIT EQ1C
	BNE UP4
	ASL HBASLN
	BCS UP2
	BIT EQ3+1
	BEQ UP1
	ADC #$1F
	SEC
	BCS UP3		;(Always taken)
UP1:	ADC #$23
	PHA
	LDA HBASLN
	ADC #$B0
	BCS UP5
	ADC #$F0
UP5:	STA HBASLN
	PLA
	BCS UP3
UP2:	ADC #$1F
UP3:	ROR HBASLN
UP4:	ADC #$FC
UPDWN1:	STA HBASLN+1
	RTS

DOWN4:	LDA HBASLN+1	;We're going down
EQ4:	ADC #$04	;Weeeeeee...
	BIT EQ1C
	BNE UPDWN1
	ASL HBASLN
	BCC DOWN1
	ADC #$E0
	CLC
	BIT EQ4+1
	BEQ DOWN2
	LDA HBASLN
	ADC #$50
	EOR #$F0
	BEQ DOWN3
	EOR #$F0
DOWN3:	STA HBASLN
	LDA #$20
	BCC DOWN2
DOWN1:	ADC #$E0
DOWN2:	ROR HBASLN
	BCC UPDWN1	;(Always branches)
.PAGE
GLINE:	JSR GNORM	;Map coordinates onto Apple's axes
	LDA YCORD
	CMP Y0
	BCS GLINE1	;OK if drawing downwards or horiz.
;Draw line in reverse: switch endpoints; position, draw line, then reposition
	LDA XCORD
	PHA		;Save XCORD
	TAX
	LDA X0L
	STA XCORD	;Switch with X0
	LDA XCORD+1
	PHA
	TAY
	LDA X0H
	STA XCORD+1
	LDA YCORD
	PHA		;Save YCORD
	LDA Y0
	STA YCORD	;Switch with Y0
	PLA
	PHA
	JSR HPOSN	;Position turtle at destination
;???HPOSN won't be able to hack X,YCORD off of screen due to wrapping (we is screwed...)!
;1.Find integral screen-length displacements of Dest.; normalize Dest to on-screen
;2.Add displacements (or subtract, whatever is the reverse) to Origin-pt.
;3.Posn at normalized Dest.
;4.Gline with dest being the displaced origin-pt. and origin being the current posn.
;5.Posn at normailzed Dest again
	LDA HBASLN	;Save destination state
	PHA
	LDA HBASLN+1
	PHA
	LDA HMASK
	PHA
	LDA HCOLR1
	PHA
	LDA HNDX
	PHA
	JSR GLINE1	;Draw line (from destination to original position)
	PLA		;Update turtle position to destination
	STA HNDX
	PLA
	STA HCOLR1
	PLA
	STA HMASK
	PLA
	STA HBASLN+1
	PLA
	STA HBASLN
	PLA		;Retrieve destination coords.
	STA Y0
	PLA
	STA X0H
	PLA
	STA X0L
	RTS

;Draws a line from X0,Y0 (current position) to XCORD,YCORD (new destination)
;(Note: YCORD has been set >= Y0 so that lines are retraced properly)
GLINE1:	LDA HNDX
	LSR A
	LDA PNCOLR
	JSR HPOSN3	;Deposit and init color mask (shifts if necessary)
	SEC
	LDA XCORD
	SBC X0L		;Compare X0 and XCORD
	PHA
	LDA XCORD+1
	SBC X0H
	STA QDRNT	;Quadrant := XCORD - X0, sign determines right or left dir.
	BCS HLIN2	;Branch if XCORD geq X0
	PLA		;Retrieve XCORD - X0 (low)
	EOR #$FF	;Negate
	ADC #$01
	PHA		;Save again
	LDA #$00
	SBC QDRNT	;Negative QDRNT for...
HLIN2:	STA DXH		;X-Incr. := ABS ( XCORD - X0 )
	STA EH
	PLA
	STA DXL
	STA EL
	CLC
	LDA Y0
	SBC YCORD
	STA DYL
	LDA Y0+1
	SBC YCORD+1
	STA DYH		;Y-Incr. := (Y0 - YCORD) - 1 (always negative)
	ROR QDRNT	;QDRNT sign bit gets 0 (always)
	SEC		;(so bit 6 is now right/left direction select)
	LDA DYL		;Compute - (Delta.X + Delta.Y + 1)
	SBC DXL
	STA DOTCNT
	LDA DYH
	SBC DXH
	STA DOTCNT+1
	LDY HNDX	;Y has horiz. index during loop
	BCS MOVEX2	;(Always taken)
MOVEX:	ASL A		;Move horizontally: Bit 6 of QDRNT (in A)
	JSR LFTRT	;determines direction, LFTRT looks at sign (bit 7)
	SEC
MOVEX2:	LDA EL		;(Carry set here) 
	ADC DYL
	STA EL		;Compute epsilon
	LDA EH
	ADC DYH		;Carry bit after this operation determines horiz. or vert. movement
HCOUNT:	STA EH
	PHP		;Save carry through dot computation
	LDA HMASK
	ASL A
	STA HMASK2
	LSR A
	STA HMASK1
	JSR FIGDOT	;hack up a correctly-colored/placed dot-byte
	STA (HBASLN),Y	;put it where it shows
	PLP		;Restore carry for branch
	INC DOTCNT	;incr. dot counter
	BNE HLIN4	;continue if not done
	INC DOTCNT+1
	BNE HLIN4
	RTS
HLIN4:	LDA QDRNT	;(sign of QDRNT says whether to move right or left)
	BCC MOVEX	;If carry clear from "MOVEX2" computation, move horiz.
	JSR UPDWN	;else move vertically
	CLC
	LDA EL		;Update epsilon
	ADC DXL
	STA EL
	LDA EH
	ADC DXH
	BVC HCOUNT	;(Always taken) Continue looping
.PAGE
;The high bit is set because the parity of the top bits (6,7)
;determine when the color mask should be shifted)
MSKTBL:	$81
	$82
	$84
	$88
	$90
	$A0
	$C0

EQ1C:	$1C

COS:	$FF
	$FE
	$FA
	$F4
	$EC
	$E1
	$D4
	$C5
	$B4
	$A1
	$8D
	$78
	$61
	$49
	$31
	$18
	$FF
.PAGE
XDRAW:	TAX		;Enter with ROT in A & X, shape addr. in SHAPE
	LSR A
	LSR A
	LSR A
	LSR A
	STA QDRNT
	TXA
	AND #$0F
	TAX
	LDY COS,X
	STY DXL		;Cosine in DX
	EOR #$0F
	TAX
	LDY COS+1,X
	INY
	STY DYL		;Sine in DYL
XDRAW2:	LDY HNDX
	LDX #$00
	DATRAM		;Enable ghost-memory
	LDA (SHAPE,X)
	BEQ XDRTS
XDRAW3:	STA SHAPEX
	NODRAM		;Disable ghost-memory
	LDX #$80
	STX EL
	STX EH
	LDX #$01	;Scale
XDRAW4:	LDA EL
	SEC
	ADC DXL
	STA EL
	BCC XDRAW5
	JSR LRUDX1
	CLC
XDRAW5:	LDA EH
	ADC DYL
	STA EH
	BCC XDRAW6
	JSR LRUDX2
XDRAW6:	DEX
	BNE XDRAW4
	LDA SHAPEX
	LSR A
	LSR A
	LSR A
	BNE XDRAW3
	INC1 SHAPE
	DATRAM		;Enable ghost-memory
	LDA (SHAPE,X)
	BNE XDRAW3
	NODRAM		;Disable ghost-memory
XDRTS:	RTS
.PAGE
;	Local variable block:
LBYTE	=ANSN4		;Left byte modify

FIGDOT:	LDA COLNUM
	CMP #$06	;PC 6 is XOR mode
	BNE FIGDT1
	LDA HMASK1	;XOR: dot
	EOR (HBASLN),Y
	RTS
FIGDT1:	LDA #$00
	STA LBYTE
	LDA PALETN
	BEQ C3TO5	;Black background (double width)
	CMP #$06
	BEQ C1TO2	;Black background (single width)
	CMP #$01
	BEQ C6TO8	;White background
	LDA HCOLR1	;Colored background here
	AND #$7F
	BEQ CASE5	;Black line, off: dot,dot+1
	CMP #$7F
	BEQ CASE3	;White line, on: dot,dot+1
	LDA PNCOLR	;Colored line here
	CMP BKGND
	BNE CAS10	;Other color line, on: dot; off: dot-1,dot+1 (or shift+1)
	JMP CAS12	;Same color line, on: dot-1,dot+1; off: dot (or shift+1)
C3TO5:	LDA HCOLR1	;Black background (double width)
	AND #$7F
	BEQ CASE5	;Black color, off: dot,dot+1
	CMP #$7F
	BNE CAS10F	;Colored line
CASE3:	LDA HMASK1	;On: dot,dot+1
	LSR A
	ROR LBYTE	;Dot+1
	ORA HMASK1	;Dot
	JMP FXCON
CASE5:	LDA HMASK1	;Off: dot,dot+1
	LSR A
	ROR LBYTE	;Dot+1
	ORA HMASK1	;Dot
	JMP FXCOFF
C1TO2:	LDA HCOLR1	;Black background (single width)
	AND #$7F
	BEQ FXCIOF	;Black line, off: dot
	LDA (HBASLN),Y
	EOR PNCOLR	;Match high bit
	BPL FXCION
	EOR PNCOLR
	EOR #$80
	STA (HBASLN),Y
FXCION:	LDA HMASK1	;On: dot
	ORA (HBASLN),Y
	RTS
FXCIOF:	LDA HMASK1	;Off: dot
	EOR #$FF
	AND (HBASLN),Y
	RTS
C6TO8:	LDA HCOLR1	;White background
	AND #$7F
	BEQ CASE5	;Black line, off: dot,dot+1
	CMP #$7F
	BNE CAS10F
	JMP CASE8	;White line, on: dot-1,dot,dot+1,dot+2
CAS10F:	LDA (HBASLN),Y	;Colored line, on: dot; off: dot-1, dot+1 (or shift+1)
	EOR PNCOLR	;Match high bit
	BPL C6TO8A
	EOR PNCOLR
	EOR #$80
	STA (HBASLN),Y
C6TO8A:	LDA HCOLR1
	AND HMASK1
	BNE CAS10A	;Match
	LDA HMASK1
	LSR A
	BCC CAS10B	;OK if not bit 0
	TYA		;Else match high bit of leftmost byte
	BEQ CAS10B	;Ignore if at left edge
	DEY
	LDA (HBASLN),Y
	EOR PNCOLR
	BPL C6TO8B
	EOR PNCOLR
	EOR #$80
	STA (HBASLN),Y
	JMP C6TO8B
CAS10:	LDA HCOLR1
	AND HMASK1
	BEQ CAS10B	;No match
CAS10A:	LDA HMASK1	;On: dot; off: dot-1,dot+1
	ORA (HBASLN),Y	;Dot
	STA (HBASLN),Y
	LDA HMASK1
	LSR A
	ROR LBYTE	;Dot+1
	ORA HMASK2	;Dot-1
	JMP FXCOFF
C6TO8B:	INY
CAS10B:	LDA HMASK1	;On: dot+1; off: dot,dot+2
	LSR A
	ROR LBYTE
	LSR A
	ROR LBYTE	;Dot+2
	ORA HMASK1	;Dot
	JSR FXCOFF
	STA (HBASLN),Y
	LDA #$00
	STA LBYTE
	LDA HMASK1
	LSR A
	ROR LBYTE	;Dot+1
	TAX		;(FXCON wants status of A)
	JMP FXCON
CAS12:	LDA HCOLR1
	AND HMASK1
	BNE CAS12A	;Match
CAS12B:	LDA HMASK1	;On: dot-1,dot+1; Off:dot
	EOR #$FF
	AND (HBASLN),Y	;Dot
	STA (HBASLN),Y
	LDA HMASK1
	LSR A
	ROR LBYTE	;Dot+1
	ORA HMASK2	;Dot-1
	BNE FXCON	;(Always)
CAS12A:	LDA HMASK1	;On: dot,dot+2; Off:dot+1
	LSR A
	ROR LBYTE
	LSR A
	ROR LBYTE	;Dot+2
	ORA HMASK1	;Dot
	JSR FXCON
	STA (HBASLN),Y
	LDA #$00
	STA LBYTE
	LDA HMASK1
	LSR A
	ROR LBYTE	;Dot+1
	TAX		;(FXCOFF wants status of A)
	JMP FXCOFF
CASE8:	LDA HMASK1	;On: dot-1,dot,dot+1,dot+2
	LSR A
	ROR LBYTE
	ORA HMASK1	;Dot+1
	LSR A
	ROR LBYTE	;Dot+2
	ORA HMASK1	;Dot
	ORA HMASK2	;Dot-1
FXCON:	PHA		;Save middle mask
	BPL FXCN1	;Right ok
	CPY #$27	;At right edge?
	BEQ FXCN1	;Yes, ignore
	INY		;Next byte
	LDA #$01	;Leftmost bit on
	ORA (HBASLN),Y
	STA (HBASLN),Y
	DEY		;Middle byte
FXCN1:	LDA LBYTE
	BEQ FXCN2	;Left ok
	CPY #$00	;At left edge?
	BEQ FXCN2	;Yes, ignore
	DEY		;Previous byte
	LSR A		;Position the mask
	ORA (HBASLN),Y	;Bits on
	STA (HBASLN),Y
	INY		;Back to middle
FXCN2:	PLA		;Retrieve middle mask
	AND #$7F	;Zap top bit
	ORA (HBASLN),Y	;Bits on
	RTS
FXCOFF:	PHA
	BPL FXCF1
	CPY #$27
	BEQ FXCF1
	INY
	LDA #$FE
	AND (HBASLN),Y
	STA (HBASLN),Y
	DEY
FXCF1:	LDA LBYTE
	BEQ FXCF2
	CPY #$00
	BEQ FXCF2
	DEY
	LSR A
	EOR #$FF
	AND (HBASLN),Y
	STA (HBASLN),Y
	INY
FXCF2:	PLA
	AND #$7F
	EOR #$FF
	AND (HBASLN),Y
	RTS
.PAGE
;	Constants:
FROTK1:	$81	;Floating-point constant, 2.5
	$50
	$00
	$00

GRPHK1:	$7F	;Floating-point constant, 0.8 (scrunch factor)
	$66
	$66
	$66

.ENDC		;End of conditional graphics inclusion
.PAGE
.IFNE MUSINC
.SBTTL		Music Primitives and Routines

PSIZE	=TEMPN3			;length of all parameter buffers together.
MBUFLN	=TEMPN2			;length of each music buffer.
MPPRT	=TEMPX2			;needed only during the scope of PM.
COUNT	=TEMPX2+1		;used in NVOICES as a temporary.

;These are the codes for the commands that are stored in the music buffers.
;All have the msb set.
HINOTE	=71			;Yes, decimal.
CREST	=HINOTE+1

;INITLZ calls this routine.
MSINIT:	LDA #MSLOTI
	STA MSLOT		;Assume slot number is MSLOTI
;	...

;Make the ALF card be quiet. It makes random noise on power up.
;Reset the device by sending a "set volume 0" byte to each stereo
;position of each channel. Then send a mode control byte of $E7
;to each stereo position. (Don't ask me what that means. I don't know.)
;	...
QUIETM:	LDA #$80
	CLC
	ADC MSLOT
	STA TEMPN1
	LDA #$C0
	ADC #$00
	STA TEMPN1+1
	LDY #$00
QMPLUP:	LDA #$9F		;Starting volume setting for each stereo pos.
	CLC
QMCLUP:	JSR ALFWAT		;need to wait for the ALF
	STA (TEMPN1),Y		;TELL CHANNEL SETVOLUME 0
	ADC #$20		;next channel.
	BCC QMCLUP		;when we get past $FF, it's done.
	LDA #$E7		;mode control byte for stereo pos.
	JSR ALFWAT
	STA (TEMPN1),Y
	INY
	CPY #$03		;stereo pos. numbers are 0,1,2.
	BNE QMPLUP		;next stereo position.
	RTS

;cretinous ALF needs 18 cycle wait between frobbing it
;THE JSR and RTS use up 6 cycles each
ALFWAT: NOP
	NOP
	NOP
	RTS
.PAGE
;	Music buffer configuration section
MJPOPJ:	JMP POPJ
NVERR:	JMP GTERR1	;the error was in the first arg.

SNVOIC:	LDA INPFLG
	BNE MJPOPJ	;Just exit if in the editor.
	LDA BUFOWN
	BPL SNVC1
	JSR RESETT	;Reset graphics screen
SNVC1:	JSR GT1FIX
	LDX #NARG1
	LDA #$06	;Maximum no. of voices
	JSR SMALFX
	BCS NVERR
	LDA NARG1
	BEQ NVERR	;Must be at least 1.
;A is a number 1-9, the number of parts.
	STA NPARTS
	LDA #$02
	STA BUFOWN	;Music owns the buffer now
;calculate size of parameter table by multiplying the number by
;the size of the parameter table.
	LDX NPARTS
	LDA #$00
	STA MEACTP
	STA PARPNT
	CLC
MULUP:	ADC #PARSIZ
	DEX
	BNE MULUP
	STA PSIZE	
;now A contains the length of the entire parameter area.
;Put starting address of first PARAMETER AREA into PARPNT. -- $2000. Increment is #PARSIZ
;Put starting address of first MUSIC BUFFER into PARMBS. -- $2000+PSIZE. Increment is MBUFLN.
;Put it in PARMBV also, so PLAYMUSIC can restore it.
;Note that the parameter area may not be >255 bytes.
	STA PENXT	;pointer to place where next note should be put
	STA PSTART	;pointer to beginning of part buffer
	LDA #$20	;this sets up the high byte of these.
	STA PENXT+1
	STA PSTART+1
	STA PARPNT+1		;initially points to beginning of hi-res graphics page.
;PARPNT points to the first parameter table. PSTART points to the first
;music buffer. It shouldn't be touched in entry. PENXT is the register
;to use for pointing to the next place when entering music.

;Figure the length of the music buffers -- <$4000-(PSTART)>/(NPARTS)
	SEC
	LDA #$00
	JSR SETN20		;this is the zero for hi-byte of (NPARTS)
	STA NARG1+2		;zero high bytes of NARG1
	STA NARG1+3
	SBC PSTART
	STA NARG1
	LDA #$40
	SBC PSTART+1
	STA NARG1+1
	LDA NPARTS		;now divide the number of bytes for all the
	STA NARG2		;music buffers by the number of buffers.
	JSR XDIVID
;Length of each music buffer is now in narg1.
	LDA NARG1
	STA MBUFLN
	CLC
	ADC PSTART		;starting address for first buffer.
	STA PEEND		;1+ending address for first buffer.
	LDA NARG1+1
	STA MBUFLN+1
	ADC PSTART+1
	STA PEEND+1
;now calculate the start and end address for each buffer and put it in the default 
;parameter table. Calculate other the defaults and install the parameter table for this buffer.
;Calculate the new SA for each buffer by adding the contents of MBUFLN, MBUFLN+1
;to PSTART, PSTART+1 and storing the result there and in PENXT, PENXT+1.
;To figure the new ending address, add contents of MBUFLN, MBUFLN+1
;to PEEND, PEEND+1 and store the result there.
;Figure the SA for the parameter table by adding the immediate quantity #PARSIZ
;to PARPNT, PARPNT+1 and storing the result there. Copy the table at 
;PARAMS to the locations pointed to by PARPNT, PARPNT+1. Do #PARSIZ bytes
	LDA NPARTS		;Do this for each part.
	STA COUNT
;Calculate defaults.
;Set up the channel number.
LODLUP:	LDA #$09		;nine parts
	SEC
	SBC COUNT		;now A contains 9 minus part number
;Why, you may ask, do we subtract the part number from nine? It is simple:
;Channel 2 (of 0,1,2) is the only one which has white noise. We want the
;user to be able to generate percussion sounds without either having to know
;about ordering of channels/sterso positions or having to allocate seven
;(the first one which would be in channel 2 if we didn't do this) buffers.
;The channel number is the quotient of this new number and 3, and the stereo
;position is the remainder.
	LDX #$00
	SEC
DIV3L:	SBC #$03
	BCC DIV3E		;we subtracted one too many 3's.
	INX
	BNE DIV3L
DIV3E:	ADC #$03		;add the 3 that we shouldn't have subtracted.
	CLC
;A now contains <PART#-9> mod 3, the stereo number. X is <PART#-9>/3 -- the
;channel number.
;Add the slot offset to the remainder -- the stereo position number.
	ADC MSLOT		;slot offset is slot number * 16.
	STA PARCHA		;CHAN in the parameter defaults table=slot*16+P
;and now for the quotient -- the channel number. CHAN+1,X=(32*CHAN) OR #$9F.
	TXA
	JSR GETCHN
	STA PARCHA+1		;CHAN+1 in the parameter defaults table.
;And finally copy the default settings (starting address and channel number included)
;to the parameter area in the hires graphics page.
	LDY #PARSIZ-1		;number of bytes in the parameter area -1
PARLUP:	LDA PARAMS,Y
	STA (PARPNT),Y
	DEY
	BNE PARLUP
;Calculate new sa for music buffer by adding MBUFLN to PSTART.
;initialize the next place to put a note to the starting address of
;the buffer.
;new enda by adding MBUFLN to PARFE, the next eob pointer.
;new sa for parameter area by adding #PARSIZ to PARPNT. 
	CLC
	LDA PSTART
	ADC MBUFLN
	STA PSTART
	STA PENXT
	LDA PSTART+1
	ADC MBUFLN+1
	STA PSTART+1
	STA PENXT+1
	CLC
	LDA PEEND
	ADC MBUFLN
	STA PEEND
	LDA PEEND+1
	ADC MBUFLN+1
	STA PEEND+1
	CLC
	LDA PARPNT
	ADC #PARSIZ
	STA PARPNT
	BCC PAR1C
	INC PARPNT+1
PAR1C:	DEC COUNT		;decrement part count.
	BNE LODLUP		;load parameters for next part.
;do the equivalent of a VOICE 1, without error checking.
	LDX #$01
	BNE VCOK		;(always)
.PAGE
;	Music entering section

SNOTE:	JSR MUSICP
	JSR GT2FIX
	LDX #NARG1
	JSR CHKINT
	BCS MRGERR
	LDX #NARG2
	LDA #HINOTE
	JSR SMALFX
	BCS MRGER2
	LDA NARG1
	LDX MEPRT		;parameter index for current part.
	LDY #$03		;we want to write three bytes
	JSR MCKBY		;errors out if no more bytes.
	JSR PUTBYT
	LDA NARG2
	JSR PUTBYT
	LDA NARG2+1
	JSR PUTBYT
	JMP POPJ

SVOICE:	JSR MUSICP
	JSR GT1FIX
	LDX #NARG1
	LDA NPARTS
	JSR SMALFX
	LDX NARG1
	BEQ MRGERR
	BCC VCOK
MRGERR:	JMP GTERR1
MRGER2:	JMP GTERR2
VCOK:	LDA #$00		;this is jumped to by nvoices.
	CLC
VCLUP:	DEX
	BEQ VCXIT
	ADC #PARSIZ
	BCC VCLUP
MUSBUG:	LDA #$06		;Music bug
	JMP SYSBUG		;means #parsiz*parts>255. shouldn't happen

VCXIT:	STA MEPRT		;#PARSIZ*(PART-1)
	JMP POPJ

SAD:	JSR MUSICP
	JSR GT2PIN		;get two positive integers.
	LDA #<ATTACK-TIME>	;Attack/Decay index
	JSR MTN12A		;transfer narg1/narg2 to current part parameter indicated by A.
	JMP POPJ
	
SVS:	JSR MUSICP
	JSR GT2PIN
	LDA #<VOLUME-TIME>	;volume/sustain
	JSR MTN12A
	JMP POPJ

SRG:	JSR MUSICP
	JSR GT2PIN
	LDA #<RELEAS-TIME>	;release/gap
	JSR MTN12A
	JMP POPJ

SFZ:	JSR MUSICP		;fuzz. narg1=type, narg2=shift
	JSR GT2PIN
	LDA NARG1		;so that 0 will be in a at nofuzz.
	DEC NARG1		;Noise type is 0 or 1.
	BMI NOFUZZ		;No fuzz if type-1<0.
	LDA NARG1
	AND #$01		;keep user from screwing self.
	ASL A
	ASL A
	STA NARG1
	LDA NARG2		;Shift rate.
	AND #$03		;and protect him again. Stupid, isn't he? 
	CLC
	ADC NARG1
	ORA #$E0		;constant which means noise control.
NOFUZZ:	LDX MEPRT		;Now A=11100TSS or 0 if BMI NOFUZZ.
	STA FUZZ,X
	JMP POPJ

;Gets two positive integers.
GT2PIN:	JSR GT2FIX
	JSR CK1PIN
	LDX #NARG2
	JSR CHKPIN
	BCS GT2PN2
	RTS
GT2PN1:	JMP GTERR1
GT2PN2:	JMP GTERR2

;Gets one positive integer.
GT1PIN:	JSR GT1FIX
CK1PIN:	LDX #NARG1
	JSR CHKPIN
	BCS GT2PN1
	RTS

SPLAYM: JSR MUSICP
	LDA NPARTS
	STA MPPRT	;current part number
	LDA MEACTP	;number parts with notes in them.
	STA MPACTP
	LDY NPARTS
	LDX #$00	;parameter index. #parsiz*(part.number-1)
ECPYLP:	LDA #$00
	STA TIME,X
	STA TIME+1,X
	STX TEMPN1
	STY COUNT
	LDY #$07	;zero loudns, down, desire, cursus
ECPY1:	STA LOUDNS,X
	INX
	DEY
	BPL ECPY1
	LDX TEMPN1
	LDY COUNT
;MSTART -> MPNXT
;MENXT -> MPEND
;MEDEAD -> MPDEAD
	LDA MSTART,X
	STA MPNXT,X
	LDA MSTART+1,X
	STA MPNXT+1,X
	LDA MENXT,X
	STA MPEND,X
	LDA MENXT+1,X
	STA MPEND+1,X
	LDA MEDEAD,X
	STA MPDEAD,X
	TXA
	CLC
	ADC #PARSIZ	;next parameter index.
	TAX
	DEY		;number of parts left to do.
	BNE ECPYLP
	LDA MPACTP
	BNE PMLUP
	JMP FINIS

PMLUP:	LDX #$00	;start with part 0. X is parameter index.
	STA $C070	;referencing this location resets the timer
;Process the envelope for each part.
;Compare the current loudness and the desired loudness.
;If it is too soft, make it louder. If it is too loud, make it softer. If
;it is just right, the attack or decay is over and we should shoot for
;the currently desired "sustain" (i.e., sustain or release) level.
;After all this, do the next part.
ENVLUP:	LDA LOUDNS,X
	SEC
	SBC DESIRE,X	;find difference between desired and current loudness.
	STA TEMPN1
	LDA LOUDNS+1,X
	SBC DESIRE+1,X
	BCC UPLD	;should be louder.
	ORA TEMPN1
	BNE DWNLD	;should be softer.
	LDA CURSUS,X	;right loudness
	STA DESIRE,X	;now we want to shoot for the sustain level.
	LDA CURSUS+1,X
	STA DESIRE+1,X
	BCS NEXTE		;(always) do next part
;We must be in the attack phase, since no other stage gets louder.
;Increment the current loudness by the attack rate, and compare the result
;to the desired loudness. If it is currently too loud, we have overshot, so
;make the current loudness be the desired loudness
;If it is now right, start the decay and send the pitch to the device.
UPLD:	LDA LOUDNS,X		;INCREMENT current loudness by attack rate
	ADC ATTACK,X
	STA LOUDNS,X
	LDA LOUDNS+1,X
	ADC ATTACK+1,X
	STA LOUDNS+1,X
	BCS ETHERE		;OVERFLOW: we got too loud, make it exact.
	TAY
	LDA LOUDNS,X
	CMP DESIRE,X
	TYA
	SBC DESIRE+1,X
	BCC SENDE	;not loud enough yet, but keep working later.
	BCS ETHERE	;too loud -- make it exact.
;We must be in the decay phase, since no other stage gets softer.
;Decrement the current loudness by the decay rate, and compare the result
;to the desired loudness. If it is currently too soft, we have undershot, so
;make the current loudness be the desired loudness.
;If it is now right, start the release and send the pitch to the device.
DWNLD:	LDA LOUDNS,X
	SBC DOWN,X
	STA LOUDNS,X
	LDA LOUDNS+1,X
	SBC DOWN+1,X
	STA LOUDNS+1,X
	BCC ETHERE	;UNDERFLOW: too soft, make it exact.
	LDA DESIRE,X
	CMP LOUDNS,X
	LDA DESIRE+1,X
	SBC LOUDNS+1,X
	BCS SENDE	;not soft enough, but keep working later.
;too soft, make it exact.

;Make the current loudness=desired loudness.
ETHERE:	LDA DESIRE,X
	STA LOUDNS,X
	LDA DESIRE+1,X
	STA LOUDNS+1,X
;and now we want to head for the sustain level (either the sustain level or 0 in release.)
	LDA CURSUS,X
	STA DESIRE,X
	LDA CURSUS+1,X
	STA DESIRE+1,X
;send the loudness to the thing.
SENDE:	LDA LOUDNS+1,X	;we have a sixteen bit number, but we only
	LSR A		;have four bits of amplitude control,
	LSR A		;so just take the top four bits of the
	LSR A		;most significant byte.
	LSR A
	EOR CHAN+1,X	;sneaky subtraction. CHAN+1,X=(32*CHAN)or$9F.
	ORA FUZZ,X	;mask for white noise.
	LDY CHAN,X	;channel number+16*slot
	STA $C080,Y

;through with this one, now for next part.
NEXTE:	TXA 
	CLC
	ADC #PARSIZ	;advance parameter index to next
	TAX		;part's parameters.
	DEC MPPRT
	BEQ CONT1	;last part?
	JMP ENVLUP	;no -- do more parts.
;We've got the volume set for each note. Now handle their durations.
CONT1:	LDX #0		;Start again with first part. X is
			;parameter index.
;Now handle durations of notes. See if anyone is through this clock cycle.
LNGTH:	LDA MPDEAD,X
	BEQ NEXTL
	LDA TIME,X
	CMP GAP,X
	BNE MDECR	;unless the gap size=time remaining, not through.
	LDA TIME+1,X
	CMP GAP+1,X
	BNE MDECR
;this note is about to finish. start the release phase.
	LDA RELEAS,X	;make the current decay rate=the release rate
	STA DOWN,X
	LDA RELEAS+1,X
	STA DOWN+1,X
	LDA #$00	;and our desired (and sustain) level is zero.
	STA DESIRE,X	
	STA DESIRE+1,X
	STA CURSUS,X
	STA CURSUS+1,X
;decrement time remaining, and get next note if this one's through.
MDECR:	LDA TIME,X
	ORA TIME+1,X
	BEQ ENDNTE
	LDA TIME,X
	SEC
	SBC #$01
	STA TIME,X
	BCS NEXTL
	DEC TIME+1,X
NEXTL:	TXA		;handle the duration for the next part.
	CLC
	ADC #PARSIZ	;point to next set of part parameters.
	TAX
	INC MPPRT
	LDA MPPRT
	CMP NPARTS
	BNE LNGTH	;more parts to do.
;no more parts to do. Wait for the clock tick.
MWAIT:	BIT PADDL
	BMI MWAIT
;that's it for this clock cycle. Calculate new amplitudes and see if
;any note is through again.
	JSR POLL
	JMP PMLUP
.PAGE
;This note has finished.
;Try to get another note. If there are no more, decrement
;the number of active parts and set the volume to 0. Set the dead flag
;to indicate that there are no more notes in this part. Handle the length
;for the next part. 
;If it is the last note of all, return to Logo.

;Otherwise, get the next note from this voice and process it.

DDERR:	JMP MUSBUG
ENDNTE:	JSR MGBCK
	BNE PROCES	;more notes. get one and handle it.
;no more notes in this voice. set the dead flag for this voice
;and set its volume to zero. Decrement number of active parts. If it is
;then zero, there are no more notes at all, so quit. If it is not zero,
;handle the next length to wait for something to happen.
	LDA MPDEAD,X
	BEQ DDERR	;bug if already dead.
	LDA #$00
	STA DESIRE,X
	STA DESIRE+1,X
	STA MPDEAD,X
	DEC MPACTP
	BEQ FINIS
	JMP NEXTL

FINIS:	JSR QUIETM	;make sure it shuts up.
	JMP POPJ

;This is the main note-processing loop. It is called whenever a note runs out,
;and gets the next note for the current part.
;Get a byte from a buffer and figure out what to do with it.
;If there aren't any more bytes in this particular part, then go to the next part
;and get the byte there. If there simply aren't any more notes, then quit.
;If a part never had anything in it to begin with, don't count it as having
;become inactive.

PROCES:	JSR MGTBYT	;Get the next character from the buffer indicated by X
;and increment.
	CMP #CREST	;the number for rest is HINOTE+1.
	BCS NPITCH	;Byte is >=#CREST, so it is a command.
;it's a pitch -- 0-71 decimal.
;get octave number.
	LDY #$00
DIVOCT:	CMP #OCTLEN
	BCC DIVOC1
	SBC #OCTLEN
	INY
	BNE DIVOCT
DIVOC1:	STY TEMPN1	;save quotient.
	ASL A		;make remainder a word index. (2 * pitch) -- pitch is [0,11]
	TAY
	LDA OCTAB+1,Y	;Yth divisor in the table.
	STA TEMPN2	;63920/this-num is frequency.
	LDA OCTAB,Y
	LDY TEMPN1	;Y is octave number again.
;rotate the number we got from the table to make it be in the right octave.
OCTAVE:	DEY
	BMI ROUND
	LSR TEMPN2	;it is a 12 bit number.
	ROR A
	JMP OCTAVE

ROUND:	ADC #$08
	BCC SENDP
	INC TEMPN2	;a carry.
;now we have the right divisor to send to the unit.
;all we have to do is get it in the right format and then find out
;where to send it.
;a contains lower 8 bits of divisor, tempn2 the upper 4.
SENDP:	ORA #$0F	;where we write the info.
	LSR A
	ROR A
	ROR A
	ROR A
	AND CHAN+1,X
	LDY CHAN,X	;The offset from the board's memory location
	STA $C080,Y
	JSR ALFWAT
	LDA TEMPN2
	STA $C080,Y	;rest of info for board.
;now start ADSR cycle.
	LDY #$06
	STX TEMPN2	;x is the param pointer for this part.
CYCLE:	LDA DECAY,X	;we're making
	STA DOWN,X	;DOWN=DECAY,DESIRE=VOLUME,CURSUS=SUSTAN
	INX		;increment index for which bytes to move
	DEY		;decrement number of bytes to move
	BNE CYCLE
	LDX TEMPN2	;restore param index after decrementing it.
;store the duration in TIME.
STORD:	JSR MGTBYT		;get this part's next byte.
	STA TIME,X
	JSR MGTBYT
	STA TIME+1,X
;that's it for this note or rest. Do the next one.
	JMP NEXTL
.PAGE
BADCOD:	JMP MUSBUG
;If we got here, the thing in A must not be a pitch. If the last comparison resulted
;in EQness, then it is a rest; otherwise, it is the result of an error.
NPITCH:	BNE BADCOD	;(just compared with 72) it is a command.
	LDA RELEAS,X
	STA DOWN,X
	LDA RELEAS+1,X
	STA DOWN+1,X
	LDA #$00
	STA DESIRE,X		;a rest has amplitude 0.
	STA DESIRE+1,X
	STA CURSUS,X
	STA CURSUS+1,X
;now store the duration.
	JMP STORD
.PAGE
;Utilities
;Utility. Store the byte in A in the location pointed to by MENXT,X MENXT+1,X.
;Increment MENXT,X, MENXT+1,X. Decrement Y, in case anybody uses it to
;keep track of how many bytes it has written.
;Doesn't check for error. You should call MCKBY first.
PUTBYT:	PHA
	STY TEMPN1
	LDA MENXT,X
	STA PARPNT
	LDA MENXT+1,X
	STA PARPNT+1
	LDY #$00
	PLA
	STA (PARPNT),Y
	INC MENXT,X
	BNE PBXIT
	INC MENXT+1,X
PBXIT:	LDY TEMPN1
	DEY
	RTS
;
;This is the MCKBY routine. It takes a number of bytes in Y and a
;parameter index in X. If the part indicated by X doesn't have at
;least Y bytes left, this routine errors out and doesn't return to the
;caller. If there are enough left, it returns.
;Subtracts the beginning of the next buffer from the current pointer.
;If the difference is less than the number of bytes to write, it
;errors out. Otherwise it returns.

;Additionally, this routine keeps track of the number of parts which
;actually have any notes in them. Each time it is called, it checks
;the MEDEAD flag for that part. If it is set (0), then no notes have
;ever been put into that part's buffer -- so it increments the number
;of active parts and clears the MEDEAD flag for the part.
MCKBY:	PHA
	LDA MEDEAD,X
	BNE MCKBY1
;This is the first time.
	LDA #$01
	STA MEDEAD,X
	INC MEACTP
MCKBY1:	LDA MEEND,X
	SEC
	SBC MENXT,X
	STA TEMPN1
	LDA MEEND+1,X
	SBC MENXT+1,X
	BNE MCKOK		;We can't want more than 255 bytes.
	CPY TEMPN1
	BCC MCKOK
	BEQ MCKOK
	ERROR XTMN		;Error (too many notes) resets the stack pointer.
MCKOK:	PLA
	RTS

;This routine expects a parameter index in X.
;If this part is dead, error out.
;Otherwise, return the next byte from that part buffer and increment the pointer.
MGTBYT:	LDA MPDEAD,X
	BEQ MGBERR
	STY TEMPN2
	LDY #$00
	LDA MPNXT,X
	STA PARPNT
	LDA MPNXT+1,X
	STA PARPNT+1
	LDA (PARPNT),Y
	TAY
	INC MPNXT,X
	BNE MGTBE
	INC MPNXT+1,X
MGTBE:	LDY TEMPN2
	RTS

;check this part to see if there is note left in it. return 0 in A if there
;aren't. Otherwise, return non-zero in A.
;If the current part pointer is the same as the end pointer, ther are no
;more bytes.
MGBCK:	LDA MPNXT+1,X
	CMP MPEND+1,X
	BEQ MGBCK1
	BCC MGBOK		;more bytes.
MGBERR:	JMP MUSBUG		;Way past end of buffer.
MGBCK1:	LDA MPNXT,X
	CMP MPEND,X
	BEQ MGBNOK		;no more bytes.
	BCS MGBERR		;Past end of buffer.
MGBOK:	LDA #$01		;<>0 means more bytes.
	RTS
MGBNOK:	LDA #$000		;=0 means no more bytes.
	RTS

;This routine gets the number to store in chan+1,x from the channel number,
;given in A.
GETCHN:	LSR A
	ROR A
	ROR A
	ROR A
;In one place, CHAN+1 is eor'd with the high four bits of the current
;loudness put in the low four bits. This makes the result be $9F+$20*C-V.
;So this part constant is $9F+$20*C.
	ORA #$9F
	RTS

;this routine moves narg1 and narg2 to the parameter for the current voice
;indicated by A.
MTN12A:	CLC
	ADC MEPRT
	TAY
	LDA NARG1
	STA TIME,Y
	LDA NARG1+1
	STA TIME+1,Y
	LDA NARG2
	STA TIME+2,Y
	LDA NARG2+1
	STA TIME+3,Y
	RTS
.PAGE
SSVMUS:	JSR MUSICP
	JSR GTWRD1
	BNE SSVSM3
	LDA NPARTS
	STA DSKB1	;DOS will save this.
	PRTSTR SAVEM
	JSR DTPATM	;Give DOS the name
	LDX #MUSM&$FF
	LDY #MUSM^
	JSR SRDX2
	JSR DBSAVE	;Save the file
IGNPRM:	JMP POPJ
SSVSM3:	JMP ERXWT1

SRDMUS:	LDA INPFLG
	BNE IGNPRM
	LDA BUFOWN
	BPL SRDMS1
	JSR RESETT
SRDMS1:	JSR SRDX1
	LDX #MUSM&$FF
	LDY #MUSM^
	JSR SRDX2
	JSR DBLOAD	;Load the file
	LDA DSKB1
	STA NPARTS
	LDA #$02
	STA BUFOWN	;Music owns the buffer now
	JMP POPJ

SERMUS:	JSR SDELTX
	LDX #MUSM&$FF
	LDY #MUSM^
	JSR SRDX2
	JSR DOSDEL	;DOS "DELETE" Routine
	JMP POPJ

;Check to see if in music mode. If not, error out to top level.
;Otherwise return.
MUSICP:	LDA NPARTS
	BEQ NOTMUS
	BMI NOTMUS
	RTS
NOTMUS:	ERROR XNTM	;error restores the stack.
.PAGE
MSLOTI	=$40		;Initial slot number assumed for music card.

;Command parameters.
;Put them in the Hi-res graphics page.
TIME	=$2000		;must be first
ATTACK	=$2002		;these five must be contiguous
DECAY	=$2004
VOLUME	=$2006
SUSTAN	=$2008
RELEAS	=$200A
GAP	=$200C		;these two must be contiguous
CHAN	=$200E
LOUDNS	=$2010
DOWN	=$2012		;these 3 must be contiguous
DESIRE	=$2014
CURSUS	=$2016
FUZZ	=$2018		;note that FUZZ is a byte.
MEDEAD	=$2019		;MEDEAD is also a byte.
MPDEAD	=$201A		;DEAD flag for PM. A byte.
MSTART	=$201B		;starting address of buffer.
MENXT	=$201D		;pointer to place where next note
			;should put. initialized to start of buffer.
MEEND	=$201F		;beginning of next buffer.
MPNXT	=$2021		;next note to be played. initialized
			;to beginning of buffer.
MPEND	=$2023		;one past last note to be played.
			;initialized to MENXT.

;Here are the defaults for each part.
PARAMS:	.ADDR $0000	;TIME
	.ADDR $2000	;ATTACK
	.ADDR $0019	;DECAY
	.ADDR $D600	;VOLUME
	.ADDR $D600	;SUSTAN
	.ADDR $05DC	;RELEAS
	.ADDR $0016	;GAP
PARCHA:	.ADDR $0000	;CHAN
	.ADDR $0000	;LOUDNS
	.ADDR $0000	;DOWN
	.ADDR $0000	;DESIRE
	.ADDR $0000	;CURSUS
	.BYTE $00	;FUZZ
	.BYTE $00	;MEDEAD
	.BYTE $00	;MPDEAD
PSTART:	.ADDR $0000	;MSTART
PENXT:	.ADDR $0000	;MENXT
PEEND:	.ADDR $0000	;MEEND
	.ADDR $0000	;MPNXT
	.ADDR $0000	;MPEND
PARSIZ=.-PARAMS

;Table of divisors for octaves.
OCTAB:	.ADDR 15632		;C
	.ADDR 14752		;C#
	.ADDR 13936		;D
	.ADDR 13152		;D#
	.ADDR 12416		;E
	.ADDR 11712		;F
	.ADDR 11056		;F#
	.ADDR 10432		;G
	.ADDR 9856		;G#
	.ADDR 9296		;A
	.ADDR 8768		;A#
	.ADDR 8288		;B
OCTLEN	=<.-OCTAB>/2
.ENDC
ENDPGM=.
.PRINT ENDPGM	;LAST LOCATION (< $9AA6)
.PAGE
.SBTTL	Input/Output Utilities

.=OCODE		;Code goes before graphics buffer

;	Local variable block:
TBLADR	=TEMPNH		;Addr. of dispatch table

;Dispatch routine Called with typecode in A; table address in XY.
TYPDSP:	CMP #HITYP+1	;See if out of range
	BCS TYPBUG	;Yes, system bug
;Entering here doesn't check for HITYP limit.
GENDSP:	STX TBLADR
	STY TBLADR+1	;Store table address
	ASL A
	TAY		;Get table index
	LDA (TBLADR),Y
	TAX
	INY
	LDA (TBLADR),Y
	STA TBLADR+1	;Get table entry
	STX TBLADR
	JMP (TBLADR)	;Jump to it
TYPBUG:	LDA #$03	;System error: Dispatch code out of range
	JMP SYSBUG

;	Local variable block:
STRPTR	=TEMPNH		;String address

;PRTSTR prints the Ascii string whose address is in the X and Y registers.
;The string is terminated with a 0.
PRTSTR: STX STRPTR
	STY STRPTR+1
	LDY #$00
PTSTR1:	DATRAM		;Enable Ghost-memory
	LDA (STRPTR),Y
	BEQ PTRRTS
	JSR TPCHR
	INY
	BNE PTSTR1	;(Always)
PTRRTS:	NODRAM		;Ghost-memory disable
	RTS

;Reset I/O drivers and other things from monitor entry.
SETUP:	NODRAM		;Enable high RAM
	JSR RSTINP	;Restore I/O Drivers
	JSR RESETT	;Clear screen
	JSR CLRMRK	;In case of gcoll crash, clear the mark bits
	LDA #$00
	STA GCFLAG	;Reset garbage collect flag
	STA $00		;Re-init Lnil for conses!
	STA $01
	STA $02
	STA $03
	JMP CLRCBF	;Clear character buffer

;Crash restart routine.
REENT:	JSR SETUP	;Reset I/O drivers etc.
	JMP TOPLOP	;Start Logo at top level.

;Clear character buffer.
CLRCBF:	LDA CHBUFR	;Buffer empty when next-free equals next-to-read
	STA CHBUFS
	LDA KBDCLR
	RTS

;Get a character from the buffer if there is one.
GTBUF:	SEC
	LDA CHBUFR
	SBC CHBUFS
	AND #$3F
	BEQ GBFRTS	;Return zero if buffer empty (CHBUFR = CHBUFS)
	LDA CHBUFR
	AND #$3F
	TAX
	LDA CHBSTT,X
	INC CHBUFR	;Increment next-to-read
GBFRTS:	RTS

;Reset and clear the screen.
RESETT:	JSR SETTXT	;Set up text screen
	JSR SETNRM	;Normal characters
	JMP HOME	;Clearscreen and home cursor

;TPCHR should always be called with an Ascii character.
;If you want it to be inverted, call SETINV first,
;and call SETNRM when done.
;NOTE: TPCHR exits with nodespace RAM enabled
BREAK1:	LDA #CR
TPCHR:	STY YSAVE	;Save Y index
	STA KILRAM	;Enable monitor ROM in case output routine wants it
	JSR TPCHR1	;Output character
	NODRAM		;Enable nodespace RAM
	LDY YSAVE	;Retrieve Y index
	RTS

TPCHR1:	JMP (OTPDEV)
.PAGE
;Reset I/O to default drivers and mode.
RSTIO:	LDA #$00
	STA INPFLG	;Reset from read-eval mode
RSTIO1:	STA OTPFLG	;Reset to normal printing mode
	STA PRSFLG	;Do this in case resetting from READLINE state
	MOV OTPDEV,DEFOUT	;Reset output driver
	MOV INPDEV,DEFINP	;Reset input driver
	RTS

;Set inverse character mode.
SETINV:	LDA #$00
	BEQ SETIFL	;(Always)
;Set normal character mode.
SETNRM:	LDA #$80
SETIFL:	STA INVFLG
	RTS
.PAGE
;Beep da bell.
BELL:	LDA #$40
	JSR WAIT
	LDY #$C0
BELL1:	LDA #$0C
	JSR WAIT
	LDA SPKR
	DEY
	BNE BELL1
BRTS:	RTS

;Home the cursor and clear the screen
HOME:	LDA WNDTOP
	STA CV
	LDY #$00
	STY CH
	BEQ CLEOP1	;(always branches)

;Clear to end-of-page
CLREOP:	LDY CH
	LDA CV
CLEOP1:	PHA
	JSR BCALCA
	JSR CLEOL1
	LDY #$00
	PLA
	ADC #$00
	CMP WNDBTM
	BCC CLEOP1
	BCS BCALC	;(Always)
.PAGE
;Output routine we tell DOS to use.
APOUT:	PHA		;Save A for DOS
	AND #$7F	;change Apple idiot char codes to Ascii
	JSR TPCHR	;type the character
	PLA		;Get A back for DOS
	RTS

;Standard output routine.
COUT:	CMP #CR
	BEQ CROUT
	CMP #$07
	BEQ BELL	;bell on output of ^G
	ORA #$80	;Assume normal first
	CMP #$E0
	BCC COUTZ	;See if it's lower case
	AND #$DF	;Make it uppercase if so
COUTZ:	LDY INVFLG	;Invert if set
	BMI COUTZ1
	AND #$3F	;Invert - strip top bits
	ORA INVFLG	;and OR in flag
COUTZ1:	LDY CH
	STA (BASLIN),Y
;Advance the output point.
CHADV:	INC CH		;Advance Horizontally
	LDA CH
	CMP WNDWTH
	BCC BRTS	;Done if not EOL, else do a CR
	BCS CRLF	;(Always)
CROUT:	JSR CLREOL	;CR output, clear-to end-of line first
CRLF:	JSR POLL	;Poll at very eol
	LDA #$00	;CR: Go to beginning of line
	STA CH		;and do a LF
LF:	INC CV		;LF: Go to next line
	LDA CV
	CMP WNDBTM
	BCC BCALCA	;If not bottom of screen, calc. new baseline and return.
	DEC CV		;Else scroll: take back the LF first
SCROLL:	LDA WNDTOP	;Scroll: push initial screen line (window top)
	PHA
	JSR BCALCA	;Calculate this baseline
SCRL1:	MOV BSLTMP,BASLIN	;Save baseline
	LDY WNDWTH
	DEY		;Window width minus 1 in Y
	PLA		;Get line no.
	ADC #$01	;Add one to get next line no.
	CMP WNDBTM	;See if below window bottom yet
	BCS SCRL3	;At bottom
	PHA		;Not at bottom, push next line no.
	JSR BCALCA	;Calculate base line for it
SCRL2:	LDA (BASLIN),Y	;Shift a line up one, character by character
	STA (BSLTMP),Y
	DEY
	BPL SCRL2	;Next character
	BMI SCRL1	;Next line
SCRL3:	LDY #$00	;At bottom of screen
	JSR CLEOL1	;Clear the bottom line, then calculate new base
;	...
.PAGE
;Calculate BASLIN from CH, CV.
;	...
BCALC:	LDA CV
BCALCA:	PHA		;Save line no.
	LSR A
	AND #$03
	ORA #$04
	STA BASLIN+1
	PLA
	AND #$18
	BCC BCALC2
	ADC #$7F
BCALC2:	STA BASLIN
	ASL A
	ASL A
	ORA BASLIN
	CLC
	ADC WNDLFT
	STA BASLIN
	RTS

;Clear to end-of-line
CLREOL:	LDY CH
CLEOL1:	LDA #$A0	;(Space, non-flashing, non-inverted)
CLEOL2:	STA (BASLIN),Y
	INY
	CPY WNDWTH
	BCC CLEOL2
	RTS

;Get a character from the input device.
;Leaves nodespace memory enabled.
RDKEY:	CMPV DEFOUT,COUT
	BNE RDKEY1	;Don't flash cursor if not screen output
	LDY CH
	LDA (BASLIN),Y
	PHA		;Save character under cursor
	AND #$7F
	ORA #$40
	STA (BASLIN),Y	;Make cursor position flash
	JSR RDKEYX	;Get the input character
	TAX
	PLA		;Retrieve character under cursor
	STA (BASLIN),Y	;Put it back
	TXA
	BNE RDKEY2	;(Always)
RDKEY1:	JSR RDKEYX
RDKEY2:	EOR #$80	;Translate to Ascii
	NODRAM
	RTS

RDKEYX:	JMP (INPDEV)

;Keyboard input routine.
KEYIN:	JSR GTBUF	;Get character from the buffer if non-empty
	TAX
	BNE TRTS1
GETCHR:	INC1 RNDL	;Update random number seed
	JSR TSTCHR
	BCC GETCHR
	RTS

;Check for input character. Return with carry set and character in A if
;character pending, else carry clear. Supplies "[" for "M" and $FF for null
;replacement characters. Shouldn't bash Y!
TSTCHR:	BIT KBDBYT
	BPL KNONE
	LDA KBDBYT
	CMP #$80
	BNE TSTC1
	LDA #$7F	;translation for null character so it can't be typed.
	SEC
	RTS
TSTC1:	CMP #LBRAK+$80
	BNE TRTS1
	LDA #$DB
TRTS1:	SEC
	RTS
KNONE:	CLC		;Return carry clear if no character
	RTS
.PAGE
;Set text mode
SETTXT:	LDA PRMPAG	;Primary page
	LDA TXTMOD	;Set text mode
	LDA #$00	;Full screen window
	STA WNDTOP
	STA WNDLFT
	LDA #$18
	STA WNDBTM
	LDA #$28
	STA WNDWTH
	LDA #$17
	STA CV
	JMP BCALCA	;Calculate baseline
.PAGE
;Wait for a fixed delay
WAIT:	SEC
WAIT1:	PHA
WAIT2:	SBC #$01
	BNE WAIT2
	PLA
	SBC #$01
	BNE WAIT1
	RTS

;Break to ROM Monitor
MONBRK:	STA MONACC	;Save A for monitor
	TXA
	PHA		;Save X
	TYA
	PHA		;Save Y
	STA KILRAM
	JSR ROMSTN	;Init monitor stuff
	JSR ROMNIT
	JSR ROMSTV	;Reset I/O Drivers
	JSR ROMSTK
	SETV MONBKV,MONOBK	;Set Monitor BRK vector
	PLA
	TAY		;Retrieve Y
	PLA
	TAX		;Retrieve X
	JMP ROMMON	;Enter the Autocrock monitor
.PAGE
;	Local variable block:
CHRIND	=PLINE		;Temp. char. index
CHRND1	=PLINE+1	;Alt. temp. char. index

;Gets a line of input from the keyboard. Looks for Logo interrupt
;characters. Line is terminated with a CR.
GETLN:	LDA #$00
	STA CHRIND
	LDA #CR
	STA LINBUF
NEXTC:	JSR RDKEY	;Get an ascii value from keyboard (or buffer)
	JSR CKINTS	;Check for interrupts
	BCC NEXTC	;Try again if intercepted
	CMP #$08	;(<-) - Cursor forward
	BEQ GTBAK
	CMP #$15	;(->) - Cursor backward
	BEQ GTFWD
	CMP #$04	;(^D) - Delete character under cursor
	BEQ GTDEL
	CMP #$1B	;(ESC) - Rubout
	BEQ GTRUB
	CMP #$01	;(^A) - Beginning of line
	BEQ GTBEG
	CMP #CR
	BEQ GTCR
	CMP #$05	;(^E) - End of line
	BEQ GTEND
	CMP #$10	;(^P) - Insert previous line
	BEQ GTPRV
	CMP #$0B	;(^K) - Kill to end of line
	BEQ GTCAN
	CMP #SPACE	;Lowest allowable character
	BCC BADCHR	;(anything above is legal)
GTINS:	JSR GTINS1	;Insert the character, move the point forward
	JMP NEXTC	;Get the next one

BADCHR:	JSR BELL
	JMP NEXTC

GTBAK:	JSR GTBAK1
	JMP NEXTC

GTFWD:	JSR GTFWD1
	JMP NEXTC

GTDEL:	JSR GTDEL1
	JMP NEXTC

;Rubout: go back one and do a delete.
GTRUB:	JSR GTBAK1
	JSR GTDEL1
	JMP NEXTC

GTBEG:	LDA CHRIND	;Back to beginning
	BEQ NEXTC	;Continue if there else
	JSR GTBAK1	;Move back one
	JMP GTBEG	;And do it again

;Carriage-return: move fwd until on a CR.
GTCR:	LDX CHRIND
	LDA LINBUF,X	;See what we're on
	CMP #CR	;Is it a CR
	BEQ GTCR1	;Yes, almost done
	JSR GTFWD1	;Else move forward
	JMP GTCR	;And try again
GTCR1:	JMP BREAK1	;Terminate screen line and exit

;Go to end-of-line.
GTEND:	LDX CHRIND
	LDA PRSBUF,X
	CMP #$0D
	BEQ NEXTC
	JSR GTFWD1
	JMP GTEND

;Previous line insert: Dump ILINE into the PRSBUF starting at the current point.
GTPRV:	SETV OTPDEV,PRVCHR	;PRVCHR becomes char. output routine
	LDX #ILINE
	JSR TYPE1	;Dump the previous command line (no outer brackets)
	JSR RSTIO	;Reset output device when done
	JMP NEXTC	;Continue munching

;Delete to end-of-line: delete chars until on a CR.
GTCAN:	JSR GTCANX
	LDX CHRIND
	LDA #CR
	STA LINBUF,X	;Move the cr back to the current position
	JMP NEXTC

GTCANX:	LDA CH
	PHA
	LDA CV
	PHA
	LDA BASLIN
	PHA
	LDA BASLIN+1
	PHA
	LDA CHRIND
	PHA
GTCAN1:	LDX CHRIND
	LDA LINBUF,X	;What are we on?
	CMP #CR
	BEQ GTDEL4	;A cr, so restore state and return
	TPCHR SPACE	;Else type a space
	INC CHRIND	;and advance to next character
	BNE GTCAN1	;(Always)

GTFWD1:	LDX CHRIND	;Forward
	LDA LINBUF,X	;What are we on top of?
	CMP #CR
	BEQ GTFWD2	;A CR, so insert space
	INX		;Increment char-index
	BEQ GTBAKB	;If at end of buffer, complain
	STX CHRIND
	JMP CHADV	;Update cursor position and continue
GTFWD2:	LDA #SPACE
	JMP GTINS1	;Insert a space and move forward

GTBAK1:	LDX CHRIND	;Back
	BEQ GTBAKB	;If at beginning of line, complain
	DEX		;Decrement char-index
	STX CHRIND
	DEC CH		;Update cursor position
	BMI GTUPLN	;Hack cursor position if past left screen edge
	LDA WNDLFT
	BEQ GTIRTS	;If WNDLFT zero and CH positive, okay
	CMP CH		;Else see if CH is less than WNDLFT
	BEQ GTIRTS	;Ok if equal
	BCC GTIRTS	;Ok if CH greater
GTUPLN:	LDA WNDWTH	;Go to last position on line above
	STA CH
	DEC CH		;(WNDWTH is length, decrement for last position)
	DEC CV		;(Can't be at top of screen, fortunately)
	JMP BCALC	;Get new baseline, too
GTBAKB:	JSR BELL	;Complain
	PLA		;Zap return address
	PLA
	JMP NEXTC	;Continue munching

GTDEL1:	LDX CHRIND
	LDA LINBUF,X	;See what we're on
	CMP #CR
	BEQ GTBAKB	;If CR, complain
	LDA CH
	PHA		;Save the cursor state and char-index. on the stack
	LDA CV
	PHA
	LDA BASLIN
	PHA
	LDA BASLIN+1
	PHA
	TXA
	PHA
GTDELL:	LDX CHRIND	;Here's the loop.
	LDA LINBUF+1,X	;Get the next character
	STA LINBUF,X	;Put it here
	INC CHRIND	;Next character
	CMP #CR
	BEQ GTDEL2	;If it's a cr, exit the loop
	JSR TPCHR	;Show it, and update the cursor position
	JMP GTDELL	;Go do it
GTDEL2:	TPCHR SPACE	;At CR, type a space to cover the last character over
GTDEL4:	PLA		;All done, restore char-index and cursor position
	STA CHRIND
	PLA
	STA BASLIN+1
	PLA
	STA BASLIN
	PLA
	STA CV
	PLA
	STA CH
GTIRTS:	RTS

;Insert character: First, find CR. If it's in last position, buffer is
;full so complain. Else move everything over, typing chars. up to CR.
GTINS1:	STA CHRND1	;Save character
	LDX CHRIND
GTINS2:	LDA LINBUF,X	;Loop until we're on a CR
	CMP #CR
	BEQ GTINS3
	INX
	BNE GTINS2	;(Always)
GTINS3:	INX		;See if X is #$FF
	BEQ GTBAKB	;Yup, complain
;PRVCHR enters here
GTINSX:	LDA CHRIND	;Save the char-index. on the stack
	PHA
GTINS4:	LDX CHRIND
	LDA LINBUF,X	;Get the char we're on
	PHA		;Save it
	LDA CHRND1	;Get the displaced/insert char.
	STA LINBUF,X	;Put it here
	CMP #CR		;If it's a CR, exit the loop
	BEQ GTINS5
	JSR TPCHR	;Else type it
	PLA		;Get the displaced char back
	STA CHRND1
	INC CHRIND	;Increment char-index, do next char.
	BNE GTINS4	;(Always)
GTINS5:	PLA		;Discard displaced char.
	PLA		;Restore char-index
	STA CHRND1
	INC CHRND1
GTINS7:	LDA CHRIND
	CMP CHRND1	;Backup until CHRIND has original value plus one
	BEQ GTIRTS
	JSR GTBAK1
	JMP GTINS7

;Output routine for Previous-line insert.
PRVCHR:	STA CHRND1	;Save the character
	LDX CHRIND	;First see if there's room
PRVC2:	LDA LINBUF,X	;Loop until we're on a CR
	CMP #CR
	BEQ PRVC3
	INX
	BNE PRVC2	;(Always)
PRVC3:	INX		;See if X is #$FF
	BEQ PRVCR	;Yup, ignore it
	TYA		;Nope, process it...
	PHA		;Save the Y index
	JSR RSTIO	;Restore output device for GTINSX
	JSR GTINSX	;Insert the character without checking for buffer full
	SETV OTPDEV,PRVCHR	;Reset the output device to this routine again
	PLA
	TAY		;Restore Y index
PRVCR:	RTS
.PAGE
;Given paddle number (0-3) in X, returns position ($00-$FF) in Y.
PREAD:	LDA PTRIG	;Trigger one-shot
	LDY #$00	;Init counter
	NOP		;Wait 6 cycles
	NOP
PREAD2:	LDA PADDL,X	;Count Y-register every 12. microseconds
	BPL PRRTS	;Unitl high bit reset
	INY
	BNE PREAD2
	DEY
PRRTS:	RTS
.PRINT .-OCODE	;LENGTH OF SEPARATED CODE (< $400)
.PAGE
.SBTTL	Ghost-Memory Storage
.=GHODAT		;Original load area
.SBTTL		Primitive Address Table
SYSTAB=.+TDIFF		;Must be on a page boundary for SFUNCL

;Primitives entered here must be in the same order as those created with
; the PRIM macro in the primitive definitions table.

	.ADDR	SINDXR
;	Arithmetic/Boolean:
	.ADDR	SUNSUM
	.ADDR	SUNDIF
	.ADDR	SSUM
	.ADDR	SDIF
	.ADDR	SPROD
	.ADDR	SDIVID
	.ADDR	SGRTR
	.ADDR	SLESS
	.ADDR	SEQUAL
	.ADDR	SQTENT
	.ADDR	SRMNDR
	.ADDR	SROUND
	.ADDR	SINT
	.ADDR	SSIN
	.ADDR	SCOS
	.ADDR	SSQRT
	.ADDR	SATAN
	.ADDR	SNOT
	.ADDR	SAND
	.ADDR	SOR
	.ADDR	STHNGP
	.ADDR	SWORDP
	.ADDR	SLISTP
	.ADDR	SNMBRP
	.ADDR	SCHARP
;	Word/list:
	.ADDR	SFIRST
	.ADDR	SLAST
	.ADDR	SBTFST
	.ADDR	SBTLST
	.ADDR	SWORD
	.ADDR	SFPUT
	.ADDR	SLPUT
	.ADDR	SLIST
	.ADDR	SSNTNC
;	Miscellaneous:
	.ADDR	SMAKE
	.ADDR	SOUTPT
	.ADDR	SSTOP
	.ADDR	SCOMMT
	.ADDR	SCNTIN
	.ADDR	STEST
	.ADDR	SIFT
	.ADDR	SIFF
	.ADDR	SIF
	.ADDR	STHEN
	.ADDR	SELSE
	.ADDR	SGO
	.ADDR	SRUN
	.ADDR	SRPEAT
	.ADDR	SREQU
	.ADDR	STHING
	.ADDR	SGCOLL
	.ADDR	SNODES
	.ADDR	SDEFIN
	.ADDR	STEXT
	.ADDR	STO
	.ADDR	SEDIT
	.ADDR	SEND
	.ADDR	SPRINT
	.ADDR	SPRNT1
	.ADDR	SPO
	.ADDR	SPOTS
	.ADDR	SERASE
	.ADDR	SERNAM
	.ADDR	SQFIER	;All
	.ADDR	SQFIER	;Names
	.ADDR	SQFIER	;Titles
	.ADDR	SQFIER	;Procedures
	.ADDR	STRCBK
	.ADDR	STRACE
	.ADDR	SNTRAC
	.ADDR	SRANDM
	.ADDR	SRNDMZ
	.ADDR	SREADC
	.ADDR	SCURSR
	.ADDR	SCLINP
	.ADDR	SCLEAR
	.ADDR	SPADDL
	.ADDR	SPDBTN
	.ADDR	SEXAM
	.ADDR	SDEP
	.ADDR	SCALL
	.ADDR	SPAUSE
	.ADDR	SBPT
	.ADDR	PPTTP
	.ADDR	LOGO1	;Goodbye
	.ADDR	PARLOP	;(left-parenthesis)
	.ADDR	SRPAR	;(right-parenthesis)
	.ADDR	SCHAR
	.ADDR	SASCII
	.ADDR	SINADR
	.ADDR	SOTADR
;	Filing:
	.ADDR	SREAD
	.ADDR	SSAVE
	.ADDR	SDELET
	.ADDR	SCATLG
.IFNE GRPINC
;	Graphics:
	.ADDR	SFD
	.ADDR	SBK
	.ADDR	SRT
	.ADDR	SLT
	.ADDR	SDRAW
	.ADDR	SHOME
	.ADDR	SPENUP
	.ADDR	SPENDN
	.ADDR	SSHOWT
	.ADDR	SHIDET
	.ADDR	STS
	.ADDR	SNDSPL
	.ADDR	SSETX
	.ADDR	SSETY
	.ADDR	SSETXY
	.ADDR	SSETH
	.ADDR	SSETT
	.ADDR	SXCOR
	.ADDR	SYCOR
	.ADDR	SHDING
	.ADDR	SFULL
	.ADDR	SSPLIT
	.ADDR	SRDPCT
	.ADDR	SSVPCT
	.ADDR	SERPCT
	.ADDR	SPALET
	.ADDR	SPENC
	.ADDR	SCS
	.ADDR	SBKGND
	.ADDR	SSCNCH
	.ADDR	STWRDS
	.ADDR	SWRAP
	.ADDR	SNOWRP
	.ADDR	SSPENC
	.ADDR	SSBKGD
.ENDC
.IFNE MUSINC
;	Music:
	.ADDR	SVOICE
	.ADDR	SNVOIC
	.ADDR	SPLAYM
	.ADDR	SNOTE
	.ADDR	SAD
	.ADDR	SVS
	.ADDR	SRG
	.ADDR	SFZ
	.ADDR	SSVMUS
	.ADDR	SRDMUS
	.ADDR	SERMUS
.ENDC
.PAGE
.SBTTL		Error Messages

;Error Message String format:
;	$00 Terminates string
;	$01 Print <Y argument to ERROR>
;	$02 Print <X argument to ERROR>
;	Anything else is printed as an Ascii character
;Note: Error messsage texts must be entered in the order of their indexes

ERMSGS=.+TDIFF		;Address of error message texts
ERRSET XMRP
	.ASCIZ "No matching right parenthesis"
ERRSET XUOP
	.ASCII "You don't say what to do with "
	$01
	$00
ERRSET XNMI
	$01
	.ASCIZ " needs more inputs"
ERRSET XNDF
	.ASCII "There is no procedure named "
	$01
	$00
ERRSET XHNV
	.ASCII "There is nothing named "
	$01
	$00
ERRSET XNIP
	.ASCIZ "Nothing inside parentheses"
	$01
ERRSET XNOP
	.ASCIZ " didn't output"
ERRSET XRPN
	.ASCIZ "Unexpected closing parenthesis"
ERRSET XIFX
	$01
	.ASCIZ " needs something before it"
ERRSET XTIP
	.ASCIZ "Too much inside parentheses"
ERRSET XWTA
	$01
	.ASCII " doesn't like "
	$02
	.ASCIZ " as input"
ERRSET XUBL
	$01
	.ASCIZ " is a Logo primitive"
ERRSET XNTL
	$01
	.ASCIZ " should only be called inside a procedure"
ERRSET XNTF
	$02
	.ASCII " was given to "
	$01
	.ASCIZ " instead of TRUE or FALSE"
ERRSET XOOP
	$01
	.ASCIZ " is out of place"
ERRSET XBRK
	.ASCIZ "I was told to pause"
ERRSET XLAB
	.ASCII "The label "
	$02
	.ASCIZ " should be at the beginning of the line"
ERRSET XLNF
	.ASCII "There is no label "
	$01
	$00
ERRSET XETL
	$01
	.ASCIZ " cannot be used inside the editor"
ERRSET XNED
	.ASCIZ "END should only be used in the editor"
ERRSET XOPO
	$01
	.ASCIZ " should only be an input to PRINTOUT, ERASE or EDIT"
ERRSET XDBZ
	.ASCIZ "Can't divide by zero"
ERRSET XOFL
	.ASCIZ "Number out of range"
ERRSET XCSR
	.ASCIZ "Cursor coordinates off of screen"
ERRSET XOOB
	.ASCIZ "Turtle out of bounds"
ERRSET XIOR
	.ASCIZ "Disk error"
ERRSET XWTP
	.ASCIZ "The disk is write protected"
ERRSET XFNF
	.ASCIZ "File not found"
ERRSET XDKF
	.ASCIZ "The disk is full"
ERRSET XLKF
	.ASCIZ "The file is locked"
ERRSET XTMN
	.ASCIZ "Too many notes"
ERRSET XNTM
	.ASCIZ "You haven't set NVOICES yet"
ERRSET XSYN
	.ASCIZ "Bad character in filename"
ERRSET XRNG
	.ASCIZ "There's nothing to save"
ERRSET XLB1
	.ASCIZ "Labels can only be used inside procedures"
ERRSET XBFX
	.ASCIZ "Line given to RUN, REPEAT, or DEFINE is too long"
ERRSET XSQT
	.ASCIZ "Can't take the square root of a negative number"

;Special-case error message address table
ZAPTBL=.+TDIFF
	.ADDR	ZPMSG0+TDIFF
	.ADDR	ZPMSG1+TDIFF
	.ADDR	ZPMSG0+TDIFF
	.ADDR	ZPMSG2+TDIFF
	.ADDR	ZPMSG3+TDIFF
	.ADDR	ZPMSG4+TDIFF
	.ADDR	ZPMSG5+TDIFF
	.ADDR	ZPMSG6+TDIFF
	.ADDR	ZPMSG7+TDIFF

ZPMSG0:	.ASCIZ "No storage left!"
ZPMSG1:	.ASCIZ "Stopped!"
ZPMSG2:	.ASCIZ "Too many procedure inputs"
ZPMSG3:	.ASCIZ "Procedure"
ZPMSG4:	.ASCIZ "Tail-recursive"
ZPMSG5:	.ASCIZ "Parenthesis"
ZPMSG6:	.ASCIZ "IF-THEN"
ZPMSG7:	.ASCIZ "Evaluation"
ZPMX1:	.ASCIZ " nesting too deep"
.PAGE
.SBTTL		Miscellaneous Messages

;Terminated by $00

HELSTR=.+TDIFF
	.ASCII "MIT APPLE LOGO PROTOTYPE VERSION 3"
	$0D
	.ASCII "(C) 1981 M.I.T. - All rights reserved"
	$0D
	.ASCII "Assembled  11 JUNE 1981"
	$0D
	.ASCII "For use at authorized test sites only"
	$0D
.IFNE MUSINC
	.ASCII "Special music version"
	$0D
.ENDC
	$00
LBUG1=.+TDIFF
	$0D
	.ASCII "Logo system bug; entering Apple Monitor"
	$0D
	$00
RDRER2=.+TDIFF
	.ASCII "Ignoring unmatched right-bracket"
	$0D
	$00
WRNMSG=.+TDIFF
	.ASCII "Please ERASE something."
	$0D
	$00
ERRM1=.+TDIFF
	.ASCIZ ' " at level '
ERRM2=.+TDIFF
	.ASCIZ ' - in line "'
ERRM3=.+TDIFF
	.ASCIZ " of "
SENDM=.+TDIFF
	.ASCII " defined"
	$0D
	$00
PNMSG1=.+TDIFF
	.ASCIZ " is "
PNMSG2=.+TDIFF
	.ASCIZ 'MAKE "'
TBMSG1=.+TDIFF
	.ASCII "We're now at top-level."
	$0D
	$00
TBMSG2=.+TDIFF
	.ASCIZ "We're currently inside "
TRACEM=.+TDIFF
	.ASCIZ "TRACING O"
TRACM1=.+TDIFF
	.ASCIZ "Executing "
TRACM2=.+TDIFF
	.ASCIZ "Ending "
TRACM3=.+TDIFF
	.ASCIZ " with "
EDTMSG=.+TDIFF
	.ASCIZ "         MIT LOGO SCREEN EDITOR        "
TOMSG=.+TDIFF
	.ASCIZ "TO "
ENDMSG=.+TDIFF
	.ASCII "END"
	$0D
	$00
WAITM=.+TDIFF
	.ASCII "Please wait..."
	$0D
	$00
EXEND=.+TDIFF
	.ASCII "Ignoring extra END"
	$0D
	$00
TOPMSG=.+TDIFF
	.ASCIZ "Output is "
.PAGE
LOGOM=.+TDIFF
	$AE		;.
	$CC		;L
	$CF		;O
	$C7		;G
	$CF		;O
	$00
SCRNM=.+TDIFF
	$AE		;.
	$D0		;P
	$C9		;I
	$C3		;C
	$D4		;T
	$00
MUSM=.+TDIFF
	$AE		;.
	$CD		;M
	$D5		;U
	$D3		;S
	$00
.PAGE
.SBTTL		Sine Table
;Start of Sine table (93 4-byte floating point numbers)
SINTB1=.+TDIFF
	SINTAB $0000,$0000	;Extra entry for interpolation routine (cosine of 90.)
	SINTAB $0000,$0000	;0 degrees
	SINTAB $7A47,$7C2D
	SINTAB $7B47,$7963
	SINTAB $7B6B,$2F1D
	SINTAB $7C47,$6E3E
	SINTAB $7C59,$3F5B
	SINTAB $7C6B,$0982
	SINTAB $7C7C,$CB51
	SINTAB $7D47,$41B2
	SINTAB $7D50,$182E
	SINTAB $7D58,$E86A
	SINTAB $7D61,$B1B7
	SINTAB $7D6A,$7367
	SINTAB $7D73,$2CC9
	SINTAB $7D7B,$DD30
	SINTAB $7E42,$41F7	;15 degrees
	SINTAB $7E46,$902B
	SINTAB $7E4A,$D8DF
	SINTAB $7E4F,$1BBD
	SINTAB $7E53,$586F
	SINTAB $7E57,$8EA2
	SINTAB $7E5B,$8E01
	SINTAB $7E5F,$E638
	SINTAB $7E64,$06F5
	SINTAB $7E68,$1FE5
	SINTAB $7E6C,$30B6
	SINTAB $7E70,$3917
	SINTAB $7E74,$38B9
	SINTAB $7E78,$2F4A
	SINTAB $7E7C,$1C7C
	SINTAB $7F40,$0000	;30 degrees
	SINTAB $7F41,$ECC5
	SINTAB $7F43,$D465
	SINTAB $7F45,$B6BB
	SINTAB $7F47,$93A2
	SINTAB $7F49,$6AF4
	SINTAB $7F4B,$3C8C
	SINTAB $7F4D,$0846
	SINTAB $7F4E,$CDFF
	SINTAB $7F50,$8D92
	SINTAB $7F52,$46DD
	SINTAB $7F53,$F9BE
	SINTAB $7F55,$A612
	SINTAB $7F57,$4BB9
	SINTAB $7F58,$EA91
	SINTAB $7F5A,$827A	;45 degrees
	SINTAB $7F5C,$1354
	SINTAB $7F5D,$9D00
	SINTAB $7F5F,$1F5F
	SINTAB $7F60,$9A53
	SINTAB $7F62,$0DBF
	SINTAB $7F63,$7985
	SINTAB $7F64,$DD89
	SINTAB $7F66,$39B0
	SINTAB $7F67,$8DDE
	SINTAB $7F68,$D9F9
	SINTAB $7F6A,$1DE7
	SINTAB $7F6B,$598F
	SINTAB $7F6C,$8CD7
	SINTAB $7F6D,$B7A8
	SINTAB $7F6E,$D9EC	;60 degrees
	SINTAB $7F6F,$F38A
	SINTAB $7F71,$046D
	SINTAB $7F72,$0C80
	SINTAB $7F73,$0BAF
	SINTAB $7F74,$01E5
	SINTAB $7F74,$EF0F
	SINTAB $7F75,$D31A
	SINTAB $7F76,$ADF6
	SINTAB $7F77,$7F90
	SINTAB $7F68,$47D9
	SINTAB $7F79,$06C1
	SINTAB $7F79,$BC38
	SINTAB $7F7A,$6832
	SINTAB $7F7B,$0AA0
	SINTAB $7F7B,$A375	;75 degrees
	SINTAB $7F7C,$32A6
	SINTAB $7F7C,$B829
	SINTAB $7F7D,$33F1
	SINTAB $7F7D,$A5F6
	SINTAB $7F7E,$0E2E
	SINTAB $7F7E,$6C92
	SINTAB $7F7E,$C11B
	SINTAB $7F7F,$0BC1
	SINTAB $7F7F,$4C7E
	SINTAB $7F7F,$834F
	SINTAB $7F7F,$B02E
	SINTAB $7F7F,$D318
	SINTAB $7F7F,$EC0A
	SINTAB $7F7F,$FB02
	SINTAB $8040,$0000	;90 degrees
	SINTAB $8040,$0000	;Extra entry for interpolation routine (sine of 90.)
SINTB2=.+TDIFF
;The low order bytes of the sine table will be put here by the
; SINTAB macro. The point won't be changed, so it's done explicitly.
.=SINTB2+SINDIF-TDIFF
.PAGE
.IFNE GRPINC
.SBTTL		Turtle Shape Table and Images

SHPTBL=.+TDIFF		;lookup table for selecting shape images
	.ADDR TRT0	;Shapes are first quadrant, every 5 degrees (0-85.)
	.ADDR TRT0
	.ADDR TRT10
	.ADDR TRT10
	.ADDR TRT20
	.ADDR TRT20
	.ADDR TRT30
	.ADDR TRT30
	.ADDR TRT40
	.ADDR TRT40
	.ADDR TRT50
	.ADDR TRT50
	.ADDR TRT60
	.ADDR TRT60
	.ADDR TRT70
	.ADDR TRT70
	.ADDR TRT80
	.ADDR TRT80
.PAGE
;	Actual shape images:
.radix 8
TRT0=.+TDIFF
	77
	77
	54
	44
	45
	54
	44
	14
	56
	76
	56
	65
	77
	67
	55
	55
	66
	65
	77
	77
	0

TRT10=.+TDIFF
	74
	77
	47
	45
	45
	45
	45
	45
	65
	76
	36
	55
	45
	26
	53
	56
	66
	77
	77
	0

TRT20=.+TDIFF
	47
	73
	47
	41
	51
	14
	55
	54
	14
	66
	67
	53
	65
	66
	76
	77
	70
	0

TRT30=.+TDIFF
	74
	34
	57
	50
	14
	55
	54
	45
	26
	67
	57
	61
	57
	62
	66
	47
	77
	74
	7
	0

TRT40=.+TDIFF
	34
	77
	50
	14
	145
	55
	56
	44
	55
	264
	67
	65
	67
	66
	76
	34
	347
	7
	0

TRT50=.+TDIFF
	74
	74
	74
	14
	55
	55
	54
	56
	54
	45
	55
	76
	66
	47
	67
	257
	65
	67
	66
	67
	47
	47
	47
	7
	0

TRT60=.+TDIFF
	44
	47
	47
	55
	55
	65
	56
	44
	55
	275
	67
	365
	67
	76
	366
	74
	44
	7
	0

TRT70=.+TDIFF
	344
	344
	55
	65
	55
	56
	254
	155
	67
	77
	67
	55
	36
	36
	36
	36
	344
	344
	0

TRT80=.+TDIFF
	44
	74
	54
	55
	25
	65
	56
	44
	65
	55
	55
	27
	77
	67
	375
	76
	76
	36
	47
	74
	7
	0
.radix 10
.ENDC
.PAGE
.SBTTL		Primitive Table

;Primitive-table format:
;	<Index>,<No. of args>,<Precedence>,<Print-name>,0
;Note:	Abbreviations use a separate entry. For primitives with a variable
;	number of arguments, the high bit of <No. of args> is set.

;Primitives created with PRIM must be in the same order as in
; the primitive address table.

PRMTAB=.+TDIFF
IUNSUM	=1	;(Unary Sum)
IUNDIF	=2	;(Unary Difference)
LP=IUNDIF			;Initialize index number
	PRIM 2,6,INSUM,"+"
INLOW=LP			;Lowest infix primitive index
	PRIM 2,6,INDIF,"-"
	PRIM 2,7,INPROD,"*"
	PRIM 2,7,INQUOT,"/"
	PRIM 2,4,INGRTR,">"
	PRIM 2,4,INLESS,"<"
	PRIM 2,3,INEQUL,"="
INHIGH=LP			;Highest infix primitive index
	PRIM 2,5,IQTENT,"QUOTIENT"
	PRIM 2,5,IRMNDR,"REMAINDER"
	PRIM 1,5,IROUND,"ROUND"
	PRIM 1,5,IINT,"INTEGER"
	PRIM 1,5,ISIN,"SIN"
	PRIM 1,5,ICOS,"COS"
	PRIM 1,5,ISQRT,"SQRT"
	PRIM 1,5,IATAN,"ATAN"
	PRIM 1,2,INOT,"NOT"
	PRIM $82,1,IAND,"ALLOF"
	PRIM $82,1,IOR,"ANYOF"
	PRIM 1,5,ITHNGP,"THING?"
	PRIM 1,5,IWORDP,"WORD?"
	PRIM 1,5,ILISTP,"LIST?"
	PRIM 1,5,INMBRP,"NUMBER?"
	PRIM 0,0,ICHARP,"CHAR?"
	PRIM 1,5,IFIRST,"FIRST"
	PRIM 1,5,ILAST,"LAST"
	PRIM 1,5,IBTFST,"BUTFIRST"
	PRIM 1,5,IBTLST,"BUTLAST"
	PRIM $82,5,IWORD,"WORD"
	PRIM 2,0,IFPUT,"FPUT"
	PRIM 2,0,ILPUT,"LPUT"
	PRIM $82,5,ILIST,"LIST"
	PRIM $82,5,ISNTNC,"SENTENCE"
	PRIM 2,0,IMAKE,"MAKE"
	PRIM 1,0,IOTPUT,"OUTPUT"
	PRIM 0,0,ISTOP,"STOP"
;	PRIM 0,0,ICOMNT,";"	Explicitly:
LP=LP+1
	.BYTE 0
	.BYTE 0
	.BYTE LP
	.BYTE $3B
	.BYTE $00
ICOMNT=LP
	PRIM 0,0,ICNTIN,"CONTINUE"
	PRIM 1,0,ITEST,"TEST"
	PRIM 0,0,IIFT,"IFTRUE"
	PRIM 0,0,IIFF,"IFFALSE"
	PRIM 1,0,IIF,"IF"
	PRIM 0,0,ITHEN,"THEN"
	PRIM 0,0,IELSE,"ELSE"
	PRIM 1,0,IGO,"GO"
	PRIM 1,5,IRUN,"RUN"
	PRIM 2,5,IRPEAT,"REPEAT"
	PRIM 0,0,IREQST,"REQUEST"
	PRIM 1,5,ITHING,"THING"
	PRIM 0,0,IGCOLL,".GCOLL"
	PRIM 0,0,INODES,".NODES"
	PRIM 2,0,IDEFIN,"DEFINE"
	PRIM 1,5,ITEXT,"TEXT"
	PRIM 0,0,ITO,"TO"
	PRIM 0,0,IEDIT,"EDIT"
	PRIM 0,0,IEND,"END"
	PRIM $81,0,IPRINT,"PRINT"
	PRIM $81,0,IPRNT1,"PRINT1"
	PRIM 0,0,IPO,"PRINTOUT"
	PRIM 0,0,IPOTS,"POTS"
	PRIM 0,0,IERASE,"ERASE"
	PRIM 1,0,IERNAM,"ERNAME"
	PRIM 0,0,IALL,"ALL"
	PRIM 0,0,INAMES,"NAMES"
	PRIM 0,0,ITITLS,"TITLES"
	PRIM 0,0,IPROCS,"PROCEDURES"
	PRIM 0,0,ITRCBK,"TRACEBACK"
	PRIM 0,0,ITRACE,"TRACE"
	PRIM 0,0,INTRAC,"NOTRACE"
	PRIM 1,5,IRANDM,"RANDOM"
	PRIM 0,0,IRNDMZ,"RANDOMIZE"
	PRIM 0,0,IRC,"READCHARACTER"
	PRIM 2,5,ICURSR,"CURSOR"
	PRIM 0,0,ICLINP,"CLEARINPUT"
	PRIM 0,0,ICLEAR,"CLEARTEXT"
	PRIM 1,5,IPADDL,"PADDLE"
	PRIM 1,5,IPDBTN,"PADDLEBUTTON"
	PRIM 1,5,IEXM,".EXAMINE"
	PRIM 2,0,IDEP,".DEPOSIT"
	PRIM 1,0,ICALL,".CALL"
	PRIM 0,0,IPAUSE,"PAUSE"
	PRIM 0,0,IBPT,".BPT"
	PRIM 0,0,ITPLVL,"TOPLEVEL"
	PRIM 0,0,IGDBYE,"GOODBYE"
	PRIM 0,0,ILPAR,"("
	PRIM 0,0,IRPAR,")"
	PRIM 1,5,ILETOF,"CHAR"
	PRIM 1,5,INUMOF,"ASCII"
	PRIM 1,0,IINADR,".INDEVICE"
	PRIM 1,0,IOTADR,".OUTDEVICE"
;	Filing:
	PRIM 1,0,IREAD,"READ"
	PRIM 1,0,ISAVE,"SAVE"
	PRIM 1,0,IDELET,"ERASEFILE"
	PRIM 0,0,ICATLG,"CATALOG"
.PAGE
	PRIMA 1,5,IBTFST,"BF"
	PRIMA 1,5,IBTLST,"BL"
	PRIMA 0,0,ICNTIN,"CO"
	PRIMA 0,0,IEDIT,"ED"
	PRIMA 0,0,IERASE,"ER"
	PRIMA 0,0,IIFF,"IFF"
	PRIMA 0,0,IIFT,"IFT"
	PRIMA 1,0,IOTPUT,"OP"
	PRIMA $81,0,IPRINT,"PR"
	PRIMA 0,0,IPO,"PO"
	PRIMA 0,0,IRC,"RC"
	PRIMA 0,0,IREQST,"RQ"
	PRIMA $82,5,ISNTNC,"SE"
	PRIMA 0,0,ITRCBK,"TB"
.PAGE
.IFNE GRPINC
;	Graphics primitives:
	PRIM 1,0,IFORWD,"FORWARD"
	PRIM 1,0,IBACK,"BACK"
	PRIM 1,0,IRIGHT,"RIGHT"
	PRIM 1,0,ILEFT,"LEFT"
	PRIM 0,0,IDRAW,"DRAW"
	PRIM 0,0,IHOME,"HOME"
	PRIM 0,0,IPENUP,"PENUP"
	PRIM 0,0,IPENDN,"PENDOWN"
	PRIM 0,0,ISHOWT,"SHOWTURTLE"
	PRIM 0,0,IHIDET,"HIDETURTLE"
	PRIM 0,0,ITSTAT,"TURTLESTATE"
	PRIM 0,0,INDSPL,"NODRAW"
	PRIM 1,0,ISETX,"SETX"
	PRIM 1,0,ISETY,"SETY"
	PRIM 2,0,ISETXY,"SETXY"
	PRIM 1,0,ISETH,"SETHEADING"
	PRIM 1,0,ISETT,"SETTURTLE"
	PRIM 0,0,IXCOR,"XCOR"
	PRIM 0,0,IYCOR,"YCOR"
	PRIM 0,0,IHDING,"HEADING"
	PRIM 0,0,IFULL,"FULLSCREEN"
	PRIM 0,0,ISPLIT,"SPLITSCREEN"
	PRIM 1,0,IRDPCT,"READPICT"
	PRIM 1,0,ISVPCT,"SAVEPICT"
	PRIM 1,0,IERPCT,"ERASEPICT"
	PRIM 1,0,IPALET,"PALETTE"
	PRIM 1,0,IPENC,"PENCOLOR"
	PRIM 0,0,ICS,"CLEARSCREEN"
	PRIM 1,0,IBKGND,"BACKGROUND"
	PRIM 1,0,ISCNCH,".ASPECT"
	PRIM 2,5,ITWRDS,"TOWARDS"
	PRIM 0,0,IWRAP,"WRAP"
	PRIM 0,0,INOWRP,"NOWRAP"
	PRIM 1,0,ISPENC,"SETPENCOLOR"
	PRIM 1,0,ISBKGD,"SETBACKGROUND"

	PRIMA 1,0,IBACK,"BK"
	PRIMA 1,0,IBKGND,"BG"
	PRIMA 0,0,ICS,"CS"
	PRIMA 1,0,IFORWD,"FD"
	PRIMA 0,0,IHIDET,"HT"
	PRIMA 1,0,ILEFT,"LT"
	PRIMA 0,0,INDSPL,"ND"
	PRIMA 1,0,IPENC,"PC"
	PRIMA 0,0,IPENDN,"PD"
	PRIMA 0,0,IPENUP,"PU"
	PRIMA 1,0,IRIGHT,"RT"
	PRIMA 1,0,ISETH,"SETH"
	PRIMA 1,0,ISBKGD,"SETBG"
	PRIMA 1,0,ISPENC,"SETPC"
	PRIMA 1,0,ISETT,"SETT"
	PRIMA 0,0,ISHOWT,"ST"
	PRIMA 0,0,ITSTAT,"TS"
.ENDC
.IFNE MUSINC
.PAGE
;	Music primitives:
	PRIM 1,0,IVOICE,"VOICE"
	PRIM 1,0,INVOIC,"NVOICES"
	PRIM 0,0,IPLAYM,"PLAYMUSIC"
	PRIM 2,0,INOTE,"NOTE"
	PRIM 2,0,IAD,"SETAD"
	PRIM 2,0,IVS,"SETVS"
	PRIM 2,0,IRG,"SETRG"
	PRIM 2,0,IFZ,"SETFUZZ"
	PRIM 1,0,ISVMUS,"SAVEMUSIC"
	PRIM 1,0,IRDMUS,"READMUSIC"
	PRIM 1,0,IERMUS,"ERASEMUSIC"

	PRIMA 0,0,IPLAYM,"PM"
.ENDC
FGRMBT:	$00	;Graphics memory map byte table
	$00
	$00
	$53
	$4C
	$48
	$00
	$00
	$00
	$00
	$50
	$47
	$53
	$00
	$00
	$00
	$00
	$4B
	$4C
	$4F
	$54
	$5A
	$00
	$00
	$00
	$00
	$48
	$41
	$4C
	$00
.PAGE

;	Unary primitives created explicitly:

PRMSUM=.+TDIFF
	1
	8
	IUNSUM

PRMDIF=.+TDIFF
	1
	8
	IUNDIF

PRMTBE=PRMSUM
ENDTAB=.	;End of Ghost-memory storage
.PRINT .-GHODAT	;LENGTH OF GHOST MEMORY (< $1000)

.=OCODE-$0A
.PRINT .	;DISK SAVE START ADDRESS
.PRINT ENDPGM-.	;DISK SAVE LENGTH
	JMP LOGO	;Cold start vector instruction
	JMP LOGO1	;Warm start vector instruction
	JMP REENT	;Crash re-entry vector instruction

;Local Modes:
;Mode:Midas
;Comment Column:24
;End Local Modes:
.END
