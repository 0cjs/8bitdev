;   arithtest: tests of and playing about with arithmetic routines

;   Standard locations for inputs and results. All operations are in the
;   form X = A ⋅ B, with Y as an additional result where needed. These are
;   prefixed by `_` to avoid conflicts with register names.
;
_A          equ $20
_B          equ $22
_X          equ $24
_Y          equ $26

; ----------------------------------------------------------------------
;   Divide unsigned 16-bit word via shift-and-subtract
;   _X = _A / _B, remainder _Y      ♠_X,_Y, ♣_A,A,B ♡_B,X
;
;   The basic algorithm works just like decimal long division by hand. We
;   collect digits (bits) from the left (most signifcant end) until we
;   have accumlated enough digits that we can subtract the divisor
;   from them. At this point the rightmost digit (bit) we've collected is
;   treated as the temporary "ones" column, we do our subtraction leaving a
;   remainder, and then add the result of the subtraction to the current
;   digit column (bit position) in the quotient that we're working on. We
;   carry on this way until all columns (bits positions) have been done.
;
;   There are two main differences from by-hand decimal when we do this in
;   binary on a computer.
;   1. Rather than moving our pencil along the digit columns from left to
;      right, we leave our attention point fixed (on the dividend's MSbit
;      and the quotient's and remainders LSbit) and instead, with each loop
;      of the algorithm, shift the columns/bits out of the dividend and
;      into the remainder and quotent.
;   2. Since every shift in binary only doubles the remainder, it is never
;      possible to subtract more than one times the divisor from the
;      remainder, meaning that we never need to add more than one bit to
;      the quotient. (In base 10 a one-digit shift multiplies by ten, so
;      you might have as much as 9 × the divisor in the remainder, and
;      thus have to subtract all that and add up to 9 to the quotent.)
;
divUW_ss    ;  Q = D / V,  R = D mod V

.Dh         equ _A          ; dividend  high byte
.Dl         equ _A+1        ;           low
.Vh         equ _B          ; divisor   high byte
.Vl         equ _B+1        ;           low
.Qh         equ _X          ; quotient  high byte
.Ql         equ _X+1        ;           low
.Rh         equ _Y          ; remainder high byte
.Rl         equ _Y+1        ;           low

            lda A,#0        ; clear outputs
            sta .Qh
            sta .Ql
            sta .Rh
            sta .Rl
            lda B,#16       ; bits in a word

.loop       asl .Dl         ; MSB out of dividend...
            rol .Dh
            rol .Rl         ;   ...and into remainder
            rol .Rh
            lda A,.Rh       ; remainder MSB - divisor MSB
            cmp A,.Vh
            bcs .noquotent  ; R < V: cannot subtract divisor from remainder
            bgt .hasquotent ; R > V: must subtract divisor from remainder
            lda A,.Rl       ; MSBs were equal, so compare LSBs
            cmp A,.Vl
            bcs .noquotent  ; R < V: cannot subtract divisor from remainder

.hasquotent ; move quotient portion from remainder to quotent
            lda A,.Rl       ; R = R - V, making R less than V again
            sub A,.Vl
            sta A,.Rl
            lda A,.Rh       ;   (MSB)
            sbc A,.Vh
            sta A,.Rh
            sec             ; V now removed from remainder; add it into Q by
            bra .next       ;   settting in Q the current bit we're working
                            ;   on. (This will be shifted up to its proper
                            ;   place as we carry on.)

.noquotent  clc             ; R was less than V, so nothing to add into to Q.

.next       rol .Ql         ; incorporate quotient update from remainder
            rol .Qh
            dec B
            bne .loop

            rts

; ----------------------------------------------------------------------
;   ♣A,B,X print unsigned 16-bit int at (X) in decimal
;
;   This uses the relatively simple and fast "multiple subtraction of
;   factors" method: count all the 10,000s you can subtract, print out
;   that digit, then the 1,000s, and so on. This iterates fewer loops
;   than doing actual division and also produces digits in the output
;   order while using minimal storage space.
;

prdec_u16

.n          equ _A          ; temp holding remainder of uint we're processing

            lda A,0,X       ; copy input MSB...
            sta A,.n
            lda A,1,X       ;   ...and LSB
            sta A,.n+1
            ldx #.ten_tab-2 ; position just before first (largest) factor

.nextfactor inx             ; next factor
            inx
            lda B,#0        ; count of this factor's quantity
            lda A,1,X       ; end of list marker?
            bne .subfactor  ;   nonzero: carry on

            lda A,.n+1      ; remaining amount is final digit
            add A,#'0'
            jsr prchar
            rts

            ;   All possible 10^n (where n>0) factors of $FFFF, terminated
            ;   by low-byte 0. The termination is slightly tricky: it relies
            ;   on the fact that none of the factors have an LSB of 0.
.ten_tab    dw  10000, 1000, 100, 10, 0

.subfactor
            lda .n+1        ; subtract factor from LSB...
            sub A,1,X
            sta .n+1
            lda .n
            sbc A,0,X       ;   ...and MSB
            sta .n
            bcs .finfactor  ; we underflowed; we're done with this factor
            inc B
            bra .subfactor

.finfactor  ;   Add factor back into current value to undo underflow.
            lda A,.n+1      ; LSB and...
            add A,1,X
            sta A,.n+1
            lda A,.n        ;   ...MSB
            adc A,0,X
            sta A,.n

            tba             ; count of this factor
            add A,#'0'      ; convert to ASCII
            jsr prchar
            bra .nextfactor
