from    mc6800sim  import MC6800, Instructions as I
import  pytest

@pytest.fixture
def m():
    return MC6800()

####################################################################
#   Registers

def test_init(m):
    assert 0 == m.a == m.b == m.x == m.sp == m.pc
    assert False == m.H == m.I == m.N == m.Z == m.V == m.C
    assert 65536 == len(m.mem)
    assert 0 == m.mem[0]
    assert 0 == m.mem[65535]

def test_set_reg8(m):
    m.a = 1;    assert 1 == m.a
    m.a = 0;    assert 0 == m.a
    m.a = 0xFF; assert 0xFF == m.a

    with pytest.raises(ValueError): m.a = -1

    with pytest.raises(ValueError) as ex:
        m.a = 0x100
    assert ex.match("^Register/flag 'a' value 0x100 exceeds range 0-0xFF")
    assert 0xFF == m.a

def test_set_reg16(m):
    m.sp = 0xFFFF
    with pytest.raises(ValueError) as ex:
        m.sp = 0x10000
    assert ex.match("^Register/flag 'sp' value 0x10000 exceeds range 0-0xFFFF")

def test_set_flag(m):
    m.C = True;  assert True  is m.C
    m.C = False; assert False is m.C

    with pytest.raises(ValueError) as ex:
        m.Z = 2
    assert ex.match("^Register/flag 'Z' value 0x2 exceeds range 0-0x1")

####################################################################
#   Memory

def test_mem(m):
    assert 0x00 == m.mem[0]
    m.mem[0] = 0xFF
    assert 0xFF == m.mem[0]

    with pytest.raises(ValueError): m.mem[0] = 0x100
    with pytest.raises(ValueError): m.mem[0] = -1

    with pytest.raises(IndexError): m.mem[0x10000] = 0

def test_mem_examine(m):
    assert 0                == m.byte(0x0005)
    assert b'\0\0\0\0'      == m.bytes(0x0004, 4)

    m.mem[5] = 0xCA
    assert 0xCA             == m.byte(0x0005)
    assert b'\0\xCA\0\0'    == m.bytes(0x0004, 4)
    assert bytes            is type(m.bytes(0x0004, 4))

    m.mem[6] = 0xFE
    assert b'\0\xCA\xFE\0'  == m.bytes(0x0004, 4)
    assert 0xCAFE           == m.word(0x0005)

    assert (0xCA, 0xFE00)   == m.words(0x0004, 2)

    with pytest.raises(IndexError): m.byte(0x10000)
    with pytest.raises(IndexError) as ex:
        m.bytes(0xFFFF, 3)
    assert ex.match('^Last address 0x10001 out of range$')

    with pytest.raises(IndexError): m.word(0xFFFF)
    with pytest.raises(IndexError): m.words(0xFFFD, 2)

def test_mem_deposit(m):
    msize = len(m.mem)

    assert b'\x01'              == m.deposit(0x800, 1)
    assert msize == len(m.mem)

    assert b'\x02\x03\x04'      == m.deposit(0x802, 2, 3, 4)
    assert b'\x05\x06\x07\x08'  == m.deposit(0x806, [5, 6], 7, b'\x08')
    assert b'\x01\x00\x02\x03\x04\x00\x05\x06\x07\x08\x00' == m.bytes(0x800, 11)
    assert msize == len(m.mem)

    with pytest.raises(IndexError) as ex:
        m.deposit(0xFFFF, (0, 0))
    assert ex.match('^Last address 0x10000 out of range$')
    assert msize == len(m.mem)

def test_mem_depword(m):
    msize = len(m.mem)

    b = m.depword(0x0200, [0xFFFF, 0x8384], 0x8586)
    assert b'\xFF\xFF\x83\x84\x85\x86' == b
    assert bytes is type(b)
    assert msize == len(m.mem)

    with pytest.raises(ValueError) as ex:
        m.depword(0x0012, 2, [1, -1, 0], 0)
    assert ex.match('^deposit @\\$0012: invalid word value \\$-1$')
    with pytest.raises(ValueError): m.depword(0x0014, 0, 0x10000)
    assert msize == len(m.mem)

def test_mem_depword_range(m):
    m.depword(0xFFFE, 0)
    with pytest.raises(IndexError) as ex:
        m.depword(0xFFFF, 0)
    assert ex.match('^Last address 0x10000 out of range$')

    m.depword(0xFFFC, 0, 0)
    with pytest.raises(IndexError) as ex:
        m.depword(0xFFFD, 0, 0)
    assert ex.match('^Last address 0x10000 out of range$')

####################################################################
#   Instruction Execution

def test_step_LDAA(m):
    ''' This is testing both `step()` and the implementation of the `LDAA`
        opcode. Possibly this should be split up somehow.
    '''

    start = 0x200
    m.deposit(start, [I.LDAA, 0xEA, I.LDAA, 0x00])

    mem = m.mem.copy();
    m.a = 0x00; m.N = False; m.Z = True; m.V = True;
    m.pc = start; m.step(1)
    #   XXX We should have a `Regs` structure like testmc.6502 for
    #   comparing registers and flags against values and don't-care.
    assert 0xEA == m.a
    assert (True, False, False) == (m.N, m.Z, m.V)
    assert start + 2 == m.pc
    assert mem == m.mem

    m.pc = start; m.step(2)
    assert 0x00 == m.a
    assert (False, True, False) == (m.N, m.Z, m.V)
    assert start + 4 == m.pc
