;   Apple II monitor extension for doing hex+ASCII dumps.
;
;   The following routines are designed to extend the Monitor via the
;   Ctrl-Y command. To connect code starting at $HHLL to Ctrl-Y, enter a
;   JMP to its start point $HHLL at $3F8: `3F8: 4C LL HH`.
;
;   Most of the routines are PIC (Position-Independent Code) and may be
;   loaded anywhere. The $300-$3CF area is a common place for these. (Note
;   that EDASM claims to use this entire page, though I've seen it use only
;   the first dozen or so bytes of it.)
;
;   For more details on how the Monitor works, see:
;   https://github.com/0cjs/sedoc/blob/master/8bit/apple2/monitor.md

            cpu     6502
            include "src/a2/def.a65"

            ;   The routine is location independent; we do not specify
            ;   the location here because we want to let the framework
            ;   that loads it do that. But here's a suggestion:
            ;org     $300

;   Argument and temporary address storage. See
;   https://github.com/0cjs/sedoc/blob/master/8bit/apple2/monitor.md

mnext       equ A1L         ; Next location to be printed;
                            ;    set by entering an address.
mend        equ A2L         ; End address; set to mnext when mnext set;
                            ;    `.` command changes it to following addr;
                            ;    cleared after following command.
mdest       equ A3L         ; Dest address copied from mnext by `<` command;
                            ;    cleared after any non-`.` command.
;PCL        equ PCL         ; Current PC set by `L` and `G` commands.

;---------------------------------------------------------------------
;   (PIC) dumpmonvar: print monitor UI variables
;
;   This prints the saved PC and the addresses/16-bit values stored in  A1
;   through A5. These are variables used by the monitor user interface for
;   command handling and "remembered" addresses.
;
;   This depends on COUT preserving X and Y. This is true for the screen
;   (PR#0), but may not be for other char switch (CSW) routines.
;
dumpmonvar  ;   Print PC, A1, ..., A5
            ldy #6              ; 6 words to display
            ldx #PCL            ; first word to display
.nextA      lda #AA(' ')
            jsr COUT
            lda 1,x             ; high byte
            jsr PRBYTE
            lda 0,x             ; low byte
            jsr PRBYTE
            inx                 ; next word
            inx
            dey                 ; decrement count
            bne .nextA
            jsr CROUT1
            rts

;---------------------------------------------------------------------
;   (PIC) Memory dump in hexadecimal and characters.
;
;   In order to make life a bit more convenient, this differs from the
;   Monitor's standard memory dump command in the following ways:
;
;   * The "end" address argument is not the last address to be dumped, but
;     _one past_ the last address to be dumped. (This also makes the code
;     simpler.
;   * The saved PC is set to the start address of the dump, so that a
;     subsequent L or G command will use that location.
;
;   Notes:
;   * This depends on COUT preserving X and Y. This is true for the screen
;     (PR#0), but may not be for other char switch (CSW) routines.

hexdump
            ldy #0          ; Constant value for indexed addressing.

            ;   Set the PC (next address for the G and L commands)
            ;   to our start address, to make it convenient to list
            ;   or run what we just looked at.
            ;   This also serves as our saved start value for printing
            ;   the characters after the hex dump.
            lda mnext
            sta PCL
            lda mnext+1
            sta PCH

            ;   Print current address (followed by hyphen) and hex bytes
            ;   up to mod-8 boundary.
.nextline   jsr PRA1
.nexthex    lda #AA(' ')    ; space before every hex byte
            jsr COUT
            lda (mnext),y   ; and the data itself
            jsr PRBYTE
            inc mnext
            bne .checkend
            inc mnext+1
.checkend   ;   Check to see if we've reached the end.
            lda mend
            cmp mnext
            bne .checkline
            lda mend+1
            cmp mnext+1
            beq .finish
.checkline  lda mnext
            and #$07        ; A mod 8 == 0?
            beq .nextline
            bne .nexthex

.finish     rts

            ; XXX print the char values somehow.
