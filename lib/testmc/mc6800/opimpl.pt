from    testmc.mc6800.opcodes   import Instructions as I
from    testmc.mc6800.opimpl    import *
from    testmc.mc6800           import Machine
from    testmc                  import tmc_tid, LSB, MSB
from    numbers                 import Number
import  pytest

#   Many functions from the opimpl module are not directly tested, but
#   instead are tested through the tests of instruction implementations.
#   This is because we want to test directly as many instruction
#   implementations as possible. The instruction implementations themselves
#   are usually very simple, and so their tests are mainly testing the
#   support functions anyway.

####################################################################
#   Address handling, reading data at the PC, reading/writing stack

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         (   0xFE,      1,     0xFF),
                         (   0xFE,      2,     0x00),
                         (   0xFE,      3,     0x01),
                         (      1,     -1,        0),
                         (      1,     -2,     0xFF),
                         (      1,     -3,     0xFE),
), ids=tmc_tid)
def test_incbyte(initial, addend, expected):
    assert expected == incbyte(initial, addend)

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         ( 0xFFFE,      1,   0xFFFF),
                         ( 0xFFFE,      2,   0x0000),
                         ( 0xFFFE,      3,   0x0001),
                         (      1,     -1,        0),
                         (      1,     -2,   0xFFFF),
                         (      1,     -3,   0xFFFE),
                         ( 0x8000, 0xFFFF,   0x7FFF),
                         ( 0x8000,-0xFFFF,   0x8001),
), ids=tmc_tid)
def test_incword(initial, addend, expected):
    assert expected == incword(initial, addend)

@pytest.mark.parametrize(' inb,   out', (
                         (0x00,     0),
                         (0x01,     1),
                         (0x7F,  0x7F),
                         (0x80, -0x80),
                         (0xFF,    -1),
), ids=tmc_tid)
def test_readsignedbyte(inb, out):
    m = Machine()
    m.pc = 0xFFFF
    m.deposit(m.pc, inb)
    assert out == readsignedbyte(m)
    assert 0x0000 == m.pc

@pytest.mark.parametrize('initsp,    word,  newsp', (
                         (     0,  0x4142,      2),
                         (     1,  0x4243,      3),
                         (0xFFFD,  0xCECF, 0xFFFF),
                         (0xFFFE,  0xCF40,      0),
                         (0xFFFF,  0x4041,      1),
), ids=tmc_tid)
def test_popword(initsp, word, newsp):
    m = Machine()
    m.deposit(0x0000, b'\x40\x41\x42\x43')
    m.deposit(0xFFFC, b'\xCC\xCD\xCE\xCF')

    m.sp = initsp
    assert word == popword(m)
    assert newsp == m.sp

####################################################################
#   Opcode test framework

R = Machine.Registers

def runop(opdata, *, machine=None, memsize=0x20,
        startaddr=0x0E, initregs=R(), initmem=None,
        changedregs=R(), changedmem=None):
    m = machine
    if m is None:
        m = Machine(memsize=memsize)

    m.deposit(startaddr, opdata)
    if initmem is not None:
        for addr, value in initmem.items():
            m.deposit(addr, value)
    m.setregs(initregs)

    #   For any register not explicitly set that has a value in changedregs,
    #   set it to some other value so we can confirm it was changed.
    unsetregs = set()
    for name, val in initregs.all().items():
        if val is None: unsetregs.add(name)
    #   But always exclude the program counter and stack pointer
    #   as they should never be randomized!
    unsetregs.discard('pc'); unsetregs.discard('sp')
    for name, val in changedregs.all().items():
        if name in unsetregs:
            setattr(m, name, not val)

    m.pc = startaddr
    prevregs = m.regs
    prevmem = bytes(m.mem)

    m.step(1)

    regs = m.regs
    #   If any regs in the machine are unvalued (i.e., set to `None`)
    #   the opcode implementation has done something very wrong.
    unvalued = set(regs.all().keys()) - set(regs.valued().keys())
    assert not unvalued, 'op produced unvalued register(s)'

    if changedregs.pc is None:
        changedregs = changedregs.clone(pc=startaddr + len(opdata))
    allregs = prevregs.clone(**changedregs.valued())

    #   Lining these up in columns makes it easier to see what was wrong.
    print('    expected all:', allregs)
    print('expected changed:', changedregs)
    print('          actual:', regs)

    #   First assert that the registers and flags expected to change have
    #   their correct values. This makes more clear test failures where a
    #   tested value is wrong.
    assert changedregs == regs, "expected register/flag changes"
    #   Now assert that the other registers and flags, which we did not expect
    #   to change (and are not explicitly tested), are actually unchanged.
    assert allregs == regs, "unexpected register/flag changes"

    if changedmem is None:
        assert prevmem == bytes(m.mem)
    else:
        newmem = bytearray(prevmem)
        for addr, value in changedmem.items():
            newmem[addr] = value
        assert newmem == m.mem

####################################################################
#   Misc instructions

def test_NOP():
    #   The test framework will ensure that nothing but the PC has changed.
    runop([I.NOP])

####################################################################
#   Branches

def test_JMP():
    runop([I.JMP, 0xAB, 0xCD], changedregs=R(pc=0xABCD))

@pytest.mark.parametrize('offset,      x,     pc', (
                         (     0, 0xFFFF, 0xFFFF),
                         (     3, 0x1234, 0x1237),
                         (  0xFF, 0xFF80, 0x007F),
), ids=tmc_tid)
def test_JMPx(offset, x, pc):
    runop([I.JMPx, offset], initregs=R(x=x), changedregs=R(pc=pc))

def test_BRA():
    runop([I.BRA,    0], startaddr=0x13, changedregs=R(pc=0x0015))
    runop([I.BRA, 0x80], startaddr=0x0E, changedregs=R(pc=0xFF90))
    #   Additional coverage in test_readsignedbyte().

############################

def test_JSR():
    runop([I.JSR, 0x56, 0x78],
        memsize=65536, startaddr=0x1234,
        initregs    = R(sp=0),                      # test stack wraparound
        changedregs = R(pc=0x5678, sp=0xFFFE),
        changedmem  = { 0x0000: 0x37, 0xFFFF: 0x12, })

def test_JSRx():
    runop([I.JSRx,                    0x16],
        initregs    = R(sp=0x1F,  x=0xFFF0, ),
        changedregs = R(sp=0x1D, pc=0x0006, ),
        startaddr   =                   0x0123,     memsize=0x140,
        changedmem  = { 0x1E: 0x01, 0x1F: 0x25, },
    )

def test_BSR():
    runop([I.BSR, 0xFE], startaddr=0x12,            # calling self
        initregs    = R(sp=0x18),
        changedregs = R(sp=0x16, pc=0x12),
        changedmem  = { 0x17: 0x00, 0x18: 0x14, },
    )

############################

def test_RTS():
    m = Machine(memsize=0x40)
    m.sp = 0x002D; m.depword(0x002E, 0x1234)
    runop([I.RTS], machine=m, changedregs=R(pc=0x1234, sp=0x002F))

############################

def test_BMI_not():
    runop([I.BMI, 0x40], initregs=R(N=0), changedregs=R(pc=0x0010))

def test_BMI_taken():
    runop([I.BMI, 0x40], initregs=R(N=1), changedregs=R(pc=0x0050))

####################################################################
#   Data Movement

def test_PULA():
    runop([I.PULA],
        initregs    = R(sp=0x000C),
        initmem     = { 0x000D: 0xA1 },
        changedregs = R(sp=0x000D, a=0xA1),
        )

def test_PSHA():
    runop([I.PSHA],
        initregs    = R(a=0xEF, sp=0x000F),
        changedregs = R(sp=0x000E),
        changedmem  = { 0x000F: 0xEF },
        )

@pytest.mark.parametrize('arg,  N, Z', (
                         (0x01, 0, 0),
                         (0x00, 0, 1),
                         (0xEA, 1, 0),
), ids=tmc_tid)
def test_LDAA(arg, N, Z):
    runop([I.LDAA, arg], changedregs=R(a=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize('   a,    loc, N, Z', (
                         (0x03, 0x0000, 0, 0),
                         (0x00, 0x0101, 0, 1),
                         (0xEB, 0x1234, 1, 0),
), ids=tmc_tid)
def test_STAAm(a, loc, N, Z):
    runop([I.STAAm, MSB(loc), LSB(loc)], memsize=max(loc+2, 0x20),
        initregs    = R(a=a),
        changedregs = R(N=N, Z=Z, V=0),
        changedmem  = { loc: a })

####################################################################
#   Flag handling for data movement and logic

def test_isneg():
    assert not isneg(0)
    assert not isneg(0x7F)
    assert     isneg(0x80)
    assert     isneg(0xFF)

def test_iszero():
    assert     iszero(0)
    assert not iszero(1)
    assert not iszero(0xFF)

def test_logicNZV():
    ' Covered by data movement and logic opcode tests. '

####################################################################
#   Logic operations

@pytest.mark.parametrize('a,     arg,  res, N, Z', (
                         (0x00, 0x00, 0x00, 0, 1),
                         (0x00, 0xFF, 0x00, 0, 1),
                         (0xFF, 0x00, 0x00, 0, 1),
                         (0xAA, 0x3C, 0x28, 0, 0),
                         (0xAA, 0xF0, 0xA0, 1, 0),
), ids=tmc_tid)
def test_ANDA(a, arg, res, N, Z):
    runop([I.ANDA, arg], initregs=R(a=a), changedregs=R(a=res, N=N, Z=Z, V=0))

@pytest.mark.parametrize('init,  res, Z, V, C', (
                         #   XXX see comment in code re V=NâŠ•C
                         (0x01, 0x00, 1, 1, 1),
                         (0x02, 0x01, 0, 0, 0),
                         (0xAA, 0x55, 0, 0, 0),
                         (0xFF, 0x7F, 0, 1, 1),
), ids=tmc_tid)
def test_LSRA(init, res, Z, V, C):
    runop([I.LSRA], initregs=R(a=init),
        changedregs=R(a=res, N=0, Z=Z, V=V, C=C))

####################################################################
#   Arithmetic operations

@pytest.mark.parametrize(
    'a,     arg,  res, H, N, Z, V, C', (
    (0x00, 0x00, 0x00, 0, 0, 1, 0, 0),
    #   H: half carry determined by bits 3
    (0x0E, 0x01, 0x0F, 0, 0, 0, 0, 0),
    (0x0F, 0x01, 0x10, 1, 0, 0, 0, 0),
    (0x10, 0x01, 0x11, 0, 0, 0, 0, 0),
    #   V: overflow determined by bits 6
    (0x7E, 0x01, 0x7F, 0, 0, 0, 0, 0),
    (0x7F, 0x01, 0x80, 1, 1, 0, 1, 0),
    (0x80, 0x01, 0x81, 0, 1, 0, 0, 0),
    #   C: carry determined by bits 7
    (0xFE, 0x01, 0xFF, 0, 1, 0, 0, 0),
    (0xFF, 0x01, 0x00, 1, 0, 1, 0, 1),
    (0xF0, 0x20, 0x10, 0, 0, 0, 0, 1),  # no half carry
    #   C and V
    (0x40, 0xF0, 0x30, 0, 0, 0, 0, 1),  # 2's comp: subtract from positive
    (0xF0, 0xF0, 0xE0, 0, 1, 0, 0, 1),  # 2's comp: subtract from negative
    (0x80, 0x80, 0x00, 0, 0, 1, 1, 1),
), ids=tmc_tid)
def test_ADDA(a, arg, res, H, N, Z, V, C):
    cr = R(a=res, H=H, N=N, Z=Z, V=V, C=C)
    #   Operation should be the same whether carry set or clear.
    runop([I.ADDA, arg], initregs=R(a=a, C=0), changedregs=cr)
    runop([I.ADDA, arg], initregs=R(a=a, C=1), changedregs=cr)

@pytest.mark.parametrize('minuend, subtrahend, difference, N, Z, V, C', (
    #minu, subt, diff, N, Z, V, C
    (0x00, 0x00, 0x00, 0, 1, 0, 0),
    #   V: overflow determined by bits 6
    (0x81, 0x01, 0x80, 1, 0, 0, 0),
    (0x81, 0x02, 0x7F, 0, 0, 1, 0),
    (0x7F, 0x01, 0x7E, 0, 0, 0, 0),
    #   C: borrow determined by bits 7
    (0x01, 0x01, 0x00, 0, 1, 0, 0),
    (0x01, 0x02, 0xFF, 1, 0, 0, 1),
    (0xFF, 0x01, 0xFE, 1, 0, 0, 0),
), ids=tmc_tid)
def test_SUBA(minuend, subtrahend, difference, N, Z, V, C):
    cr = R(a=difference, N=N, Z=Z, V=V, C=C)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=0), changedregs=cr)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=1), changedregs=cr)

def test_CMPA():
    #   Confirm that A register is unchanged;
    #   test_suba() provides the rest of the coverage.
    runop([I.CMPA, 0x02], initregs=R(a=0x81), changedregs=R(N=0, Z=0, V=1, C=0))
