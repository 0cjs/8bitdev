;   a simple reader for (very limited) S-expressions

q_point     equ $60         ; pointer to current parse point in input buffer
q_value     equ $62         ; parsed value (if any)

; ----------------------------------------------------------------------
;   parsers
;
;   A parser attempts to parse a value starting at q_point.
;   - On success:
;     - Its input is consumed by incrementing q_point.
;     - The parsed value (if any) is stored in q_value.
;     - Z=0 (BNE) to indicate success ONLY if the parser is capable of
;       failing. Otherwise Z is not indicative of anything.
;   - On failure:
;     - No input is consumed (q_point is untouched)
;     - q_value may be destroyed
;     - Z=1 (BEQ) to indicate failure
;
;   XXX Stuff to consider:
;   - Should have some parsers assume Y=0 on entry?
;   - Should qspaces INY and then add Y to q_point when done?
;

;   ♣Z ♡AXY,q_value  Consume any character. Always successful.
qchar       inc q_point
            bne .done
            inc q_point+1
.done       rts

;   ♠Y=0 ♣Z,A ♡X,q_value  Consume spaces. Always successful.
qspaces     ldy #0
            lda (q_point),y
            cmp #' '
            beq .consume
            rts
.consume    jsr qchar
            clc
            bcc qspaces

;   ♠Z,q_value ♣? ♡? Parse a '()' (left-paren, right paren) as value nil.
qLR         ldy #0
            lda (q_point),y
            cmp #'('
            beq .close
.rts        rts
.close      ;   XXX we can't consume here until we know end!
            ;   use Y instead
            jsr qchar               ; consume '('
            jsr qspaces
            lda (q_point),y
            cmp #')'
            bne .rts
            ; XXX store a nil here
            rts

;   ♠Z,q_value ♣? ♡? Consume a symbol (no more than 2 chars!)
qsym        rts




            end
----------------------------------------------------------------------

    parse: start by consuming spaces, then:
        - '(', ' '*, ')'    -> nil
        - 
        - consume spaces
        - '
        - '(' → start of list or nil (consume spaces to check
        - try smallint
        - anything else: symbol (just 2 chars for the moment)

    TOP:
        parse
        case
            object:         val := obj, goto DONE
            end of list:    ERROR "unclosed expr"
            start of list:  push(val), val → alloc(), cur = val, goto STARTING

    STARTING:   # reading value for already-alloc'd head cell of a list
                # - cur.car is waiting to be filled
                # - cur.cdr will be filled by APPENDING
        parse
        case
            object:         cur.car := obj
                            goto APPENDING
            end of list:    NOTREACHED because parser reads () as nil
            start of list:  cur.car → alloc()   # same as 2nd half SOL below
                            push(cur)
                            cur := cur.car
                            goto STARTING

    APPENDING:  # reading value for not-yet-alloc'd cell to append to cur list
                # - cur.car is filled
                # - cur.cdr is waiting to fill w/next cell ptr or end of list
        parse
        case
            end of input:   ERROR "unclosed expr"
            end of list:    cur.cdr := ∅
                            cur → pop(),
                            if cur = val: goto DONE
                                    else: goto APPENDING
            object:         cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car := obj      # ...is object
                            goto APPENDING      # continue with current list
            start of list:  cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car → alloc()   # ...points to head of new list
                            push(cur)           # we'll come back to this later
                            cur := cur.car      # start with new list
                            goto STARTING
