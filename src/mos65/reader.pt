from    testmc  import tmc_tid
from    testmc.mos65  import  Machine
from    b8tool  import path
import  pytest

test_rig = '''
            cpu 6502
            include src/mos65/std.a65

            org $20         ; ZP for support routines ----------------------
hc_org      equ $8000
hc_brk      ds 2

            org $50         ; ZP for CUT ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
q_point     ds 2            ; pointer to current parse point in input buffer
pstk_ptr    ds 2

            org $D0         ; ZP for test rig ------------------------------
pstk_org    equ $D0         ; base of parse stack
            org $E0
value       ds 2            ; output from routines

            org $280        ; non-ZP for CUT -------------------------------
q_buf       ds $80
q_buf_end

            org $800
            include src/mos65/objects.a65
            include src/mos65/heap.a65
            include src/mos65/reader.a65
'''

####################################################################
#   Utility routines

def qset(m, input):
    ''' Set `input` as the parser input, returning the ``q_point`` value. This
        does not explicitly terminate the input with 0, though that will
        happen "automatically" when the simulator started with zeroed memory.

        This also does the following additional setup useful to most tests:
        - Set pstk_ptr to pstk_org (initializing an empty parse stack)
        - Set ``value`` to the sentinel $DEAD (57005).
        - Call ``hcinit`` to initialize the heap.
    '''
    S = m.symtab
    buf = S.q_buf_end - 2 - len(input)
    m.deposit(buf, input)
    m.depword(S.q_point, buf)
    m.deposit(S.pstk_ptr, S.pstk_org)
    m.depword(S.value, 0xDEAD)
    m.call(S.hcinit)
    return buf

def S(name):
    ''' Return a function that, given a `SymTab`, returns the value of
        `name` from that symbol table. This is essentially a partial
        application of a function that would take ``(name, symtab)`` so
        that at top-level when we do not yet have the symbol table
        available we can pass in a value to be looked up later.
    '''
    def lookup(symtab):
        return symtab[name]
    return lookup

def sym1(c):
    ' Return a sym1 object word containing `c`. '
    n = ord(c)
    if n > 0xFF: raise ValueError("Char {} (${:02X}) > $FF".format(repr(c), n))
    return (n << 8) + 2

@pytest.mark.parametrize('input, output', [
    ('\x00', 0x0002), ('a',    0x6102), ('\x80', 0x8002), ('\xFF', 0xFF02),
])
def test_sym1(input, output):
    assert output == sym1(input)

####################################################################
#   Tests

@pytest.mark.parametrize('start, y, end', [
    (0x7123,    0, 0x7123),
    (0x7220,    1, 0x7221),
    (0x7FFF,    2, 0x8001),
    (0x8003, 0xFF, 0x8102),
], ids=tmc_tid)
def test_qYconsume(m, R, S, start, y, end):
    m.depword(S.q_point, start)
    m.call(S.qYconsume, R(y=y))
    assert (start, y, end) == (start, y, m.word(S.q_point))

#   Values to be returned by parsers
Alloc   = 'Alloc'           # Special: we expect an allocation from startcons

#   Parse success indicators
qA      = 'A'               # Always sucessful; ignore Z flag
qS      = 'S'               # Success: Z=1
qF      = 'F'               # Failure, Z=0

@pytest.mark.parametrize('qf, value, success, consumed, input', [
    #   qf: parser function
    #   value: expected value from the parser, `None` if failure (Z=0) expected
    #   success: qA, qS, qF (see above)
    #   consumed: the number input characters consumed (moving foward `q_point`)
    #   input: the input (bytestring) on which to run the parser function
    ('qspaces',         None,   qA,  0,  b'_'),
    ('qspaces',         None,   qA,  1,  b' _'),
    ('qspaces',         None,   qA,  3,  b'   _'),
    ('qLR',             None,   qF,  0,  b'_()'),
    ('qLR',             None,   qF,  0,  b'(('),
    ('qLR',         S('nil'),   qS,  2,  b'()'),
    ('qLR',         S('nil'),   qS,  4,  b'(  )'),
    ('qlist',           None,   qF,  0,  b'x'),
    ('qlist',         0x7FFC,   qS,  1,  b'('),     # first alloc from heap
    ('qsym1',           None,   qF,  0,  b'ab'),
    ('qsym1',      sym1('c'),   qS,  1,  b'c\x00'),
    ('qsym1',      sym1('d'),   qS,  1,  b'd '),
    ('qsym1',      sym1('e'),   qS,  1,  b'e)'),
    ('qsym1',      sym1('f'),   qS,  1,  b'f('),
], ids=tmc_tid)
def testq(m, R, S, qf, value, success, consumed, input):
    if value is None:       value = 0xDEAD      # sentinel set by qset
    elif callable(value):   value = value(S)    # lazy symbol lookup

    start = qset(m, input)
    flags = { qA: R(), qS: R(Z=1), qF: R(Z=0) }[success]

    print('qf={} value={} start={} consumed={} input={}' \
        .format( qf, value, start, consumed, input))
    m.call(S[qf], R(Z=0, x=S.value))
    assert flags == m.regs
    assert (flags,   start + consumed,          value) \
        == (m.regs, m.word(S.q_point), m.word(S.value))

def hcalloc_addrs(m, n):
    ' Return a list of the first _n_ addresses allocated by ``hcalloc``. '
    org   = m.symtab.hc_org
    size  = 4
    start = org - (n * size)
    return tuple(range(org - size, start - size, -size))

def test_read(m, R, S):
    qset(m, b'(a () (b c) d)')
    #         ││ k
    #         ││
    #         │└────────── pstk[0].car
    #         └─────────── pstk[0] → $7FFC cons cell

    m.call(S.read)

    def b(addr): return m.byte(addr)
    def car(addr): return m.word(addr)
    def cdr(addr): return m.word(addr+2)

    nil = 0
    #   First three addresses on parse stack.
    p0, p1, p2 = S.pstk_org - 2, S.pstk_org - 4, S.pstk_org - 6
    #   First seven addresses allocated in heap
    a0, a1, a2, a3, a4, a5, a6 = hcalloc_addrs(m, 7)

    #   Data structure as (location, value) pairs:
    actual, expected = zip(*(
        ( m.regs.x, p0          ),  # one entry left on parse stack,
        (  car(p0), a0          ),  # pointing to first alloc
        (  car(a0), sym1('a')   ),  # list[0] = 'a
        (  cdr(a0), a1          ),
        (  car(a1), nil         ),  # list[1] = nil
        (  cdr(a1), a2          ),
        (  car(a2), a3          ),  # list[2] = sublist

        (  car(a3), sym1('b')   ),  # sublist[0] = 'b
        (  cdr(a3), a4          ),
        (  car(a4), sym1('c')   ),  # sublist[1] = 'c
        (  cdr(a4), nil         ),

        (  cdr(a2), a5          ),
        (  car(a5), sym1('d')   ),  # list[3] = 'd
        (  cdr(a5), nil         ),
    ))
    assert actual == expected           # diff prints as -expected, +actual
