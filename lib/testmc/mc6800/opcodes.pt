''' Test individual opcode execution.

    Each test covers both the opcode/instruction mapping in the `opcodes`
    module and the implementation itself in the `opimpl` module.
'''

from    testmc.mc6800.machine  import Machine
from    testmc.mc6800.opcodes  import Instructions as I
import  pytest

####################################################################
#   Framework

R = Machine.Registers

def runop(opdata, *, machine=None, memsize=0x20,
        startaddr=0x0E, initregs=R(),
        changedregs=R(), changedmem=None):
    m = machine
    if m is None:
        m = Machine(memsize=memsize)

    m.deposit(startaddr, opdata)
    m.setregs(initregs)

    #   For any register not explicitly set that has a value in changedregs,
    #   set it to some other value so we can confirm it was changed.
    unsetregs = set()
    for name, val in initregs.all().items():
        if val is None: unsetregs.add(name)
    #   But always exclude the program counter and stack pointer
    #   as they should never be randomized!
    unsetregs.discard('pc'); unsetregs.discard('sp')
    for name, val in changedregs.all().items():
        if name in unsetregs:
            setattr(m, name, not val)

    m.pc = startaddr
    prevregs = m.regs
    prevmem = bytes(m.mem)

    m.step(1)

    regs = m.regs
    #   If any regs in the machine are unvalued (i.e., set to `None`)
    #   the opcode implementation has done something very wrong.
    unvalued = set(regs.all().keys()) - set(regs.valued().keys())
    assert not unvalued, 'op produced unvalued register(s)'

    if changedregs.pc is None:
        changedregs = changedregs.clone(pc=startaddr + len(opdata))
    allregs = prevregs.clone(**changedregs.valued())

    #   Lining these up in columns makes it easier to see what was wrong.
    print('    expected all:', allregs)
    print('expected changed:', changedregs)
    print('          actual:', regs)

    #   First assert that the registers and flags expected to change have
    #   their correct values. This makes more clear test failures where a
    #   tested value is wrong.
    assert changedregs == regs, "expected register/flag changes"
    #   Now assert that the other registers and flags, which we did not expect
    #   to change (and are not explicitly tested), are actually unchanged.
    assert allregs == regs, "unexpected register/flag changes"

    if changedmem is None:
        assert prevmem == bytes(m.mem)
    else:
        newmem = bytearray(prevmem)
        for addr, value in changedmem.items():
            newmem[addr] = value
        assert newmem == m.mem


####################################################################
#   Opcode Tests

def test_NOP():
    #   The test framework will ensure that nothing but the PC has changed.
    runop([I.NOP])

def test_BRA():
    runop([I.BRA,    0], startaddr=0x13, changedregs=R(pc=0x0015))
    runop([I.BRA, 0x80], startaddr=0x0E, changedregs=R(pc=0xFF90))
    #   Additional coverage in test_readsignedbyte().

def test_RTS():
    m = Machine(memsize=0x40)
    m.sp = 0x002D; m.depword(0x002E, 0x1234)
    runop([I.RTS], machine=m, changedregs=R(pc=0x1234, sp=0x002F))

@pytest.mark.parametrize(
    'offset,      x,     pc', (
    (     0, 0xFFFF, 0xFFFF),
    (     3, 0x1234, 0x1237),
    (  0xFF, 0xFF80, 0x007F),
))
def test_JMPx(offset, x, pc):
    runop([I.JMPx, offset], initregs=R(x=x), changedregs=R(pc=pc))

def test_JMP():
    runop([I.JMP, 0xAB, 0xCD], changedregs=R(pc=0xABCD))

@pytest.mark.parametrize(
    'arg,  N, Z', (
    (0x01, 0, 0),
    (0x00, 0, 1),
    (0xEA, 1, 0),
))
def test_LDAA(arg, N, Z):
    runop([I.LDAA, arg], changedregs=R(a=arg, N=N, Z=Z, V=0))

def test_bsr():
    runop([I.BSR, 0xFE], startaddr=0x12,            # calling self
        initregs    = R(sp=0x18),
        changedregs = R(sp=0x16, pc=0x12),
        changedmem  = { 0x17: 0x00, 0x18: 0x14, },
    )

def test_jsrx():
    runop([I.JSRx,                    0x16],
        initregs    = R(sp=0x1F,  x=0xFFF0, ),
        changedregs = R(sp=0x1D, pc=0x0006, ),

        startaddr   =                   0x0123,     memsize=0x140,
        changedmem  = { 0x1E: 0x01, 0x1F: 0x25, },
    )

def test_jsr():
    runop([I.JSR, 0x56, 0x78],
        memsize=65536, startaddr=0x1234,
        initregs    = R(sp=0),                      # test stack wraparound
        changedregs = R(pc=0x5678, sp=0xFFFE),
        changedmem  = { 0x0000: 0x37, 0xFFFF: 0x12, })
