;   nkbin - "New" MB-6885 keyboard read with 2-key rollover

; ----------------------------------------------------------------------

;   For the moment we use the monitor's setting for break key processing.
brkkey_ena  equ  $13        ; BREAK key processing: $00=ignored
                            ;   $F0=call BREAKV (default after reset)

;    Keyboard: read/write
;      RD bits 7-4: kana-symbols, kana,    romaji-symbols, romaji
;        (equiv to: AltGR,        R-Shift, Ctrl,   L-Shift
;      WR bits 7-4: ??? break key enable/disable?
;      WR bits 3-0: row (col?) output (strobe?)
IO_kbd      equ  $EEC0

; ----------------------------------------------------------------------

;   ♡B Non-blocking read of keyboard state; same API as ROM `KBIN`.
;   C=1: nothing pressed. C=0: char/graphic code returned in A.
nkbin       psh B

            ldb #3          ; nkbin_actv length
            ldx #nkbin_actv
            bsr .clear_released
            bsr .nextkey

   ;lda #'@'                ; XXX debug
   ;jsr prchar
            sec             ; nothing read

            lda B,brkkey_ena; restore BREAK key on/off state
            sta B,IO_kbd    ; (we don't care about the column number)
            pul B
            rts

;   Clear any keys that were marked as pressed in `nkbin_actv` but have
;   since been released.
.clear_released
            ldb #nkbin_len
            ldx #nkbin_actv
.cr.check   psh B
            ;   Check [X] and leave it set or clear it to $00.
            lda A,,X        ; load row bits (7-4), column (3-0)
            beq .cr.next    ; $00 = no active key in this slot
            tab             ; copy row bits, column
            and A,#$0F      ; mask column to scan
            sta A,IO_kbd    ;   (disables BREAK NMI too; dealt with later)
            lda A,IO_kbd    ; get modifier and rows currently down
   ;sta A,4,X               ; XXX DEBUG
            asl A           ; shift rows to high nybble
            asl A
            asl A
            asl A
            and A,,X        ; is row from nkbin_actv set in what we read?
            bne .cr.next    ;   yes: move on to next nkbin_actv
            lda #0          ; clear this active key
            sta A,,X
            ;   Next byte in array.
.cr.next    pul B
            dec B
            beq .rts        ; return if done
            inx
            bra .cr.check

.rts        rts

;   ♣ABX Return in X the first free (empty) slot in nkbin_actv.
;   Returns in flag N: 0=success, 1=no slots free
.freeslot   lda B,#nkbin_len-1
            ldx #nkbin_actv
-           lda A,,X
            beq .rts        ; 0 = free slot = not negative
            inx
            dec B
            bmi .rts        ; negative so returns no slots free
            bra -

;   Find the "next" keypress, i.e., the first in a scan of the entire
;   keyboard that is not in `nkbin_actv`.
.nextkey    lda A,#$0C      ; highest column number
.nk.loop    psh A           ; save current column
            sta A,IO_kbd    ; set column (disables BREAK NMI; dealt with later)
            lda A,IO_kbd    ; read modifier keys (b7-4) and rows (b3-0)
            ; XXX ...
            pul A           ; restore current column
            dec A           ; next column
            bpl .nk.loop    ; ≥0 → continue
            ; XXX create row/col and save key in first empty nkbin_actv slot
            rts

;   Array of bytes indicating which keys (excluding modifier keys) that
;   were still pressed when we last exited `nkbin`. The low nybble is the
;   column number as written to `IO_kbd` bits 3-0; the high nybble is
;   one bit from the row bits returned on a read of `IO_kbd` bits 3-0.
;   $00 indicates "no key pressed" in that slot.
    .ifndef nkbin_actv
nkbin_len   equ 3           ; length of nkbin_actv array
nkbin_actv  db 0
            db 0
            db 0
    .endif ; nkbin_actv
