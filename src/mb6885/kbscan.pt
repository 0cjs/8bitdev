from    testmc  import *
from    testmc.mc6800  import *
import  pytest

R = Machine.Registers

test_rig = '''
                cpu 6800
                org $800

kbscan_len      equ 4
kbscan_down     ds  kbscan_len
debug_area      ds  kbscan_len   ; write here for debug display on test failure

                org $1000

               ;include src/mc68/std.a68
               ;include src/tmc68/bios.a68
                include src/mb6885/kbscan.a68
'''

param = pytest.mark.parametrize

def k(S,name):
    ' Return local symbol `name` under ``kbscan``. '
    return S['kbscan.' + name]

def setactv(m, actv):
    #   $EE area helps detect overrun and can store test-only debug data:
    #   `sta A,4,X` and later `print(m.hexdump(S.kbscan_down, 8))`
    m.deposit(m.symtab.kbscan_down, actv + b'\xEE\xEE\xEE\xEE')
    print(m.hexdump(m.symtab.kbscan_down, 4))    # for debugging on test failure

@param('actv, kboutputs, kbinputs, newactv', [
    (b'\x00\x00\x00\x00',   # no active keys; reads/changes nothing
        b'',                 b'',                   b'\x00\x00\x00\x00'),
    (b'\x11\x00\x22\x8C',   # no active non-mod keys pressed; clears all
        b'\x01\x02\x0C',     b'\x00\xF0\x10',       b'\x00\x00\x00\x00'),
    (b'\x8A\x2A\x1A\x1B',   # 3/4 active non-mod keys pressed
        b'\x0A\x0A\x0A\x0B', b'\x09\xF9\xA9\xB3',     b'\x8A\x00\x1A\x1B'),
])
def test_clear_released(m, S, actv, kboutputs, kbinputs, newactv):
    setactv(m, actv)
    istream, ostream = m.setiostreams(S.IO_kbd, kbinputs)
    m.call(k(S,'cr.start'), stopat=[k(S,'cr.end')])

    print(m.hexdump(S.kbscan_down, 8))
    assert (kboutputs,          newactv) \
        == (ostream.getvalue(), m.bytes(S.kbscan_down, 4))
    assert b'' == istream.read()

@param('actv, slot, nflag', [
    (b'\x00\xff\xff\xff', 0, False),
    (b'\x10\x20\x8F\x00', 3, False),
    (b'\x10\x20\x8F\x40', 4, True),
])
def test_freeslot(m, S, actv, slot, nflag):
    setactv(m, actv)
    m.call(k(S,'freeslot'), R(x=0, N=not nflag))
    print('actv={} slot={} x={}'.format(S.kbscan_down, slot, m.x))
    assert (nflag, S.kbscan_down + slot) == (m.N, m.x)

@param('actv, scan, isnewkey', [
    #   `scan` is active row as one of b7-4 and column as b3-0
    (b'\x00\x00\x00\x00', 0x00, False),     # no row pressed
    (b'\x0F\x0F\x0F\x0F', 0x0F, False),
    (b'\x00\x00\x00\x00', 0x10, True ),     # row not in kbscan_down
    (b'\x11\x20\x43\x84', 0x2C, True ),
    (b'\x11\x20\x43\x84', 0x11, False),     # row in kbscan_down
    (b'\x00\x00\x00\x84', 0x84, False),
])
def test_chknewkey(m, S, actv, scan, isnewkey):
    print('scan={:02X}, expected isnewkey={}'.format(scan, isnewkey))
    setactv(m, actv)
    expected_Z = not isnewkey
    m.call(k(S,'chknewkey'), R(a=scan, b=0xFF, x=0, Z=not expected_Z))
    assert expected_Z == m.Z

@param('actv, kbinputs', [
    (b'\x00\x00\x00\x00',
        b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'),
    (b'\x1C\x00\x00\x00',
        b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'),
    (b'\x00\x80\x1B\x2C',
        b'\x02\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08'),
])
def test_nextkey_notpressed(m, S, actv, kbinputs):
    expected_outputs = bytes(range(0x0C, -1, -1))
    setactv(m, actv)
    istream, ostream = m.setiostreams(S.IO_kbd, kbinputs)

    print(hex(k(S,'nk.end')))
    m.call(k(S,'nk.start'), R(C=False),
        stopat=[k(S,'nk.end'), k(S,'savekey')])
    assert (R(C=True, pc=k(S,'nk.end')), expected_outputs) \
        == (m.regs,    ostream.getvalue())
    assert b'' == istream.read()

def test_nextkey_pressed(m, S):
    setactv(m, b'\x00\x4A\x2B\x00')
    istream, ostream = m.setiostreams(S.IO_kbd, b'\x00\x00\x00\x08')
    m.call(k(S,'nk.start'), R(C=False), stopat=[k(S,'savekey')])
    assert R(a=0x89) == m.regs

def test_savekey_nospace(m, S):
    setactv(m, b'\x11\x22\x44\x88')
    #m.call(k(S,'savekey'))
    #assert 0

def test_savekey_saved(m, S):
    pass
    #assert 0
