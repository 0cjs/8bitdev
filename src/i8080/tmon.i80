;   tmon - "tiny" (relatively) 8080 monitor
;
;   See the README for the user documentation.

; ----------------------------------------------------------------------
;   Status:
;   • Implemented:  ' , . > / ; B D E F I J K M Q R V
;   • Untested:     O P           # tests require addtional support from t8dev
;   • To-do:        W T Y : S A   # roughly priority order

; ----------------------------------------------------------------------
;   Requirements:
;
;   Headers (no code generated):
;   • std.i80: common 8080/Z80 definitions.
;
;   Libraries:
;   • `prspace`: available in i8080/pt/space.i80 if not in BIOS.
;
;   This requires the system-dependent files define the following before
;   including this file:
;   • tmon_ram: start of the the RAM workspace area (which extends to
;     tmon_ram_end) No code or data is generated here; it's all initialised
;     at runtime.
;   • tmon_stack: start of tmon's monitor stack (separate from user stack),
;     growing down from the address below this value. tmon itself does not
;     use much stack, but the BIOS routines it calls may use much more.
;   • tmon_rom: start of code and static data, and monitor entry point.

;   Abort assembly with a clear message if an essential definition is missing.
;   (Otherwise it says "error: expression must be evaluatable in first pass".)
;
;   XXX This doesn't work inside a section … endsection block. We should
;   just change this to generate error messages in some nice way. Maybe we
;   can set up a std.i80 macro that tests a symbol and generates an error
;   if it's not defined.
;
;   set ______,
;   pushv , tmon_rom, tmon_ram, tmon_stack
;   popv  , ______,     ______,     ______

; ----------------------------------------------------------------------
;   Symbol naming:
;   • pr*       print routines
;   • q*        parsing routines
;   • cmd_ccc   command routines: ccc=command name
;   • ptab_ccc  parameter tables for commands; ccc=command name
;   • vX_ccc    memorised parameter values; X=parameter name, ccc=command name

; ======================================================================
;   Definitions

;   ASCII characters
ACK         equ  $06            ; Ctrl-F, keep current val and move forward
BS          equ  $08            ; Ctrl-H, backspace
LF          equ  $0A            ; Ctrl-J, linefeed
VT          equ  $0B            ; Ctrl-K, vertical tab
CR          equ  $0D            ; Ctrl-M, carriage return
NAK         equ  $15            ; Ctrl-U
CAN         equ  $18            ; Ctrl-X
DEL         equ  $7F

SPACE       equ  ' '
BACKSLASH   equ  '\\'
    ifndef BACKSPACE            ; Systems such as PC-8001 where `prchar` takes
BACKSPACE   equ  BS             ; different char to move the cursor back one
    endif                       ; position can override this.

UPCASE      equ  %11011111      ; (lower case ASCII) ∧ UPCASE → upper case

; ----------------------------------------------------------------------

iCALL       equ  $CD            ; 8080 CALL aaaa instruction
iJP         equ  $C3            ; 8080 JMP aaaa instruction
iRET        equ  $C9            ; 8080 RET instruction

;   Byte-valued parameter: char followed by addr at which to store byte value.
pb          macro char,addr
            db    char
            dw    addr
            endm

;   Word-valued parameter: char followed by addr at which to store word value.
pw          macro char,addr
            db    char|$80
            dw    addr
            endm

; ======================================================================
;   RAM Work Area

            org  tmon_ram

;   Registers
ureg_AF
ureg_F      ds   1
ureg_A      ds   1
ureg_BC
ureg_C      ds   1
ureg_B      ds   1
ureg_DE
ureg_E      ds   1
ureg_D      ds   1
ureg_HL
ureg_L      ds   1
ureg_H      ds   1
ureg_SP     ds   2
ureg_PC     ds   2

;   Command parameter values: v<PARAM>_<CMD>
v_start
vS_exec         ds   2      ; execute: start addr
vS_examine      ds   2      ; examine: start addr
vM_examine      ds   1      ; examine: display mode flags:
                            ;   b0=hex, b1=ASCII, b2=screen codes
vL_examine      ds   1      ; examine: # of lines to print
vW_examine      ds   1      ; examine: # of bytes per line ("width")
vS_deposit      ds   2      ; deposit: start addr
vN_deposit      ds   1      ; deposit: advance to next mode $00=off, $01=on
vP_port_in      ds   1      ; input port
vP_port_out     ds   1      ; output port
vV_port_out     ds   1      ; output port value
vS_source       ds   2      ; source range (copy/cksum/etc.): start addr
vE_source       ds   2      ; source range: end addr (non-inclusive)
vT_target       ds   2      ; target range: start addr
vU_target       ds   2      ; target range: end addr
vL_calc         ds   2      ; calc: ? param (left value)
vR_calc         ds   2      ; calc: / param (right value)
;
v_end
v_cksum         ds   2      ; checksum to determine if we re-init

;   Temporary storage, word and byte
t0          ds   1
t1          ds   1
t2          ds   1
t3          ds   1

tmon_ram_end

; ======================================================================
;   Entry point and main loop

            org  tmon_rom

;   Locations `tmon_rom` and `tmon_rom`+3  are the standard entry points
;   for the monitor.
;   • `entry` must be used for initial startup, and can be used when a
;     program wants to "exit" back to the monitor. This saves all registers
;     but the PC.
;   • `intentry` is the entry point for interrupts, whether via hardware
;     or software (the latter typically an RST instruction). This saves
;     all registers including the PC, and the `I`

entry       jp entry1

;   Interrupt entry point for the monitor.
;   Interrupts on the 8080 push only the return address on the stack.
;
;   We want to use as much of `entry` as possible, but because at the start
;   we can use no registers or flags until we save them we duplicate some
;   code. The only difference is that we set, rather than clear, the "entry
;   via interrupt" bit (b7) in A to indicate that we want to set the user
;   PC to set the user PC to the return address on the user stack.
;
intentry    di
            ld   (ureg_A),a
            ld   a,$80          ; Carry (t0) and entry via interrupt (b7) bits.
            jp   NC,entry1.savecarry
            ld   a,$81
            jp   entry1.savecarry

;   We don't have a PC to save here: either `intentry` above saved it or
;   we entered via `entry` with no known user PC, so we just retain the
;   last known value.
entry1      di                  ; ensure as best we can nothing will touch stack
            ld   (ureg_A),a
            ;   We must save the carry bit separately here because the DAD
            ;   we use later will affect it. We set bits in A to indicate
            ;   the value of the user carry (t0) and whether we entered via
            ;   an interrupt (b7). (`intentry` sets t0 to 1.)
            ld   a,0            ; do not affect flags
            jp   NC,.savecarry
            ld   a,1            ; set "carry was set" bit, flags unaffected
.savecarry  ld   (t0),a         ; save carry and interrupt entry bits
            ld   (ureg_HL),hl
            ex   de,hl
            ld   (ureg_DE),hl
            ld   h,b
            ld   l,c
            ld   (ureg_BC),hl
            ld   hl,$0000
            add  hl,sp          ; SP → HL
            ld   (ureg_SP),hl
            ;   Now that we've saved the user stack pointer, we can switch
            ;   to our own stack. (We must never use the user stack because
            ;   it may be invalid, e.g. pointing into ROM.)
            ld   sp,tmon_stack
            push af
            ex   (sp),hl
            pop  de             ; clean up stack
            ld   a,l            ; get flags
            and  a,$FE          ; clear carry
            ld   l,a
            ld   a,(t0)         ; load original carry, int flag, etc.
            and  $01            ;   and mask it
            or   a,l            ; bring in all other flags
            ld   (ureg_F),a
            ld   a,(t0)         ; load original carry, int flag, etc.
            and  $80            ; isolate entry-via-int flag
            ld   a,'.'          ; (pre-showregs entry symbol if not)
            jp   Z,.end         ; if not entry, skip additional int processing
            ;
            ld   hl,(ureg_SP)   ; entered via intentry, so copy the return
            ld   e,(hl)         ;   address on the stack to the user PC
            inc  hl
            ld   d,(hl)
            ex   de,hl
            ld   (ureg_PC),hl
            ld   a,'^'          ; indicate we came in via int
            ;
.end        ei                  ; interrupts can now use our stack
            call prchar         ; pre-regs entry indication character
            call showregs       ; always print registers on entry

;   Check to see if our current saved command parameter values are valid,
;   i.e., matching a previously calculated and deposited checksum. (The
;   checksum is calculated and written just before the monitor calls
;   usercode or exits.)
;       If invalid, we init because this is either the first time the user
;   has entered the monitor or something stomped on our values.
;
init        call cksum_v
            ex   de,hl              ; DE = current checksum
            ld   hl,(v_cksum)       ; HL = previous checksum
            call subHLDE            ; same?
            jp   Z,.end             ;   yes; do not re-init
            ld   a,'@'
            call prchar             ; notify that we're re-initing param vals
.copy       ld   hl,v_initdata
            ld   de,v_start
            ld   b,v_end - v_start
.loop       ld   a,(hl)
            ld   (de),a
            inc  hl
            inc  de
            dec  b
            jp   NZ,.loop
    if (MOMPASS == 1) || symexist(init_platform)
            ;   If available, call platform-specific init code
            ;   for comand parameter values.
            call init_platform
    endif
.end
            ; FALLTHROUGH

;   Reset the stack, print the prompt and read and dispatch a command
;   (but not the command's parameters).
;
;   Commands are expected to generate a newline (moving to the next line
;   after the command) if necessary, though they may also overwrite the
;   current line (by generating CR) if that won't overwrite any useful
;   input made before command execution.
;
;   Because this resets the stack, it may be entered via either a `jp`
;   (with the stack in any state) or via a `ret` to the address of
;   itself that it places on the stack before jumping to any command.
;
prompt      ld   sp,tmon_stack
.setstack   ld   hl,prompt
            push hl             ; ret will go to prompt
            ld   a,'.'
            call prchar         ; prompt
.read       call rdchar
            call qignspace      ; ignored whitespace "commands"
            jp   Z,.read
.echocmd    call prvischar      ; echo input visibly
            call upcase         ; force to upper case if letter
            ;   Dispatch command if we match one.
            ;   • Commands are not called but are jumped to; they must
            ;     themselves come back here via a jump to `prompt`.
            ;   • Commands must generate their own initial newline; see above.
            ;   • Commands that execute immediately rather than waiting for
            ;     parameters and/or confirmation should be marked somehow.
            ld   hl,cmdtbl
            ld   b,a            ; B ← command char to match
.dispatch   ld   a,(hl)         ; A ← char in table entry
            inc  hl             ; move to address in table entry
            or   a,a            ; end of table?
            jp   Z,.cmderr      ;   yes: bad command
            sub  a,b            ; char match? (tested 5 instructions below)
.cmdmatch   ld   e,(hl)         ; command addr LSB
            inc  hl
            ld   d,(hl)         ; command addr MSB
            inc  hl             ; move to next entry
            jp   NZ,.dispatch   ; if char did not match
            ex   de,hl
.cmdjmp     jp   (hl)
            ;
.cmderr     call errbeep        ; invalid command, signal error
            ld   a,CR           ; back up over invalid command and prompt
            jp   prchar         ; TCO ret to prompt

;   Command character and address of command code definition.
cmd         macro   char,addr
            db   char
            dw   addr
            endm

cmdtbl      cmd  VT,  cmd_newline
            cmd  '#', cmd_comment
            cmd  "'", cmd_deposit_ascii
            cmd  ',', cmd_deposit_params
            cmd  '.', cmd_deposit_bytes
            cmd  '/', cmd_calc
            cmd  ':', cmd_deposit_intelhex
            cmd  ';', cmd_regs_deposit
            cmd  '>', cmd_deposit_words
          ; cmd  'A', cmd_examine_asm
            cmd  'B', cmd_examine_prev
            cmd  'D', cmd_examine_cur
            cmd  'E', cmd_examine_params
            cmd  'F', cmd_examine_next
            cmd  'I', cmd_iret
            cmd  'J', cmd_jump
            cmd  'K', cmd_call
            cmd  'M', cmd_memcopy
            cmd  'O', cmd_port_out
            cmd  'P', cmd_port_in
            cmd  'Q', cmd_quit
            cmd  'R', cmd_regs_examine
          ; cmd  'S', cmd_deposit_motosrec
          ; cmd  'T', cmd_device_write
            cmd  'V', cmd_cksum
          ; cmd  'W', cmd_find
          ; cmd  'Y', cmd_device_read

;   Cancel current command.
;   • This may be used (via `jp`) by a routine at any call depth.
;   • It will print a backslash at the current cursor position to indicate
;     that the command has been cancelled, print a newline, and then restart
;     the prompt, which will reset the stack.
;   • We do NOT clear the entire line, because any param values entered
;     before cancellation remain in effect.
cancel      call  pr4clear      ; clear any displayed value
            ld   a,BACKSLASH    ; indicate cancelled
            call prchar
            call prnl
            jp   prompt         ; cannot be `ret`; we don't know call depth

;   Checksum the command parameters, returning the checksum in HL.
;   When stored in (v_cksum), this lets us tell if param vals have changed.
cksum_v     ld   de,v_start
            ld   bc,v_end - v_start
            call cksum_crc_16_ccitt
            ret

; ======================================================================
;   Initial command parameter values.

v_default   macro   name,value
        ifndef  name
name        equ  value
        endif
            endm

;   These default parameters are fairly well suited for a system with ROM
;   in the lower 32K, RAM in the upper 32K and an 80-column terminal.
;
    v_default  vini_start,  $8000   ; start addr of examine, deposit, execute,
    v_default  vini_end,    $8100   ;   etc.; end addr of copy, cksum etc.
    v_default  vini_lines,  4       ; examine: number of lines to print
    v_default  vini_width,  16      ; examine: bytes/line to print
    v_default  vini_format, $03     ; examine: hex+ascii format

v_initdata  dw   vini_start     ; execute start
            dw   vini_start     ; examine start
            db   vini_format    ; examine format
            db   vini_lines     ; examine #lines
            db   vini_width     ; examine width #bytes
            dw   vini_start     ; deposit start
            db   $00            ; deposit advance to next mode off
            db   $00,$00,$00    ; input, output port, output data
            dw   vini_start     ; copy/cksum start
            dw   vini_end       ; copy/cksum end
            dw   $0000          ; target range: start address
            dw   $0000          ; target range: end address
            dw   $0000          ; calc left arg
            dw   $0000          ; calc right arg

; ======================================================================
;   Command parameter management.

;   ♠HL ♣ABCHL,(t2⋅3)   We've found a command; it's asking us to read and
;   update parameters (specified in a table passed in HL) and execute or
;   cancel it.
;
;   The parameters table is a sequence of 3-byte entries,
;   terminated by a $00 byte:
;   • byte0 [7:7]: param value size: 0=8-bit, 1=16-bit
;   • byte0 [6:0]: param name, as upper-case ASCII letter
;   • byte1,byte2 [15:0]: location in which to store param value
;
read_params ld   (t2),hl         ; save params table
.next       call rdchar
            call qexec          ; execute command?
            ret  Z              ;   yes: continue running command
            call cqcancel       ; cancel command if requested
            call prvischar
            cp   SPACE          ; ignore spaces.
            jp   Z,.next
            ;
.parse_name ld   hl,(t2)        ; load params table
            call upcase         ; force to upper case if lettter
            ld   b,a            ; table entry to match
.tabnext    ld   a,(hl)         ; param name char from table
            or   a,a            ; end of table?
            jp   Z,.bad         ;   yes: char does not match a param name
            and  a,$7F          ; clear table char high bit (param value size)
            cp   a,b            ; this param matches?
            jp   Z,.found       ;   yes: process param
            inc  hl             ; no: next table entry
            inc  hl
            inc  hl
            jp   .tabnext
            ;
.found      ld   a,(hl)         ; param name from table
            and  $80            ; mask 16-bit (vs. 8-bit) flag
            ld   c,a            ;   and set this parameter for qhex
            inc  hl             ; go to param value location (no flags changed)
            ld   b,(hl)         ; save location LSB
            inc  hl
            ld   h,(hl)         ; load location MSB
            ld   l,b            ; load location LSB
            call qhex           ; C=value size, HL=store location
            ret  Z              ; input terminated w/execute; exec command
            jp   .next
            ;
.bad        call prback         ; backspace over bad param name
            call errbeep
            jp   .next

;   ♠CHL ♣ABDE ♡C   Read ASCII hex digits and update byte or word (HL).
;
;   This reads and stores an 8-bit (C=0) or 16-bit (C=*) value.
;   The existing value (HL) is displayed and the cursor is backspaced
;   to the start of the value.
;
;   At this point the user may type an initial character:
;   • a space to preserve the curent value:
;     returns Z=0 ("continue input") and HL moved past the value
;   • a `qexec` character to preserve the current value:
;     returns Z=1 ("execute") and HL is moved past the value
;   • a `cqcancel` character to preserve the current value:
;     jumps to `cancel` instead of returning; HL left at the value
;   • a digit to start entering a new value
;
;   Once a digit has been typed, the user may terminate digit input with:
;   • a space to store the new value in (HL):
;     returns Z=0 ("continue input") and HL moved past the value
;   • a `qexec` character to store the new value in (HL):
;     returns Z=1 ("execute") and HL is moved past the value
;   • a `cqcancel` character to preserve the current value:
;     jumps to `cancel` instead of returning; HL left at the value
;
;   If more digits than needed are entered the least-significant
;   (last-entered) digits are used.
;
qhex        call prhexval       ; load (DE=val B=#digits) and print curval
            ld   a,BACKSPACE    ; backspace to
            call prBchars       ;   start of printed value
            call rdchar         ; first char requires special processing:
                                ;   space is preserve, but after it's store
            cp   ' '            ; keep current value and continue params?
            jp   Z,.keepval     ;   yes
            cp   ACK            ; alternate keep (Ctrl-F)
            jp   Z,.keepval
            call qexec          ; execute (not changing current val)?
            ret  Z              ;   yes
            ld   de,0           ; set leading digits 0 for entering new value
            jp   .startval

.next       call rdchar
.startval   call cqcancel       ; cancel command if requested
            jp   Z,cancel       ;   yes
            ;   At this point we've had input before the exec char, or
            ;   we would have exec'd above. So we must store it.
+           call qexec          ; terminate input and execute command?
            jp   Z,.storeDE     ;   yes (TCO)
            ;   We're not aborting input, but we can't yet store at this
            ;   point because we don't know if we might abort after future
            ;   digit input. Ideally we'd be able to handle backspace here,
            ;   but that requires not just undoing the last digit added to
            ;   DE but also knowing how far back we can backspace, which
            ;   is more code than we'd like to add here right now.
            call prvischar
            ld   b,0            ; set ASCII input to high bit clear
            cp   "'"            ; ASCII char input?
            jp   Z,.parsechar   ;   yes
            cp   '"'            ; ASCII char input with high bit set?
            jp   Z,.parsecharhi ;   yes
            cp   ' '            ; terminate input and continue?
            jp   Z,.storeDE     ;    yes: (TCO) store and return
            call qhexdigitDE    ;     no: parse digit, add to DE, continue
            jp   NC,.next       ; continue on good digit
            call errbeep        ; notify/back up over bad digit
            call prback
            jp   .next


.keepval    push af
            call prhexval       ; print value again
            call prspace
            pop  af
            jp   .storeDE       ; increment HL, set Z, ret (TCO)
                                ;   (extra store is no-op)

.storeDE    push af             ; preserve input termination char
            ld   (hl),e         ; store LSB
            ld   a,0
            or   a,c            ; 16-bit flag set?
            jp   Z,.sdone       ;  no
            inc  hl             ;   yes: store MSB
            ld   (hl),d
.sdone      inc  hl;            ; return next location
            ;   It would acually be a bit nicer here to back up over all the
            ;   entered chars and reprint the value, so that you see any
            ;   leading 0 digits, but that seems more work than worthwhile.
            call pr4clear       ; clear extra digits if entered # was shorter
            pop  af             ; restore input termination char
            call qexec          ; set Z flag if it was an execute char
            ret

.parsecharhi ld  b,$80          ; set ASCII input to high bit set
.parsechar  call rdchar
            or   a,b
            call prvischar      ; to make sure we can backspace over it
            ld   d,e
            ld   e,a
            call prback         ; overwrite...
            call prback
            ld   a,e            ;   with hex value of char
            call prhexA
            jp   .next

;   ♠ADE ♣A ♡BCHL   Parse ASCII hex digit in A and add the value to DE.
;   Returns with CY clear on success; CY set and DE not updated if the
;   digit is invalid.
qhexdigitDE call qdigit
            ret  C              ; return error flag if not number or letter
            cp   $10            ; digit > 'F'?
            ccf
            ret  C              ;   yes: return error flag
            push bc             ; preserved registers
            ld   c,a            ; save new rightmost digit
            ;   Shift DE left one digit.
            ld   a,d
            rlca
            rlca
            rlca
            rlca
            and  $F0            ;   temporarily clear lower nybble of D
            ld   d,a            ;   save new D upper nybble
            ld   a,e
            rlca                ;   swap E upper/lower nybbles
            rlca
            rlca
            rlca
            ld   b,a            ;   save copy of E's old upper nybble
            and  a,$F0          ;   temporarily clear new E lower nybble
            ld   e,a            ;   save new E upper nybble
            ld   a,b            ;   restore old E upper nybble
            and  a,$0F          ;   mask E's old upper (now lower) nybble
            or   a,d            ;   D new lower nybble ← E old upper nybble
            ld   d,a            ;   new D complete
            ;   DE LSnybble ← new digit and clear carry indicating no error.
            ld   a,e            ; load new E upper upper nybble
            or   a,c            ; mask new digit into E lower nyb, clear carry
            ld   e,a            ; new E complete
            pop  bc
            ret                 ; clear carry indicates no error

; ======================================================================
;   Commands

; ----------------------------------------------------------------------
;   Execution commands

ptab_exec   pw   'S',vS_exec        ; start address of execution
            db   0

cmd_iret    ld   a,iRET
            ld   (t0),a
            ld   hl,ptab_none
            jp   exec

cmd_call    ld   a,iJP          ; we simulate the call with a JP
            ld   (t0),a
            ld   hl,(ureg_SP)   ;   after pushing the monitor entry point
            dec  hl             ;   on the user stack
            ld   a,MB(entry)
            ld   (hl),a
            dec  hl
            ld   a,LB(entry)
            ld   (hl),a
            ld   (ureg_SP),hl
            ;
            ld   hl,ptab_exec
            jp   exec

cmd_jump    ld   a,iJP
            ld   (t0),a
            ld   hl,ptab_exec
            jp   exec

            ;   XXX optimise the above with a ↓ fallthrough etc.
            ;   and maybe remove dup code in cmd_{call,jump}

;   ♣(t0⋅1⋅2)   Execute location
;   This sets up a trampoline at (t0⋅1⋅2) that does the appropriate JMP or
;   RET to start execution. Using this means that we need not use or change
;   any registers to execute at an arbitrary address.
;
exec        call read_params
            call prnl           ; to easily identify output from the routine
            ;
            call cksum_v        ; checksum current params so we don't re-init
            ld   (v_cksum),hl   ;   on re-entry if they've not been stomped
            ;
            ld   hl,(vS_exec)
            ld   (t1),hl        ; set addr or JMP or CALL instruction
            ;   Restore user values to most registers
            ld   hl,(ureg_DE)
            push hl
            pop  de
            ld   hl,(ureg_BC)
            push hl
            pop  bc
            ld   hl,(ureg_AF)
            push hl
            pop  af
            ;   Switch to and set up set up user stack
            ld   hl,(ureg_SP)   ; (load user stack)
            ld   sp,hl
            ld   hl,(ureg_HL)
            jp   t0             ; trampoline into user code

ptab_quit   pb   'T',t0         ; exit "to" whence specified by number
            db   0

cmd_quit    xor  a,a
            ld   (t0),a         ; default value of param is always 0
            ld   hl,ptab_quit
            call read_params    ; not just for param, but must confirm/cancel
            call cksum_v        ; checksum current params so we don't re-init
            ld   (v_cksum),hl   ;   on re-entry if they've not been stomped
            call prnl
            ld   a,(t0)         ; A ← param `t` value
            jp   exit           ; system-supplied routine

; ----------------------------------------------------------------------
;   Examine commands

ptab_examine
            pw   'S',vS_examine     ; start: 16-bit value
            pb   'M',vM_examine     ; display mode bitfield (see above)
            pb   'L',vL_examine     ; number of lines to print: 8-bit value
            pb   'W',vW_examine     ; width (# of bytes to print): 8-bit value
ptab_none   db   0                  ; end of table

cmd_examine_params
            ld   hl,ptab_examine
            call read_params
.end        jp   cmd_examine_cur

;   Load examine parameters into registers and temps:
;   t0⋅1=HL=start address, BC=bytes/line, DE=lines to dump
examine_setup
            ld  hl,(vS_examine) ; start address parameter
            ld   (t0),hl        ; t0⋅1: current line start
            ld   b,0
            ld   a,(vW_examine)
            ld   c,a            ; BC: bytes/line
            ld   d,0
            ld   a,(vL_examine)
            ld   e,a            ; DE: number of lines to dump
            ret

cmd_examine_prev
            call examine_setup  ; BC=bytes/line, DE=lines
            ld   a,b            ; complement BC so add subtracts
            cpl
            ld   b,a
            ld   a,c
            cpl
            ld   c,a
            inc  bc
            jp   cmd_examine_next.addpage

cmd_examine_next
            call examine_setup  ; BC=bytes/line, DE=lines
.addpage    add  hl,bc          ; add to start addr no. of bytes per line
            dec  e              ;   as many times as lines to dump
            jp   NZ,.addpage
            ld   (vS_examine),hl ; update start address
            ; fallthrough: do the display

cmd_examine_cur
            call prcr           ; we will overwrite the command line
            call examine_setup  ; BC=bytes/line DE=lines, HL=(t0⋅1)=curline addr
            ;
.startline  push bc             ; save BC=bytes/line
            push de             ; save DE=lines remaining
            call praddrHL       ; entered with HL=curline start addr
            ;
            ld   a,$01          ; hex format bit
            ld   hl,prmhexA
            call prexamine
            ld   a,$02          ; ASCII format bit
            ld   hl,prvischar
            call prexamine
            ld   a,$04          ; screen code format bit
            ld   hl,prscreenchar
            call prexamine
            ;
.nextline   call prnl
            pop  de             ; restore DE=lines remaining
            pop  bc             ; restore BC=bytes/line
            ld   hl,(t0)        ; curline start addr
            add  hl,bc          ; next line start addr
            ld   (t0),hl
            dec  e
            jp   NZ,.startline
            ;
.end        ret                 ; to prompt

;   ♠AHL(t0⋅1) ♣*(t2⋅3)   prexamine: If the bit in A is set in (vM_examine),
;   i.e. if the format is enabled, print a sequence of (vW_examine)
;   locations starting at (t0⋅1) using the routine in HL. If the bit is not
;   set, just return.
;
prexamine   ld   (t2),hl        ; save address of pr* routine
            ld   hl,vM_examine  ; formats bitfield address
            and  a,(hl)         ;   is our bit set?
            ret  Z              ;      no: just return
            ;
            call prspace
            ld   hl,(t0)        ; current line start address
            ld   a,(vW_examine)
            ld   c,a            ; number of bytes to print (width)
.nextbyte   ex   de,hl          ; save current byte address
            ld   hl,.continue
            push hl             ; continuation address whence pr* will return
            ld   hl,(t2)        ; pr* routine address
            push hl
            ex   de,hl          ; restore current byte address
            ld   a,(hl)         ; load byte to print
            ret                 ; call pr* with continuation
.continue   inc  hl             ; next byte
            dec  c              ; printed all bytes?
            jp   NZ,.nextbyte   ;    no: carry on
            ret

ptab_regs   pb   'F',ureg_F     ; flags
            pb   'A',ureg_A
            pb   'B',ureg_B
            pb   'C',ureg_C
            pw   'I',ureg_BC    ; mnemonic "Index" (like a count)
            pb   'D',ureg_D
            pb   'E',ureg_E
            pw   'T',ureg_DE    ; mnemonic "Target"
            pb   'H',ureg_H
            pb   'L',ureg_L
            pw   'M',ureg_HL    ; mnemonic "Memory"
            pw   'P',ureg_PC
            pw   'S',ureg_SP
            db 0

cmd_regs_deposit
            ld   hl,ptab_regs
            call read_params
            ; fallthrough

cmd_regs_examine
            call prcr           ; overwrite line, since we display everything
            call showregs
.end        ret                 ; to prompt

showregs    ld   hl,(ureg_PC)
            call prhexHL
            ld   hl,(ureg_SP)
            call .spprhexHL
            ;   flags
            call prspace
            ld   a,(ureg_F)
            call prflags
            ;   A BC CD EF HL
            call prspace
            ld   a,(ureg_A)
            call prhexA
            ld   hl,(ureg_BC)
            call .spprhexHL
            ld   hl,(ureg_DE)
            call .spprhexHL
            ld   hl,(ureg_HL)
            call .spprhexHL
            call prnl
            ret
            ;
.spprhexHL  call prspace
            call prhexHL
            ret

prflags     ld   b,8            ; 8 bits in flags
            ld   hl,flagchars   ; letters for flags, or 0 for no print
.nextbit    rla                 ; next flag value into carry
            push af             ; save remaining flags
            ld   a,(hl)         ; flag print char - 1
            inc  a              ; set flag char and ZSPA flags (C unaffected)
            jp   Z,.noprint
            jp   C,.print       ; if flag set, print flag char
            ld   a,'-'          ; otherwise flag-no-set char
.print      call prchar
.noprint    pop  af             ; restore remaining flags
            inc  hl             ; next flag char
            dec  b              ; next bit?
            jp   NZ,.nextbit    ;   yes: continue printing
            ret

;   We store the flag characters and $00 "ignore bit" bytes as one
;   less than their actual values because this makes it easier to test
;   the value, which we do by using INC. (We use INC instead of a logic
;   operation because that preserves the carry flag, which contains the
;   value of the flag we're printing.)
flagchars   db   'S'-1, 'Z'-1, 0-1, 'H'-1, 0-1, 'P'-1, 0-1, 'C'-1

; ----------------------------------------------------------------------
;   Deposit Commands

ptab_deposit_params
            pw   'S',vS_deposit     ; start: 16-bit value
            pb   'N',vN_deposit     ; advance to next mode
            pb   'E',t0             ; copy examine start address: temp store
            db   0                  ; end of table

cmd_deposit_params
            xor  a,a
            ld   (t0),a
            ld   hl,ptab_deposit_params
            call read_params
            call prnl
            ld   a,(t0)          ; copy examine start address?
            or   a,a
            jp   Z,.end         ;   no
            ld   hl,(vS_examine)
            ld   (vS_deposit),hl
.end        ret                 ; to prompt

cmd_deposit_words
            ld   c,1            ; qhex size flag: 16-bit stores (preserved)
            jp   cmd_deposit_hex

cmd_deposit_bytes
            ld   c,0            ; qhex size flag: 8-bit stores (preserved)
            ; fallthrough

cmd_deposit_hex
            call prcr           ; use existing line for entry
            ld  hl,(vS_deposit) ; start address
            call praddrHL
            call prspace
.next       call qhex
            jp   NZ,.next
            jp   deposit_end

depaddr     call prcr           ; use existing line for entry
            ld  hl,(vS_deposit) ; start address
            call praddrHL
            call prspace
            ret

cmd_deposit_ascii
            call depaddr
            ld   c,0            ; qhex size flag: 8-bit values in Ctrl-D mode
            dec  hl
.next       inc  hl
            ld   a,(hl)         ; load/print current value
            call prvischar
            call prback
            ;
            call rdchar
            call cqcancel       ; terminate command if cancel character
            call qexec          ; "execute" char? (newline)
            jp   Z,deposit_end  ;   yes: input complete
            ;
            cp   a,ACK          ; Ctrl-F to skip over this location?
            jp   NZ,+           ;    no: process input
            ld   a,(hl)         ;   yes: reprint and move to next char
            call prvischar
            jp   .next
            ;
+           cp   a,$04          ; Ctrl-D to switch to hex digit input?
            jp   NZ,.char       ;    no: normal char input
            call qhex
            jp   Z,deposit_end  ; we're done if qhex was exited w/"execute"
            dec  hl
            jp   .next
            ;
.char
            ld   (hl),a         ; store char
            call  prvischar     ; print input
            jp   .next          ; and next loc

deposit_end call prnl
            ld   a,(vN_deposit)
            or   a,a
            jp   Z,.noadvance
            ld   (vS_deposit),hl
.noadvance  ret                 ; to prompt

; ----------------------------------------------------------------------;
;   "Hex file" Deposit Commands

;   SIZE We can save ~8 bytes on 8080 by pushing `.hexerror` and using
;   conditional returns, but only a couple on Z80 if we use `jr`.
cmd_deposit_intelhex            ; ':' prefix has already been read
            ld   hl,(vL_calc)   ; increment current record count
            inc  hl
            ld   (vL_calc),hl
            call qrhex2
            jp   C,.hexerror
            ld   b,a            ; byte count of data field
            call qrhex4
            jp   C,.hexerror
            ex   de,hl
            ld   (t2),hl        ; load address
            call qrhex2
            jp   C,.hexerror
            and  %11111110      ; record type $00 (data) or $01 (EOF)?
            jp   NZ,.hexerror   ;    no: we can't handle it
            ;   XXX No check that type 1 (EOF) has no data; we deposit anyway.
            ;   Read data bytes.
            ld   hl,(t2)
            inc  b
.databyte   dec  b
            jp   Z,.checksum
            call qrhex2
            jp   C,.hexerror
            ld   (hl),a
            inc  hl
            jp   .databyte
            ;
.checksum   call qrhex2         ; checksum is ignored
            jp   C,.hexerror
            ld   hl,(vR_calc)   ; increment current success count
            inc  hl
            ld   (vR_calc),hl
            jp   prnl           ; TCO ret to prompt
            ;
.hexerror   ;   On any error we:
            ;   • Indicate error with a beep followed by a newline, `?` and
            ;     another newline.
            ;     (It would be nice to print the character offset of the
            ;     error, but doing this would add considerable code.)
            ;   • Consume all text up to the next colon or CR or colon, to
            ;     avoid trying to read remaining data as commands. If a
            ;     colon is found we start a new intelhex deposit command;
            ;     if a CR is found we return to the prompt.
            call errbeep
            call prnl
            ld   a,'?'
            call prchar
            call prnl
            ld   a,(t0)         ; char that caused the parse failure
.clearinp   cp   CR
            jp   Z,prompt
            ;   This is buggy: the `:` isn't printed to indicate that a new
            ;   record is being read. But it's not entirely clear we should
            ;   bother with this (supporting records w/o CR separators) at all.
            cp   ':'
            jp   Z,cmd_deposit_intelhex
            call  rdchar
            jp   .clearinp

;   ♠CDE,t0 … ♡B   Read N valid hex digits into DE/A.
;   • The char read is stored in t0 for later error handling.
;   • Any invalid char returns with carry set.
;   • Otherwise it returns with carry clear.
;   • For convenience in storing the result to memory, the return value in
;     E is copied to A.
qrhex4      ld   c,4
            jp   qrhexN         ; XXX we can use a skip trick to shorten this.
qrhex2      ld   c,2
qrhexN      ld   de,$0000
.nextchar   call rdchar
            ld   (t0),a         ; save char for error handler
            call prvischar
            call qhexdigitDE    ; ♡BCHL (must preserve these!)
            ret  C              ; fail on error
            dec  c
            jp   nz,.nextchar
.done       ld   a,e
            ret

; ----------------------------------------------------------------------
;   Checksum and Copy Commands

ptab_target     pw   'T',vT_target  ; target start: 16-bit value
                pw   'U',vU_target  ; target end: 16-bit value
                pw   'V',t0         ; calculate target end from other addrs
ptab_source     pw   'S',vS_source  ; source start: 16-bit value
                pw   'E',vE_source  ; source end: 16-bit value
                db   0

;   Currently we support only the required CRC-16-CCITT algorithm,
;   and thus do not bother with an `f##` parameter.
cmd_cksum   ld   hl,ptab_source
            call read_params
.exec       call prcr           ; overprint with "start.end =cksum"
            ld   hl,(vS_source)
            ld   d,h            ; start address
            ld   e,l
            call praddrHL       ; print with colon to indicate end addr follows
            ld   hl,(vE_source) ; end address
            call prhexHL
            call subHLDE
            call pr3sp
            ld   a,'='
            call prchar
            ;
            ld   b,h            ; length
            ld   c,l
            call cksum_crc_16_ccitt
            call prhexHL
            call prnl
.end        ret                 ; to prompt

            ;   Included here because required for all monitors.
            include src/i8080/checksum/crc_16_ccitt.i80

cmd_memcopy ld   hl,ptab_target
            call read_params
            call prnl
.exec       ld   hl,(vT_target)     ; DE = current target addr
            ex   de,hl
            ld   hl,(vU_target)     ; BC = remaining target length to copy
            ld   bc,vT_target       ;      (vU_target) - (vT_target)
            call subHLpBC
            ld   b,h
            ld   c,l
            ld   hl,(vS_source)     ; HL = current source addr
            ;                       ;      (reset when it hits end of course)
.loop       ld   a,c
            or   a,b                ; remaining target length BC = 0?
            jp   Z,prompt           ;   yes: copy is complete
            call cmp_vE_HL          ; reached end of source range?
            jp   NZ,+               ;    no: continue w/current src addr
            ld   hl,(vS_source)     ;   yes: reset src addr to start
+           ld   a,(hl)             ; copy (DE) ← (HL)
            ld   (de),a
            inc  hl
            inc  de
            dec  bc
            jp   .loop

; ----------------------------------------------------------------------
;   Other Commands

cmd_newline call prback         ; erase visible ^K
            call prspace
            jp   prnl           ; TCO ret to prompt

;   This echos non-printing chars as-is to enable the use of terminal
;   codes or the like in comments.
;   Kinda-bug: LF immediately after the command will leave the '#' in the
;   second column visible, but that's pathological input and not worth fixing.
cmd_comment call prcr
            ld   a,'#'
.nextchar   call prchar         ; non-printing chars echoed as-is
            call rdchar
            cp   CR             ; CR terminates comment
            jp   NZ,.nextchar
.done       jp   prnl           ; TCO ret to prompt

ptab_port_in
            pb   'P',vP_port_in
            db   0

cmd_port_in
            ld   hl,ptab_port_in
            call read_params
            ld   a,(vP_port_in)
            ld   c,a                ; port number
            ld   a,$DB              ; OUT instruction
            jp   cmd_port_cont

ptab_port_out
            pb  'P',vP_port_out
            pb  'V',vV_port_out
            db   0

cmd_port_out
            ld   hl,ptab_port_out
            call read_params
            ld   a,(vP_port_out)
            ld   c,a                ; port number
            ld   a,(vV_port_out)
            ld   d,a                ; data to write
            ld   a,$D3              ; OUT instruction
            ;    fallthrough

cmd_port_cont ;  Set up trampoline
            ld   (t0),a         ; IN/OUT instruction
            ld   a,c
            ld   (t1),a         ; port to read/write
            ld   a,$C9
            ld   (t2),a         ; RET instruction
            call pr3sp          ; space out before printing read/write data
            ld   a,d            ; data to write (ignored if read)
            call t0             ; call trampoline
            call prhexA
            jp   prnl           ; TCO ret to prompt

ptab_calc
            pw   '?',vL_calc    ; left value: 16 bits
            pw   '/',vR_calc    ; right value: 16 bits
            db   0

cmd_calc
            ld   hl,ptab_calc
            call read_params
.exec       call prcr           ; output on same line, since we print inputs
            ;   Left/right input values
            ld   hl,(vL_calc)
            call praddrHL
            ex   hl,de
            ld   hl,(vR_calc)
            call prhexHL
            ex   hl,de
            ;   Addition result
            add  hl,de
            call .print
            ;   Subtraction result
            ld   hl,(vL_calc)
            call subHLDE
            call .print
            ;   Clear two spaces of any junk just to the right of the output.
            ;   This takes us to col 31, so we don't scroll on 32-col displays.
            call prspace
            call prspace
            jp   prnl           ; TCO ret to prompt
            ;
.print      call pr3sp
            call prhexHL
            call prspace
            ld   a,l
            call prvischar
            call prscreenchar
            ret

; ----------------------------------------------------------------------
;   Parsing Routines `q*`

;   ♠A   Set Z flag if the char in A is "ignored" whitespace (space, CR or LF).
;        (We might include the cancel chars here so that at a command prompt
;        they wouldn't generate an error, but it doesn't seem worth the 6
;        bytes it would take.)
qignspace   cp  ' '
            ret Z
            ;   fallthrough

;   ♠A Set Z flag if the char in A is an execute command character (CR or LF).
qexec       cp   CR
            ret  Z
            cp   LF
            ret

;   ♠A ♡A   If the char in A is a cancel command character (^U or ^X)
;           cancel the current command and go back to the prompt,
;           otherwise just return.
cqcancel    cp   CAN
            jp   Z,cancel
            cp   NAK
            jp   Z,cancel
            ret

            include "src/i8080/qhex.i80"     ; hex parsing

;   ♠A   If the char in A is not in the ctrl/numbers/punct area, upper-case it.
;        BUGS: modifies punctuation above $40, DEL, and anything with bit 7 set.
upcase      cp   '@'            ; in the letters area?
            ret  C              ;    no: don't change the char
            and  UPCASE
            ret

; ----------------------------------------------------------------------
;   Printing Routines `pr*`

;   ♣A ♡*   Backspace over the last printed character
prback      ld   a,BACKSPACE
            jp   prchar         ; ret (TCO)

;   ♣A ♡*   Print a carriage return to move to the start of the current line.
prcr        ld   a,CR
            jp   prchar         ; ret (TCO)

;   ♣AB   Print three spaces or N spaces.
pr3sp       ld   b,3
prNsp       ld   a,' '
            ;   FALLTHROUGH

;   ♠AB ♣A ♡B*   Print char in A, B times. (Preserves B.)
prBchars    push bc
            ld   c,a
.next       ld   a,c
            call prchar
            dec  b
            jp   NZ,.next
            pop  bc
            ret

;   ♣AB ♡CDE   Print 4 spaces, 4 backspaces to clear ahead of cursor.
pr4clear    ld   b,4
            call prNsp
            ld   a,BACKSPACE
            jp   prBchars       ; ret (TCO)

;   ♠AC ♣A ♡*   Print a byte in hex as part of multiple bytes on a line.
;               Spacing afterwards depends on C:
;               • C=0:   1 space: we're done printing the line
;               • C/8≠0: 1 space: we're in a group of 8 bytes
;               • C/8=0: 2 spaces: we're separating next 8-byte group
;               The space at the end gives better separation w/anything else
;               coming after.
prmhexA     call prhexA
            ld   a,c
            dec  a              ; last byte of line for 1-based count?
            jp   Z,prspace      ;   yes: one trailing space and ret (TCO)
            call prspace        ;    no: trailing space and may have a second
            ld   a,c
            and  a,$07          ; mask bottom three bits
            dec  a              ; adjust for 1-based count
            ret  NZ             ;   no: just the one space is fine
            jp   prspace        ;  yes: add a second space and ret (TCO)

;   ♠CHL,BDE ♣A ♡CHL   Print 2-byte (C=0) or 4-byte (C=*) value (HL).
;                      Return value in DE and # of digits in B.
;   C=0: print 2-digit byte; C=*: print 4-digit word.
;   On return, B is set to the length printed, 2 or 4.
prhexval    ld   b,2            ; default to 2-digit word
            ld   d,$00          ;   with returned MSB zero just in case
            xor  a,a
            or   a,c            ; print 4-digit word?
            jp   Z,.print2      ;    no
            ld   b,4            ; update digit count
            inc  hl             ; move up to MSB
            ld   d,(hl)
            ld   a,d
            call prhexA
            dec  hl             ; move down to LSB
.print2     ld   e,(hl)
            ld   a,e
            jp   prhexA         ; ret (TCO)

            include  src/i8080/pr/hex.i80       ; printing

;   ♠HL ♣A ♡HL,*   Print HL as a hex addres, followed by a colon.
praddrHL    call prhexHL
            ld   a,':'
            jp   prchar         ; ret (TCO)

; ======================================================================
;   Misc. routines. Possibly these should be library routines.

;   ♡HL ♣A   Compare (vE_source) to HL; Z=0 for equal, Z=1 for not equal.
cmp_vE_HL   push hl
            ld   a,(vE_source)      ; end address LSB
            sub  l
            ld   l,a                ; temp save in L
            ld   a,(vE_source+1)    ; end address MSB
            sbc  a,h
            ld   h,a                ; temp save in H
            ld   a,l
            or   a,h                ; == 0? (setting Z flag for return)
            pop  hl
            ret

;   ♣A   HL ← HL - DE. Affected flags: Z.
;   XXX This should be in a generic file somewhere?
subHLDE     ld   a,l
            sub  a,e
            ld   l,a
            ld   a,h
            sbc  a,d
            ld   h,a
            or   a,l        ; Z flag set only if H and L are 0
            ret

;   ♠BCHL ♣AHL  Compare BC - HL and set "borrow" (carry):
;               • NCy = BC ≥ HL
;               •  Cy = BC < HL
cpBCHL      ld   a,c        ; LSB
            sub  a,l        ; affects carry
            ld   a,b        ; MSB
            sbc  a,h        ; use and affect carry
            ret

;   ♠BCHL ♡DE ♣ABC   HL ← HL - [BC]
subHLpBC    ;   load BC with [BC]
            ld   a,(bc)     ; LSB of [BC]
            push af
            inc  bc
            ld   a,(bc)     ; MSB of [BC]
            ld   b,a
            pop  af         ; restore LSB
            ld   c,a
            ;
            ld   a,l        ; subtract LSB from L
            sub  a,c
            ld   l,a
            ld   a,h        ; subtract MSB from H
            sbc  a,b
            ld   h,a
            ret

tmon_rom_end
