#!/usr/bin/env python3
'''
    Configure for use of the Macroassembler AS.

    This will prefer, in order:
      1. An already-built version local to this project under .build/.
      2. A version provided by the environment.
      3. Fetch, build and install a local version for #1 above.

    This has three output streams: stdout and stderr from this program
    and any programs it calls to do the setup (fetch, build and
    install), and the "configuration output," which prints Bash
    commands to configure the caller to use what it's set up.

    If file descriptor 3 is open when this is started, the
    configuration commands will be printed to that. The caller is
    expected to execute these, while passing through stdout and
    stderr, with the following Bash magic incantation:

        . <($tool_path 3>&1 1>/proc/$$/fd/1)

    If file descriptor 3 is not open, the configuration commands will
    be printed to stdout, prefixed by ``CONFIG: ``. (The caller can
    copy these and execute them by hand if he likes.)

    TODO:
    - Add ability to force fetch/build/use of local tool version even
      when one is available from the environment.

'''

####################################################################
#   Configuration

TOOLSET_NAME = 'asl'
SOURCE_REPO = 'https://github.com/KubaO/asl.git'
SOURCE_REF  = 'dev/cjs/current'

####################################################################
#   Globals

from    pathlib import Path
import  os, shutil, subprocess, sys, traceback

BUILDDIR = None  # Project build directory for tool source and executables

def pdir(dir, *subdirs, create=True):
    ''' Return an absolute path to a subdirectory under the prefix
        (`BUILDDIR`/tools) we use for toolsets. The first level `dir`
        must be a member of `PREFIX_SUBDIRS`.

        If `create` is `True`, this will create the directory, if
        necessary.
    '''
    if not dir in PREFIX_SUBDIRS:
        raise ValueError('Internal error: {} not in PREFIX_SUBDIRS'.format(dir))

    d = BUILDDIR.joinpath('tool', dir, *subdirs)
    if create:
        d.mkdir(parents=True, exist_ok=True)
    #   We do not have strict=False in which means we must
    #   create the directories _before_
    d = d.resolve()     # strict=False not available in Python ≤3.5, so we
                        # must have created the directories before we resolve.
    return d


def srcdir(resolve=False):
    if not resolve:
        return BUILDDIR.joinpath('tool', 'src', TOOLSET_NAME)
    else:
        #   Work around not having ``strict=True`` option to `Path.resolve()`
        #   in Python ≤3.5 by resolving `BUILDDIR` instead, which will
        #   always exist if we've reached the point of needing the target dir.
        return BUILDDIR.joinpath('tool', 'src').resolve().joinpath(TOOLSET_NAME)

####################################################################
#   Fetch/build/install routines

def check_installed():
    ''' *Silently* determine if the toolset is currently available or
        not and exit with success if it is.
    '''
    #   XXX Start with shutil.which, first?
    try:
        c = subprocess.run(['asl', '-this-is-not-an-option'],
            stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    except FileNotFoundError:
        return
    if c.returncode == 4 and b'Invalid option' in c.stdout:
        successexit()

def setbuilddir():
    ''' Locate build and target directories.

        If the ``BUILDDIR`` environment variable is set, we use that,
        creating that directory if necessary. Otherwise if ``.build/``
        exists in the current working directory, we use that.
    '''
    global BUILDDIR

    if os.environ.get('BUILDDIR', None):
        BUILDDIR = Path(os.environ['BUILDDIR'])
        for d in PREFIX_SUBDIRS:
            BUILDDIR.joinpath('tool', d).mkdir(parents=True, exist_ok=True)
        return

    if Path('.build').is_dir():
        BUILDDIR = Path('.build')
        return

def setpath():
    ''' Update ``PATH`` to include the tools we're building.

        XXX This does not work on Windows.
    '''
    if not BUILDDIR:
        #   Cannot build, so must rely on the environment providing the tool.
        return

    path = os.environ.get('PATH', None)
    if path is None:
        errexit(EX_CONFIG, 'ERROR: No PATH variable in environment')
    separator = ':'     # XXX not right for Windows
    td = str(pdir('bin'))
    if td in path:                      # XXX mismatches if substring
        return
    path = td + separator + path
    os.environ['PATH'] = path
    printconfig("PATH='{}'".format(path))

def fetch():
    ''' Fetch the tool if not already present in TARGET. '''
    if srcdir().is_dir():
        print('----- Using existing source in {}'.format(srcdir()))
        return

    print('----- Cloning {} from {}'.format(TOOLSET_NAME, SOURCE_REPO))
    runcmd([ 'git', 'clone', str(SOURCE_REPO), str(srcdir()) ])

    print('----- Switching to ref or branch {}'.format(SOURCE_REF))
    runcmd([ 'git', '-C', str(srcdir()), 'checkout', str(SOURCE_REF) ])

def configure():
    ''' Configure build, if not already done. '''
    if srcdir().joinpath('Makefile.def').exists():
        print('----- Using existing build configuration')
        return

    print('----- Configuring {}'.format(srcdir()))

    shutil.copyfile(
        str(Path(__file__).parent.joinpath('gitignore')),
        str(srcdir().joinpath('.gitignore')))
    shutil.copyfile(
        str(srcdir().joinpath(
            'Makefile.def-samples', 'Makefile.def-x86_64-unknown-linux')),
        str(srcdir().joinpath('Makefile.def')))

def build():
    ''' Build  the tool.

        This is generally expected to rebuild the tool if any files
        have changed in the local source copy.
    '''
    #   Note we avoid building the documentation here.
    runcmd(['make', '-j8'], cwd=srcdir())

def install():
    ''' For ASL we don't use `make install` because that wants to build the
        documentation, which requires LaTeX and even then tends to drop to
        interactive prompts about missing `german.sty` etc.

        As well, it's nicer four our purposes to use symlinks back to the
        build directory because then a developer tweaking AS can just
        `make` in the source directory to make the new version available to
        the build system.

        So instead we emulate the parts of install.{bat,cmd,sh} we want,
        which is bin/, lib/ (the message files are required) and include/.
    '''

    binfiles = ('asl', 'plist', 'alink', 'pbind', 'p2hex', 'p2bin',)
    for f in binfiles:
        dest = pdir('bin').joinpath(f)
        if not dest.exists(): dest.symlink_to(srcdir().joinpath(f))

    #   The localization message files normally go in lib/asl/, but the
    #   programs don't find them there by default (unless perhaps the
    #   prefix is /usr/local/). We could emit a setting for the AS_MSGPATH
    #   environment variable to indicate where they are, but to allow use
    #   of these tools from the command line without running the Setup
    #   script, it seems better to just drop the files into bin/, where the
    #   programs can automatically find them.
    #
    for path in srcdir().glob('*.msg'):
        dest = pdir('bin').joinpath(path.name)
        if not dest.exists(): dest.symlink_to(path)

    srcs = srcdir().joinpath('include')
    for src in srcs.glob('**/*'):
        if src.is_dir(): continue
        dest = pdir('include', 'asl').joinpath(src.relative_to(srcs))
        dest.parent.mkdir(parents=True, exist_ok=True)
        if not dest.exists(): dest.symlink_to(src)

####################################################################
#   Main program

def main():
    setbuilddir()
    setpath()
    check_installed()
    if not BUILDDIR:
        errexit(EX_USAGE,
            'BUILDDIR not set and {} is not a directory.'.format(BUILDDIR))
    else:
        fetch()
        configure()
        build()
        install()

if (__name__) == '__main__':
    try:
        sys.path.insert(0, str(Path(__file__).parent.parent.resolve()))
        from setup import *
        main()
    except Exception as ex:
        printconfig('return', EX_SOFTWARE)
        errprint('INTERNAL ERROR in', sys.argv[0])
        traceback.print_exc()
        sys.exit(EX_SOFTWARE)
