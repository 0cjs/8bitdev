;   pmon: a machine-language monitor

; ----------------------------------------------------------------------
;   Memory Configuration

;   The memory areas used by the monitor are configured by constants that
;   must be defined before this file included.
;
;   `pmon_ramlo` and `pmon_ramhi` are the two blocks of RAM storage
;   required by the monitor. Each may be anywhere in memory, but there is a
;   slight code size and performance benefit to having `pmon_ramlo` in the
;   direct page.
;
;   `pmon_ramhi` may be left undefined to place that area immediately after
;   `pmon_ramlo`
;
;   `pmon_org` sets the start of the code.
;
;   XXX define pmon_ramlo_end and pmon_ramhi_end? Test usefulness with
;   usage of these forward definitions.

;   Abort assembly with a clear message if an essential definition is missing.
    set ______,
    pushv , pmon_ramlo, pmon_org
    popv  , ______,     ______

; ----------------------------------------------------------------------
;   Standard functions, macros and definitions
;   (Much of this should probably be moved to `stddef`.)

;   ASCII character definitions
BEL         equ $07             ; bell ('\a')
BS          equ $08             ; backspace ('\b')
LF          equ $0A             ; line feed ('\n')
CR          equ $0D             ; carriage return ('\r')
CAN         equ $18             ; cancel (Ctrl-X)

;   Monitor definitions
PROMPT      equ '_'

;   Command table entries and types
CT_END      equ $00             ; end of table/end of entry
CT_CONTINUE equ $01             ; continuation "command"
CTP_END     equ $00             ; end of parameters
CTP_WORD    equ $FF             ; parameter with word value
CTP_BYTE    equ $FE             ;     "      "   byte value
CTP_CHAR    equ $FD             ;     "      "   character value
CTP_NYBBLE  equ $FC             ;     "      "   nybble value
CTP_B7      equ %10000000       ;     "      "   boolean value stored in bit 7
CTP_B6      equ %01000000       ;     "      "      "      "      "   "   "  6
CTP_B5      equ %00100000       ;     "      "      "      "      "   "   "  5
CTP_B4      equ %00010000       ;     "      "      "      "      "   "   "  4
CTP_B3      equ %00001000       ;     "      "      "      "      "   "   "  3
CTP_B2      equ %00000100       ;     "      "      "      "      "   "   "  2
CTP_B1      equ %00000010       ;     "      "      "      "      "   "   "  1
CTP_B0      equ %00000001       ;     "      "      "      "      "   "   "  0

; ----------------------------------------
;   "Low" area aimed at maximum gain from minimum direct page usage.
;   This does not actually _have_ to be in the direct page, however.
;
            org pmon_ramlo

;   It's a convention in this repo to have _[axbyij] zero pages words
;   defined for arithmetic routine parameters/returns/counters so we re-use
;   this here for temp space for non-arithemtic routines.
_a          ds  2
_x          ds  2
_i          ds  1

pmon_ramlo_end equ *

; ----------------------------------------
;   "High" area that gains little from being in the direct page.
;   (This may be because few instructions access it or because accesses are
;   usually with instructions that have no shorter direct page version.)
;   If `pmon_ramhi` is not defined, this starts immediately after `pmon_ramlo`.

        if defined(pmon_ramhi)
            org pmon_ramhi
        endif

cmdtbl      ds  2       ; pointer to command table (see below)
;   Saved register values (same memory order as interrupt stack frame):
Rcc         ds  1       ; condition codes
Rb          ds  1       ; accumulator B
Ra          ds  1       ; accumulator A
Rx          ds  2       ; index register X
Rpc         ds  2       ; program counter
Rsp         ds  2       ; stack pointer

pricount    ds  1       ; printed input count: how far we need to backspace to
                        ;   clear the currently pending or previous input value
cmdentry    ds  2       ; pointer to entry found by cmdlookup

pmon_ramhi_end equ *

; ----------------------------------------------------------------------
;   Code

            org pmon_org

; ----------------------------------------------------------------------
;   Command loop

init        ;   The machine state at this entry point may not be particularly
            ;   meaningful, but has some potentially useful information.
            psh A               ; cannot STA until flags are saved
            tpa
            sta A,Rcc
            pul A
            sta A,Ra
            sta B,Rb
            stx Rx
            tsx
            stx Rsp             ; just our own stack pointer
            lda A,1,X           ; saved PC shows where exit command will return
            sta A,Rpc
            lda A,2,X
            sta A,Rpc+1

            ldx #banner
            jsr prstr0
            jsr prnl

            ;   No need to init pricount since our first lineCR will do it.
            ldx #cmdtabl_rom
            stx cmdtbl

            bra qcommand        ; XXX use pristr here instead

;   Keep banner near start so it's easy to see in dumps of the file.
banner      db 'pmon 2022-05-30 cjs',0

qcommand    ;   Command read mode
            jsr lineCR          ; ensure we're at beginning of line
            lda A,#PROMPT
            jsr prchar

            ;   Commands RTS when done, so we set up the stack with a return to
            ;   here and JMP to the command. (Continuation-passing style.)
            lda A,#LB(qcommand)
            psh A
            lda A,#MB(qcommand)
            psh A

            jsr rd1
            jsr prchar
            jsr cmdlookup
            bcc .foundcmd

            ;   Unknown command: generate an error tone and backspace over
            ;   the bad input. Does not overwrite the bad input so that you
            ;   see the character that caused the error under the cursor.
            lda A,#BEL
            jsr prchar
            lda A,#BS
            jsr prchar
            dec pricount        ; we backspaced over the rd1 pricount
            rts                 ; continue with qcommand

.foundcmd   jsr qparams         ; parse parameters
            bcc .execute        ; got CR to execute
            rts                 ; got cancel; use continuation to start parsing
                                ;   new command on this same line

.execute    jsr lineCR          ; we overwrite command entry
            ;   XXX Should we try to wipe the line with some spaces? Or just
            ;   leave it to output routines to decide how much to clear
            ;   after what they print?
            ldx cmdentry        ; load pointer to command table entry
            ldx 1,X             ; load execution addr of that command
            jmp ,X              ; command will RTS to above

; ----------------------------------------------------------------------
;   Fixed ("ROM") command table. This is our default command table, but
;   users may override it by changing `cmdtbl` to point to their own
;   command table which usually would continue back to this after they
;   define their own commands.
;
cmdtabl_rom
            db  'b'
            dw  Cbanner
            db  CTP_END

            db  'x'
            dw  Cexit
            db  CTP_END

            db  'o'
            dw  Cout
            db  'a', CTP_WORD
            db  'v', CTP_BYTE   ; value to write
          ; db  'm', CTP_B7     ; use memory-mapped I/O; not present on 6800
            db CTP_END

            db  'r'
            dw  Cregs
            db  'p', CTP_WORD
            db  's', CTP_WORD
            db  'f', CTP_BYTE
            db  'a', CTP_BYTE
            db  'b', CTP_BYTE
            db  'x', CTP_WORD
            db  CTP_END

            db  CT_END

; ----------------------------------------------------------------------
;   Command implementations

;   Exit the monitor back to whatever called it.
Cexit       jsr prnl            ; leave prompt and command char on the screen
                                ;   so we see why we exited
            pul A               ; remove continuation return address so we
            pul A               ;   return to whatever called the monitor
            rts

;   Print the banner (XXX just for testing)
Cbanner     ldx #banner
            jsr prstr0
            jsr prspace         ; a few spaces to ensure end of string is clear
            jsr prspace         ;   if we had lots of parameters on line
            jmp prnl            ; RTS TCO

;   Send byte to output port etc.
Cout        db $02              ; end simulator w/invalid instruction

;   Modify/print registers
Cregs       db $03              ; end simulator w/invalid instruction

; ----------------------------------------------------------------------
;   ♠Xc ♡A ♣B  Starting at command table pointed to by `cmdtbl`, find the
;   entry in that table for char given in A. A is always preserved. On
;   failure the carry is set; on success the carry is clear and `cmdentry`
;   points to the entry in the command table.
;
cmdlookup   ldx cmdtbl

            ;   parse type of command table entry
.qentry     lda B,,X            ; CT_END?
            beq .notfound       ;   yes: failure to match
            dec B               ; was 1, CT_CONTINUE?
            bne .cmd_entry      ;   no: it's a regular command entry
            ldx 1,X             ; load continuation address
            bra .qentry         ; continue parsing table

            ;   command entry
.cmd_entry  cmp A,,X            ; matches command letter?
            beq .found          ;   yes: we're done
            inx                 ; increment past command char
            inx                 ; increment past command exec addr
            inx                 ;   (may contain $00 values)
.next_param tst ,X              ; end of parameters (CT_END)?
            beq .param_end      ;   yes: get ready for next entry
            inx                 ; move past this parameter
            inx
            bra .next_param

.param_end  inx                 ; move forward to next entry
            bra .qentry

.notfound   sec                 ; indicate failure, X is don't-care
.found      ;   if found, carry clear on entry because we arrived via `beq`,
            ;   thus success already indicated
            stx cmdentry
            rts

; ----------------------------------------------------------------------
;   parse parameters for a command
;
qparams     jsr rd1
            cmp A,#BS           ; before we've parsed any params,
            beq .cancel         ;   backspace also cancels command

.checkchar  cmp A,#CAN
            beq .cancel
            cmp A,#CR
            beq .execute
            jsr prvischar       ; XXX for the moment, just echo
            jsr rd1
            bra .checkchar

.execute    clc                 ; execute indicator
            rts

.cancel     sec                 ; cancel indicator
            rts

; ----------------------------------------------------------------------
;   pr* - printing output

            include "src/mc68/pr.a68"

;   ♡ABX Move to the start of the _current_ line, as a CR usually does.
;        Also clears `pricount` since we now have no printed input to BS over.
lineCR      psh a
            clr pricount
            lda A,#CR
            jsr prchar
            pul a
            rts

; ----------------------------------------------------------------------
;   rd* - reading input

;   ♠A  Blocking read of one character with increment of character input count.
;       This also converts DEL to BS because we have no special use for
;       separating the two in this system.
rd1         inc pricount
            jsr rdchar          ; RTS
            cmp A,#DEL
            bne +
            lda A,#BS
+           rts
