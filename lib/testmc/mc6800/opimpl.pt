from    testmc.mc6800.opcodes   import Instructions as I
from    testmc.mc6800.opcodes   import *
from    testmc.mc6800.opimpl    import *
from    testmc.mc6800           import Machine
from    testmc                  import tmc_tid, LSB, MSB
from    numbers                 import Number
import  pytest

#   Many functions from the opimpl module are not directly tested, but
#   instead are tested through the tests of instruction implementations.
#   This is because we want to test directly as many instruction
#   implementations as possible. The instruction implementations themselves
#   are usually very simple, and so their tests are mainly testing the
#   support functions anyway.

####################################################################
#   Address handling, reading data at the PC

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         (   0xFE,      1,     0xFF),
                         (   0xFE,      2,     0x00),
                         (   0xFE,      3,     0x01),
                         (      1,     -1,        0),
                         (      1,     -2,     0xFF),
                         (      1,     -3,     0xFE),
), ids=tmc_tid)
def test_incbyte(initial, addend, expected):
    assert expected == incbyte(initial, addend)

@pytest.mark.parametrize('initial, addend, expected', (
                         (      0,      0,        0),
                         (      0,      1,        1),
                         (      0,      2,        2),
                         ( 0xFFFE,      1,   0xFFFF),
                         ( 0xFFFE,      2,   0x0000),
                         ( 0xFFFE,      3,   0x0001),
                         (      1,     -1,        0),
                         (      1,     -2,   0xFFFF),
                         (      1,     -3,   0xFFFE),
                         ( 0x8000, 0xFFFF,   0x7FFF),
                         ( 0x8000,-0xFFFF,   0x8001),
), ids=tmc_tid)
def test_incword(initial, addend, expected):
    assert expected == incword(initial, addend)

@pytest.mark.parametrize(' inb,   out', (
                         (0x00,     0),
                         (0x01,     1),
                         (0x7F,  0x7F),
                         (0x80, -0x80),
                         (0xFF,    -1),
), ids=tmc_tid)
def test_readsignedbyte(inb, out):
    #   This covers signedbyteat() as well.
    m = Machine()
    m.pc = 0xFFFF
    m.deposit(m.pc, inb)
    assert out == readsignedbyte(m)
    assert 0x0000 == m.pc

@pytest.mark.parametrize('     x, offset, target', (
                         (0x0000,   0x00, 0x0000),
                         (0x0004,   0x03, 0x0007),
                         (0x0080,   0xFF, 0x017F),
                         (0xFFFF,   0x01, 0x0000),
                         (0xFFFF,   0xFF, 0x00FE),
))
def test_readindex(x, offset, target):
    m = Machine()
    m.setregs(R(x=x, pc=0x10))
    m.deposit(0x10, offset)
    assert target == readindex(m)

####################################################################
#   Opcode test framework

R = Machine.Registers

def runop(opdata, *, machine=None, memsize=0x402, startaddr=None,
        initregs=R(), initmem={}, changedregs=R(), changedmem={}):
    m = machine
    if m is None:
        m = Machine(memsize=memsize)
    if startaddr is None:
        startaddr = 0x300 + v8(opdata[0])

    #   Set registers A, B and X to have non-zero values if they're not
    #   otherwise used to help detect if they're accidentally zeroed.
    m.a = 0xA5; m.b = 0xB5; m.x = 0xC5D5;

    #   For any register not explicitly set that has a value in changedregs,
    #   set it to some other value so we can confirm it was changed.
    unsetregs = set()
    for name, val in initregs.all().items():
        if val is None: unsetregs.add(name)
    #   But always exclude the program counter and stack pointer
    #   as they should never be randomized!
    unsetregs.discard('pc'); unsetregs.discard('sp')
    for name, val in changedregs.valued().items():
        if name in unsetregs:
            setattr(m, name, not val)
    #   Also set unexpected values for any memory locations expected to change.
    for addr, value in changedmem.items():
        m.mem[addr] = not value

    #   Now that unexpected values have been placed, set any specified
    #   initial data. This is done after the unexpected value
    #   initialization so that those can be explicitly overridden.
    m.deposit(startaddr, opdata)
    for addr, value in initmem.items():
        m.deposit(addr, value)
    m.setregs(initregs)

    m.pc = startaddr
    prevregs = m.regs
    prevmem = bytes(m.mem)

    m.step(1)

    regs = m.regs
    #   If any regs in the machine are unvalued (i.e., set to `None`)
    #   the opcode implementation has done something very wrong.
    unvalued = set(regs.all().keys()) - set(regs.valued().keys())
    assert not unvalued, 'op produced unvalued register(s)'

    if changedregs.pc is None:
        changedregs = changedregs.clone(pc=startaddr + len(opdata))
    allregs = prevregs.clone(**changedregs.valued())

    #   Lining these up in columns makes it easier to see what was wrong.
   #print('    expected all:', allregs)
   #print('expected changed:', changedregs)
   #print('          actual:', regs)

    #   First assert that the registers and flags expected to change have
    #   their correct values. This makes more clear test failures where a
    #   tested value is wrong.
    assert changedregs == regs, "expected register/flag changes"
    #   Now assert that the other registers and flags, which we did not expect
    #   to change (and are not explicitly tested), are actually unchanged.
    assert allregs == regs, "unexpected register/flag changes"

    newmem = bytearray(prevmem)
    for addr, value in changedmem.items():
        newmem[addr] = value
    assert newmem == m.mem

def v8(val):
    ''' Given a byte or word `val`, return an 8-bit value dependent upon
        but not obviously related to `val`. (A given input value will
        always produce the same output value.) This is useful to produce
        different offsets for tests based on their test data.
    '''
    if val > 0xFF:
        val = (val >> 8) ^ val
    return (val-60) & 0xFF

def v16(val, offset=0x80):
    ''' Given a byte or word `val`, return a 16-bit value between `offset`
        and `offset`+$FF that is dependent upon but not obviously related
        to `val`. (A given input value will always produce the same output
        value.) This is useful to produce different addresses for tests
        based on their test data.
    '''
    return offset + (v8(val) ^ 0xFF)

def accx(optemplate):
    ''' Parameterize a test by A and B accumulators.
    '''
    return pytest.mark.parametrize(**ACC(optemplate))

def ACC(optemplate):
    ''' Parametrize by A and B accumulators.

        `optemplate` is the name of the opcode from `opcodes.OPCODES` with
        `~` in place of the accumulator name, e.g., ``LDA~m`` or ``BIT~m``.

        The opcode names for the A and B versions (``LDAAm``, ``LDABm``)
        will be generated; these can be looked up with ``I[opname]``.

        An `accval(value, regs_flags)` function will also be given; this
        constructs a `Registers` object where the selected accumulator is
        initialized with *value* and the remaining parameters are passed
        on to the `Registers` constructor, e.g. ``accval(0xFF, Z=1, V=0)``.
    '''
    opnameA = optemplate.replace('~', 'A')
    opnameB = optemplate.replace('~', 'B')
    def make_accval(accname):
        def accval(accvalue, **kwargs):
            return R(**{ accname: accvalue, **kwargs })
        return accval
    return dict(argnames='opname, accval',
        argvalues=((opnameA, make_accval('a')), (opnameB, make_accval('b'))))

####################################################################
#   Misc instructions

def test_invalid_opcodes():
    badops = (
        0x00, 0x02, 0x03, 0x04, 0x05,
        0x12, 0x13, 0x14, 0x15, 0x18, 0x1A, 0x1C, 0x1D, 0x1E, 0x1F,
        0x21,                           0x38, 0x3A, 0x3C, 0x3D,
        0x41, 0x42, 0x45, 0x4B, 0x4E,   0x51, 0x52, 0x55, 0x5B, 0x5E,
        0x61, 0x62, 0x65, 0x6B,         0x71, 0x72, 0x75, 0x7B,
        0x83, 0x87, 0x8F,               0x93, 0x9D,
        0xA3,                           0xB3,
        0xC3, 0xC7, 0xCC, 0xCD, 0xCF,   0xD3, 0xDC, 0xDD,
        0xE3, 0xEC, 0xED,               0xF3, 0xFC, 0xFD,
    )
    for i, op in enumerate(badops):
        addr = 0x00E0 + i
        with pytest.raises(InvalidOpcode) as ex:
            runop([op], startaddr=addr)
        assert (op, addr) == (ex.value.opcode, ex.value.pc)
        assert ex.match(r'^opcode=\${:02X} pc=\${:04X}$'.format(op, addr))

def test_NOP():
    #   The test framework will ensure that nothing but the PC has changed.
    runop([I.NOP])

####################################################################
#   Branches

def test_JMP():
    runop([I.JMP, 0xAB, 0xCD], changedregs=R(pc=0xABCD))

@pytest.mark.parametrize('offset,      x,     pc', (
                         (     0, 0xFFFF, 0xFFFF),
                         (     3, 0x1234, 0x1237),
                         (  0xFF, 0xFF80, 0x007F),
), ids=tmc_tid)
def test_JMPx(offset, x, pc):
    runop([I.JMPx, offset], initregs=R(x=x), changedregs=R(pc=pc))

def test_BRA():
    runop([I.BRA,    0], startaddr=0x13, changedregs=R(pc=0x0015))
    runop([I.BRA,    3], startaddr=0x14, changedregs=R(pc=0x0019))
    runop([I.BRA, 0x7F], startaddr=0x00, changedregs=R(pc=0x0081))
    runop([I.BRA, 0x80], startaddr=0x0E, changedregs=R(pc=0xFF90))
    runop([I.BRA, 0xFC], startaddr=0x08, changedregs=R(pc=0x0006))
    #   Additional coverage in test_readsignedbyte().

@pytest.mark.parametrize('op, taken, initregs', (
    #                       Carry flag
    (I.BCC, False, R(C=1)),             (I.BCC, True,  R(C=0)),
    (I.BCS, False, R(C=0)),             (I.BCS, True,  R(C=1)),
    #                       Zero flag
    (I.BEQ, False, R(Z=0)),             (I.BEQ, True,  R(Z=1)),
    (I.BNE, False, R(Z=1)),             (I.BNE, True,  R(Z=0)),
    #                       Negative flag
    (I.BMI, False, R(N=0)),             (I.BMI, True,  R(N=1)),
    (I.BPL, False, R(N=1)),             (I.BPL, True,  R(N=0)),
    #                       Overflow flag
    (I.BVC, False, R(V=1)),             (I.BVC, True,  R(V=0)),
    (I.BVS, False, R(V=0)),             (I.BVS, True,  R(V=1)),

), ids=tmc_tid)
def test_condbranch(op, initregs, taken):
    print('op {} ${:02X}, flag: {}, taken {} expected\n'
        .format(OPCODES[op][0], op, str(initregs).split()[-1], taken))
    runop([op, 0x40], initregs=initregs, startaddr=0x0E,
        changedregs= R(pc=0x0050) if taken else R(pc=0x0010))

####################################################################
#   Instructions affecting the stack

@pytest.mark.parametrize('initsp,    word,  newsp', (
                         (     0,  0x4142,      2),
                         (     1,  0x4243,      3),
                         (0xFFFD,  0xCECF, 0xFFFF),
                         (0xFFFE,  0xCF40,      0),
                         (0xFFFF,  0x4041,      1),
), ids=tmc_tid)
def test_popword(initsp, word, newsp):
    m = Machine()
    m.deposit(0x0000, b'\x40\x41\x42\x43')
    m.deposit(0xFFFC, b'\xCC\xCD\xCE\xCF')

    m.sp = initsp
    assert word == popword(m)
    assert newsp == m.sp

### Subroutine calls

def test_JSR():
    runop([I.JSR, 0x56, 0x78],
        memsize=65536, startaddr=0x1234,
        initregs    = R(sp=0),                      # test stack wraparound
        changedregs = R(pc=0x5678, sp=0xFFFE),
        changedmem  = { 0x0000: 0x37, 0xFFFF: 0x12, })

def test_JSRx():
    runop([I.JSRx,                    0x16],
        initregs    = R(sp=0x1F,  x=0xFFF0, ),
        changedregs = R(sp=0x1D, pc=0x0006, ),
        startaddr   =                   0x0123,
        changedmem  = { 0x1E: 0x01, 0x1F: 0x25, },
    )

def test_BSR():
    runop([I.BSR, 0xFE], startaddr=0x12,            # calling self
        initregs    = R(sp=0x18),
        changedregs = R(sp=0x16, pc=0x12),
        changedmem  = { 0x17: 0x00, 0x18: 0x14, },
    )

def test_RTS():
    runop([I.RTS],
        initregs=R(sp=0x002D), initmem={ 0x002E:0x12, 0x002F:0x34 },
        changedregs=R(pc=0x1234, sp=0x002F))

### Data Movement
#   All the other data movement operations affect flags.
#   PSH and PUL do not, which is why they belong here.

@pytest.mark.parametrize(**ACC('PUL~'))
def test_PUL(opname, accval):
    runop([I[opname]], initregs=R(sp=0x000C), initmem={ 0x000D: 0xA1 },
        changedregs = accval(0xA1, sp=0x000D))

@pytest.mark.parametrize(**ACC('PSH~'))
def test_PSH(opname, accval):
    runop([I[opname]], initregs=accval(0xEF, sp=0x000F),
        changedregs = R(sp=0x000E), changedmem  = { 0x000F: 0xEF })

####################################################################
#   Flag (Condition Code) Changes

@pytest.mark.parametrize('op, flag', (
    (I.CLC, R(C=0)), (I.SEC, R(C=1)),
    (I.CLV, R(V=0)), (I.SEV, R(V=1)),
    (I.CLI, R(I=0)), (I.SEI, R(I=1)),
), ids=tmc_tid)
def test_flag_change(op, flag):
    runop([op], changedregs=flag)

#   pccr = processor condition codes register (PRM A-70, A-72)
PCCRparams = {
    'argnames': 'pccr, flags',
    'argvalues': (
        (0b11000000, R(H=0, I=0, N=0, Z=0, V=0, C=0)),
        (0b11000001, R(H=0, I=0, N=0, Z=0, V=0, C=1)),
        (0b11000010, R(H=0, I=0, N=0, Z=0, V=1, C=0)),
        (0b11000100, R(H=0, I=0, N=0, Z=1, V=0, C=0)),
        (0b11001000, R(H=0, I=0, N=1, Z=0, V=0, C=0)),
        (0b11010000, R(H=0, I=1, N=0, Z=0, V=0, C=0)),
        (0b11100000, R(H=1, I=0, N=0, Z=0, V=0, C=0)),
        (0b11010101, R(H=0, I=1, N=0, Z=1, V=0, C=1)),
        (0b11101010, R(H=1, I=0, N=1, Z=0, V=1, C=0)),
        (0b11111111, R(H=1, I=1, N=1, Z=1, V=1, C=1)),
        ),
    'ids': tmc_tid,
    }

@pytest.mark.parametrize(**PCCRparams)
def test_tap(pccr, flags):
    runop([I.TAP], initregs=R(a=pccr), changedregs=flags)

@pytest.mark.parametrize(**PCCRparams)
def test_tpa(pccr, flags):
    runop([I.TPA], initregs=flags, changedregs=R(a=pccr))

####################################################################
#   Data Movement

#   LDx/STx instructions loading/storing 8-bit values.
#   All loads and stores affect N and Z and clear V.
LDSTparams = {      'argnames': '  arg, N, Z ',
                  'argvalues': (( 0x00, 0, 1 ),
                                ( 0x01, 0, 0 ),
                                ( 0x7F, 0, 0 ),
                                ( 0x80, 1, 0 ),
                                ( 0xEA, 1, 0 ),
                                ( 0xFF, 1, 0 ),
    ), 'ids': tmc_tid, }

#   LDx/STx instructions loading/storing 16-bit values.
#   All loads and stores affect N and Z and clear V.
LDST16params = {     'argnames':  '    arg, N, Z ',
                    'argvalues': (( 0x0000, 0, 1 ),
                                ( 0x0001, 0, 0 ),
                                ( 0x00FF, 0, 0 ),
                                ( 0x0100, 0, 0 ),
                                ( 0x7FFF, 0, 0 ),
                                ( 0x8000, 1, 0 ),
                                ( 0xEA00, 1, 0 ),
                                ( 0xFFFF, 1, 0 ),
    ), 'ids': tmc_tid, }

#### Loads

@pytest.mark.parametrize(**LDSTparams)
def test_TAB(arg, N, Z):
    runop([I.TAB], initregs=R(a=arg), changedregs=R(b=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDSTparams)
def test_TBA(arg, N, Z):
    runop([I.TBA], initregs=R(b=arg), changedregs=R(a=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**ACC('LDA~'))
@pytest.mark.parametrize(**LDSTparams)
def test_LDA(opname, accval, arg, N, Z):
    addr = v16(arg)
    runop([I[opname], arg], changedregs=accval(arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**ACC('LDA~z'))
@pytest.mark.parametrize(**LDSTparams)
def test_LDAz(opname, accval, arg, N, Z):
    addr = v8(arg)
    runop([I[opname], LSB(addr)], changedregs=accval(arg, N=N, Z=Z, V=0),
        initmem={ addr: arg })

@pytest.mark.parametrize(**ACC('LDA~m'))
@pytest.mark.parametrize(**LDSTparams)
def test_LDAAm(opname, accval, arg, N, Z):
    addr =v16(arg)
    runop([I[opname], MSB(addr), LSB(addr)],
        changedregs=accval(arg, N=N, Z=Z, V=0),
        initmem={ addr: arg })

@pytest.mark.parametrize(**ACC('LDA~x'))
@pytest.mark.parametrize(**LDSTparams)
def test_LDAx(opname, accval, arg, N, Z):
    addr = v16(arg); offset = v8(arg)
    runop([I[opname], offset],
        initmem={ addr+offset: LSB(arg) },
        initregs=R(x=addr), changedregs=accval(arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDST16params)
def test_LDX(arg, N, Z):
    runop([I.LDX, MSB(arg), LSB(arg)], changedregs=R(x=arg, N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDST16params)
def test_LDXz(arg, N, Z):
    addr = v8(arg)
    runop([I.LDXz, addr],
        changedregs=R(x=arg, N=N, Z=Z, V=0),
        initmem={ addr: MSB(arg), addr+1: LSB(arg) })

@pytest.mark.parametrize(**LDST16params)
def test_LDXm(arg, N, Z):
    addr = v16(arg)
    runop([I.LDXm, MSB(addr), LSB(addr)],
        changedregs=R(x=arg, N=N, Z=Z, V=0),
        initmem={ addr: MSB(arg), addr+1: LSB(arg) })

@pytest.mark.parametrize(**LDST16params)
def test_LDXx(arg, N, Z):
    addr = v16(arg); offset = v8(arg)
    runop([I.LDXx, offset],
        initregs    = R(x=addr),
        initmem     = { addr+offset: MSB(arg), addr+offset+1: LSB(arg) },
        changedregs = R(x=arg, N=N, Z=Z, V=0),
    )

@pytest.mark.parametrize('arg', (0x0000, 0x1234, 0xFFED))
def test_TSX(arg):
    #   Not clear if this is the best way to catch flag changes....
    runop([I.TSX], initregs=R(sp=arg, N=0, Z=1), changedregs=R(x=arg))
    runop([I.TSX], initregs=R(sp=arg, N=1, Z=0), changedregs=R(x=arg))

@pytest.mark.parametrize('arg', (0x0000, 0x1234, 0xFFED))
def test_TXS(arg):
    runop([I.TXS], initregs=R(x=arg, N=0, Z=1), changedregs=R(sp=arg))
    runop([I.TXS], initregs=R(x=arg, N=1, Z=0), changedregs=R(sp=arg))

#### Stores

@pytest.mark.parametrize(**ACC('CLR~'))
@pytest.mark.parametrize('initval', (0x00, 0x02, 0xFF))
def test_CLRa(opname, accval, initval):
    runop([I[opname]], initregs=accval(initval),
        changedregs=(accval(0, N=0, Z=1, V=0, C=0)))

@pytest.mark.parametrize(' addr, initval', (
                         (0x0012,   0x00),
                         (0x0013,   0x03),
                         (0x0111,   0xFF),
), ids=tmc_tid)
def test_CLRm(addr, initval):
    runop([I.CLRm, MSB(addr), LSB(addr)],
        initmem={ addr: initval }, changedmem={ addr: 0 },
        changedregs=R(N=0, Z=1, V=0, C=0))

@pytest.mark.parametrize('x, offset, addr', (
    (      0x0003,    0, 0x0003),
    (      0x0004,    2, 0x0006),
    (0x10000-0xF8, 0xFF, 0x0007),
), ids=tmc_tid)
def test_CLRx(x, offset, addr):
    runop([I.CLRx, offset], initregs=R(x=x),
        changedregs=R(N=0, Z=1, V=0, C=0), changedmem={ addr: 0 })

@pytest.mark.parametrize(**ACC('STA~z'))
@pytest.mark.parametrize(**LDSTparams)
def test_STAz(opname, accval, arg, N, Z):
    addr = v8(arg)
    runop([I[opname], addr], initregs=accval(arg),
        changedmem={ addr: arg }, changedregs=R(N=N, Z=Z, V=0))

@pytest.mark.parametrize(**ACC('STA~m'))
@pytest.mark.parametrize(**LDSTparams)
def test_STAm(opname, accval, arg, N, Z):
    addr = v16(arg)
    runop([I[opname], MSB(addr), LSB(addr)], initregs=accval(arg),
        changedmem={ addr: arg }, changedregs=R(N=N, Z=Z, V=0))

@pytest.mark.parametrize(**ACC('STA~x'))
@pytest.mark.parametrize(**LDSTparams)
def test_STAx(opname, accval, arg, N, Z):
    addr = v16(arg); offset = v8(arg)
    runop([I[opname], offset], initregs=accval(arg, x=addr),
        changedmem={ addr+offset: arg }, changedregs=R(N=N, Z=Z, V=0))

@pytest.mark.parametrize(**LDST16params)
def test_STXm(arg, N, Z):
    addr = v16(arg)
    runop([I.STXm, MSB(addr), LSB(addr)], initregs=R(x=arg),
        changedmem={ addr: MSB(arg), addr+1: LSB(arg) },
        changedregs=R(N=N, Z=Z, V=0))

def test_STXm_rollover():
    runop([I.STXm, 0xFF, 0xFF], memsize=64*1024, initregs=R(x=0x89AB),
        changedmem={ 0xFFFF: 0x89, 0x0000: 0xAB }, changedregs=R(N=1, Z=0, V=0))

@pytest.mark.parametrize(**LDST16params)
def test_STXz(arg, N, Z):
    addr = v8(arg)
    runop([I.STXz, addr], initregs=R(x=arg),
        changedmem={ addr: MSB(arg), addr+1: LSB(arg) },
        changedregs = R(N=N, Z=Z, V=0))

####################################################################
#   Flag handling for data movement and logic

def test_isneg():
    assert not isneg(0)
    assert not isneg(0x7F)
    assert     isneg(0x80)
    assert     isneg(0xFF)

def test_isneg16():
    assert not isneg(0x0000, signbit=15)
    assert not isneg(0x7FFF, signbit=15)
    assert     isneg(0x8000, signbit=15)
    assert     isneg(0xFFFF, signbit=15)

def test_iszero():
    assert     iszero(0)
    assert not iszero(1)
    assert not iszero(0xFF)

def test_logicNZV():
    ' Covered by data movement and logic opcode tests. '

####################################################################
#   Logic operations

@pytest.mark.parametrize(**
    { 'argnames':    ' arg,  res, N, Z, V, C',
      'argvalues': ( (0xFF, 0x00, 0, 1, 0, 1),
                     (0x00, 0xFF, 1, 0, 0, 1),
                     (0x55, 0xAA, 1, 0, 0, 1),
                     (0xAA, 0x55, 0, 0, 0, 1),
    ), 'ids': tmc_tid, })
def test_COMa(arg, res, N, Z, V, C):
    outflags = R(N=N, Z=Z, V=V, C=C)

    runop([I.COMA], initregs=R(a=arg), changedregs=outflags.clone(a=res))
    runop([I.COMB], initregs=R(b=arg), changedregs=outflags.clone(b=res))
    addr = v16(arg)
    runop([I.COMm, MSB(addr), LSB(addr)], initmem={ addr:arg },
        changedmem={ addr:res }, changedregs=outflags)
    base, offset = v16(arg), v8(arg)
    runop([I.COMx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base),
        changedmem={ base+offset:res }, changedregs=outflags)

@pytest.mark.parametrize('a,     arg,  res, N, Z', (
                         (0x00, 0x00, 0x00, 0, 1),
                         (0x00, 0xFF, 0x00, 0, 1),
                         (0xFF, 0x00, 0x00, 0, 1),
                         (0xAA, 0x3C, 0x28, 0, 0),
                         (0xAA, 0xF0, 0xA0, 1, 0),
), ids=tmc_tid)
def test_ANDA(a, arg, res, N, Z):
    runop([I.ANDA, arg], initregs=R(a=a), changedregs=R(a=res, N=N, Z=Z, V=0))

####################################################################
#   Shifts and Rotates

#   The correct values for the N and Z (and for shifts, C) flags could be
#   calculated automatically by the test. However, we specify them manually
#   (and confirm they're correct in the test using the automated method)
#   because this makes it more clear in the test data that we're getting
#   coverage of all states of those flags.

ASLparams = { 'argnames':    ' arg,  res, N, Z, C',
              'argvalues': ( (0x00, 0x00, 0, 1, 0),
                             (0x21, 0x42, 0, 0, 0),
                             (0x80, 0x00, 0, 1, 1),
                             (0x81, 0x02, 0, 0, 1),
                             (0xC8, 0x90, 1, 0, 1),
                             (0xFF, 0xFE, 1, 0, 1),
                             (0x55, 0xAA, 1, 0, 0),
                             (0xAA, 0x54, 0, 0, 1),
              ), 'ids': tmc_tid, }

@pytest.mark.parametrize(**ASLparams)
@pytest.mark.parametrize(**ACC('ASL~'))
def test_ASLa(opname, accval, arg, res, N, Z, C):
    runop([I[opname]], initregs=accval(arg),
        changedregs=accval(res, N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**ASLparams)
def test_ASLm(arg, res, N, Z, C):
    addr = v16(arg)
    runop([I.ASLm, MSB(addr), LSB(addr)], initmem={ addr:arg },
        changedmem={ addr:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**ASLparams)
def test_ASLx(arg, res, N, Z, C):
    base, offset = v16(arg), v8(arg)
    runop([I.ASLx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base),
        changedmem={ base+offset:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

ROLparams = {
    'argnames':    ' arg, inC, C,  res, N, Z',   #  arg, inC, C,  res, N, Z
    'argvalues': ( (0x00, 0,   0, 0x00, 0, 1),    (0x00, 1,   0, 0x01, 0, 0),
                   (0x01, 0,   0, 0x02, 0, 0),    (0x01, 1,   0, 0x03, 0, 0),
                   (0x7F, 0,   0, 0xFE, 1, 0),    (0x7F, 1,   0, 0xFF, 1, 0),
                   (0x80, 0,   1, 0x00, 0, 1),    (0x80, 1,   1, 0x01, 0, 0),
                   (0xFE, 0,   1, 0xFC, 1, 0),    (0xFE, 1,   1, 0xFD, 1, 0),
                   (0xFF, 0,   1, 0xFE, 1, 0),    (0xFF, 1,   1, 0xFF, 1, 0),
                   (0x55, 0,   0, 0xAA, 1, 0),    (0x55, 1,   0, 0xAB, 1, 0),
                   (0xAA, 0,   1, 0x54, 0, 0),    (0xAA, 1,   1, 0x55, 0, 0),
    ), 'ids': tmc_tid, }

@pytest.mark.parametrize(**ROLparams)
@pytest.mark.parametrize(**ACC('ROL~'))
def test_ROLa(opname, accval, inC, arg, res, N, Z, C):
    assert res & 1 == inC
    assert N == bool(res >> 7)  # shift just to be different from CUT's AND
    runop([I[opname]], initregs=accval(arg, C=inC),
        changedregs=accval(res, N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**ROLparams)
def test_ROLm(inC, arg, res, N, Z, C):
    addr = v16(arg)
    runop([I.ROLm, MSB(addr), LSB(addr)],
        initmem={ addr:arg }, initregs=R(C=inC),
        changedmem={ addr:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**ROLparams)
def test_ROLx(inC, arg, res, N, Z, C):
    base, offset = v16(arg), v8(arg)
    runop([I.ROLx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base, C=inC),
        changedmem={ base+offset:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

LSRparams = { 'argnames':    ' arg,  res, Z, V, C',
              'argvalues': ( (0x01, 0x00, 1, 1, 1),
                             (0x02, 0x01, 0, 0, 0),
                             (0xAA, 0x55, 0, 0, 0),
                             (0xFF, 0x7F, 0, 1, 1),
              ), 'ids': tmc_tid, }

@pytest.mark.parametrize(**LSRparams)
@pytest.mark.parametrize(**ACC('LSR~'))
def test_LSRa(opname, accval, arg, res, Z, V, C):
    N = 0; assert V == C
    #   V is meaningless for LSR, but with ASL means "the sign has changed."
    runop([I[opname]], initregs=accval(arg),
        changedregs=accval(res, N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**LSRparams)
def test_LSRm(arg, res, Z, V, C):
    N = 0; assert V == C
    addr = v16(arg)
    runop([I.LSRm, MSB(addr), LSB(addr)], initmem={ addr:arg },
        changedmem={ addr:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**LSRparams)
def test_LSRx(arg, res, Z, V, C):
    N = 0; assert V == C
    base, offset = v16(arg), v8(arg)
    runop([I.LSRx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base),
        changedmem={ base+offset:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

ASRparams = { 'argnames':    ' arg,  res, N, Z, C',
              'argvalues': ( (0x00, 0x00, 0, 1, 0),
                             (0x01, 0x00, 0, 1, 1),
                             (0x02, 0x01, 0, 0, 0),
                             (0x7F, 0x3F, 0, 0, 1),
                             (0x80, 0xC0, 1, 0, 0),
                             (0x81, 0xC0, 1, 0, 1),
                             (0xFF, 0xFF, 1, 0, 1),
                             (0x55, 0x2A, 0, 0, 1),
                             (0xAA, 0xD5, 1, 0, 0),
              ), 'ids': tmc_tid, }

@pytest.mark.parametrize(**ASRparams)
@pytest.mark.parametrize(**ACC('ASR~'))
def test_ASRa(opname, accval, arg, res, N, Z, C):
    assert N == bool(res >> 7)
    runop([I[opname]], initregs=accval(arg),
        changedregs=accval(res, N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**ASRparams)
def test_ASRm(arg, res, N, Z, C):
    addr = v16(arg)
    runop([I.ASRm, MSB(addr), LSB(addr)], initmem={ addr:arg },
        changedmem={ addr:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**ASRparams)
def test_ASRx(arg, res, N, Z, C):
    base, offset = v16(arg), v8(arg)
    runop([I.ASRx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base),
        changedmem={ base+offset:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

RORparams = {
    'argnames':    'inC,  arg,  res, C, N, Z',   # inC,  arg,  res, C, N, Z
    'argvalues': ( (  0, 0x00, 0x00, 0, 0, 1),    (  1, 0x00, 0x80, 0, 1, 0),
                   (  0, 0x01, 0x00, 1, 0, 1),    (  1, 0x01, 0x80, 1, 1, 0),
                   (  0, 0x02, 0x01, 0, 0, 0),    (  1, 0x02, 0x81, 0, 1, 0),
                   (  0, 0x03, 0x01, 1, 0, 0),    (  1, 0x03, 0x81, 1, 1, 0),
                   (  0, 0x55, 0x2A, 1, 0, 0),    (  1, 0x55, 0xAA, 1, 1, 0),
                   (  0, 0xAA, 0x55, 0, 0, 0),    (  1, 0xAA, 0xD5, 0, 1, 0),
                   (  0, 0xFE, 0x7F, 0, 0, 0),    (  1, 0xFE, 0xFF, 0, 1, 0),
                   (  0, 0xFF, 0x7F, 1, 0, 0),    (  1, 0xFF, 0xFF, 1, 1, 0),
    ), 'ids': tmc_tid, }

@pytest.mark.parametrize(**RORparams)
@pytest.mark.parametrize(**ACC('ROR~'))
def test_RORa(opname, accval, inC, arg, res, N, Z, C):
    assert N == inC
    assert N == bool(res >> 7)  # shift just to be different from CUT's AND
    runop([I[opname]], initregs=accval(arg, C=inC),
        changedregs=accval(res, N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**RORparams)
def test_RORm(inC, arg, res, N, Z, C):
    addr = v16(arg)
    runop([I.RORm, MSB(addr), LSB(addr)],
        initmem={ addr:arg }, initregs=R(C=inC),
        changedmem={ addr:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

@pytest.mark.parametrize(**RORparams)
def test_RORx(inC, arg, res, N, Z, C):
    base, offset = v16(arg), v8(arg)
    runop([I.RORx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base, C=inC),
        changedmem={ base+offset:res }, changedregs=R(N=N, Z=Z, V=N^C, C=C))

####################################################################
#   Arithmetic operations

@pytest.mark.parametrize(**
    { 'argnames':    ' arg,  res, N, Z, V, C',
      'argvalues': ( (0x01, 0xFF, 1, 0, 0, 1),
                     (0xFF, 0x01, 0, 0, 0, 1),
                     (0x7F, 0x81, 1, 0, 0, 1),
                     (0x81, 0x7F, 0, 0, 0, 1),
                     (0x00, 0x00, 0, 1, 0, 0),
                     (0x80, 0x80, 1, 0, 1, 1),
    ), 'ids': tmc_tid, })
def test_NEG(arg, res, N, Z, V, C):
    outflags = R(N=N, Z=Z, V=V, C=C)
    runop([I.NEGA], initregs=R(a=arg), changedregs=outflags.clone(a=res))
    runop([I.NEGB], initregs=R(b=arg), changedregs=outflags.clone(b=res))
    addr = v16(arg)
    runop([I.NEGm, MSB(addr), LSB(addr)], initmem={ addr:arg },
        changedmem={ addr:res }, changedregs=outflags)
    base, offset = v16(arg), v8(arg)
    runop([I.NEGx, offset],
        initmem={ base+offset:arg }, initregs=R(x=base),
        changedmem={ base+offset:res }, changedregs=outflags)

@pytest.mark.parametrize(**
    { 'argnames':    ' arg,  res, N, Z, V, C',
      'argvalues': ( (0x00, 0x01, 0, 0, 0, None),
                     (0x01, 0x02, 0, 0, 0, None),
                     (0x7E, 0x7F, 0, 0, 0, None),
                     (0x7F, 0x80, 1, 0, 1, None),
                     (0x80, 0x81, 1, 0, 0, None),
                     (0xFE, 0xFF, 1, 0, 0, None),
                     (0xFF, 0x00, 0, 1, 0, None),
    ), 'ids': tmc_tid, })
def test_INCa(arg, res, N, Z, V, C):
    outflags = R(N=N, Z=Z, V=V, C=C)

    #   If a flag is not tested, meaning it doesn't change, set it to a
    #   pseudo-random value based on the argument to try to find cases
    #   where it's changed when it ought not be.
    inflags = R()
    for flag in ('N', 'Z', 'V', 'C'):
        if getattr(outflags, flag) is None:
            f = arg & 1
            inflags = inflags.clone(**{flag:f})
            outflags = outflags.clone(**{flag:f})

    runop([I.INCA], initregs=inflags.clone(a=arg), changedregs=outflags.clone(a=res))
    runop([I.INCB], initregs=inflags.clone(b=arg), changedregs=outflags.clone(b=res))
    addr = v16(arg)
    runop([I.INCm, MSB(addr), LSB(addr)],
        initmem={ addr:arg }, initregs=inflags,
        changedmem={ addr:res }, changedregs=outflags)
    base, offset = v16(arg), v8(arg)
    runop([I.INCx, offset],
        initmem={ base+offset:arg }, initregs=inflags.clone(x=base),
        changedmem={ base+offset:res }, changedregs=outflags)

@pytest.mark.parametrize('   n,  dec, N, Z, V', (
                         (0xFF, 0xFE, 1, 0, 0),
                         (0x81, 0x80, 1, 0, 0),
                         (0x80, 0x7F, 0, 0, 1),     # only case where V set
                         (0x7F, 0x7E, 0, 0, 0),
                         (0x01, 0x00, 0, 1, 0),
))
def test_decb(n, dec, N, Z, V):
    runop([I.DECB], initregs=R(b=n), changedregs=R(b=dec, N=N, Z=Z, V=V))

@pytest.mark.parametrize('     n, succ, Z', (
                         (0x0000, 0x0001, 0),
                         (0x00FF, 0x0100, 0),
                         (0xFFFE, 0xFFFF, 0),
                         (0xFFFF, 0x0000, 1),
))
def test_inx(n, succ, Z):
    runop([I.INX], initregs=R(x=n), changedregs=R(x=succ, Z=Z))

@pytest.mark.parametrize('     n, succ, Z', (
                         (0x0001, 0x0000, 1),
                         (0x0100, 0x00FF, 0),
                         (0xFFFF, 0xFFFE, 0),
                         (0x0000, 0xFFFF, 0),
))
def test_dex(n, succ, Z):
    runop([I.DEX], initregs=R(x=n), changedregs=R(x=succ, Z=Z))

@pytest.mark.parametrize(
    'a,     arg,  res, H, N, Z, V, C', (
    (0x00, 0x00, 0x00, 0, 0, 1, 0, 0),
    #   H: half carry determined by bits 3
    (0x0E, 0x01, 0x0F, 0, 0, 0, 0, 0),
    (0x0F, 0x01, 0x10, 1, 0, 0, 0, 0),
    (0x10, 0x01, 0x11, 0, 0, 0, 0, 0),
    #   V: overflow determined by bits 6
    (0x7E, 0x01, 0x7F, 0, 0, 0, 0, 0),
    (0x7F, 0x01, 0x80, 1, 1, 0, 1, 0),
    (0x80, 0x01, 0x81, 0, 1, 0, 0, 0),
    #   C: carry determined by bits 7
    (0xFE, 0x01, 0xFF, 0, 1, 0, 0, 0),
    (0xFF, 0x01, 0x00, 1, 0, 1, 0, 1),
    (0xF0, 0x20, 0x10, 0, 0, 0, 0, 1),  # no half carry
    #   C and V
    (0x40, 0xF0, 0x30, 0, 0, 0, 0, 1),  # 2's comp: subtract from positive
    (0xF0, 0xF0, 0xE0, 0, 1, 0, 0, 1),  # 2's comp: subtract from negative
    (0x80, 0x80, 0x00, 0, 0, 1, 1, 1),
), ids=tmc_tid)
def test_ADDA(a, arg, res, H, N, Z, V, C):
    cr = R(a=res, H=H, N=N, Z=Z, V=V, C=C)
    #   Operation should be the same whether carry set or clear.
    runop([I.ADDA, arg], initregs=R(a=a, C=0), changedregs=cr)
    runop([I.ADDA, arg], initregs=R(a=a, C=1), changedregs=cr)

@pytest.mark.parametrize('minuend, subtrahend, difference, N, Z, V, C', (
    #minu, subt, diff, N, Z, V, C
    (0x00, 0x00, 0x00, 0, 1, 0, 0),
    #   V: overflow determined by bits 6
    (0x81, 0x01, 0x80, 1, 0, 0, 0),
    (0x81, 0x02, 0x7F, 0, 0, 1, 0),
    (0x7F, 0x01, 0x7E, 0, 0, 0, 0),
    #   C: borrow determined by bits 7
    (0x01, 0x01, 0x00, 0, 1, 0, 0),
    (0x01, 0x02, 0xFF, 1, 0, 0, 1),
    (0xFF, 0x01, 0xFE, 1, 0, 0, 0),
), ids=tmc_tid)
def test_SUBA(minuend, subtrahend, difference, N, Z, V, C):
    cr = R(a=difference, N=N, Z=Z, V=V, C=C)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=0), changedregs=cr)
    runop([I.SUBA, subtrahend], initregs=R(a=minuend, C=1), changedregs=cr)

def test_CMPA():
    #   Confirm that A register is unchanged;
    #   test_suba() provides the rest of the coverage.
    runop([I.CMPA, 0x02], initregs=R(a=0x81), changedregs=R(N=0, Z=0, V=1, C=0))

CPXparams = {
    'argnames':     ' addr,      x,    arg, Z, N, V',
    #  Flag register value:                 4  8  2
    'argvalues': (  (0x0F1, 0x0000, 0x0000, 1, 0, 0),     # BEQ taken
                    (0x0F3, 0x0001, 0x0001, 1, 0, 0),
                    (0x0F5, 0x0080, 0x0080, 1, 0, 0),
                    (0x0F7, 0x7FFF, 0x7FFF, 1, 0, 0),
                    (0x0F9, 0x8000, 0x8000, 1, 0, 0),
                    (0x0FB, 0xFFFF, 0xFFFF, 1, 0, 0),

                    (0x0FD, 0x0000, 0x0001, 0, 0, 0),     # BNE taken
                    (0x0FF, 0x0000, 0x00FF, 0, 0, 0),
                    (0x101, 0x0000, 0x0100, 0, 1, 0),

                    (0x103, 0x0000, 0x8100, 0, 0, 0),
                    (0x105, 0x0000, 0x80FF, 0, 1, 1),
                    (0x107, 0x0000, 0x8000, 0, 1, 1),
                    (0x109, 0x0000, 0x7FFF, 0, 1, 0),

                    (0x10B, 0x0000, 0xFFFF, 0, 0, 0),
                    (0x10D, 0x8000, 0x0000, 0, 1, 0),
                    (0x10F, 0x8000, 0x00FF, 0, 1, 0),
                    (0x121, 0x8000, 0x0100, 0, 0, 1),
                ),
    'ids': tmc_tid,
}

@pytest.mark.parametrize(**CPXparams)
def test_CPX(addr, x, arg, N, Z, V):
    runop([I.CPX, MSB(arg), LSB(arg)],
        initregs=R(x=x), changedregs=R(N=N, Z=Z, V=V))

@pytest.mark.parametrize(**CPXparams)
def test_CPXz(addr, x, arg, N, Z, V):
    addr -= 0x40
    runop([I.CPXz, addr],
        initmem     = { addr: MSB(arg), addr+1: LSB(arg) },
        initregs    = R(x=x),
        changedregs = R(N=N, Z=Z, V=V))

@pytest.mark.parametrize(**CPXparams)
def test_CPXm(addr, x, arg, N, Z, V):
    runop([I.CPXm, MSB(addr), LSB(addr)],
        initmem     = { addr: MSB(arg), addr+1: LSB(arg) },
        initregs    = R(x=x),
        changedregs = R(N=N, Z=Z, V=V))
