;   a simple reader for (very limited) S-expressions

; ----------------------------------------------------------------------
;   parsers
;
;   q* indicates a parser at q_point, incrementing q_point to consume
;   qY* indicates a parser at qpoint,y, incrementing y to consume
;
;   A parser attempts to parse a value starting at q_point. Except where
;   noted, they always assume that leading whitespace has been consumed
;   and there is at least one unconsumed character to parse.
;   - On success:
;     - Its input is consumed by incrementing q_point.
;     - The parsed value (if any) is stored in q_value.
;     - Z=1 (BNE) to indicate success ONLY if the parser is capable of
;       failing. Otherwise Z is not indicative of anything.
;   - On failure:
;     - No input is consumed (q_point is untouched)
;     - q_value may be destroyed
;     - Z=0 (BEQ) to indicate failure
;
;   The reason we use Z=0 for failure is that a very common test for
;   parsers is to CMP the next character, BEQ if it matches, or exit
;   with an RTS if it doesn't, in which case Z=0.
;
;   XXX Stuff to consider:
;   - Should have some parsers assume Y=0 on entry?
;   - Should qspaces INY and then add Y to q_point when done?
;

;   ♣Z ♡AXY,q_value  Consume any character. Always successful.
qchar       inc q_point
            bne .done
            inc q_point+1
.done       rts

;   ♠YZ ♣A  Advance q_point by Y characters to consume them.
;          • This does not check for end of input!
;          • Always returns with Z=0 for tail calls from successful parsers.
;          • Always returns with Y=0, in case that's useful.
;
qYconsume   tya
            clc
            adc q_point
            sta q_point
            bcc .done
            inc q_point+1
.done       ldy #0          ; set Z to indicate success
            rts


;   ♠Y ♡AX,q_point,q_value  Consume spaces at Y. Always successful.
qYspaces    lda (q_point),y
            iny
            cmp #' '
            beq qYspaces
            dey
            rts

;   ♠Y=0 ♣Z,A ♡X,q_value  Consume spaces. Always successful.
qspaces     ldy #0
            jsr qYspaces
            jmp qYconsume   ; TCO


;   ♠Z,q_value ♣AY  Parse a '()' (left-paren, right paren) as value nil.
qLR         ldy #0
            lda (q_point),y
            cmp #'('
            beq .qright
            rts             ; Z=0: failure
.qright     iny
            jsr qYspaces
            lda (q_point),y
            cmp #')'
            beq .qsuccess
            rts
.qsuccess   lda #nil        ; intrinsic constant
            sta q_value
            sta q_value+1   ; hack: we know that `nil`'s value is 0
            iny             ; consume the ')'
            jmp qYconsume   ; TCO

;   ♠Z,q_value ♣AY  Parse a '(' as start of a list, a heap-allocated cons cell
qlist       ldy #0
            lda (q_point),Y
            cmp #'('
            beq .list
            rts
.list       ldx #q_value    ; newly allocated cell to q_value
            jsr hcalloc
            jsr qchar       ; consume the '('
            ldy #0          ; z=1 success
            rts

;   ♠Z,q_value ♣A,Y ♡? Consume a sym1 (1 char
;   Assumes that leading spaces have been consumed.
qsym1       ldy #1          ; character after current one
            lda (q_point),y ;   must be a terminator
            beq .sym1       ; $00: end of parse
            cmp #' '        ; space: end of token
            beq .sym1
            cmp #')'        ; close paren: end of list
            beq .sym1
            cmp #'('        ; open paren: start of next list
            beq .sym1
            rts             ; Z=0 return failure
.sym1       lda #2          ; sym1 tag
            sta q_value     ; tagged pointer LSB
            dey             ; y=0
            lda (q_point),y ; load character
            sta q_value+1   ; tagged pointer MSB
            jsr qchar       ; consume character we stored
            ldy #0          ; Z=1 success
            rts




            end
----------------------------------------------------------------------

    parse: start by consuming spaces, then:
        - ✓ consume spaces
        - ✓ '(', ' '*, ')'    -> nil
        - ○ sym1
        - ○ smallint
        - ○ '(' → start of list or nil (consume spaces to check
        - ○ sym2

    TOP:
        parse
        case
            object:         val := obj, goto DONE
            end of list:    ERROR "unclosed expr"
            start of list:  push(val), val → alloc(), cur = val, goto STARTING

    STARTING:   # reading value for already-alloc'd head cell of a list
                # - cur.car is waiting to be filled
                # - cur.cdr will be filled by APPENDING
        parse
        case
            object:         cur.car := obj
                            goto APPENDING
            end of list:    NOTREACHED because parser reads () as nil
            start of list:  cur.car → alloc()   # same as 2nd half SOL below
                            push(cur)
                            cur := cur.car
                            goto STARTING

    APPENDING:  # reading value for not-yet-alloc'd cell to append to cur list
                # - cur.car is filled
                # - cur.cdr is waiting to fill w/next cell ptr or end of list
        parse
        case
            end of input:   ERROR "unclosed expr"
            end of list:    cur.cdr := ∅
                            cur → pop(),
                            if cur = val: goto DONE
                                    else: goto APPENDING
            object:         cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car := obj      # ...is object
                            goto APPENDING      # continue with current list
            start of list:  cur.cdr → alloc()   # next val on list...
                            cur := cur.cdr
                            cur.car → alloc()   # ...points to head of new list
                            push(cur)           # we'll come back to this later
                            cur := cur.car      # start with new list
                            goto STARTING
