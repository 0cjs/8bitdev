;   clic/qform.i80 - parse CLIC forms
;
;   Requires: clic/qtok, clic/heap

TAB         equ     $09
LF          equ     $0A
VT          equ     $0B
FF          equ     $0C
CR          equ     $0D
SPACE       equ     ' '

qform_init  xor  a,a
            ld   (getc_buf),a
            ret

; ----------------------------------------------------------------------
;   Character Reads

;   ♠A ♡* ┃ Tokenizer character read. Return in A the last char pushed back
;   into the input queue by `ungetc`, if there is one, otherwise read and
;   return the next char from the console.
getc:       ld   a,(getc_buf)
            or   a,a
            jp   NZ,.bufret
            jp   rdchar         ; TCO
            ;
.bufret     push af
            xor  a,a
            ld   (getc_buf),a
            pop  af
            ret

;   ♢A ♡AF* ┃ Tokenizer character pushback. Make A the next char to be
;   returned by `getc`. This wipes out any previous `ungetc`'d character,
;   if present. Nor is there any check that A contains the character last
;   read. It is not possible to `ungetc` the NUL ($00) character.
ungetc:     ld   (getc_buf),a
            ret

; ----------------------------------------------------------------------
;   Tokenization
;
;   This works along the lines of the Common Lisp reader algorithm[1],
;   except that for us the "macro chars"[2] are only about terminating
;   the token; other code takes care of determining how to parse the
;   returned token.
;
;   Currently the terminating chars are just `(` and `)` as well as
;   whitespace. This obviously needs to be reviewed/expanded.
;
;   Terminating characters that _start_ a token also immediately terminate
;   that token. This also needs to be reviewed as our rules for termination
;   become more complex.
;
;   [1]: https://novaspec.org/cl/2_2_Reader_Algorithm#sec_2_2
;   [2]: https://novaspec.org/cl/2_1_Character_Syntax#sec_2_1_4
;   [3]: https://novaspec.org/cl/f_read

;   ♠ACHL ♣DE ♡B  ┃ Read a token, depositing it in `tokbuf`.
;   Returns A=terminating char, C=length, HL=tokbuf.
;   This expects that we are at the character that terminated any
;   previous token.
;   • XXX Signal error if it's longer than tokbuflen. (We consume the
;     remainder anyway?)
;   • XXX In long run, allocate tokbuf on heap, w/dynamic len?
;
rtok        ld   hl,tokbuf
            ld   de,tokbuf
            ld   c,0            ; length read
.firstchar  call getc
            call wspQ           ; leading whitespace?
            jp   Z,.firstchar   ;   yes: ignore
            ld   (de),a
            inc  de
            inc  c
            call termcharQ
            ret  Z
            ;   Continue collecting chars until we hit a termchar.
            ;   (XXX or the token gets too long....)
.nextchars  call getc
            call termcharQ      ; done with token?
            call Z,ungetc       ;   yes: push back termnating char (this is 
            ret  Z              ;      `read-preserving-whitespace`!) and ret
            ld   (de),a
            inc  de
            inc  c
            jp   .nextchars

;   ♢A ♡* ┃ Return Z=1 if character terminates a token.
termcharQ   cp   '('
            ret  Z
            cp   ')'
            ret  Z
            ;   fallthrough

;   ♢A ♡* ┃ Return Z=1 if character is whitespace.
wspQ        cp   TAB
            ret  Z
            cp   LF
            ret  Z
            cp   VT
            ret  Z
            cp   FF
            ret  Z
            cp   CR
            ret  Z
            cp   SPACE
            ret  Z
            ret

; ----------------------------------------------------------------------

;   ♠DE ♣?? ♡?? ┃ Read an AST read via `getc`. If the input is not an atom
;   (or is an atom that requires objdata) this will will allocate as much
;   memory as necessary in the heap to store the structures referenced by
;   the AST root. Returns:
;   • Success: Cy=0 DE=AST
;   • Failure: Cy=1 DE=invalid
;
;   XXX not clear how to deal with the recursion. Do I create a cons
;   and call `rform` again asking it to deposit the root in that cons?
;   It should cons up the entire sequence until a ')', but then how
;   do I deal with not having a '(' at the top level, when just an
;   atom is supplied? And then there's `()`....
;
rform       call rtok
            cp  ')'             ; unmatched closing paren?
            jp  Z,.error        ;   yes: parse error
            cp  '('
            jp  Z,.subform
            call qtok           ; parse atom
            or  a,a             ; clear carry
            ret
            ;
.subform    call rformls
            ; XXX handle result
            ;   it returns DE = cons cell it allocated?
            ;   it has carry flag indicating on return
            ret
.error      scf
            ret

;   ??? ┃ Read a subform from the character _after_ the opening paren to
;   the matching close paren, allocating as necessary. Return the AST root
;   in DE. (XXX can this encounter errors? Certainly not a missing close
;   paren.)
;
;   XXX check for and deal with stack overflow
;
rformls     call rtok
            cp   ')'            ; close paren immediately follows open paren?
            jp   NZ,.startlist  ;    no: we're parsing a list
            ld   DE,NIL         ;   yes: it's just a NIL
            ret
            ;
.startlist  call hcons          ; DE ← new cons cell (must ♡CHL)
            push de             ; save head of list
            jp   .parsetok

.nexttok    ;   We enter with DE pointing to the cdr of a cons cell whose
            ;   car has been filled with the previous parsed token.
            call rtok           ; read next token
            cp   ')'            ; list completed?
            jp   NZ,.done       ;   yes: terminate it and return
            ;   We have a new atom or sublist: allocate a cons for
            ;   it and link the previous cons to the new one.
            push hl             ; save token pointer
            ex   de,hl          ; save pointer to current cdr
            call hcons          ; DE ← new cons cell (must ♡CHL)
            ld   (hl),e         ; fill previous cdr with current cons
            inc  hl
            ld   (hl),d
            pop  hl             ; restore token pointer
            ;
.parsetok   cp   '('            ; subform?
            jp   Z,.subform
            ;   fallthrough

.atom       push de             ; save current cons
            call qtok           ; DE ← objref parsed from token len C at HL
            pop  hl             ; HL ← restored pointer to current cons
            ld   (hl),e         ; store subform pointer in the car
            inc  hl
            ld   (hl),d
            inc  hl
            ex   hl,de          ; DE ← cdr of current cons
            jp   .nexttok

.subform    push de             ; save pointer to current cons
            call rformls        ; DE ← parsed subform cons
            pop  hl             ; HL ← restored pointer to current cons
            ld   (hl),e         ; store subform pointer in the car
            inc  hl
            ld   (hl),d
            inc  hl
            ex   hl,de          ; DE ← cdr of current cons
            jp   .nexttok
            ;

.done       ;   We enter with DE pointing to the cdr of a cons cell whose
            ;   car has been filled with the previous parsed token.
            ex  de,hl
            ld  (hl),NIL        ; terminate list
            pop  de             ; restore head of list we generated
            ret                 ; and return it

; ----------------------------------------------------------------------
;   Storage
;   XXX This needs to go into a RAM area

getc_buf    ds   1              ; ; last `ungetc`'d char or $00 for no char.
tokbuflen   equ  32
tokbuf      ds   tokbuflen
